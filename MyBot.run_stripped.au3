#RequireAdmin
#pragma compile(Icon, "Images\MyBot.ico")
#pragma compile(FileDescription, Clash of Clans Bot - A Free Clash of Clans bot - https://mybot.run)
#pragma compile(ProductName, My Bot)
#pragma compile(ProductVersion, 7.0)
#pragma compile(FileVersion, 7.0)
#pragma compile(LegalCopyright, © https://mybot.run)
#pragma compile(Out, MyBot.run.exe) ; Required
Opt("MustDeclareVars", 1)
Global $g_sBotVersion = "v7.0.1"
Global $g_sModversion = "v3.6"
Global $g_sModSupportUrl = "https://mybot.run/forums/index.php?/topic/27601-mybotrun-dococ-v352/&"
Global $g_sBotTitle = ""
Global $g_hFrmBot = 0
Global $icmbAccountsQuantity = 0, $CurrentAccount = 0
Global $aTxtLogInitText[0][6] = [[]]
Global Const $WS_OVERLAPPED = 0
Global Const $WS_MAXIMIZEBOX = 0x00010000
Global Const $WS_MINIMIZEBOX = 0x00020000
Global Const $WS_TABSTOP = 0x00010000
Global Const $WS_GROUP = 0x00020000
Global Const $WS_SIZEBOX = 0x00040000
Global Const $WS_THICKFRAME = $WS_SIZEBOX
Global Const $WS_SYSMENU = 0x00080000
Global Const $WS_HSCROLL = 0x00100000
Global Const $WS_VSCROLL = 0x00200000
Global Const $WS_DLGFRAME = 0x00400000
Global Const $WS_BORDER = 0x00800000
Global Const $WS_CAPTION = 0x00C00000
Global Const $WS_MAXIMIZE = 0x01000000
Global Const $WS_CLIPCHILDREN = 0x02000000
Global Const $WS_CLIPSIBLINGS = 0x04000000
Global Const $WS_DISABLED = 0x08000000
Global Const $WS_VISIBLE = 0x10000000
Global Const $WS_MINIMIZE = 0x20000000
Global Const $WS_CHILD = 0x40000000
Global Const $WS_POPUP = 0x80000000
Global Const $WS_POPUPWINDOW = 0x80880000
Global Const $WS_EX_APPWINDOW = 0x00040000
Global Const $WS_EX_LAYERED = 0x00080000
Global Const $WS_EX_MDICHILD = 0x00000040
Global Const $WS_EX_NOACTIVATE = 0x08000000
Global Const $WS_EX_RIGHT = 0x00001000
Global Const $WS_EX_STATICEDGE = 0x00020000
Global Const $WS_EX_TOOLWINDOW = 0x00000080
Global Const $WS_EX_TOPMOST = 0x00000008
Global Const $WS_EX_TRANSPARENT = 0x00000020
Global Const $WS_EX_WINDOWEDGE = 0x00000100
Global Const $WM_MOVE = 0x0003
Global Const $WM_SETFOCUS = 0x0007
Global Const $WM_KILLFOCUS = 0x0008
Global Const $WM_SETREDRAW = 0x000B
Global Const $WM_CLOSE = 0x0010
Global Const $WM_GETFONT = 0x0031
Global Const $WM_NOTIFY = 0x004E
Global Const $WM_NCHITTEST = 0x0084
Global Const $WM_NCACTIVATE = 0x0086
Global Const $WM_KEYDOWN = 0x0100
Global Const $WM_KEYUP = 0x0101
Global Const $WM_SYSKEYDOWN = 0x0104
Global Const $WM_SYSKEYUP = 0x0105
Global Const $WM_COMMAND = 0x0111
Global Const $WM_MOUSEMOVE = 0x0200
Global Const $WM_LBUTTONDOWN = 0x0201
Global Const $WM_LBUTTONUP = 0x0202
Global Const $WM_RBUTTONDOWN = 0x0204
Global Const $WM_RBUTTONUP = 0x0205
Global Const $WM_MBUTTONDOWN = 0x0207
Global Const $WM_MBUTTONDBLCLK = 0x0209
Global Const $WM_MOUSEWHEEL = 0x020A
Global Const $WM_MOUSEHWHEEL = 0x020E
Global Const $SRCCOPY = 0x00CC0020
Global Const $RDW_ERASE = 0x0004
Global Const $RDW_INVALIDATE = 0x0001
Global Const $RDW_ALLCHILDREN = 0x0080
Global Const $HTCAPTION = 2
Global Const $SD_SHUTDOWN = 1
Global Const $SD_REBOOT = 2
Global Const $SD_FORCE = 4
Global Const $SD_STANDBY = 32
Global Const $STDIN_CHILD = 1
Global Const $STDERR_MERGED = 8
Global Const $UBOUND_DIMENSIONS = 0
Global Const $UBOUND_ROWS = 1
Global Const $UBOUND_COLUMNS = 2
Global Const $HWND_BOTTOM = 1
Global Const $HWND_NOTOPMOST = -2
Global Const $HWND_TOP = 0
Global Const $HWND_TOPMOST = -1
Global Const $SWP_NOMOVE = 0x0002
Global Const $SWP_NOZORDER = 0x0004
Global Const $SWP_NOACTIVATE = 0x0010
Global Const $SWP_SHOWWINDOW = 0x0040
Global Const $SWP_HIDEWINDOW = 0x0080
Global Const $SWP_NOREPOSITION = 0x0200
Global Const $SWP_NOSENDCHANGING = 0x0400
Global Const $DIR_REMOVE= 1
Global Const $PROCESS_ABOVENORMAL = 3
Global Const $FC_NOOVERWRITE = 0
Global Const $FC_OVERWRITE = 1
Global Const $FC_CREATEPATH = 8
Global Const $FT_MODIFIED = 0
Global Const $FT_CREATED = 1
Global Const $FT_STRING = 1
Global Const $FSF_NEWDIALOG = 2
Global Const $FO_READ = 0
Global Const $FO_APPEND = 1
Global Const $FO_OVERWRITE = 2
Global Const $FO_CREATEPATH = 8
Global Const $FO_BINARY = 16
Global Const $FO_UTF16_LE = 32
Global Const $FD_FILEMUSTEXIST = 1
Global Const $CREATE_NEW = 1
Global Const $CREATE_ALWAYS = 2
Global Const $OPEN_EXISTING = 3
Global Const $OPEN_ALWAYS = 4
Global Const $TRUNCATE_EXISTING = 5
Global Const $FILE_ATTRIBUTE_READONLY = 0x00000001
Global Const $FILE_ATTRIBUTE_HIDDEN = 0x00000002
Global Const $FILE_ATTRIBUTE_SYSTEM = 0x00000004
Global Const $FILE_ATTRIBUTE_ARCHIVE = 0x00000020
Global Const $FILE_SHARE_READ = 0x00000001
Global Const $FILE_SHARE_WRITE = 0x00000002
Global Const $FILE_SHARE_DELETE = 0x00000004
Global Const $GENERIC_EXECUTE = 0x20000000
Global Const $GENERIC_WRITE = 0x40000000
Global Const $GENERIC_READ = 0x80000000
Global Const $FV_FILEDESCRIPTION = "FileDescription"
Global Const $FLTA_FILESFOLDERS = 0
Global Const $FLTA_FILES = 1
Global Const $FLTA_FOLDERS = 2
Global Const $FLTAR_FILESFOLDERS = 0
Global Const $FLTAR_FILES = 1
Global Const $FLTAR_NORECUR = 0
Global Const $FLTAR_RECUR = 1
Global Const $FLTAR_NOSORT = 0
Global Const $FLTAR_SORT = 1
Global Const $FLTAR_NOPATH = 0
Global Const $FLTAR_RELPATH = 1
Global Const $MB_OK = 0
Global Const $MB_OKCANCEL = 1
Global Const $MB_YESNO = 4
Global Const $MB_ICONERROR = 16
Global Const $MB_ICONWARNING = 48
Global Const $MB_ICONINFORMATION = 64
Global Const $MB_APPLMODAL = 0
Global Const $MB_SYSTEMMODAL = 4096
Global Const $MB_TOPMOST = 0x00040000
Global Const $IDOK = 1
Global Const $IDYES = 6
Global Const $SE_PRIVILEGE_ENABLED = 0x00000002
Global Enum $SECURITYANONYMOUS = 0, $SECURITYIDENTIFICATION, $SECURITYIMPERSONATION, $SECURITYDELEGATION
Global Const $TOKEN_QUERY = 0x00000008
Global Const $TOKEN_ADJUST_PRIVILEGES = 0x00000020
Func _WinAPI_GetLastError(Const $_iCurrentError = @error, Const $_iCurrentExtended = @extended)
Local $aResult = DllCall("kernel32.dll", "dword", "GetLastError")
Return SetError($_iCurrentError, $_iCurrentExtended, $aResult[0])
EndFunc
Func _WinAPI_SetLastError($iErrorCode, Const $_iCurrentError = @error, Const $_iCurrentExtended = @extended)
DllCall("kernel32.dll", "none", "SetLastError", "dword", $iErrorCode)
Return SetError($_iCurrentError, $_iCurrentExtended, Null)
EndFunc
Func _Security__AdjustTokenPrivileges($hToken, $bDisableAll, $tNewState, $iBufferLen, $tPrevState = 0, $pRequired = 0)
Local $aCall = DllCall("advapi32.dll", "bool", "AdjustTokenPrivileges", "handle", $hToken, "bool", $bDisableAll, "struct*", $tNewState, "dword", $iBufferLen, "struct*", $tPrevState, "struct*", $pRequired)
If @error Then Return SetError(@error, @extended, False)
Return Not($aCall[0] = 0)
EndFunc
Func _Security__ImpersonateSelf($iLevel = $SECURITYIMPERSONATION)
Local $aCall = DllCall("advapi32.dll", "bool", "ImpersonateSelf", "int", $iLevel)
If @error Then Return SetError(@error, @extended, False)
Return Not($aCall[0] = 0)
EndFunc
Func _Security__LookupPrivilegeValue($sSystem, $sName)
Local $aCall = DllCall("advapi32.dll", "bool", "LookupPrivilegeValueW", "wstr", $sSystem, "wstr", $sName, "int64*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $aCall[3]
EndFunc
Func _Security__OpenThreadToken($iAccess, $hThread = 0, $bOpenAsSelf = False)
If $hThread = 0 Then
Local $aResult = DllCall("kernel32.dll", "handle", "GetCurrentThread")
If @error Then Return SetError(@error + 10, @extended, 0)
$hThread = $aResult[0]
EndIf
Local $aCall = DllCall("advapi32.dll", "bool", "OpenThreadToken", "handle", $hThread, "dword", $iAccess, "bool", $bOpenAsSelf, "handle*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $aCall[4]
EndFunc
Func _Security__OpenThreadTokenEx($iAccess, $hThread = 0, $bOpenAsSelf = False)
Local $hToken = _Security__OpenThreadToken($iAccess, $hThread, $bOpenAsSelf)
If $hToken = 0 Then
Local Const $ERROR_NO_TOKEN = 1008
If _WinAPI_GetLastError() <> $ERROR_NO_TOKEN Then Return SetError(20, _WinAPI_GetLastError(), 0)
If Not _Security__ImpersonateSelf() Then Return SetError(@error + 10, _WinAPI_GetLastError(), 0)
$hToken = _Security__OpenThreadToken($iAccess, $hThread, $bOpenAsSelf)
If $hToken = 0 Then Return SetError(@error, _WinAPI_GetLastError(), 0)
EndIf
Return $hToken
EndFunc
Func _Security__SetPrivilege($hToken, $sPrivilege, $bEnable)
Local $iLUID = _Security__LookupPrivilegeValue("", $sPrivilege)
If $iLUID = 0 Then Return SetError(@error + 10, @extended, False)
Local Const $tagTOKEN_PRIVILEGES = "dword Count;align 4;int64 LUID;dword Attributes"
Local $tCurrState = DllStructCreate($tagTOKEN_PRIVILEGES)
Local $iCurrState = DllStructGetSize($tCurrState)
Local $tPrevState = DllStructCreate($tagTOKEN_PRIVILEGES)
Local $iPrevState = DllStructGetSize($tPrevState)
Local $tRequired = DllStructCreate("int Data")
DllStructSetData($tCurrState, "Count", 1)
DllStructSetData($tCurrState, "LUID", $iLUID)
If Not _Security__AdjustTokenPrivileges($hToken, False, $tCurrState, $iCurrState, $tPrevState, $tRequired) Then Return SetError(2, @error, False)
DllStructSetData($tPrevState, "Count", 1)
DllStructSetData($tPrevState, "LUID", $iLUID)
Local $iAttributes = DllStructGetData($tPrevState, "Attributes")
If $bEnable Then
$iAttributes = BitOR($iAttributes, $SE_PRIVILEGE_ENABLED)
Else
$iAttributes = BitAND($iAttributes, BitNOT($SE_PRIVILEGE_ENABLED))
EndIf
DllStructSetData($tPrevState, "Attributes", $iAttributes)
If Not _Security__AdjustTokenPrivileges($hToken, False, $tPrevState, $iPrevState, $tCurrState, $tRequired) Then Return SetError(3, @error, False)
Return True
EndFunc
Func _SendMessage($hWnd, $iMsg, $wParam = 0, $lParam = 0, $iReturn = 0, $wParamType = "wparam", $lParamType = "lparam", $sReturnType = "lresult")
Local $aResult = DllCall("user32.dll", $sReturnType, "SendMessageW", "hwnd", $hWnd, "uint", $iMsg, $wParamType, $wParam, $lParamType, $lParam)
If @error Then Return SetError(@error, @extended, "")
If $iReturn >= 0 And $iReturn <= 4 Then Return $aResult[$iReturn]
Return $aResult
EndFunc
Global Const $STR_CASESENSE = 1
Global Const $STR_NOCASESENSEBASIC = 2
Global Const $STR_STRIPLEADING = 1
Global Const $STR_STRIPTRAILING = 2
Global Const $STR_STRIPSPACES = 4
Global Const $STR_STRIPALL = 8
Global Const $STR_CHRSPLIT = 0
Global Const $STR_ENTIRESPLIT = 1
Global Const $STR_NOCOUNT = 2
Global Const $STR_REGEXPMATCH = 0
Global Const $STR_REGEXPARRAYMATCH = 1
Global Const $STR_REGEXPARRAYGLOBALMATCH = 3
Global Const $STR_ENDISSTART = 0
Global Const $STR_ENDNOTSTART = 1
Global Const $tagPOINT = "struct;long X;long Y;endstruct"
Global Const $tagRECT = "struct;long Left;long Top;long Right;long Bottom;endstruct"
Global Const $tagSIZE = "struct;long X;long Y;endstruct"
Global Const $tagFILETIME = "struct;dword Lo;dword Hi;endstruct"
Global Const $tagSYSTEMTIME = "struct;word Year;word Month;word Dow;word Day;word Hour;word Minute;word Second;word MSeconds;endstruct"
Global Const $tagCOMBOBOXEXITEM = "uint Mask;int_ptr Item;ptr Text;int TextMax;int Image;int SelectedImage;int OverlayImage;" & "int Indent;lparam Param"
Global Const $tagGDIPBITMAPDATA = "uint Width;uint Height;int Stride;int Format;ptr Scan0;uint_ptr Reserved"
Global Const $tagGDIPENCODERPARAM = "struct;byte GUID[16];ulong NumberOfValues;ulong Type;ptr Values;endstruct"
Global Const $tagGDIPENCODERPARAMS = "uint Count;" & $tagGDIPENCODERPARAM
Global Const $tagGDIPRECTF = "struct;float X;float Y;float Width;float Height;endstruct"
Global Const $tagGDIPSTARTUPINPUT = "uint Version;ptr Callback;bool NoThread;bool NoCodecs"
Global Const $tagGDIPIMAGECODECINFO = "byte CLSID[16];byte FormatID[16];ptr CodecName;ptr DllName;ptr FormatDesc;ptr FileExt;" & "ptr MimeType;dword Flags;dword Version;dword SigCount;dword SigSize;ptr SigPattern;ptr SigMask"
Global Const $tagMENUITEMINFO = "uint Size;uint Mask;uint Type;uint State;uint ID;handle SubMenu;handle BmpChecked;handle BmpUnchecked;" & "ulong_ptr ItemData;ptr TypeData;uint CCH;handle BmpItem"
Global Const $tagREBARBANDINFO = "uint cbSize;uint fMask;uint fStyle;dword clrFore;dword clrBack;ptr lpText;uint cch;" & "int iImage;hwnd hwndChild;uint cxMinChild;uint cyMinChild;uint cx;handle hbmBack;uint wID;uint cyChild;uint cyMaxChild;" & "uint cyIntegral;uint cxIdeal;lparam lParam;uint cxHeader" &((@OSVersion = "WIN_XP") ? "" : ";" & $tagRECT & ";uint uChevronState")
Global Const $tagBLENDFUNCTION = "byte Op;byte Flags;byte Alpha;byte Format"
Global Const $tagGUID = "struct;ulong Data1;ushort Data2;ushort Data3;byte Data4[8];endstruct"
Global Const $tagWINDOWPOS = "hwnd hWnd;hwnd InsertAfter;int X;int Y;int CX;int CY;uint Flags"
Global Const $tagLOGFONT = "struct;long Height;long Width;long Escapement;long Orientation;long Weight;byte Italic;byte Underline;" & "byte Strikeout;byte CharSet;byte OutPrecision;byte ClipPrecision;byte Quality;byte PitchAndFamily;wchar FaceName[32];endstruct"
Global Const $tagSECURITY_ATTRIBUTES = "dword Length;ptr Descriptor;bool InheritHandle"
Global Const $tagTEXTMETRIC = "long tmHeight;long tmAscent;long tmDescent;long tmInternalLeading;long tmExternalLeading;" & "long tmAveCharWidth;long tmMaxCharWidth;long tmWeight;long tmOverhang;long tmDigitizedAspectX;long tmDigitizedAspectY;" & "wchar tmFirstChar;wchar tmLastChar;wchar tmDefaultChar;wchar tmBreakChar;byte tmItalic;byte tmUnderlined;byte tmStruckOut;" & "byte tmPitchAndFamily;byte tmCharSet"
Global Const $HGDI_ERROR = Ptr(-1)
Global Const $INVALID_HANDLE_VALUE = Ptr(-1)
Global Const $DEFAULT_GUI_FONT = 17
Global Const $ULW_ALPHA = 0x02
Global Const $WH_CBT = 5
Global Const $WH_KEYBOARD_LL = 13
Global Const $WH_MOUSE_LL = 14
Global Const $KF_EXTENDED = 0x0100
Global Const $KF_ALTDOWN = 0x2000
Global Const $KF_UP = 0x8000
Global Const $LLKHF_EXTENDED = BitShift($KF_EXTENDED, 8)
Global Const $LLKHF_ALTDOWN = BitShift($KF_ALTDOWN, 8)
Global Const $LLKHF_UP = BitShift($KF_UP, 8)
Global Const $GW_HWNDNEXT = 2
Global Const $GW_CHILD = 5
Global Const $GWL_WNDPROC = 0xFFFFFFFC
Global Const $GWL_HWNDPARENT = 0xFFFFFFF8
Global Const $GWL_STYLE = 0xFFFFFFF0
Global Const $GWL_EXSTYLE = 0xFFFFFFEC
Global Const $LR_LOADFROMFILE = 0x0010
Global $__g_aInProcess_WinAPI[64][2] = [[0, 0]]
Global $__g_aWinList_WinAPI[64][2] = [[0, 0]]
Global Const $__WINAPICONSTANT_WM_SETFONT = 0x0030
Global Const $__WINAPICONSTANT_FW_NORMAL = 400
Global Const $__WINAPICONSTANT_DEFAULT_CHARSET = 1
Global Const $__WINAPICONSTANT_OUT_DEFAULT_PRECIS = 0
Global Const $__WINAPICONSTANT_CLIP_DEFAULT_PRECIS = 0
Global Const $__WINAPICONSTANT_DEFAULT_QUALITY = 0
Global Const $tagCURSORINFO = "dword Size;dword Flags;handle hCursor;" & $tagPOINT
Global Const $tagICONINFO = "bool Icon;dword XHotSpot;dword YHotSpot;handle hMask;handle hColor"
Func _WinAPI_BitBlt($hDestDC, $iXDest, $iYDest, $iWidth, $iHeight, $hSrcDC, $iXSrc, $iYSrc, $iROP)
Local $aResult = DllCall("gdi32.dll", "bool", "BitBlt", "handle", $hDestDC, "int", $iXDest, "int", $iYDest, "int", $iWidth, "int", $iHeight, "handle", $hSrcDC, "int", $iXSrc, "int", $iYSrc, "dword", $iROP)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_CallNextHookEx($hHook, $iCode, $wParam, $lParam)
Local $aResult = DllCall("user32.dll", "lresult", "CallNextHookEx", "handle", $hHook, "int", $iCode, "wparam", $wParam, "lparam", $lParam)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_CallWindowProc($pPrevWndFunc, $hWnd, $iMsg, $wParam, $lParam)
Local $aResult = DllCall("user32.dll", "lresult", "CallWindowProc", "ptr", $pPrevWndFunc, "hwnd", $hWnd, "uint", $iMsg, "wparam", $wParam, "lparam", $lParam)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_ClientToScreen($hWnd, ByRef $tPoint)
Local $aRet = DllCall("user32.dll", "bool", "ClientToScreen", "hwnd", $hWnd, "struct*", $tPoint)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tPoint
EndFunc
Func _WinAPI_CloseHandle($hObject)
Local $aResult = DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hObject)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_CopyIcon($hIcon)
Local $aResult = DllCall("user32.dll", "handle", "CopyIcon", "handle", $hIcon)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateCompatibleBitmap($hDC, $iWidth, $iHeight)
Local $aResult = DllCall("gdi32.dll", "handle", "CreateCompatibleBitmap", "handle", $hDC, "int", $iWidth, "int", $iHeight)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateCompatibleDC($hDC)
Local $aResult = DllCall("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateFile($sFileName, $iCreation, $iAccess = 4, $iShare = 0, $iAttributes = 0, $tSecurity = 0)
Local $iDA = 0, $iSM = 0, $iCD = 0, $iFA = 0
If BitAND($iAccess, 1) <> 0 Then $iDA = BitOR($iDA, $GENERIC_EXECUTE)
If BitAND($iAccess, 2) <> 0 Then $iDA = BitOR($iDA, $GENERIC_READ)
If BitAND($iAccess, 4) <> 0 Then $iDA = BitOR($iDA, $GENERIC_WRITE)
If BitAND($iShare, 1) <> 0 Then $iSM = BitOR($iSM, $FILE_SHARE_DELETE)
If BitAND($iShare, 2) <> 0 Then $iSM = BitOR($iSM, $FILE_SHARE_READ)
If BitAND($iShare, 4) <> 0 Then $iSM = BitOR($iSM, $FILE_SHARE_WRITE)
Switch $iCreation
Case 0
$iCD = $CREATE_NEW
Case 1
$iCD = $CREATE_ALWAYS
Case 2
$iCD = $OPEN_EXISTING
Case 3
$iCD = $OPEN_ALWAYS
Case 4
$iCD = $TRUNCATE_EXISTING
EndSwitch
If BitAND($iAttributes, 1) <> 0 Then $iFA = BitOR($iFA, $FILE_ATTRIBUTE_ARCHIVE)
If BitAND($iAttributes, 2) <> 0 Then $iFA = BitOR($iFA, $FILE_ATTRIBUTE_HIDDEN)
If BitAND($iAttributes, 4) <> 0 Then $iFA = BitOR($iFA, $FILE_ATTRIBUTE_READONLY)
If BitAND($iAttributes, 8) <> 0 Then $iFA = BitOR($iFA, $FILE_ATTRIBUTE_SYSTEM)
Local $aResult = DllCall("kernel32.dll", "handle", "CreateFileW", "wstr", $sFileName, "dword", $iDA, "dword", $iSM, "struct*", $tSecurity, "dword", $iCD, "dword", $iFA, "ptr", 0)
If @error Or($aResult[0] = $INVALID_HANDLE_VALUE) Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateFont($iHeight, $iWidth, $iEscape = 0, $iOrientn = 0, $iWeight = $__WINAPICONSTANT_FW_NORMAL, $bItalic = False, $bUnderline = False, $bStrikeout = False, $iCharset = $__WINAPICONSTANT_DEFAULT_CHARSET, $iOutputPrec = $__WINAPICONSTANT_OUT_DEFAULT_PRECIS, $iClipPrec = $__WINAPICONSTANT_CLIP_DEFAULT_PRECIS, $iQuality = $__WINAPICONSTANT_DEFAULT_QUALITY, $iPitch = 0, $sFace = 'Arial')
Local $aResult = DllCall("gdi32.dll", "handle", "CreateFontW", "int", $iHeight, "int", $iWidth, "int", $iEscape, "int", $iOrientn, "int", $iWeight, "dword", $bItalic, "dword", $bUnderline, "dword", $bStrikeout, "dword", $iCharset, "dword", $iOutputPrec, "dword", $iClipPrec, "dword", $iQuality, "dword", $iPitch, "wstr", $sFace)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateFontIndirect($tLogFont)
Local $aResult = DllCall("gdi32.dll", "handle", "CreateFontIndirectW", "struct*", $tLogFont)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateWindowEx($iExStyle, $sClass, $sName, $iStyle, $iX, $iY, $iWidth, $iHeight, $hParent, $hMenu = 0, $hInstance = 0, $pParam = 0)
If $hInstance = 0 Then $hInstance = _WinAPI_GetModuleHandle("")
Local $aResult = DllCall("user32.dll", "hwnd", "CreateWindowExW", "dword", $iExStyle, "wstr", $sClass, "wstr", $sName, "dword", $iStyle, "int", $iX, "int", $iY, "int", $iWidth, "int", $iHeight, "hwnd", $hParent, "handle", $hMenu, "handle", $hInstance, "struct*", $pParam)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_DeleteDC($hDC)
Local $aResult = DllCall("gdi32.dll", "bool", "DeleteDC", "handle", $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_DeleteObject($hObject)
Local $aResult = DllCall("gdi32.dll", "bool", "DeleteObject", "handle", $hObject)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_DestroyIcon($hIcon)
Local $aResult = DllCall("user32.dll", "bool", "DestroyIcon", "handle", $hIcon)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_DestroyWindow($hWnd)
Local $aResult = DllCall("user32.dll", "bool", "DestroyWindow", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_DrawIcon($hDC, $iX, $iY, $hIcon)
Local $aResult = DllCall("user32.dll", "bool", "DrawIcon", "handle", $hDC, "int", $iX, "int", $iY, "handle", $hIcon)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_EnableWindow($hWnd, $bEnable = True)
Local $aResult = DllCall("user32.dll", "bool", "EnableWindow", "hwnd", $hWnd, "bool", $bEnable)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func __WinAPI_EnumWindowsAdd($hWnd, $sClass = "")
If $sClass = "" Then $sClass = _WinAPI_GetClassName($hWnd)
$__g_aWinList_WinAPI[0][0] += 1
Local $iCount = $__g_aWinList_WinAPI[0][0]
If $iCount >= $__g_aWinList_WinAPI[0][1] Then
ReDim $__g_aWinList_WinAPI[$iCount + 64][2]
$__g_aWinList_WinAPI[0][1] += 64
EndIf
$__g_aWinList_WinAPI[$iCount][0] = $hWnd
$__g_aWinList_WinAPI[$iCount][1] = $sClass
EndFunc
Func __WinAPI_EnumWindowsInit()
ReDim $__g_aWinList_WinAPI[64][2]
$__g_aWinList_WinAPI[0][0] = 0
$__g_aWinList_WinAPI[0][1] = 64
EndFunc
Func _WinAPI_EnumWindowsTop()
__WinAPI_EnumWindowsInit()
Local $hWnd = _WinAPI_GetWindow(_WinAPI_GetDesktopWindow(), $GW_CHILD)
While $hWnd <> 0
If _WinAPI_IsWindowVisible($hWnd) Then __WinAPI_EnumWindowsAdd($hWnd)
$hWnd = _WinAPI_GetWindow($hWnd, $GW_HWNDNEXT)
WEnd
Return $__g_aWinList_WinAPI
EndFunc
Func _WinAPI_ExtractIconEx($sFilePath, $iIndex, $paLarge, $paSmall, $iIcons)
Local $aResult = DllCall("shell32.dll", "uint", "ExtractIconExW", "wstr", $sFilePath, "int", $iIndex, "struct*", $paLarge, "struct*", $paSmall, "uint", $iIcons)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_FatalAppExit($sMessage)
DllCall("kernel32.dll", "none", "FatalAppExitW", "uint", 0, "wstr", $sMessage)
If @error Then Return SetError(@error, @extended)
EndFunc
Func _WinAPI_FindWindow($sClassName, $sWindowName)
Local $aResult = DllCall("user32.dll", "hwnd", "FindWindowW", "wstr", $sClassName, "wstr", $sWindowName)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetAncestor($hWnd, $iFlags = 1)
Local $aResult = DllCall("user32.dll", "hwnd", "GetAncestor", "hwnd", $hWnd, "uint", $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetClassName($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $aResult = DllCall("user32.dll", "int", "GetClassNameW", "hwnd", $hWnd, "wstr", "", "int", 4096)
If @error Or Not $aResult[0] Then Return SetError(@error, @extended, '')
Return SetExtended($aResult[0], $aResult[2])
EndFunc
Func _WinAPI_GetClientHeight($hWnd)
Local $tRECT = _WinAPI_GetClientRect($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tRECT, "Bottom") - DllStructGetData($tRECT, "Top")
EndFunc
Func _WinAPI_GetClientWidth($hWnd)
Local $tRECT = _WinAPI_GetClientRect($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tRECT, "Right") - DllStructGetData($tRECT, "Left")
EndFunc
Func _WinAPI_GetClientRect($hWnd)
Local $tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall("user32.dll", "bool", "GetClientRect", "hwnd", $hWnd, "struct*", $tRECT)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tRECT
EndFunc
Func _WinAPI_GetCurrentProcess()
Local $aResult = DllCall("kernel32.dll", "handle", "GetCurrentProcess")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetCurrentThreadId()
Local $aResult = DllCall("kernel32.dll", "dword", "GetCurrentThreadId")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetCursorInfo()
Local $tCursor = DllStructCreate($tagCURSORINFO)
Local $iCursor = DllStructGetSize($tCursor)
DllStructSetData($tCursor, "Size", $iCursor)
Local $aRet = DllCall("user32.dll", "bool", "GetCursorInfo", "struct*", $tCursor)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aCursor[5]
$aCursor[0] = True
$aCursor[1] = DllStructGetData($tCursor, "Flags") <> 0
$aCursor[2] = DllStructGetData($tCursor, "hCursor")
$aCursor[3] = DllStructGetData($tCursor, "X")
$aCursor[4] = DllStructGetData($tCursor, "Y")
Return $aCursor
EndFunc
Func _WinAPI_GetDC($hWnd)
Local $aResult = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetDesktopWindow()
Local $aResult = DllCall("user32.dll", "hwnd", "GetDesktopWindow")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetDeviceCaps($hDC, $iIndex)
Local $aResult = DllCall("gdi32.dll", "int", "GetDeviceCaps", "handle", $hDC, "int", $iIndex)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetDlgCtrlID($hWnd)
Local $aResult = DllCall("user32.dll", "int", "GetDlgCtrlID", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetFileSizeEx($hFile)
Local $aResult = DllCall("kernel32.dll", "bool", "GetFileSizeEx", "handle", $hFile, "int64*", 0)
If @error Or Not $aResult[0] Then Return SetError(@error, @extended, -1)
Return $aResult[2]
EndFunc
Func _WinAPI_GetFocus()
Local $aResult = DllCall("user32.dll", "hwnd", "GetFocus")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetGuiResources($iFlag = 0, $hProcess = -1)
If $hProcess = -1 Then $hProcess = _WinAPI_GetCurrentProcess()
Local $aResult = DllCall("user32.dll", "dword", "GetGuiResources", "handle", $hProcess, "dword", $iFlag)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetIconInfo($hIcon)
Local $tInfo = DllStructCreate($tagICONINFO)
Local $aRet = DllCall("user32.dll", "bool", "GetIconInfo", "handle", $hIcon, "struct*", $tInfo)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aIcon[6]
$aIcon[0] = True
$aIcon[1] = DllStructGetData($tInfo, "Icon") <> 0
$aIcon[2] = DllStructGetData($tInfo, "XHotSpot")
$aIcon[3] = DllStructGetData($tInfo, "YHotSpot")
$aIcon[4] = DllStructGetData($tInfo, "hMask")
$aIcon[5] = DllStructGetData($tInfo, "hColor")
Return $aIcon
EndFunc
Func _WinAPI_GetModuleHandle($sModuleName)
Local $sModuleNameType = "wstr"
If $sModuleName = "" Then
$sModuleName = 0
$sModuleNameType = "ptr"
EndIf
Local $aResult = DllCall("kernel32.dll", "handle", "GetModuleHandleW", $sModuleNameType, $sModuleName)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetObject($hObject, $iSize, $pObject)
Local $aResult = DllCall("gdi32.dll", "int", "GetObjectW", "handle", $hObject, "int", $iSize, "struct*", $pObject)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetParent($hWnd)
Local $aResult = DllCall("user32.dll", "hwnd", "GetParent", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetStockObject($iObject)
Local $aResult = DllCall("gdi32.dll", "handle", "GetStockObject", "int", $iObject)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetSystemMetrics($iIndex)
Local $aResult = DllCall("user32.dll", "int", "GetSystemMetrics", "int", $iIndex)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetWindow($hWnd, $iCmd)
Local $aResult = DllCall("user32.dll", "hwnd", "GetWindow", "hwnd", $hWnd, "uint", $iCmd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetWindowDC($hWnd)
Local $aResult = DllCall("user32.dll", "handle", "GetWindowDC", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetWindowLong($hWnd, $iIndex)
Local $sFuncName = "GetWindowLongW"
If @AutoItX64 Then $sFuncName = "GetWindowLongPtrW"
Local $aResult = DllCall("user32.dll", "long_ptr", $sFuncName, "hwnd", $hWnd, "int", $iIndex)
If @error Or Not $aResult[0] Then Return SetError(@error + 10, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetWindowThreadProcessId($hWnd, ByRef $iPID)
Local $aResult = DllCall("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $hWnd, "dword*", 0)
If @error Then Return SetError(@error, @extended, 0)
$iPID = $aResult[2]
Return $aResult[0]
EndFunc
Func _WinAPI_GetXYFromPoint(ByRef $tPoint, ByRef $iX, ByRef $iY)
$iX = DllStructGetData($tPoint, "X")
$iY = DllStructGetData($tPoint, "Y")
EndFunc
Func _WinAPI_GUIDFromString($sGUID)
Local $tGUID = DllStructCreate($tagGUID)
_WinAPI_GUIDFromStringEx($sGUID, $tGUID)
If @error Then Return SetError(@error + 10, @extended, 0)
Return $tGUID
EndFunc
Func _WinAPI_GUIDFromStringEx($sGUID, $tGUID)
Local $aResult = DllCall("ole32.dll", "long", "CLSIDFromString", "wstr", $sGUID, "struct*", $tGUID)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_HiWord($iLong)
Return BitShift($iLong, 16)
EndFunc
Func _WinAPI_InProcess($hWnd, ByRef $hLastWnd)
If $hWnd = $hLastWnd Then Return True
For $iI = $__g_aInProcess_WinAPI[0][0] To 1 Step -1
If $hWnd = $__g_aInProcess_WinAPI[$iI][0] Then
If $__g_aInProcess_WinAPI[$iI][1] Then
$hLastWnd = $hWnd
Return True
Else
Return False
EndIf
EndIf
Next
Local $iPID
_WinAPI_GetWindowThreadProcessId($hWnd, $iPID)
Local $iCount = $__g_aInProcess_WinAPI[0][0] + 1
If $iCount >= 64 Then $iCount = 1
$__g_aInProcess_WinAPI[0][0] = $iCount
$__g_aInProcess_WinAPI[$iCount][0] = $hWnd
$__g_aInProcess_WinAPI[$iCount][1] =($iPID = @AutoItPID)
Return $__g_aInProcess_WinAPI[$iCount][1]
EndFunc
Func _WinAPI_IsClassName($hWnd, $sClassName)
Local $sSeparator = Opt("GUIDataSeparatorChar")
Local $aClassName = StringSplit($sClassName, $sSeparator)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $sClassCheck = _WinAPI_GetClassName($hWnd)
For $x = 1 To UBound($aClassName) - 1
If StringUpper(StringMid($sClassCheck, 1, StringLen($aClassName[$x]))) = StringUpper($aClassName[$x]) Then Return True
Next
Return False
EndFunc
Func _WinAPI_IsWindowVisible($hWnd)
Local $aResult = DllCall("user32.dll", "bool", "IsWindowVisible", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_LoadImage($hInstance, $sImage, $iType, $iXDesired, $iYDesired, $iLoad)
Local $aResult, $sImageType = "int"
If IsString($sImage) Then $sImageType = "wstr"
$aResult = DllCall("user32.dll", "handle", "LoadImageW", "handle", $hInstance, $sImageType, $sImage, "uint", $iType, "int", $iXDesired, "int", $iYDesired, "uint", $iLoad)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_LoWord($iLong)
Return BitAND($iLong, 0xFFFF)
EndFunc
Func _WinAPI_MakeLong($iLo, $iHi)
Return BitOR(BitShift($iHi, -16), BitAND($iLo, 0xFFFF))
EndFunc
Func _WinAPI_OpenProcess($iAccess, $bInherit, $iPID, $bDebugPriv = False)
Local $aResult = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iAccess, "bool", $bInherit, "dword", $iPID)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return $aResult[0]
If Not $bDebugPriv Then Return SetError(100, 0, 0)
Local $hToken = _Security__OpenThreadTokenEx(BitOR($TOKEN_ADJUST_PRIVILEGES, $TOKEN_QUERY))
If @error Then Return SetError(@error + 10, @extended, 0)
_Security__SetPrivilege($hToken, "SeDebugPrivilege", True)
Local $iError = @error
Local $iExtended = @extended
Local $iRet = 0
If Not @error Then
$aResult = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iAccess, "bool", $bInherit, "dword", $iPID)
$iError = @error
$iExtended = @extended
If $aResult[0] Then $iRet = $aResult[0]
_Security__SetPrivilege($hToken, "SeDebugPrivilege", False)
If @error Then
$iError = @error + 20
$iExtended = @extended
EndIf
Else
$iError = @error + 30
EndIf
_WinAPI_CloseHandle($hToken)
Return SetError($iError, $iExtended, $iRet)
EndFunc
Func _WinAPI_PointFromRect(ByRef $tRECT, $bCenter = True)
Local $iX1 = DllStructGetData($tRECT, "Left")
Local $iY1 = DllStructGetData($tRECT, "Top")
Local $iX2 = DllStructGetData($tRECT, "Right")
Local $iY2 = DllStructGetData($tRECT, "Bottom")
If $bCenter Then
$iX1 = $iX1 +(($iX2 - $iX1) / 2)
$iY1 = $iY1 +(($iY2 - $iY1) / 2)
EndIf
Local $tPoint = DllStructCreate($tagPOINT)
DllStructSetData($tPoint, "X", $iX1)
DllStructSetData($tPoint, "Y", $iY1)
Return $tPoint
EndFunc
Func _WinAPI_PostMessage($hWnd, $iMsg, $wParam, $lParam)
Local $aResult = DllCall("user32.dll", "bool", "PostMessage", "hwnd", $hWnd, "uint", $iMsg, "wparam", $wParam, "lparam", $lParam)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_ReadFile($hFile, $pBuffer, $iToRead, ByRef $iRead, $tOverlapped = 0)
Local $aResult = DllCall("kernel32.dll", "bool", "ReadFile", "handle", $hFile, "struct*", $pBuffer, "dword", $iToRead, "dword*", 0, "struct*", $tOverlapped)
If @error Then Return SetError(@error, @extended, False)
$iRead = $aResult[4]
Return $aResult[0]
EndFunc
Func _WinAPI_RedrawWindow($hWnd, $tRECT = 0, $hRegion = 0, $iFlags = 5)
Local $aResult = DllCall("user32.dll", "bool", "RedrawWindow", "hwnd", $hWnd, "struct*", $tRECT, "handle", $hRegion, "uint", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_RegisterWindowMessage($sMessage)
Local $aResult = DllCall("user32.dll", "uint", "RegisterWindowMessageW", "wstr", $sMessage)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_ReleaseDC($hWnd, $hDC)
Local $aResult = DllCall("user32.dll", "int", "ReleaseDC", "hwnd", $hWnd, "handle", $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SelectObject($hDC, $hGDIObj)
Local $aResult = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hDC, "handle", $hGDIObj)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetFilePointer($hFile, $iPos, $iMethod = 0)
Local $aResult = DllCall("kernel32.dll", "INT", "SetFilePointer", "handle", $hFile, "long", $iPos, "ptr", 0, "long", $iMethod)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_SetFocus($hWnd)
Local $aResult = DllCall("user32.dll", "hwnd", "SetFocus", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SetFont($hWnd, $hFont, $bRedraw = True)
_SendMessage($hWnd, $__WINAPICONSTANT_WM_SETFONT, $hFont, $bRedraw, 0, "hwnd")
EndFunc
Func _WinAPI_SetParent($hWndChild, $hWndParent)
Local $aResult = DllCall("user32.dll", "hwnd", "SetParent", "hwnd", $hWndChild, "hwnd", $hWndParent)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SetWindowLong($hWnd, $iIndex, $iValue)
_WinAPI_SetLastError(0)
Local $sFuncName = "SetWindowLongW"
If @AutoItX64 Then $sFuncName = "SetWindowLongPtrW"
Local $aResult = DllCall("user32.dll", "long_ptr", $sFuncName, "hwnd", $hWnd, "int", $iIndex, "long_ptr", $iValue)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SetWindowPos($hWnd, $hAfter, $iX, $iY, $iCX, $iCY, $iFlags)
Local $aResult = DllCall("user32.dll", "bool", "SetWindowPos", "hwnd", $hWnd, "hwnd", $hAfter, "int", $iX, "int", $iY, "int", $iCX, "int", $iCY, "uint", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetWindowsHookEx($iHook, $pProc, $hDll, $iThreadId = 0)
Local $aResult = DllCall("user32.dll", "handle", "SetWindowsHookEx", "int", $iHook, "ptr", $pProc, "handle", $hDll, "dword", $iThreadId)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SetWindowText($hWnd, $sText)
Local $aResult = DllCall("user32.dll", "bool", "SetWindowTextW", "hwnd", $hWnd, "wstr", $sText)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_ShowWindow($hWnd, $iCmdShow = 5)
Local $aResult = DllCall("user32.dll", "bool", "ShowWindow", "hwnd", $hWnd, "int", $iCmdShow)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_StringFromGUID($tGUID)
Local $aResult = DllCall("ole32.dll", "int", "StringFromGUID2", "struct*", $tGUID, "wstr", "", "int", 40)
If @error Or Not $aResult[0] Then Return SetError(@error, @extended, "")
Return SetExtended($aResult[0], $aResult[2])
EndFunc
Func _WinAPI_UnhookWindowsHookEx($hHook)
Local $aResult = DllCall("user32.dll", "bool", "UnhookWindowsHookEx", "handle", $hHook)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_UpdateLayeredWindow($hWnd, $hDestDC, $tPTDest, $tSize, $hSrcDC, $tPTSrce, $iRGB, $tBlend, $iFlags)
Local $aResult = DllCall("user32.dll", "bool", "UpdateLayeredWindow", "hwnd", $hWnd, "handle", $hDestDC, "struct*", $tPTDest, "struct*", $tSize, "handle", $hSrcDC, "struct*", $tPTSrce, "dword", $iRGB, "struct*", $tBlend, "dword", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_UpdateWindow($hWnd)
Local $aResult = DllCall("user32.dll", "bool", "UpdateWindow", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_WaitForSingleObject($hHandle, $iTimeout = -1)
Local $aResult = DllCall("kernel32.dll", "INT", "WaitForSingleObject", "handle", $hHandle, "dword", $iTimeout)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_WideCharToMultiByte($vUnicode, $iCodePage = 0, $bRetString = True)
Local $sUnicodeType = "wstr"
If Not IsString($vUnicode) Then $sUnicodeType = "struct*"
Local $aResult = DllCall("kernel32.dll", "int", "WideCharToMultiByte", "uint", $iCodePage, "dword", 0, $sUnicodeType, $vUnicode, "int", -1, "ptr", 0, "int", 0, "ptr", 0, "ptr", 0)
If @error Or Not $aResult[0] Then Return SetError(@error + 20, @extended, "")
Local $tMultiByte = DllStructCreate("char[" & $aResult[0] & "]")
$aResult = DllCall("kernel32.dll", "int", "WideCharToMultiByte", "uint", $iCodePage, "dword", 0, $sUnicodeType, $vUnicode, "int", -1, "struct*", $tMultiByte, "int", $aResult[0], "ptr", 0, "ptr", 0)
If @error Or Not $aResult[0] Then Return SetError(@error + 10, @extended, "")
If $bRetString Then Return DllStructGetData($tMultiByte, 1)
Return $tMultiByte
EndFunc
Func _WinAPI_WriteFile($hFile, $pBuffer, $iToWrite, ByRef $iWritten, $tOverlapped = 0)
Local $aResult = DllCall("kernel32.dll", "bool", "WriteFile", "handle", $hFile, "struct*", $pBuffer, "dword", $iToWrite, "dword*", 0, "struct*", $tOverlapped)
If @error Then Return SetError(@error, @extended, False)
$iWritten = $aResult[4]
Return $aResult[0]
EndFunc
Global Const $PROCESS_VM_OPERATION = 0x00000008
Global Const $PROCESS_VM_READ = 0x00000010
Global Const $PROCESS_VM_WRITE = 0x00000020
Global Const $PROCESS_QUERY_INFORMATION = 0x00000400
Global Const $PROCESS_QUERY_LIMITED_INFORMATION = 0x1000
Global Const $PROCESS_ALL_ACCESS = 0x001F0FFF
Func _ProcessGetPriority($vProcess)
Local $iError = 0, $iExtended = 0, $iReturn = -1
Local $iPID = ProcessExists($vProcess)
If Not $iPID Then Return SetError(1, 0, -1)
Local $hDLL = DllOpen('kernel32.dll')
Do
Local $aProcessHandle = DllCall($hDLL, 'handle', 'OpenProcess', 'dword', $PROCESS_QUERY_INFORMATION, 'bool', False, 'dword', $iPID)
If @error Then
$iError = @error + 10
$iExtended = @extended
ExitLoop
EndIf
If Not $aProcessHandle[0] Then ExitLoop
Local $aPriority = DllCall($hDLL, 'dword', 'GetPriorityClass', 'handle', $aProcessHandle[0])
If @error Then
$iError = @error
$iExtended = @extended
EndIf
DllCall($hDLL, 'bool', 'CloseHandle', 'handle', $aProcessHandle[0])
If $iError Then ExitLoop
Switch $aPriority[0]
Case 0x00000040
$iReturn = 0
Case 0x00004000
$iReturn = 1
Case 0x00000020
$iReturn = 2
Case 0x00008000
$iReturn = 3
Case 0x00000080
$iReturn = 4
Case 0x00000100
$iReturn = 5
Case Else
$iError = 1
$iExtended = $aPriority[0]
$iReturn = -1
EndSwitch
Until True
DllClose($hDLL)
Return SetError($iError, $iExtended, $iReturn)
EndFunc
Func _Max($iNum1, $iNum2)
If Not IsNumber($iNum1) Then Return SetError(1, 0, 0)
If Not IsNumber($iNum2) Then Return SetError(2, 0, 0)
Return($iNum1 > $iNum2) ? $iNum1 : $iNum2
EndFunc
Func _Min($iNum1, $iNum2)
If Not IsNumber($iNum1) Then Return SetError(1, 0, 0)
If Not IsNumber($iNum2) Then Return SetError(2, 0, 0)
Return($iNum1 > $iNum2) ? $iNum2 : $iNum1
EndFunc
Global Const $BS_DEFPUSHBUTTON = 0x0001
Global Const $BS_MULTILINE = 0x2000
Global Const $BS_PUSHLIKE = 0x1000
Global Const $BS_VCENTER = 0x0C00
Global Const $BS_FLAT = 0x8000
Global Const $BS_ICON = 0x0040
Global Const $GUI_SS_DEFAULT_GROUP = 0
Global Const $BCM_FIRST = 0x1600
Global Const $BCM_SETIMAGELIST =($BCM_FIRST + 0x0002)
Global Const $CB_ERR = -1
Global Const $CBS_AUTOHSCROLL = 0x40
Global Const $CBS_DROPDOWN = 0x2
Global Const $CBS_DROPDOWNLIST = 0x3
Global Const $CB_FINDSTRINGEXACT = 0x158
Global Const $CB_GETCOUNT = 0x146
Global Const $CB_GETCURSEL = 0x147
Global Const $CB_GETLBTEXT = 0x148
Global Const $CB_GETLBTEXTLEN = 0x149
Global Const $CB_RESETCONTENT = 0x14B
Global Const $CB_SELECTSTRING = 0x14D
Global Const $CB_SETCURSEL = 0x14E
Global Const $CBN_SELCHANGE = 1
Global Const $__COMBOBOXCONSTANT_WM_USER = 0X400
Global Const $CBEM_GETCOMBOCONTROL =($__COMBOBOXCONSTANT_WM_USER + 6)
Global Const $CBEM_GETUNICODEFORMAT = 0x2000 + 6
Global Const $CBEM_INSERTITEMA =($__COMBOBOXCONSTANT_WM_USER + 1)
Global Const $CBEM_INSERTITEMW =($__COMBOBOXCONSTANT_WM_USER + 11)
Global Const $CBEM_SETIMAGELIST =($__COMBOBOXCONSTANT_WM_USER + 2)
Global Const $CBEIF_DI_SETITEM = 0x10000000
Global Const $CBEIF_IMAGE = 0x2
Global Const $CBEIF_INDENT = 0x10
Global Const $CBEIF_LPARAM = 0x20
Global Const $CBEIF_OVERLAY = 0x8
Global Const $CBEIF_SELECTEDIMAGE = 0x4
Global Const $CBEIF_TEXT = 0x1
Global Const $ES_LEFT = 0
Global Const $ES_CENTER = 1
Global Const $ES_MULTILINE = 4
Global Const $ES_AUTOVSCROLL = 64
Global Const $ES_AUTOHSCROLL = 128
Global Const $ES_READONLY = 2048
Global Const $ES_WANTRETURN = 4096
Global Const $ES_NUMBER = 8192
Global Const $EM_SETREADONLY = 0xCF
Global Const $EM_SETSEL = 0xB1
Global Const $GUI_SS_DEFAULT_INPUT = 0x00000080
Global Const $GUI_EVENT_CLOSE = -3
Global Const $GUI_EVENT_MINIMIZE = -4
Global Const $GUI_EVENT_RESTORE = -5
Global Const $GUI_RUNDEFMSG = 'GUI_RUNDEFMSG'
Global Const $GUI_CHECKED = 1
Global Const $GUI_UNCHECKED = 4
Global Const $GUI_SHOW = 16
Global Const $GUI_HIDE = 32
Global Const $GUI_ENABLE = 64
Global Const $GUI_DISABLE = 128
Global Const $GUI_FONTUNDER = 4
Global Const $GUI_DOCKLEFT = 0x0002
Global Const $GUI_DOCKBOTTOM = 0x0040
Global Const $GUI_DOCKWIDTH = 0x0100
Global Const $GUI_DOCKHEIGHT = 0x0200
Global Const $GUI_DOCKALL = 0x0322
Global Const $GUI_DOCKBORDERS = 0x0066
Global Const $GUI_BKCOLOR_TRANSPARENT = -2
Global Const $_UDF_GlobalIDs_OFFSET = 2
Global Const $_UDF_GlobalID_MAX_WIN = 16
Global Const $_UDF_STARTID = 10000
Global Const $_UDF_GlobalID_MAX_IDS = 55535
Global Const $__UDFGUICONSTANT_WS_TABSTOP = 0x00010000
Global Const $__UDFGUICONSTANT_WS_VISIBLE = 0x10000000
Global Const $__UDFGUICONSTANT_WS_CHILD = 0x40000000
Global $__g_aUDF_GlobalIDs_Used[$_UDF_GlobalID_MAX_WIN][$_UDF_GlobalID_MAX_IDS + $_UDF_GlobalIDs_OFFSET + 1]
Func __UDF_GetNextGlobalID($hWnd)
Local $nCtrlID, $iUsedIndex = -1, $bAllUsed = True
If Not WinExists($hWnd) Then Return SetError(-1, -1, 0)
For $iIndex = 0 To $_UDF_GlobalID_MAX_WIN - 1
If $__g_aUDF_GlobalIDs_Used[$iIndex][0] <> 0 Then
If Not WinExists($__g_aUDF_GlobalIDs_Used[$iIndex][0]) Then
For $x = 0 To UBound($__g_aUDF_GlobalIDs_Used, $UBOUND_COLUMNS) - 1
$__g_aUDF_GlobalIDs_Used[$iIndex][$x] = 0
Next
$__g_aUDF_GlobalIDs_Used[$iIndex][1] = $_UDF_STARTID
$bAllUsed = False
EndIf
EndIf
Next
For $iIndex = 0 To $_UDF_GlobalID_MAX_WIN - 1
If $__g_aUDF_GlobalIDs_Used[$iIndex][0] = $hWnd Then
$iUsedIndex = $iIndex
ExitLoop
EndIf
Next
If $iUsedIndex = -1 Then
For $iIndex = 0 To $_UDF_GlobalID_MAX_WIN - 1
If $__g_aUDF_GlobalIDs_Used[$iIndex][0] = 0 Then
$__g_aUDF_GlobalIDs_Used[$iIndex][0] = $hWnd
$__g_aUDF_GlobalIDs_Used[$iIndex][1] = $_UDF_STARTID
$bAllUsed = False
$iUsedIndex = $iIndex
ExitLoop
EndIf
Next
EndIf
If $iUsedIndex = -1 And $bAllUsed Then Return SetError(16, 0, 0)
If $__g_aUDF_GlobalIDs_Used[$iUsedIndex][1] = $_UDF_STARTID + $_UDF_GlobalID_MAX_IDS Then
For $iIDIndex = $_UDF_GlobalIDs_OFFSET To UBound($__g_aUDF_GlobalIDs_Used, $UBOUND_COLUMNS) - 1
If $__g_aUDF_GlobalIDs_Used[$iUsedIndex][$iIDIndex] = 0 Then
$nCtrlID =($iIDIndex - $_UDF_GlobalIDs_OFFSET) + 10000
$__g_aUDF_GlobalIDs_Used[$iUsedIndex][$iIDIndex] = $nCtrlID
Return $nCtrlID
EndIf
Next
Return SetError(-1, $_UDF_GlobalID_MAX_IDS, 0)
EndIf
$nCtrlID = $__g_aUDF_GlobalIDs_Used[$iUsedIndex][1]
$__g_aUDF_GlobalIDs_Used[$iUsedIndex][1] += 1
$__g_aUDF_GlobalIDs_Used[$iUsedIndex][($nCtrlID - 10000) + $_UDF_GlobalIDs_OFFSET] = $nCtrlID
Return $nCtrlID
EndFunc
Func __UDF_FreeGlobalID($hWnd, $iGlobalID)
If $iGlobalID - $_UDF_STARTID < 0 Or $iGlobalID - $_UDF_STARTID > $_UDF_GlobalID_MAX_IDS Then Return SetError(-1, 0, False)
For $iIndex = 0 To $_UDF_GlobalID_MAX_WIN - 1
If $__g_aUDF_GlobalIDs_Used[$iIndex][0] = $hWnd Then
For $x = $_UDF_GlobalIDs_OFFSET To UBound($__g_aUDF_GlobalIDs_Used, $UBOUND_COLUMNS) - 1
If $__g_aUDF_GlobalIDs_Used[$iIndex][$x] = $iGlobalID Then
$__g_aUDF_GlobalIDs_Used[$iIndex][$x] = 0
Return True
EndIf
Next
Return SetError(-3, 0, False)
EndIf
Next
Return SetError(-2, 0, False)
EndFunc
Global Const $tagBUTTON_IMAGELIST = "ptr ImageList;" & $tagRECT & ";uint Align"
Global Const $__BUTTONCONSTANT_ClassName = "Button"
Func _GUICtrlButton_Enable($hWnd, $bEnable = True)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If _WinAPI_IsClassName($hWnd, $__BUTTONCONSTANT_ClassName) Then Return _WinAPI_EnableWindow($hWnd, $bEnable) = $bEnable
EndFunc
Func _GUICtrlButton_SetImageList($hWnd, $hImage, $iAlign = 0, $iLeft = 1, $iTop = 1, $iRight = 1, $iBottom = 1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If $iAlign < 0 Or $iAlign > 4 Then $iAlign = 0
Local $tBUTTON_IMAGELIST = DllStructCreate($tagBUTTON_IMAGELIST)
DllStructSetData($tBUTTON_IMAGELIST, "ImageList", $hImage)
DllStructSetData($tBUTTON_IMAGELIST, "Left", $iLeft)
DllStructSetData($tBUTTON_IMAGELIST, "Top", $iTop)
DllStructSetData($tBUTTON_IMAGELIST, "Right", $iRight)
DllStructSetData($tBUTTON_IMAGELIST, "Bottom", $iBottom)
DllStructSetData($tBUTTON_IMAGELIST, "Align", $iAlign)
Local $bEnabled = _GUICtrlButton_Enable($hWnd, False)
Local $iRet = _SendMessage($hWnd, $BCM_SETIMAGELIST, 0, $tBUTTON_IMAGELIST, 0, "wparam", "struct*") <> 0
_GUICtrlButton_Enable($hWnd)
If Not $bEnabled Then _GUICtrlButton_Enable($hWnd, False)
Return $iRet
EndFunc
Global Const $COLOR_AQUA = 0x00FFFF
Global Const $COLOR_BLACK = 0x000000
Global Const $COLOR_BLUE = 0x0000FF
Global Const $COLOR_FUCHSIA = 0xFF00FF
Global Const $COLOR_GRAY = 0x808080
Global Const $COLOR_GREEN = 0x008000
Global Const $COLOR_MAROON = 0x8B1C62
Global Const $COLOR_MEDGRAY = 0xA0A0A4
Global Const $COLOR_MONEYGREEN = 0xC0DCC0
Global Const $COLOR_NAVY = 0x000080
Global Const $COLOR_PURPLE = 0x800080
Global Const $COLOR_RED = 0xFF0000
Global Const $COLOR_WHITE = 0xFFFFFF
Global Const $COLOR_YELLOW = 0xFFFF00
Global Const $ILC_MASK = 0x00000001
Global Const $ILC_COLOR = 0x00000000
Global Const $ILC_COLORDDB = 0x000000FE
Global Const $ILC_COLOR4 = 0x00000004
Global Const $ILC_COLOR8 = 0x00000008
Global Const $ILC_COLOR16 = 0x00000010
Global Const $ILC_COLOR24 = 0x00000018
Global Const $ILC_COLOR32 = 0x00000020
Global Const $ILC_MIRROR = 0x00002000
Global Const $ILC_PERITEMMIRROR = 0x00008000
Global Const $__IMAGELISTCONSTANT_IMAGE_BITMAP = 0
Func _GUIImageList_Add($hWnd, $hImage, $hMask = 0)
Local $aResult = DllCall("comctl32.dll", "int", "ImageList_Add", "handle", $hWnd, "handle", $hImage, "handle", $hMask)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _GUIImageList_AddBitmap($hWnd, $sImage, $sMask = "")
Local $aSize = _GUIImageList_GetIconSize($hWnd)
Local $hImage = _WinAPI_LoadImage(0, $sImage, $__IMAGELISTCONSTANT_IMAGE_BITMAP, $aSize[0], $aSize[1], $LR_LOADFROMFILE)
If $hImage = 0 Then Return SetError(_WinAPI_GetLastError(), 1, -1)
Local $hMask = 0
If $sMask <> "" Then
$hMask = _WinAPI_LoadImage(0, $sMask, $__IMAGELISTCONSTANT_IMAGE_BITMAP, $aSize[0], $aSize[1], $LR_LOADFROMFILE)
If $hMask = 0 Then Return SetError(_WinAPI_GetLastError(), 2, -1)
EndIf
Local $iRet = _GUIImageList_Add($hWnd, $hImage, $hMask)
_WinAPI_DeleteObject($hImage)
If $hMask <> 0 Then _WinAPI_DeleteObject($hMask)
Return $iRet
EndFunc
Func _GUIImageList_AddIcon($hWnd, $sFilePath, $iIndex = 0, $bLarge = False)
Local $iRet, $tIcon = DllStructCreate("handle Handle")
If $bLarge Then
$iRet = _WinAPI_ExtractIconEx($sFilePath, $iIndex, $tIcon, 0, 1)
Else
$iRet = _WinAPI_ExtractIconEx($sFilePath, $iIndex, 0, $tIcon, 1)
EndIf
If $iRet <= 0 Then Return SetError(-1, $iRet, -1)
Local $hIcon = DllStructGetData($tIcon, "Handle")
$iRet = _GUIImageList_ReplaceIcon($hWnd, -1, $hIcon)
_WinAPI_DestroyIcon($hIcon)
If $iRet = -1 Then Return SetError(-2, $iRet, -1)
Return $iRet
EndFunc
Func _GUIImageList_Create($iCX = 16, $iCY = 16, $iColor = 4, $iOptions = 0, $iInitial = 4, $iGrow = 4)
Local Const $aColor[7] = [$ILC_COLOR, $ILC_COLOR4, $ILC_COLOR8, $ILC_COLOR16, $ILC_COLOR24, $ILC_COLOR32, $ILC_COLORDDB]
Local $iFlags = 0
If BitAND($iOptions, 1) <> 0 Then $iFlags = BitOR($iFlags, $ILC_MASK)
If BitAND($iOptions, 2) <> 0 Then $iFlags = BitOR($iFlags, $ILC_MIRROR)
If BitAND($iOptions, 4) <> 0 Then $iFlags = BitOR($iFlags, $ILC_PERITEMMIRROR)
$iFlags = BitOR($iFlags, $aColor[$iColor])
Local $aResult = DllCall("comctl32.dll", "handle", "ImageList_Create", "int", $iCX, "int", $iCY, "uint", $iFlags, "int", $iInitial, "int", $iGrow)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _GUIImageList_Destroy($hWnd)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_Destroy", "handle", $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_GetIconSize($hWnd)
Local $aSize[2]
Local $tPoint = _GUIImageList_GetIconSizeEx($hWnd)
$aSize[0] = DllStructGetData($tPoint, "X")
$aSize[1] = DllStructGetData($tPoint, "Y")
Return $aSize
EndFunc
Func _GUIImageList_GetIconSizeEx($hWnd)
Local $tPoint = DllStructCreate($tagPOINT)
Local $pPointX = DllStructGetPtr($tPoint, "X")
Local $pPointY = DllStructGetPtr($tPoint, "Y")
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_GetIconSize", "hwnd", $hWnd, "struct*", $pPointX, "struct*", $pPointY)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tPoint)
EndFunc
Func _GUIImageList_ReplaceIcon($hWnd, $iIndex, $hIcon)
Local $aResult = DllCall("comctl32.dll", "int", "ImageList_ReplaceIcon", "handle", $hWnd, "int", $iIndex, "handle", $hIcon)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Global Const $GMEM_MOVEABLE = 0x0002
Global Const $MEM_COMMIT = 0x00001000
Global Const $MEM_RESERVE = 0x00002000
Global Const $PAGE_READWRITE = 0x00000004
Global Const $MEM_RELEASE = 0x00008000
Global Const $tagMEMMAP = "handle hProc;ulong_ptr Size;ptr Mem"
Func _MemFree(ByRef $tMemMap)
Local $pMemory = DllStructGetData($tMemMap, "Mem")
Local $hProcess = DllStructGetData($tMemMap, "hProc")
Local $bResult = _MemVirtualFreeEx($hProcess, $pMemory, 0, $MEM_RELEASE)
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hProcess)
If @error Then Return SetError(@error, @extended, False)
Return $bResult
EndFunc
Func _MemGlobalAlloc($iBytes, $iFlags = 0)
Local $aResult = DllCall("kernel32.dll", "handle", "GlobalAlloc", "uint", $iFlags, "ulong_ptr", $iBytes)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _MemGlobalLock($hMemory)
Local $aResult = DllCall("kernel32.dll", "ptr", "GlobalLock", "handle", $hMemory)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _MemGlobalUnlock($hMemory)
Local $aResult = DllCall("kernel32.dll", "bool", "GlobalUnlock", "handle", $hMemory)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _MemInit($hWnd, $iSize, ByRef $tMemMap)
Local $aResult = DllCall("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $hWnd, "dword*", 0)
If @error Then Return SetError(@error + 10, @extended, 0)
Local $iProcessID = $aResult[2]
If $iProcessID = 0 Then Return SetError(1, 0, 0)
Local $iAccess = BitOR($PROCESS_VM_OPERATION, $PROCESS_VM_READ, $PROCESS_VM_WRITE)
Local $hProcess = __Mem_OpenProcess($iAccess, False, $iProcessID, True)
Local $iAlloc = BitOR($MEM_RESERVE, $MEM_COMMIT)
Local $pMemory = _MemVirtualAllocEx($hProcess, 0, $iSize, $iAlloc, $PAGE_READWRITE)
If $pMemory = 0 Then Return SetError(2, 0, 0)
$tMemMap = DllStructCreate($tagMEMMAP)
DllStructSetData($tMemMap, "hProc", $hProcess)
DllStructSetData($tMemMap, "Size", $iSize)
DllStructSetData($tMemMap, "Mem", $pMemory)
Return $pMemory
EndFunc
Func _MemRead(ByRef $tMemMap, $pSrce, $pDest, $iSize)
Local $aResult = DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", DllStructGetData($tMemMap, "hProc"), "ptr", $pSrce, "struct*", $pDest, "ulong_ptr", $iSize, "ulong_ptr*", 0)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _MemWrite(ByRef $tMemMap, $pSrce, $pDest = 0, $iSize = 0, $sSrce = "struct*")
If $pDest = 0 Then $pDest = DllStructGetData($tMemMap, "Mem")
If $iSize = 0 Then $iSize = DllStructGetData($tMemMap, "Size")
Local $aResult = DllCall("kernel32.dll", "bool", "WriteProcessMemory", "handle", DllStructGetData($tMemMap, "hProc"), "ptr", $pDest, $sSrce, $pSrce, "ulong_ptr", $iSize, "ulong_ptr*", 0)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _MemVirtualAllocEx($hProcess, $pAddress, $iSize, $iAllocation, $iProtect)
Local $aResult = DllCall("kernel32.dll", "ptr", "VirtualAllocEx", "handle", $hProcess, "ptr", $pAddress, "ulong_ptr", $iSize, "dword", $iAllocation, "dword", $iProtect)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _MemVirtualFreeEx($hProcess, $pAddress, $iSize, $iFreeType)
Local $aResult = DllCall("kernel32.dll", "bool", "VirtualFreeEx", "handle", $hProcess, "ptr", $pAddress, "ulong_ptr", $iSize, "dword", $iFreeType)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func __Mem_OpenProcess($iAccess, $bInherit, $iProcessID, $bDebugPriv = False)
Local $aResult = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iAccess, "bool", $bInherit, "dword", $iProcessID)
If @error Then Return SetError(@error + 10, @extended, 0)
If $aResult[0] Then Return $aResult[0]
If Not $bDebugPriv Then Return 0
Local $hToken = _Security__OpenThreadTokenEx(BitOR($TOKEN_ADJUST_PRIVILEGES, $TOKEN_QUERY))
If @error Then Return SetError(@error + 20, @extended, 0)
_Security__SetPrivilege($hToken, "SeDebugPrivilege", True)
Local $iError = @error
Local $iLastError = @extended
Local $iRet = 0
If Not @error Then
$aResult = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iAccess, "bool", $bInherit, "dword", $iProcessID)
$iError = @error
$iLastError = @extended
If $aResult[0] Then $iRet = $aResult[0]
_Security__SetPrivilege($hToken, "SeDebugPrivilege", False)
If @error Then
$iError = @error + 30
$iLastError = @extended
EndIf
Else
$iError = @error + 40
EndIf
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hToken)
Return SetError($iError, $iLastError, $iRet)
EndFunc
Global Const $__STATUSBARCONSTANT_WM_USER = 0X400
Global Const $SB_GETUNICODEFORMAT = 0x2000 + 6
Global Const $SB_ISSIMPLE =($__STATUSBARCONSTANT_WM_USER + 14)
Global Const $SB_SETPARTS =($__STATUSBARCONSTANT_WM_USER + 4)
Global Const $SB_SETTEXTA =($__STATUSBARCONSTANT_WM_USER + 1)
Global Const $SB_SETTEXTW =($__STATUSBARCONSTANT_WM_USER + 11)
Global Const $SB_SETTEXT = $SB_SETTEXTA
Global Const $SB_SIMPLE =($__STATUSBARCONSTANT_WM_USER + 9)
Global Const $SB_SIMPLEID = 0xff
Global $__g_hSBLastWnd
Global Const $__STATUSBARCONSTANT_ClassName = "msctls_statusbar32"
Global Const $__STATUSBARCONSTANT_WM_SIZE = 0x05
Func _GUICtrlStatusBar_Create($hWnd, $vPartEdge = -1, $vPartText = "", $iStyles = -1, $iExStyles = 0x00000000)
If Not IsHWnd($hWnd) Then Return SetError(1, 0, 0)
Local $iStyle = BitOR($__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE)
If $iStyles = -1 Then $iStyles = 0x00000000
If $iExStyles = -1 Then $iExStyles = 0x00000000
Local $aPartWidth[1], $aPartText[1]
If @NumParams > 1 Then
If IsArray($vPartEdge) Then
$aPartWidth = $vPartEdge
Else
$aPartWidth[0] = $vPartEdge
EndIf
If @NumParams = 2 Then
ReDim $aPartText[UBound($aPartWidth)]
Else
If IsArray($vPartText) Then
$aPartText = $vPartText
Else
$aPartText[0] = $vPartText
EndIf
If UBound($aPartWidth) <> UBound($aPartText) Then
Local $iLast
If UBound($aPartWidth) > UBound($aPartText) Then
$iLast = UBound($aPartText)
ReDim $aPartText[UBound($aPartWidth)]
Else
$iLast = UBound($aPartWidth)
ReDim $aPartWidth[UBound($aPartText)]
For $x = $iLast To UBound($aPartWidth) - 1
$aPartWidth[$x] = $aPartWidth[$x - 1] + 75
Next
$aPartWidth[UBound($aPartText) - 1] = -1
EndIf
EndIf
EndIf
If Not IsHWnd($hWnd) Then $hWnd = HWnd($hWnd)
If @NumParams > 3 Then $iStyle = BitOR($iStyle, $iStyles)
EndIf
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Local $hWndSBar = _WinAPI_CreateWindowEx($iExStyles, $__STATUSBARCONSTANT_ClassName, "", $iStyle, 0, 0, 0, 0, $hWnd, $nCtrlID)
If @error Then Return SetError(@error, @extended, 0)
If @NumParams > 1 Then
_GUICtrlStatusBar_SetParts($hWndSBar, UBound($aPartWidth), $aPartWidth)
For $x = 0 To UBound($aPartText) - 1
_GUICtrlStatusBar_SetText($hWndSBar, $aPartText[$x], $x)
Next
EndIf
Return $hWndSBar
EndFunc
Func _GUICtrlStatusBar_GetUnicodeFormat($hWnd)
Return _SendMessage($hWnd, $SB_GETUNICODEFORMAT) <> 0
EndFunc
Func _GUICtrlStatusBar_IsSimple($hWnd)
Return _SendMessage($hWnd, $SB_ISSIMPLE) <> 0
EndFunc
Func _GUICtrlStatusBar_Resize($hWnd)
_SendMessage($hWnd, $__STATUSBARCONSTANT_WM_SIZE)
EndFunc
Func _GUICtrlStatusBar_SetParts($hWnd, $aParts = -1, $aPartWidth = 25)
Local $tParts, $iParts = 1
If IsArray($aParts) <> 0 Then
$aParts[UBound($aParts) - 1] = -1
$iParts = UBound($aParts)
$tParts = DllStructCreate("int[" & $iParts & "]")
For $x = 0 To $iParts - 2
DllStructSetData($tParts, 1, $aParts[$x], $x + 1)
Next
DllStructSetData($tParts, 1, -1, $iParts)
ElseIf IsArray($aPartWidth) <> 0 Then
$iParts = UBound($aPartWidth)
$tParts = DllStructCreate("int[" & $iParts & "]")
For $x = 0 To $iParts - 2
DllStructSetData($tParts, 1, $aPartWidth[$x], $x + 1)
Next
DllStructSetData($tParts, 1, -1, $iParts)
ElseIf $aParts > 1 Then
$iParts = $aParts
$tParts = DllStructCreate("int[" & $iParts & "]")
For $x = 1 To $iParts - 1
DllStructSetData($tParts, 1, $aPartWidth * $x, $x)
Next
DllStructSetData($tParts, 1, -1, $iParts)
Else
$tParts = DllStructCreate("int")
DllStructSetData($tParts, $iParts, -1)
EndIf
If _WinAPI_InProcess($hWnd, $__g_hSBLastWnd) Then
_SendMessage($hWnd, $SB_SETPARTS, $iParts, $tParts, 0, "wparam", "struct*")
Else
Local $iSize = DllStructGetSize($tParts)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iSize, $tMemMap)
_MemWrite($tMemMap, $tParts)
_SendMessage($hWnd, $SB_SETPARTS, $iParts, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
_GUICtrlStatusBar_Resize($hWnd)
Return True
EndFunc
Func _GUICtrlStatusBar_SetSimple($hWnd, $bSimple = True)
_SendMessage($hWnd, $SB_SIMPLE, $bSimple)
EndFunc
Func _GUICtrlStatusBar_SetText($hWnd, $sText = "", $iPart = 0, $iUFlag = 0)
Local $bUnicode = _GUICtrlStatusBar_GetUnicodeFormat($hWnd)
Local $iBuffer = StringLen($sText) + 1
Local $tText
If $bUnicode Then
$tText = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tText = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
DllStructSetData($tText, "Text", $sText)
If _GUICtrlStatusBar_IsSimple($hWnd) Then $iPart = $SB_SIMPLEID
Local $iRet
If _WinAPI_InProcess($hWnd, $__g_hSBLastWnd) Then
$iRet = _SendMessage($hWnd, $SB_SETTEXTW, BitOR($iPart, $iUFlag), $tText, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iBuffer, $tMemMap)
_MemWrite($tMemMap, $tText)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $SB_SETTEXTW, BitOR($iPart, $iUFlag), $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $SB_SETTEXT, BitOR($iPart, $iUFlag), $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Return $iRet <> 0
EndFunc
Global Const $TTF_IDISHWND = 0x00000001
Global Const $TTF_SUBCLASS = 0x00000010
Global Const $__TOOLTIPCONSTANTS_WM_USER = 0X400
Global Const $TTM_SETMAXTIPWIDTH = $__TOOLTIPCONSTANTS_WM_USER + 24
Global Const $TTM_ADDTOOLW = $__TOOLTIPCONSTANTS_WM_USER + 50
Global Const $TTM_GETTEXTW = $__TOOLTIPCONSTANTS_WM_USER + 56
Global Const $TTS_ALWAYSTIP = 0x00000001
Global Const $TTS_NOPREFIX = 0x00000002
Global Const $__EDITCONSTANT_WM_SETTEXT = 0x000C
Func _GUICtrlEdit_SetReadOnly($hWnd, $bReadOnly)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_SETREADONLY, $bReadOnly) <> 0
EndFunc
Func _GUICtrlEdit_SetText($hWnd, $sText)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $__EDITCONSTANT_WM_SETTEXT, 0, $sText, 0, "wparam", "wstr")
EndFunc
Global Const $__COMBOBOXCONSTANT_DEFAULT_GUI_FONT = 17
Func _GUICtrlComboBox_FindStringExact($hWnd, $sText, $iIndex = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_FINDSTRINGEXACT, $iIndex, $sText, 0, "wparam", "wstr")
EndFunc
Func _GUICtrlComboBox_GetCount($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_GETCOUNT)
EndFunc
Func _GUICtrlComboBox_GetCurSel($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_GETCURSEL)
EndFunc
Func _GUICtrlComboBox_GetLBText($hWnd, $iIndex, ByRef $sText)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iLen = _GUICtrlComboBox_GetLBTextLen($hWnd, $iIndex)
Local $tBuffer = DllStructCreate("wchar Text[" & $iLen + 1 & "]")
Local $iRet = _SendMessage($hWnd, $CB_GETLBTEXT, $iIndex, $tBuffer, 0, "wparam", "struct*")
If($iRet == $CB_ERR) Then Return SetError($CB_ERR, $CB_ERR, $CB_ERR)
$sText = DllStructGetData($tBuffer, "Text")
Return $iRet
EndFunc
Func _GUICtrlComboBox_GetLBTextLen($hWnd, $iIndex)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_GETLBTEXTLEN, $iIndex)
EndFunc
Func _GUICtrlComboBox_GetList($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $sDelimiter = Opt("GUIDataSeparatorChar")
Local $sResult = "", $sItem
For $i = 0 To _GUICtrlComboBox_GetCount($hWnd) - 1
_GUICtrlComboBox_GetLBText($hWnd, $i, $sItem)
$sResult &= $sItem & $sDelimiter
Next
Return StringTrimRight($sResult, StringLen($sDelimiter))
EndFunc
Func _GUICtrlComboBox_GetListArray($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $sDelimiter = Opt("GUIDataSeparatorChar")
Return StringSplit(_GUICtrlComboBox_GetList($hWnd), $sDelimiter)
EndFunc
Func _GUICtrlComboBox_ResetContent($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $CB_RESETCONTENT)
EndFunc
Func _GUICtrlComboBox_SelectString($hWnd, $sText, $iIndex = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_SELECTSTRING, $iIndex, $sText, 0, "wparam", "wstr")
EndFunc
Func _GUICtrlComboBox_SetCurSel($hWnd, $iIndex = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_SETCURSEL, $iIndex)
EndFunc
Global $__g_hCBExLastWnd
Global Const $__COMBOBOXEXCONSTANT_ClassName = "ComboBoxEx32"
Global Const $__COMBOBOXEXCONSTANT_WM_SIZE = 0x05
Func _GUICtrlComboBoxEx_AddString($hWnd, $sText, $iImage = -1, $iSelectedImage = -1, $iOverlayImage = -1, $iIndent = -1, $iParam = -1)
Return _GUICtrlComboBoxEx_InsertString($hWnd, $sText, -1, $iImage, $iSelectedImage, $iOverlayImage, $iIndent, $iParam)
EndFunc
Func _GUICtrlComboBoxEx_Create($hWnd, $sText, $iX, $iY, $iWidth = 100, $iHeight = 200, $iStyle = 0x00200002, $iExStyle = 0x00000000)
If Not IsHWnd($hWnd) Then Return SetError(1, 0, 0)
If Not IsString($sText) Then Return SetError(2, 0, 0)
Local $sDelimiter = Opt("GUIDataSeparatorChar")
If $iWidth = -1 Then $iWidth = 100
If $iHeight = -1 Then $iHeight = 200
Local Const $WS_VSCROLL = 0x00200000
If $iStyle = -1 Then $iStyle = BitOR($WS_VSCROLL, $CBS_DROPDOWN)
If $iExStyle = -1 Then $iExStyle = 0x00000000
$iStyle = BitOR($iStyle, $__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_TABSTOP, $__UDFGUICONSTANT_WS_VISIBLE)
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Local $hCombo = _WinAPI_CreateWindowEx($iExStyle, $__COMBOBOXEXCONSTANT_ClassName, "", $iStyle, $iX, $iY, $iWidth, $iHeight, $hWnd, $nCtrlID)
_WinAPI_SetFont($hCombo, _WinAPI_GetStockObject($__COMBOBOXCONSTANT_DEFAULT_GUI_FONT))
If StringLen($sText) Then
Local $aText = StringSplit($sText, $sDelimiter)
For $x = 1 To $aText[0]
_GUICtrlComboBoxEx_AddString($hCombo, $aText[$x])
Next
EndIf
Return $hCombo
EndFunc
Func _GUICtrlComboBoxEx_FindStringExact($hWnd, $sText, $iIndex = -1)
Return _SendMessage($hWnd, $CB_FINDSTRINGEXACT, $iIndex, $sText, 0, "wparam", "wstr")
EndFunc
Func _GUICtrlComboBoxEx_GetComboControl($hWnd)
Return HWnd(_SendMessage($hWnd, $CBEM_GETCOMBOCONTROL))
EndFunc
Func _GUICtrlComboBoxEx_GetCount($hWnd)
Return _SendMessage($hWnd, $CB_GETCOUNT)
EndFunc
Func _GUICtrlComboBoxEx_GetUnicode($hWnd)
Return _SendMessage($hWnd, $CBEM_GETUNICODEFORMAT) <> 0
EndFunc
Func _GUICtrlComboBoxEx_InsertString($hWnd, $sText, $iIndex = -1, $iImage = -1, $iSelectedImage = -1, $iOverlayImage = -1, $iIndent = -1, $iParam = -1)
Local $iBuffer = 0, $iMask, $iRet
Local $bUnicode = _GUICtrlComboBoxEx_GetUnicode($hWnd)
Local $tItem = DllStructCreate($tagCOMBOBOXEXITEM)
If $sText <> -1 Then
$iMask = BitOR($CBEIF_TEXT, $CBEIF_LPARAM)
$iBuffer = StringLen($sText) + 1
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
DllStructSetData($tBuffer, "Text", $sText)
DllStructSetData($tItem, "Text", DllStructGetPtr($tBuffer))
DllStructSetData($tItem, "TextMax", $iBuffer)
Else
$iMask = BitOR($CBEIF_DI_SETITEM, $CBEIF_LPARAM)
EndIf
If $iImage >= 0 Then $iMask = BitOR($iMask, $CBEIF_IMAGE)
If $iSelectedImage >= 0 Then $iMask = BitOR($iMask, $CBEIF_SELECTEDIMAGE)
If $iOverlayImage >= 0 Then $iMask = BitOR($iMask, $CBEIF_OVERLAY)
If $iIndent >= 1 Then $iMask = BitOR($iMask, $CBEIF_INDENT)
If $iParam = -1 Then $iParam = _GUICtrlComboBoxEx_GetCount($hWnd)
DllStructSetData($tItem, "Mask", $iMask)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "Image", $iImage)
DllStructSetData($tItem, "SelectedImage", $iSelectedImage)
DllStructSetData($tItem, "OverlayImage", $iOverlayImage)
DllStructSetData($tItem, "Indent", $iIndent)
DllStructSetData($tItem, "Param", $iParam)
If _WinAPI_InProcess($hWnd, $__g_hCBExLastWnd) Or($sText = -1) Then
$iRet = _SendMessage($hWnd, $CBEM_INSERTITEMW, 0, $tItem, 0, "wparam", "struct*")
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iItem
DllStructSetData($tItem, "Text", $pText)
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $CBEM_INSERTITEMW, 0, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $CBEM_INSERTITEMA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Return $iRet
EndFunc
Func _GUICtrlComboBoxEx_SetCurSel($hWnd, $iIndex = -1)
Return _SendMessage($hWnd, $CB_SETCURSEL, $iIndex)
EndFunc
Func _GUICtrlComboBoxEx_SetImageList($hWnd, $hHandle)
Local $hResult = _SendMessage($hWnd, $CBEM_SETIMAGELIST, 0, $hHandle, 0, "wparam", "handle", "handle")
_SendMessage($hWnd, $__COMBOBOXEXCONSTANT_WM_SIZE)
Return $hResult
EndFunc
Global Const $__SLIDERCONSTANT_WM_USER = 0x400
Global Const $TBM_SETTICFREQ = $__SLIDERCONSTANT_WM_USER + 20
Global Const $TBM_SETTIPSIDE = $__SLIDERCONSTANT_WM_USER + 31
Global Const $TBTS_BOTTOM = 2
Global Const $TBS_AUTOTICKS = 0x0001
Global Const $TBS_TOOLTIPS = 0x100
Func _GUICtrlSlider_SetTicFreq($hWnd, $iFreg)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $TBM_SETTICFREQ, $iFreg)
EndFunc
Func _GUICtrlSlider_SetTipSide($hWnd, $iLocation)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $TBM_SETTIPSIDE, $iLocation)
EndFunc
Global Const $PBS_SMOOTH = 1
Global Const $SS_LEFT = 0x0
Global Const $SS_CENTER = 0x1
Global Const $SS_RIGHT = 0x2
Global Const $SS_BLACKRECT = 0x4
Global Const $SS_SUNKEN = 0x1000
Global Const $STM_SETIMAGE = 0x0172
Global Const $TCS_MULTILINE = 0x00000200
Global Const $TCS_RIGHTJUSTIFY = 0x00000000
Global Const $TCM_FIRST = 0x1300
Global Const $TCCM_FIRST = 0X2000
Global Const $TCM_GETITEMRECT =($TCM_FIRST + 10)
Global Const $TCM_SETCURFOCUS =($TCM_FIRST + 48)
Global Const $TCM_SETIMAGELIST = $TCM_FIRST + 3
Global $__g_vEnum, $__g_vExt = 0
Global $__g_hHeap = 0, $__g_iRGBMode = 1
Global Const $tagOSVERSIONINFO = 'struct;dword OSVersionInfoSize;dword MajorVersion;dword MinorVersion;dword BuildNumber;dword PlatformId;wchar CSDVersion[128];endstruct'
Global Const $__WINVER = __WINVER()
Func _WinAPI_CreateRectEx($iX, $iY, $iWidth, $iHeight)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, 1, $iX)
DllStructSetData($tRECT, 2, $iY)
DllStructSetData($tRECT, 3, $iX + $iWidth)
DllStructSetData($tRECT, 4, $iY + $iHeight)
Return $tRECT
EndFunc
Func _WinAPI_FatalExit($iCode)
DllCall('kernel32.dll', 'none', 'FatalExit', 'int', $iCode)
If @error Then Return SetError(@error, @extended)
EndFunc
Func _WinAPI_IsBadReadPtr($pAddress, $iLength)
Local $aRet = DllCall('kernel32.dll', 'bool', 'IsBadReadPtr', 'struct*', $pAddress, 'uint_ptr', $iLength)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IsBadWritePtr($pAddress, $iLength)
Local $aRet = DllCall('kernel32.dll', 'bool', 'IsBadWritePtr', 'struct*', $pAddress, 'uint_ptr', $iLength)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_MoveMemory($pDestination, $pSource, $iLength)
If _WinAPI_IsBadReadPtr($pSource, $iLength) Then Return SetError(10, @extended, 0)
If _WinAPI_IsBadWritePtr($pDestination, $iLength) Then Return SetError(11, @extended, 0)
DllCall('ntdll.dll', 'none', 'RtlMoveMemory', 'struct*', $pDestination, 'struct*', $pSource, 'ulong_ptr', $iLength)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_StrLen($pString, $bUnicode = True)
Local $W = ''
If $bUnicode Then $W = 'W'
Local $aRet = DllCall('kernel32.dll', 'int', 'lstrlen' & $W, 'struct*', $pString)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SwitchColor($iColor)
If $iColor = -1 Then Return $iColor
Return BitOR(BitAND($iColor, 0x00FF00), BitShift(BitAND($iColor, 0x0000FF), -16), BitShift(BitAND($iColor, 0xFF0000), 16))
EndFunc
Func __CheckErrorCloseHandle($aRet, $hFile, $bLastError = 0, $iCurErr = @error, $iCurExt = @extended)
If Not $iCurErr And Not $aRet[0] Then $iCurErr = 10
Local $iLastError = _WinAPI_GetLastError()
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hFile)
If $iCurErr Then _WinAPI_SetLastError($iLastError)
If $bLastError Then $iCurExt = $iLastError
Return SetError($iCurErr, $iCurExt, $iCurErr)
EndFunc
Func __EnumWindowsProc($hWnd, $bVisible)
Local $aResult
If $bVisible Then
$aResult = DllCall("user32.dll", "bool", "IsWindowVisible", "hwnd", $hWnd)
If Not $aResult[0] Then
Return 1
EndIf
EndIf
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0][0]][0] = $hWnd
$aResult = DllCall("user32.dll", "int", "GetClassNameW", "hwnd", $hWnd, "wstr", "", "int", 4096)
$__g_vEnum[$__g_vEnum[0][0]][1] = $aResult[2]
Return 1
EndFunc
Func __FatalExit($iCode, $sText = '')
If $sText Then MsgBox($MB_SYSTEMMODAL, 'AutoIt', $sText)
_WinAPI_FatalExit($iCode)
EndFunc
Func __HeapAlloc($iSize, $bAbort = False)
Local $aRet
If Not $__g_hHeap Then
$aRet = DllCall('kernel32.dll', 'handle', 'HeapCreate', 'dword', 0, 'ulong_ptr', 0, 'ulong_ptr', 0)
If @error Or Not $aRet[0] Then __FatalExit(1, 'Error allocating memory.')
$__g_hHeap = $aRet[0]
EndIf
$aRet = DllCall('kernel32.dll', 'ptr', 'HeapAlloc', 'handle', $__g_hHeap, 'dword', 0x00000008, 'ulong_ptr', $iSize)
If @error Or Not $aRet[0] Then
If $bAbort Then __FatalExit(1, 'Error allocating memory.')
Return SetError(@error + 30, @extended, 0)
EndIf
Return $aRet[0]
EndFunc
Func __HeapReAlloc($pMemory, $iSize, $bAmount = False, $bAbort = False)
Local $aRet, $pRet
If __HeapValidate($pMemory) Then
If $bAmount And(__HeapSize($pMemory) >= $iSize) Then Return SetExtended(1, Ptr($pMemory))
$aRet = DllCall('kernel32.dll', 'ptr', 'HeapReAlloc', 'handle', $__g_hHeap, 'dword', 0x00000008, 'ptr', $pMemory, 'ulong_ptr', $iSize)
If @error Or Not $aRet[0] Then
If $bAbort Then __FatalExit(1, 'Error allocating memory.')
Return SetError(@error + 20, @extended, Ptr($pMemory))
EndIf
$pRet = $aRet[0]
Else
$pRet = __HeapAlloc($iSize, $bAbort)
If @error Then Return SetError(@error, @extended, 0)
EndIf
Return $pRet
EndFunc
Func __HeapSize($pMemory, $bCheck = False)
If $bCheck And(Not __HeapValidate($pMemory)) Then Return SetError(@error, @extended, 0)
Local $aRet = DllCall('kernel32.dll', 'ulong_ptr', 'HeapSize', 'handle', $__g_hHeap, 'dword', 0, 'ptr', $pMemory)
If @error Or($aRet[0] = Ptr(-1)) Then Return SetError(@error + 50, @extended, 0)
Return $aRet[0]
EndFunc
Func __HeapValidate($pMemory)
If(Not $__g_hHeap) Or(Not Ptr($pMemory)) Then Return SetError(9, 0, False)
Local $aRet = DllCall('kernel32.dll', 'int', 'HeapValidate', 'handle', $__g_hHeap, 'dword', 0, 'ptr', $pMemory)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func __Inc(ByRef $aData, $iIncrement = 100)
Select
Case UBound($aData, $UBOUND_COLUMNS)
If $iIncrement < 0 Then
ReDim $aData[$aData[0][0] + 1][UBound($aData, $UBOUND_COLUMNS)]
Else
$aData[0][0] += 1
If $aData[0][0] > UBound($aData) - 1 Then
ReDim $aData[$aData[0][0] + $iIncrement][UBound($aData, $UBOUND_COLUMNS)]
EndIf
EndIf
Case UBound($aData, $UBOUND_ROWS)
If $iIncrement < 0 Then
ReDim $aData[$aData[0] + 1]
Else
$aData[0] += 1
If $aData[0] > UBound($aData) - 1 Then
ReDim $aData[$aData[0] + $iIncrement]
EndIf
EndIf
Case Else
Return 0
EndSelect
Return 1
EndFunc
Func __Iif($bTest, $vTrue, $vFalse)
Return $bTest ? $vTrue : $vFalse
EndFunc
Func __RGB($iColor)
If $__g_iRGBMode Then
$iColor = _WinAPI_SwitchColor($iColor)
EndIf
Return $iColor
EndFunc
Func __WINVER()
Local $tOSVI = DllStructCreate($tagOSVERSIONINFO)
DllStructSetData($tOSVI, 1, DllStructGetSize($tOSVI))
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetVersionExW', 'struct*', $tOSVI)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return BitOR(BitShift(DllStructGetData($tOSVI, 2), -8), DllStructGetData($tOSVI, 3))
EndFunc
Func _WinAPI_CreateStreamOnHGlobal($hGlobal = 0, $bDeleteOnRelease = True)
Local $aReturn = DllCall('ole32.dll', 'long', 'CreateStreamOnHGlobal', 'handle', $hGlobal, 'bool', $bDeleteOnRelease, 'ptr*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aReturn[0] Then Return SetError(10, $aReturn[0], 0)
Return $aReturn[3]
EndFunc
Func _WinAPI_ReleaseStream($pStream)
Local $aReturn = DllCall('oleaut32.dll', 'long', 'DispCallFunc', 'ptr', $pStream, 'ulong_ptr', 8 *(1 + @AutoItX64), 'uint', 4, 'ushort', 23, 'uint', 0, 'ptr', 0, 'ptr', 0, 'str', '')
If @error Then Return SetError(@error, @extended, 0)
If $aReturn[0] Then Return SetError(10, $aReturn[0], 0)
Return 1
EndFunc
Func _WinAPI_CreateSemaphore($sSemaphore, $iInitial, $iMaximum, $tSecurity = 0)
Local $aRet = DllCall('kernel32.dll', 'handle', 'CreateSemaphoreW', 'struct*', $tSecurity, 'long', $iInitial, 'long', $iMaximum, 'wstr', $sSemaphore)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_EmptyWorkingSet($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', __Iif($__WINVER < 0x0600, 0x00000500, 0x00001100), 'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, 0)
Local $aRet = DllCall(@SystemDir & '\psapi.dll', 'bool', 'EmptyWorkingSet', 'handle', $hProcess[0])
If __CheckErrorCloseHandle($aRet, $hProcess[0]) Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_EnumProcessThreads($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hSnapshot = DllCall('kernel32.dll', 'handle', 'CreateToolhelp32Snapshot', 'dword', 0x00000004, 'dword', 0)
If @error Or Not $hSnapshot[0] Then Return SetError(@error + 10, @extended, 0)
Local Const $tagTHREADENTRY32 = 'dword Size;dword Usage;dword ThreadID;dword OwnerProcessID;long BasePri;long DeltaPri;dword Flags'
Local $tTHREADENTRY32 = DllStructCreate($tagTHREADENTRY32)
Local $aResult[101] = [0]
$hSnapshot = $hSnapshot[0]
DllStructSetData($tTHREADENTRY32, 'Size', DllStructGetSize($tTHREADENTRY32))
Local $aRet = DllCall('kernel32.dll', 'bool', 'Thread32First', 'handle', $hSnapshot, 'struct*', $tTHREADENTRY32)
While Not @error And $aRet[0]
If DllStructGetData($tTHREADENTRY32, 'OwnerProcessID') = $iPID Then
__Inc($aResult)
$aResult[$aResult[0]] = DllStructGetData($tTHREADENTRY32, 'ThreadID')
EndIf
$aRet = DllCall('kernel32.dll', 'bool', 'Thread32Next', 'handle', $hSnapshot, 'struct*', $tTHREADENTRY32)
WEnd
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hSnapshot)
If Not $aResult[0] Then Return SetError(1, 0, 0)
__Inc($aResult, -1)
Return $aResult
EndFunc
Func _WinAPI_EnumProcessWindows($iPID = 0, $bVisible = True)
Local $aThreads = _WinAPI_EnumProcessThreads($iPID)
If @error Then Return SetError(@error, @extended, 0)
Local $hEnumProc = DllCallbackRegister('__EnumWindowsProc', 'bool', 'hwnd;lparam')
Dim $__g_vEnum[101][2] = [[0]]
For $i = 1 To $aThreads[0]
DllCall('user32.dll', 'bool', 'EnumThreadWindows', 'dword', $aThreads[$i], 'ptr', DllCallbackGetPtr($hEnumProc), 'lparam', $bVisible)
If @error Then
ExitLoop
EndIf
Next
DllCallbackFree($hEnumProc)
If Not $__g_vEnum[0][0] Then Return SetError(11, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_ReleaseSemaphore($hSemaphore, $iIncrease = 1)
Local $aRet = DllCall('kernel32.dll', 'bool', 'ReleaseSemaphore', 'handle', $hSemaphore, 'long', $iIncrease, 'long*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $aRet[3]
EndFunc
Global Const $LOCALE_SDATE = 0x001D
Global Const $LOCALE_STIME = 0x001E
Global Const $LOCALE_SSHORTDATE = 0x001F
Global Const $LOCALE_SLONGDATE = 0x0020
Global Const $LOCALE_STIMEFORMAT = 0x1003
Global Const $LOCALE_S1159 = 0x0028
Global Const $LOCALE_S2359 = 0x0029
Global Const $LOCALE_INVARIANT = 0x007F
Global Const $LOCALE_USER_DEFAULT = 0x0400
Global Const $DIB_RGB_COLORS = 0
Global Const $BI_RGB = 0
Global Const $tagBITMAPV5HEADER = 'struct;dword bV5Size;long bV5Width;long bV5Height;ushort bV5Planes;ushort bV5BitCount;dword bV5Compression;dword bV5SizeImage;long bV5XPelsPerMeter;long bV5YPelsPerMeter;dword bV5ClrUsed;dword bV5ClrImportant;dword bV5RedMask;dword bV5GreenMask;dword bV5BlueMask;dword bV5AlphaMask;dword bV5CSType;int bV5Endpoints[9];dword bV5GammaRed;dword bV5GammaGreen;dword bV5GammaBlue;dword bV5Intent;dword bV5ProfileData;dword bV5ProfileSize;dword bV5Reserved;endstruct'
Func _WinAPI_CreateDIBSection($hDC, $tBITMAPINFO, $iUsage, ByRef $pBits, $hSection = 0, $iOffset = 0)
$pBits = 0
Local $aRet = DllCall('gdi32.dll', 'handle', 'CreateDIBSection', 'handle', $hDC, 'struct*', $tBITMAPINFO, 'uint', $iUsage, 'ptr*', 0, 'handle', $hSection, 'dword', $iOffset)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
$pBits = $aRet[4]
Return $aRet[0]
EndFunc
Func _WinAPI_DwmEnableComposition($bEnable)
If $bEnable Then $bEnable = 1
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmEnableComposition', 'uint', $bEnable)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmIsCompositionEnabled()
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmIsCompositionEnabled', 'bool*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $aRet[1]
EndFunc
Func _WinAPI_DwmQueryThumbnailSourceSize($hThumbnail)
Local $tSIZE = DllStructCreate($tagSIZE)
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmQueryThumbnailSourceSize', 'handle', $hThumbnail, 'struct*', $tSIZE)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $tSIZE
EndFunc
Func _WinAPI_DwmRegisterThumbnail($hDestination, $hSource)
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmRegisterThumbnail', 'hwnd', $hDestination, 'hwnd', $hSource, 'handle*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $aRet[3]
EndFunc
Func _WinAPI_DwmUnregisterThumbnail($hThumbnail)
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmUnregisterThumbnail', 'handle', $hThumbnail)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmUpdateThumbnailProperties($hThumbnail, $bVisible = True, $bClientAreaOnly = False, $iOpacity = 255, $tRectDest = 0, $tRectSrc = 0)
Local Const $tagDWM_THUMBNAIL_PROPERTIES = 'struct;dword dwFlags;int rcDestination[4];int rcSource[4];byte opacity;bool opacity;bool fSourceClientAreaOnly;endstruct'
Local $tTHUMBNAILPROPERTIES = DllStructCreate($tagDWM_THUMBNAIL_PROPERTIES)
Local $tSIZE, $iFlags = 0
If Not IsDllStruct($tRectDest) Then
$tSIZE = _WinAPI_DwmQueryThumbnailSourceSize($hThumbnail)
If @error Then
Return SetError(@error + 10, @extended, 0)
EndIf
$tRectDest = _WinAPI_CreateRectEx(0, 0, DllStructGetData($tSIZE, 1), DllStructGetData($tSIZE, 2))
EndIf
For $i = 1 To 4
DllStructSetData($tTHUMBNAILPROPERTIES, 2, DllStructGetData($tRectDest, $i), $i)
Next
If IsDllStruct($tRectSrc) Then
$iFlags += 2
For $i = 1 To 4
DllStructSetData($tTHUMBNAILPROPERTIES, 3, DllStructGetData($tRectSrc, $i), $i)
Next
EndIf
DllStructSetData($tTHUMBNAILPROPERTIES, 1, BitOR($iFlags, 0x1D))
DllStructSetData($tTHUMBNAILPROPERTIES, 4, $iOpacity)
DllStructSetData($tTHUMBNAILPROPERTIES, 5, $bVisible)
DllStructSetData($tTHUMBNAILPROPERTIES, 6, $bClientAreaOnly)
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmUpdateThumbnailProperties', 'handle', $hThumbnail, 'struct*', $tTHUMBNAILPROPERTIES)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_EnumDisplayMonitors($hDC = 0, $tRECT = 0)
Local $hEnumProc = DllCallbackRegister('__EnumDisplayMonitorsProc', 'bool', 'handle;handle;ptr;lparam')
Dim $__g_vEnum[101][2] = [[0]]
Local $aRet = DllCall('user32.dll', 'bool', 'EnumDisplayMonitors', 'handle', $hDC, 'struct*', $tRECT, 'ptr', DllCallbackGetPtr($hEnumProc), 'lparam', 0)
If @error Or Not $aRet[0] Or Not $__g_vEnum[0][0] Then
$__g_vEnum = @error + 10
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_GetPixel($hDC, $iX, $iY)
Local $aRet = DllCall('gdi32.dll', 'dword', 'GetPixel', 'handle', $hDC, 'int', $iX, 'int', $iY)
If @error Or($aRet[0] = 4294967295) Then Return SetError(@error, @extended, -1)
Return __RGB($aRet[0])
EndFunc
Func _WinAPI_GetPosFromRect($tRECT)
Local $aResult[4]
For $i = 0 To 3
$aResult[$i] = DllStructGetData($tRECT, $i + 1)
If @error Then Return SetError(@error, @extended, 0)
Next
For $i = 2 To 3
$aResult[$i] -= $aResult[$i - 2]
Next
Return $aResult
EndFunc
Func _WinAPI_MonitorFromWindow($hWnd, $iFlag = 1)
Local $aRet = DllCall('user32.dll', 'handle', 'MonitorFromWindow', 'hwnd', $hWnd, 'dword', $iFlag)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func __EnumDisplayMonitorsProc($hMonitor, $hDC, $pRECT, $lParam)
#forceref $hDC, $lParam
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0][0]][0] = $hMonitor
If Not $pRECT Then
$__g_vEnum[$__g_vEnum[0][0]][1] = 0
Else
$__g_vEnum[$__g_vEnum[0][0]][1] = DllStructCreate($tagRECT)
If Not _WinAPI_MoveMemory(DllStructGetPtr($__g_vEnum[$__g_vEnum[0][0]][1]), $pRECT, 16) Then Return 0
EndIf
Return 1
EndFunc
Func _WinAPI_GetFileVersionInfo($sFilePath, ByRef $pBuffer, $iFlags = 0)
Local $aRet
If $__WINVER >= 0x0600 Then
$aRet = DllCall('version.dll', 'dword', 'GetFileVersionInfoSizeExW', 'dword', BitAND($iFlags, 0x03), 'wstr', $sFilePath, 'ptr', 0)
Else
$aRet = DllCall('version.dll', 'dword', 'GetFileVersionInfoSizeW', 'wstr', $sFilePath, 'ptr', 0)
EndIf
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
$pBuffer = __HeapReAlloc($pBuffer, $aRet[0], 1)
If @error Then Return SetError(@error + 100, @extended, 0)
Local $iNbByte = $aRet[0]
If $__WINVER >= 0x0600 Then
$aRet = DllCall('version.dll', 'bool', 'GetFileVersionInfoExW', 'dword', BitAND($iFlags, 0x07), 'wstr', $sFilePath, 'dword', 0, 'dword', $iNbByte, 'ptr', $pBuffer)
Else
$aRet = DllCall('version.dll', 'bool', 'GetFileVersionInfoW', 'wstr', $sFilePath, 'dword', 0, 'dword', $iNbByte, 'ptr', $pBuffer)
EndIf
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $iNbByte
EndFunc
Func _WinAPI_VerQueryValue($pData, $sValues = '')
$sValues = StringRegExpReplace($sValues, '\A[\s\|]*|[\s\|]*\Z', '')
If Not $sValues Then
$sValues = 'Comments|CompanyName|FileDescription|FileVersion|InternalName|LegalCopyright|LegalTrademarks|OriginalFilename|ProductName|ProductVersion|PrivateBuild|SpecialBuild'
EndIf
$sValues = StringSplit($sValues, '|', $STR_NOCOUNT)
Local $aRet = DllCall('version.dll', 'bool', 'VerQueryValueW', 'ptr', $pData, 'wstr', '\VarFileInfo\Translation', 'ptr*', 0, 'uint*', 0)
If @error Or Not $aRet[0] Or Not $aRet[4] Then Return SetError(@error + 10, 0, 0)
Local $iLength = Floor($aRet[4] / 4)
Local $tLang = DllStructCreate('dword[' & $iLength & ']', $aRet[3])
If @error Then Return SetError(@error + 20, 0, 0)
Local $sCP, $aInfo[101][UBound($sValues) + 1] = [[0]]
For $i = 1 To $iLength
__Inc($aInfo)
$aInfo[$aInfo[0][0]][0] = _WinAPI_LoWord(DllStructGetData($tLang, 1, $i))
$sCP = Hex(_WinAPI_MakeLong(_WinAPI_HiWord(DllStructGetData($tLang, 1, $i)), _WinAPI_LoWord(DllStructGetData($tLang, 1, $i))), 8)
For $j = 0 To UBound($sValues) - 1
$aRet = DllCall('version.dll', 'bool', 'VerQueryValueW', 'ptr', $pData, 'wstr', '\StringFileInfo\' & $sCP & '\' & $sValues[$j], 'ptr*', 0, 'uint*', 0)
If Not @error And $aRet[0] And $aRet[4] Then
$aInfo[$aInfo[0][0]][$j + 1] = DllStructGetData(DllStructCreate('wchar[' & $aRet[4] & ']', $aRet[3]), 1)
Else
$aInfo[$aInfo[0][0]][$j + 1] = ''
EndIf
Next
Next
__Inc($aInfo, -1)
Return $aInfo
EndFunc
Global Const $GDIP_EPGCOLORDEPTH = '{66087055-AD66-4C7C-9A18-38A2310B8337}'
Global Const $GDIP_EPGCOMPRESSION = '{E09D739D-CCD4-44EE-8EBA-3FBF8BE4FC58}'
Global Const $GDIP_EPGQUALITY = '{1D5BE4B5-FA4A-452D-9CDD-5DB35105E7EB}'
Global Const $GDIP_EPTLONG = 4
Global Const $GDIP_EVTCOMPRESSIONLZW = 2
Global Const $GDIP_ILMREAD = 0x0001
Global Const $GDIP_PXF24RGB = 0x00021808
Global Const $GDIP_PXF32RGB = 0x00022009
Global Const $GDIP_PXF32ARGB = 0x0026200A
Global Const $GDIP_SMOOTHINGMODE_DEFAULT = 0
Global Const $GDIP_SMOOTHINGMODE_HIGHQUALITY = 2
Global Const $GDIP_SMOOTHINGMODE_ANTIALIAS8X8 = 5
Global Const $GDIP_INTERPOLATIONMODE_HIGHQUALITYBICUBIC = 7
Global $__g_hGDIPBrush = 0
Global $__g_hGDIPDll = 0
Global $__g_hGDIPPen = 0
Global $__g_iGDIPRef = 0
Global $__g_iGDIPToken = 0
Global $__g_bGDIP_V1_0 = True
Func _GDIPlus_BitmapCloneArea($hBitmap, $nLeft, $nTop, $nWidth, $nHeight, $iFormat = 0x00021808)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCloneBitmapArea", "float", $nLeft, "float", $nTop, "float", $nWidth, "float", $nHeight, "int", $iFormat, "handle", $hBitmap, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[7]
EndFunc
Func _GDIPlus_BitmapCreateDIBFromBitmap($hBitmap)
Local $aRet = DllCall($__g_hGDIPDll, "uint", "GdipGetImageDimension", "handle", $hBitmap, "float*", 0, "float*", 0)
If @error Or $aRet[0] Then Return SetError(@error + 10, $aRet[0], 0)
Local $tData = _GDIPlus_BitmapLockBits($hBitmap, 0, 0, $aRet[2], $aRet[3], $GDIP_ILMREAD, $GDIP_PXF32ARGB)
Local $pBits = DllStructGetData($tData, "Scan0")
If Not $pBits Then Return 0
Local $tBIHDR = DllStructCreate($tagBITMAPV5HEADER)
DllStructSetData($tBIHDR, "bV5Size", DllStructGetSize($tBIHDR))
DllStructSetData($tBIHDR, "bV5Width", $aRet[2])
DllStructSetData($tBIHDR, "bV5Height", $aRet[3])
DllStructSetData($tBIHDR, "bV5Planes", 1)
DllStructSetData($tBIHDR, "bV5BitCount", 32)
DllStructSetData($tBIHDR, "bV5Compression", 0)
DllStructSetData($tBIHDR, "bV5SizeImage", $aRet[3] * DllStructGetData($tData, "Stride"))
DllStructSetData($tBIHDR, "bV5AlphaMask", 0xFF000000)
DllStructSetData($tBIHDR, "bV5RedMask", 0x00FF0000)
DllStructSetData($tBIHDR, "bV5GreenMask", 0x0000FF00)
DllStructSetData($tBIHDR, "bV5BlueMask", 0x000000FF)
DllStructSetData($tBIHDR, "bV5CSType", 2)
DllStructSetData($tBIHDR, "bV5Intent", 4)
Local $hHBitmapv5 = DllCall("gdi32.dll", "ptr", "CreateDIBSection", "hwnd", 0, "struct*", $tBIHDR, "uint", 0, "ptr*", 0, "ptr", 0, "dword", 0)
If Not @error And $hHBitmapv5[0] Then
DllCall("gdi32.dll", "dword", "SetBitmapBits", "ptr", $hHBitmapv5[0], "dword", $aRet[2] * $aRet[3] * 4, "ptr", DllStructGetData($tData, "Scan0"))
$hHBitmapv5 = $hHBitmapv5[0]
Else
$hHBitmapv5 = 0
EndIf
_GDIPlus_BitmapUnlockBits($hBitmap, $tData)
$tData = 0
$tBIHDR = 0
Return $hHBitmapv5
EndFunc
Func _GDIPlus_BitmapCreateFromFile($sFileName)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateBitmapFromFile", "wstr", $sFileName, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_BitmapCreateFromHBITMAP($hBitmap, $hPal = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateBitmapFromHBITMAP", "handle", $hBitmap, "handle", $hPal, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[3]
EndFunc
Func _GDIPlus_BitmapCreateFromScan0($iWidth, $iHeight, $iPixelFormat = $GDIP_PXF32ARGB, $iStride = 0, $pScan0 = 0)
Local $aResult = DllCall($__g_hGDIPDll, "uint", "GdipCreateBitmapFromScan0", "int", $iWidth, "int", $iHeight, "int", $iStride, "int", $iPixelFormat, "struct*", $pScan0, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[6]
EndFunc
Func _GDIPlus_BitmapCreateFromStream($pStream)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateBitmapFromStream", "ptr", $pStream, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_BitmapCreateHBITMAPFromBitmap($hBitmap, $iARGB = 0xFF000000)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateHBITMAPFromBitmap", "handle", $hBitmap, "handle*", 0, "dword", $iARGB)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_BitmapDispose($hBitmap)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDisposeImage", "handle", $hBitmap)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_BitmapGetPixel($hBitmap, $iX, $iY)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipBitmapGetPixel", "handle", $hBitmap, "int", $iX, "int", $iY, "uint*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[4]
EndFunc
Func _GDIPlus_BitmapLockBits($hBitmap, $iLeft, $iTop, $iWidth, $iHeight, $iFlags = $GDIP_ILMREAD, $iFormat = $GDIP_PXF32RGB)
Local $tData = DllStructCreate($tagGDIPBITMAPDATA)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Left", $iLeft)
DllStructSetData($tRECT, "Top", $iTop)
DllStructSetData($tRECT, "Right", $iWidth)
DllStructSetData($tRECT, "Bottom", $iHeight)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipBitmapLockBits", "handle", $hBitmap, "struct*", $tRECT, "uint", $iFlags, "int", $iFormat, "struct*", $tData)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $tData
EndFunc
Func _GDIPlus_BitmapUnlockBits($hBitmap, $tBitmapData)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipBitmapUnlockBits", "handle", $hBitmap, "struct*", $tBitmapData)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_BrushCreateSolid($iARGB = 0xFF000000)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateSolidFill", "int", $iARGB, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_BrushDispose($hBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeleteBrush", "handle", $hBrush)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_Encoders()
Local $iCount = _GDIPlus_EncodersGetCount()
Local $iSize = _GDIPlus_EncodersGetSize()
Local $tBuffer = DllStructCreate("byte[" & $iSize & "]")
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageEncoders", "uint", $iCount, "uint", $iSize, "struct*", $tBuffer)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tCodec, $aInfo[$iCount + 1][14]
$aInfo[0][0] = $iCount
For $iI = 1 To $iCount
$tCodec = DllStructCreate($tagGDIPIMAGECODECINFO, $pBuffer)
$aInfo[$iI][1] = _WinAPI_StringFromGUID(DllStructGetPtr($tCodec, "CLSID"))
$aInfo[$iI][2] = _WinAPI_StringFromGUID(DllStructGetPtr($tCodec, "FormatID"))
$aInfo[$iI][3] = _WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, "CodecName"))
$aInfo[$iI][4] = _WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, "DllName"))
$aInfo[$iI][5] = _WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, "FormatDesc"))
$aInfo[$iI][6] = _WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, "FileExt"))
$aInfo[$iI][7] = _WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, "MimeType"))
$aInfo[$iI][8] = DllStructGetData($tCodec, "Flags")
$aInfo[$iI][9] = DllStructGetData($tCodec, "Version")
$aInfo[$iI][10] = DllStructGetData($tCodec, "SigCount")
$aInfo[$iI][11] = DllStructGetData($tCodec, "SigSize")
$aInfo[$iI][12] = DllStructGetData($tCodec, "SigPattern")
$aInfo[$iI][13] = DllStructGetData($tCodec, "SigMask")
$pBuffer += DllStructGetSize($tCodec)
Next
Return $aInfo
EndFunc
Func _GDIPlus_EncodersGetCLSID($sFileExtension)
Local $aEncoders = _GDIPlus_Encoders()
If @error Then Return SetError(@error, 0, "")
For $iI = 1 To $aEncoders[0][0]
If StringInStr($aEncoders[$iI][6], "*." & $sFileExtension) > 0 Then Return $aEncoders[$iI][1]
Next
Return SetError(-1, -1, "")
EndFunc
Func _GDIPlus_EncodersGetCount()
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageEncodersSize", "uint*", 0, "uint*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[1]
EndFunc
Func _GDIPlus_EncodersGetSize()
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageEncodersSize", "uint*", 0, "uint*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_FontCreate($hFamily, $fSize, $iStyle = 0, $iUnit = 3)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateFont", "handle", $hFamily, "float", $fSize, "int", $iStyle, "int", $iUnit, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[5]
EndFunc
Func _GDIPlus_FontDispose($hFont)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeleteFont", "handle", $hFont)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_FontFamilyCreate($sFamily, $pCollection = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateFontFamilyFromName", "wstr", $sFamily, "ptr", $pCollection, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[3]
EndFunc
Func _GDIPlus_FontFamilyDispose($hFamily)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeleteFontFamily", "handle", $hFamily)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsClear($hGraphics, $iARGB = 0xFF000000)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGraphicsClear", "handle", $hGraphics, "dword", $iARGB)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsCreateFromHDC($hDC)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateFromHDC", "handle", $hDC, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_GraphicsDispose($hGraphics)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeleteGraphics", "handle", $hGraphics)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawEllipse($hGraphics, $nX, $nY, $nWidth, $nHeight, $hPen = 0)
__GDIPlus_PenDefCreate($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawEllipse", "handle", $hGraphics, "handle", $hPen, "float", $nX, "float", $nY, "float", $nWidth, "float", $nHeight)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawImageRect($hGraphics, $hImage, $nX, $nY, $nW, $nH)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawImageRect", "handle", $hGraphics, "handle", $hImage, "float", $nX, "float", $nY, "float", $nW, "float", $nH)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawLine($hGraphics, $nX1, $nY1, $nX2, $nY2, $hPen = 0)
__GDIPlus_PenDefCreate($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawLine", "handle", $hGraphics, "handle", $hPen, "float", $nX1, "float", $nY1, "float", $nX2, "float", $nY2)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawRect($hGraphics, $nX, $nY, $nWidth, $nHeight, $hPen = 0)
__GDIPlus_PenDefCreate($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawRectangle", "handle", $hGraphics, "handle", $hPen, "float", $nX, "float", $nY, "float", $nWidth, "float", $nHeight)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawString($hGraphics, $sString, $nX, $nY, $sFont = "Arial", $fSize = 10, $iFormat = 0)
Local $hBrush = _GDIPlus_BrushCreateSolid()
Local $hFormat = _GDIPlus_StringFormatCreate($iFormat)
Local $hFamily = _GDIPlus_FontFamilyCreate($sFont)
Local $hFont = _GDIPlus_FontCreate($hFamily, $fSize)
Local $tLayout = _GDIPlus_RectFCreate($nX, $nY, 0.0, 0.0)
Local $aInfo = _GDIPlus_GraphicsMeasureString($hGraphics, $sString, $hFont, $tLayout, $hFormat)
If @error Then Return SetError(@error, @extended, 0)
Local $aResult = _GDIPlus_GraphicsDrawStringEx($hGraphics, $sString, $hFont, $aInfo[0], $hFormat, $hBrush)
Local $iError = @error, $iExtended = @extended
_GDIPlus_FontDispose($hFont)
_GDIPlus_FontFamilyDispose($hFamily)
_GDIPlus_StringFormatDispose($hFormat)
_GDIPlus_BrushDispose($hBrush)
Return SetError($iError, $iExtended, $aResult)
EndFunc
Func _GDIPlus_GraphicsDrawStringEx($hGraphics, $sString, $hFont, $tLayout, $hFormat, $hBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawString", "handle", $hGraphics, "wstr", $sString, "int", -1, "handle", $hFont, "struct*", $tLayout, "handle", $hFormat, "handle", $hBrush)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsFillRect($hGraphics, $nX, $nY, $nWidth, $nHeight, $hBrush = 0)
__GDIPlus_BrushDefCreate($hBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipFillRectangle", "handle", $hGraphics, "handle", $hBrush, "float", $nX, "float", $nY, "float", $nWidth, "float", $nHeight)
__GDIPlus_BrushDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsMeasureString($hGraphics, $sString, $hFont, $tLayout, $hFormat)
Local $tRECTF = DllStructCreate($tagGDIPRECTF)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipMeasureString", "handle", $hGraphics, "wstr", $sString, "int", -1, "handle", $hFont, "struct*", $tLayout, "handle", $hFormat, "struct*", $tRECTF, "int*", 0, "int*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Local $aInfo[3]
$aInfo[0] = $tRECTF
$aInfo[1] = $aResult[8]
$aInfo[2] = $aResult[9]
Return $aInfo
EndFunc
Func _GDIPlus_GraphicsSetInterpolationMode($hGraphics, $iInterpolationMode)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetInterpolationMode", "handle", $hGraphics, "int", $iInterpolationMode)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsSetSmoothingMode($hGraphics, $iSmooth)
If $iSmooth < $GDIP_SMOOTHINGMODE_DEFAULT Or $iSmooth > $GDIP_SMOOTHINGMODE_ANTIALIAS8X8 Then $iSmooth = $GDIP_SMOOTHINGMODE_DEFAULT
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetSmoothingMode", "handle", $hGraphics, "int", $iSmooth)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ImageDispose($hImage)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDisposeImage", "handle", $hImage)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ImageGetGraphicsContext($hImage)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageGraphicsContext", "handle", $hImage, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_ImageGetHeight($hImage)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageHeight", "handle", $hImage, "uint*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_ImageGetWidth($hImage)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageWidth", "handle", $hImage, "uint*", -1)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_ImageSaveToFile($hImage, $sFileName)
Local $sExt = __GDIPlus_ExtractFileExt($sFileName)
Local $sCLSID = _GDIPlus_EncodersGetCLSID($sExt)
If $sCLSID = "" Then Return SetError(-1, 0, False)
Local $bRet = _GDIPlus_ImageSaveToFileEx($hImage, $sFileName, $sCLSID, 0)
Return SetError(@error, @extended, $bRet)
EndFunc
Func _GDIPlus_ImageSaveToFileEx($hImage, $sFileName, $sEncoder, $tParams = 0)
Local $tGUID = _WinAPI_GUIDFromString($sEncoder)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSaveImageToFile", "handle", $hImage, "wstr", $sFileName, "struct*", $tGUID, "struct*", $tParams)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ImageResize($hImage, $iNewWidth, $iNewHeight, $iInterpolationMode = $GDIP_INTERPOLATIONMODE_HIGHQUALITYBICUBIC)
Local $hBitmap = _GDIPlus_BitmapCreateFromScan0($iNewWidth, $iNewHeight)
If @error Then Return SetError(1, 0, 0)
Local $hBmpCtxt = _GDIPlus_ImageGetGraphicsContext($hBitmap)
If @error Then
_GDIPlus_BitmapDispose($hBitmap)
Return SetError(2, @extended, 0)
EndIf
_GDIPlus_GraphicsSetInterpolationMode($hBmpCtxt, $iInterpolationMode)
If @error Then
_GDIPlus_GraphicsDispose($hBmpCtxt)
_GDIPlus_BitmapDispose($hBitmap)
Return SetError(3, @extended, 0)
EndIf
_GDIPlus_GraphicsDrawImageRect($hBmpCtxt, $hImage, 0, 0, $iNewWidth, $iNewHeight)
If @error Then
_GDIPlus_GraphicsDispose($hBmpCtxt)
_GDIPlus_BitmapDispose($hBitmap)
Return SetError(4, @extended, 0)
EndIf
_GDIPlus_GraphicsDispose($hBmpCtxt)
Return $hBitmap
EndFunc
Func _GDIPlus_ParamAdd(ByRef $tParams, $sGUID, $iNbOfValues, $iType, $pValues)
Local $iCount = DllStructGetData($tParams, "Count")
Local $pGUID = DllStructGetPtr($tParams, "GUID") +($iCount * _GDIPlus_ParamSize())
Local $tParam = DllStructCreate($tagGDIPENCODERPARAM, $pGUID)
_WinAPI_GUIDFromStringEx($sGUID, $pGUID)
DllStructSetData($tParam, "Type", $iType)
DllStructSetData($tParam, "NumberOfValues", $iNbOfValues)
DllStructSetData($tParam, "Values", $pValues)
DllStructSetData($tParams, "Count", $iCount + 1)
EndFunc
Func _GDIPlus_ParamInit($iCount)
Local $sStruct = $tagGDIPENCODERPARAMS
For $i = 2 To $iCount
$sStruct &= ";struct;byte[16];ulong;ulong;ptr;endstruct"
Next
Return DllStructCreate($sStruct)
EndFunc
Func _GDIPlus_ParamSize()
Local $tParam = DllStructCreate($tagGDIPENCODERPARAM)
Return DllStructGetSize($tParam)
EndFunc
Func _GDIPlus_PenCreate($iARGB = 0xFF000000, $nWidth = 1, $iUnit = 2)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreatePen1", "dword", $iARGB, "float", $nWidth, "int", $iUnit, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[4]
EndFunc
Func _GDIPlus_PenDispose($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeletePen", "handle", $hPen)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_RectFCreate($nX = 0, $nY = 0, $nWidth = 0, $nHeight = 0)
Local $tRECTF = DllStructCreate($tagGDIPRECTF)
DllStructSetData($tRECTF, "X", $nX)
DllStructSetData($tRECTF, "Y", $nY)
DllStructSetData($tRECTF, "Width", $nWidth)
DllStructSetData($tRECTF, "Height", $nHeight)
Return $tRECTF
EndFunc
Func _GDIPlus_Shutdown()
If $__g_hGDIPDll = 0 Then Return SetError(-1, -1, False)
$__g_iGDIPRef -= 1
If $__g_iGDIPRef = 0 Then
DllCall($__g_hGDIPDll, "none", "GdiplusShutdown", "ulong_ptr", $__g_iGDIPToken)
DllClose($__g_hGDIPDll)
$__g_hGDIPDll = 0
EndIf
Return True
EndFunc
Func _GDIPlus_Startup($sGDIPDLL = Default, $bRetDllHandle = False)
$__g_iGDIPRef += 1
If $__g_iGDIPRef > 1 Then Return True
If $sGDIPDLL = Default Then $sGDIPDLL = "gdiplus.dll"
$__g_hGDIPDll = DllOpen($sGDIPDLL)
If $__g_hGDIPDll = -1 Then
$__g_iGDIPRef = 0
Return SetError(1, 2, False)
EndIf
Local $sVer = FileGetVersion($sGDIPDLL)
$sVer = StringSplit($sVer, ".")
If $sVer[1] > 5 Then $__g_bGDIP_V1_0 = False
Local $tInput = DllStructCreate($tagGDIPSTARTUPINPUT)
Local $tToken = DllStructCreate("ulong_ptr Data")
DllStructSetData($tInput, "Version", 1)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdiplusStartup", "struct*", $tToken, "struct*", $tInput, "ptr", 0)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
$__g_iGDIPToken = DllStructGetData($tToken, "Data")
If $bRetDllHandle Then Return $__g_hGDIPDll
Return SetExtended($sVer[1], True)
EndFunc
Func _GDIPlus_StringFormatCreate($iFormat = 0, $iLangID = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateStringFormat", "int", $iFormat, "word", $iLangID, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[3]
EndFunc
Func _GDIPlus_StringFormatDispose($hFormat)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeleteStringFormat", "handle", $hFormat)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func __GDIPlus_BrushDefCreate(ByRef $hBrush)
If $hBrush = 0 Then
$__g_hGDIPBrush = _GDIPlus_BrushCreateSolid()
$hBrush = $__g_hGDIPBrush
EndIf
EndFunc
Func __GDIPlus_BrushDefDispose($iCurError = @error, $iCurExtended = @extended)
If $__g_hGDIPBrush <> 0 Then
_GDIPlus_BrushDispose($__g_hGDIPBrush)
$__g_hGDIPBrush = 0
EndIf
Return SetError($iCurError, $iCurExtended)
EndFunc
Func __GDIPlus_ExtractFileExt($sFileName, $bNoDot = True)
Local $iIndex = __GDIPlus_LastDelimiter(".\:", $sFileName)
If($iIndex > 0) And(StringMid($sFileName, $iIndex, 1) = '.') Then
If $bNoDot Then
Return StringMid($sFileName, $iIndex + 1)
Else
Return StringMid($sFileName, $iIndex)
EndIf
Else
Return ""
EndIf
EndFunc
Func __GDIPlus_LastDelimiter($sDelimiters, $sString)
Local $sDelimiter, $iN
For $iI = 1 To StringLen($sDelimiters)
$sDelimiter = StringMid($sDelimiters, $iI, 1)
$iN = StringInStr($sString, $sDelimiter, 0, -1)
If $iN > 0 Then Return $iN
Next
EndFunc
Func __GDIPlus_PenDefCreate(ByRef $hPen)
If $hPen = 0 Then
$__g_hGDIPPen = _GDIPlus_PenCreate()
$hPen = $__g_hGDIPPen
EndIf
EndFunc
Func __GDIPlus_PenDefDispose($iCurError = @error, $iCurExtended = @extended)
If $__g_hGDIPPen <> 0 Then
_GDIPlus_PenDispose($__g_hGDIPPen)
$__g_hGDIPPen = 0
EndIf
Return SetError($iCurError, $iCurExtended)
EndFunc
Global $__g_iBMPFormat = $GDIP_PXF24RGB
Global $__g_iJPGQuality = 100
Global $__g_iTIFColorDepth = 24
Global $__g_iTIFCompression = $GDIP_EVTCOMPRESSIONLZW
Global Const $__SCREENCAPTURECONSTANT_SM_CXSCREEN = 0
Global Const $__SCREENCAPTURECONSTANT_SM_CYSCREEN = 1
Global Const $__SCREENCAPTURECONSTANT_SRCCOPY = 0x00CC0020
Func _ScreenCapture_Capture($sFileName = "", $iLeft = 0, $iTop = 0, $iRight = -1, $iBottom = -1, $bCursor = True)
Local $bRet = False
If $iRight = -1 Then $iRight = _WinAPI_GetSystemMetrics($__SCREENCAPTURECONSTANT_SM_CXSCREEN) - 1
If $iBottom = -1 Then $iBottom = _WinAPI_GetSystemMetrics($__SCREENCAPTURECONSTANT_SM_CYSCREEN) - 1
If $iRight < $iLeft Then Return SetError(-1, 0, $bRet)
If $iBottom < $iTop Then Return SetError(-2, 0, $bRet)
Local $iW =($iRight - $iLeft) + 1
Local $iH =($iBottom - $iTop) + 1
Local $hWnd = _WinAPI_GetDesktopWindow()
Local $hDDC = _WinAPI_GetDC($hWnd)
Local $hCDC = _WinAPI_CreateCompatibleDC($hDDC)
Local $hBMP = _WinAPI_CreateCompatibleBitmap($hDDC, $iW, $iH)
_WinAPI_SelectObject($hCDC, $hBMP)
_WinAPI_BitBlt($hCDC, 0, 0, $iW, $iH, $hDDC, $iLeft, $iTop, $__SCREENCAPTURECONSTANT_SRCCOPY)
If $bCursor Then
Local $aCursor = _WinAPI_GetCursorInfo()
If Not @error And $aCursor[1] Then
$bCursor = True
Local $hIcon = _WinAPI_CopyIcon($aCursor[2])
Local $aIcon = _WinAPI_GetIconInfo($hIcon)
If Not @error Then
_WinAPI_DeleteObject($aIcon[4])
If $aIcon[5] <> 0 Then _WinAPI_DeleteObject($aIcon[5])
_WinAPI_DrawIcon($hCDC, $aCursor[3] - $aIcon[2] - $iLeft, $aCursor[4] - $aIcon[3] - $iTop, $hIcon)
EndIf
_WinAPI_DestroyIcon($hIcon)
EndIf
EndIf
_WinAPI_ReleaseDC($hWnd, $hDDC)
_WinAPI_DeleteDC($hCDC)
If $sFileName = "" Then Return $hBMP
$bRet = _ScreenCapture_SaveImage($sFileName, $hBMP, True)
Return SetError(@error, @extended, $bRet)
EndFunc
Func _ScreenCapture_SaveImage($sFileName, $hBitmap, $bFreeBmp = True)
_GDIPlus_Startup()
If @error Then Return SetError(-1, -1, False)
Local $sExt = StringUpper(__GDIPlus_ExtractFileExt($sFileName))
Local $sCLSID = _GDIPlus_EncodersGetCLSID($sExt)
If $sCLSID = "" Then Return SetError(-2, -2, False)
Local $hImage = _GDIPlus_BitmapCreateFromHBITMAP($hBitmap)
If @error Then Return SetError(-3, -3, False)
Local $tData, $tParams
Switch $sExt
Case "BMP"
Local $iX = _GDIPlus_ImageGetWidth($hImage)
Local $iY = _GDIPlus_ImageGetHeight($hImage)
Local $hClone = _GDIPlus_BitmapCloneArea($hImage, 0, 0, $iX, $iY, $__g_iBMPFormat)
_GDIPlus_ImageDispose($hImage)
$hImage = $hClone
Case "JPG", "JPEG"
$tParams = _GDIPlus_ParamInit(1)
$tData = DllStructCreate("int Quality")
DllStructSetData($tData, "Quality", $__g_iJPGQuality)
_GDIPlus_ParamAdd($tParams, $GDIP_EPGQUALITY, 1, $GDIP_EPTLONG, DllStructGetPtr($tData))
Case "TIF", "TIFF"
$tParams = _GDIPlus_ParamInit(2)
$tData = DllStructCreate("int ColorDepth;int Compression")
DllStructSetData($tData, "ColorDepth", $__g_iTIFColorDepth)
DllStructSetData($tData, "Compression", $__g_iTIFCompression)
_GDIPlus_ParamAdd($tParams, $GDIP_EPGCOLORDEPTH, 1, $GDIP_EPTLONG, DllStructGetPtr($tData, "ColorDepth"))
_GDIPlus_ParamAdd($tParams, $GDIP_EPGCOMPRESSION, 1, $GDIP_EPTLONG, DllStructGetPtr($tData, "Compression"))
EndSwitch
Local $pParams = 0
If IsDllStruct($tParams) Then $pParams = $tParams
Local $bRet = _GDIPlus_ImageSaveToFileEx($hImage, $sFileName, $sCLSID, $pParams)
_GDIPlus_ImageDispose($hImage)
If $bFreeBmp Then _WinAPI_DeleteObject($hBitmap)
_GDIPlus_Shutdown()
Return SetError($bRet = False, 0, $bRet)
EndFunc
Global Enum $ARRAYFILL_FORCE_DEFAULT, $ARRAYFILL_FORCE_SINGLEITEM, $ARRAYFILL_FORCE_INT, $ARRAYFILL_FORCE_NUMBER, $ARRAYFILL_FORCE_PTR, $ARRAYFILL_FORCE_HWND, $ARRAYFILL_FORCE_STRING
Func _ArrayAdd(ByRef $aArray, $vValue, $iStart = 0, $sDelim_Item = "|", $sDelim_Row = @CRLF, $iForce = $ARRAYFILL_FORCE_DEFAULT)
If $iStart = Default Then $iStart = 0
If $sDelim_Item = Default Then $sDelim_Item = "|"
If $sDelim_Row = Default Then $sDelim_Row = @CRLF
If $iForce = Default Then $iForce = $ARRAYFILL_FORCE_DEFAULT
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS)
Local $hDataType = 0
Switch $iForce
Case $ARRAYFILL_FORCE_INT
$hDataType = Int
Case $ARRAYFILL_FORCE_NUMBER
$hDataType = Number
Case $ARRAYFILL_FORCE_PTR
$hDataType = Ptr
Case $ARRAYFILL_FORCE_HWND
$hDataType = Hwnd
Case $ARRAYFILL_FORCE_STRING
$hDataType = String
EndSwitch
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If $iForce = $ARRAYFILL_FORCE_SINGLEITEM Then
ReDim $aArray[$iDim_1 + 1]
$aArray[$iDim_1] = $vValue
Return $iDim_1
EndIf
If IsArray($vValue) Then
If UBound($vValue, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(5, 0, -1)
$hDataType = 0
Else
Local $aTmp = StringSplit($vValue, $sDelim_Item, $STR_NOCOUNT + $STR_ENTIRESPLIT)
If UBound($aTmp, $UBOUND_ROWS) = 1 Then
$aTmp[0] = $vValue
EndIf
$vValue = $aTmp
EndIf
Local $iAdd = UBound($vValue, $UBOUND_ROWS)
ReDim $aArray[$iDim_1 + $iAdd]
For $i = 0 To $iAdd - 1
If IsFunc($hDataType) Then
$aArray[$iDim_1 + $i] = $hDataType($vValue[$i])
Else
$aArray[$iDim_1 + $i] = $vValue[$i]
EndIf
Next
Return $iDim_1 + $iAdd - 1
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS)
If $iStart < 0 Or $iStart > $iDim_2 - 1 Then Return SetError(4, 0, -1)
Local $iValDim_1, $iValDim_2 = 0, $iColCount
If IsArray($vValue) Then
If UBound($vValue, $UBOUND_DIMENSIONS) <> 2 Then Return SetError(5, 0, -1)
$iValDim_1 = UBound($vValue, $UBOUND_ROWS)
$iValDim_2 = UBound($vValue, $UBOUND_COLUMNS)
$hDataType = 0
Else
Local $aSplit_1 = StringSplit($vValue, $sDelim_Row, $STR_NOCOUNT + $STR_ENTIRESPLIT)
$iValDim_1 = UBound($aSplit_1, $UBOUND_ROWS)
Local $aTmp[$iValDim_1][0], $aSplit_2
For $i = 0 To $iValDim_1 - 1
$aSplit_2 = StringSplit($aSplit_1[$i], $sDelim_Item, $STR_NOCOUNT + $STR_ENTIRESPLIT)
$iColCount = UBound($aSplit_2)
If $iColCount > $iValDim_2 Then
$iValDim_2 = $iColCount
ReDim $aTmp[$iValDim_1][$iValDim_2]
EndIf
For $j = 0 To $iColCount - 1
$aTmp[$i][$j] = $aSplit_2[$j]
Next
Next
$vValue = $aTmp
EndIf
If UBound($vValue, $UBOUND_COLUMNS) + $iStart > UBound($aArray, $UBOUND_COLUMNS) Then Return SetError(3, 0, -1)
ReDim $aArray[$iDim_1 + $iValDim_1][$iDim_2]
For $iWriteTo_Index = 0 To $iValDim_1 - 1
For $j = 0 To $iDim_2 - 1
If $j < $iStart Then
$aArray[$iWriteTo_Index + $iDim_1][$j] = ""
ElseIf $j - $iStart > $iValDim_2 - 1 Then
$aArray[$iWriteTo_Index + $iDim_1][$j] = ""
Else
If IsFunc($hDataType) Then
$aArray[$iWriteTo_Index + $iDim_1][$j] = $hDataType($vValue[$iWriteTo_Index][$j - $iStart])
Else
$aArray[$iWriteTo_Index + $iDim_1][$j] = $vValue[$iWriteTo_Index][$j - $iStart]
EndIf
EndIf
Next
Next
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return UBound($aArray, $UBOUND_ROWS) - 1
EndFunc
Func _ArrayColInsert(ByRef $aArray, $iColumn)
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS)
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
Local $aTempArray[$iDim_1][2]
Switch $iColumn
Case 0, 1
For $i = 0 To $iDim_1 - 1
$aTempArray[$i][(Not $iColumn)] = $aArray[$i]
Next
Case Else
Return SetError(3, 0, -1)
EndSwitch
$aArray = $aTempArray
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS)
If $iColumn < 0 Or $iColumn > $iDim_2 Then Return SetError(3, 0, -1)
ReDim $aArray[$iDim_1][$iDim_2 + 1]
For $i = 0 To $iDim_1 - 1
For $j = $iDim_2 To $iColumn + 1 Step -1
$aArray[$i][$j] = $aArray[$i][$j - 1]
Next
$aArray[$i][$iColumn] = ""
Next
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return UBound($aArray, $UBOUND_COLUMNS)
EndFunc
Func _ArrayConcatenate(ByRef $aArrayTarget, Const ByRef $aArraySource, $iStart = 0)
If $iStart = Default Then $iStart = 0
If Not IsArray($aArrayTarget) Then Return SetError(1, 0, -1)
If Not IsArray($aArraySource) Then Return SetError(2, 0, -1)
Local $iDim_Total_Tgt = UBound($aArrayTarget, $UBOUND_DIMENSIONS)
Local $iDim_Total_Src = UBound($aArraySource, $UBOUND_DIMENSIONS)
Local $iDim_1_Tgt = UBound($aArrayTarget, $UBOUND_ROWS)
Local $iDim_1_Src = UBound($aArraySource, $UBOUND_ROWS)
If $iStart < 0 Or $iStart > $iDim_1_Src - 1 Then Return SetError(6, 0, -1)
Switch $iDim_Total_Tgt
Case 1
If $iDim_Total_Src <> 1 Then Return SetError(4, 0, -1)
ReDim $aArrayTarget[$iDim_1_Tgt + $iDim_1_Src - $iStart]
For $i = $iStart To $iDim_1_Src - 1
$aArrayTarget[$iDim_1_Tgt + $i - $iStart] = $aArraySource[$i]
Next
Case 2
If $iDim_Total_Src <> 2 Then Return SetError(4, 0, -1)
Local $iDim_2_Tgt = UBound($aArrayTarget, $UBOUND_COLUMNS)
If UBound($aArraySource, $UBOUND_COLUMNS) <> $iDim_2_Tgt Then Return SetError(5, 0, -1)
ReDim $aArrayTarget[$iDim_1_Tgt + $iDim_1_Src - $iStart][$iDim_2_Tgt]
For $i = $iStart To $iDim_1_Src - 1
For $j = 0 To $iDim_2_Tgt - 1
$aArrayTarget[$iDim_1_Tgt + $i - $iStart][$j] = $aArraySource[$i][$j]
Next
Next
Case Else
Return SetError(3, 0, -1)
EndSwitch
Return UBound($aArrayTarget, $UBOUND_ROWS)
EndFunc
Func _ArrayDelete(ByRef $aArray, $vRange)
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
If IsArray($vRange) Then
If UBound($vRange, $UBOUND_DIMENSIONS) <> 1 Or UBound($vRange, $UBOUND_ROWS) < 2 Then Return SetError(4, 0, -1)
Else
Local $iNumber, $aSplit_1, $aSplit_2
$vRange = StringStripWS($vRange, 8)
$aSplit_1 = StringSplit($vRange, ";")
$vRange = ""
For $i = 1 To $aSplit_1[0]
If Not StringRegExp($aSplit_1[$i], "^\d+(-\d+)?$") Then Return SetError(3, 0, -1)
$aSplit_2 = StringSplit($aSplit_1[$i], "-")
Switch $aSplit_2[0]
Case 1
$vRange &= $aSplit_2[1] & ";"
Case 2
If Number($aSplit_2[2]) >= Number($aSplit_2[1]) Then
$iNumber = $aSplit_2[1] - 1
Do
$iNumber += 1
$vRange &= $iNumber & ";"
Until $iNumber = $aSplit_2[2]
EndIf
EndSwitch
Next
$vRange = StringSplit(StringTrimRight($vRange, 1), ";")
EndIf
If $vRange[1] < 0 Or $vRange[$vRange[0]] > $iDim_1 Then Return SetError(5, 0, -1)
Local $iCopyTo_Index = 0
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
For $i = 1 To $vRange[0]
$aArray[$vRange[$i]] = ChrW(0xFAB1)
Next
For $iReadFrom_Index = 0 To $iDim_1
If $aArray[$iReadFrom_Index] == ChrW(0xFAB1) Then
ContinueLoop
Else
If $iReadFrom_Index <> $iCopyTo_Index Then
$aArray[$iCopyTo_Index] = $aArray[$iReadFrom_Index]
EndIf
$iCopyTo_Index += 1
EndIf
Next
ReDim $aArray[$iDim_1 - $vRange[0] + 1]
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
For $i = 1 To $vRange[0]
$aArray[$vRange[$i]][0] = ChrW(0xFAB1)
Next
For $iReadFrom_Index = 0 To $iDim_1
If $aArray[$iReadFrom_Index][0] == ChrW(0xFAB1) Then
ContinueLoop
Else
If $iReadFrom_Index <> $iCopyTo_Index Then
For $j = 0 To $iDim_2
$aArray[$iCopyTo_Index][$j] = $aArray[$iReadFrom_Index][$j]
Next
EndIf
$iCopyTo_Index += 1
EndIf
Next
ReDim $aArray[$iDim_1 - $vRange[0] + 1][$iDim_2 + 1]
Case Else
Return SetError(2, 0, False)
EndSwitch
Return UBound($aArray, $UBOUND_ROWS)
EndFunc
Func _ArrayDisplay(Const ByRef $aArray, $sTitle = Default, $sArrayRange = Default, $iFlags = Default, $vUser_Separator = Default, $sHeader = Default, $iMax_ColWidth = Default, $iAlt_Color = Default, $hUser_Function = Default)
If $sTitle = Default Then $sTitle = "ArrayDisplay"
If $sArrayRange = Default Then $sArrayRange = ""
If $iFlags = Default Then $iFlags = 0
If $vUser_Separator = Default Then $vUser_Separator = ""
If $sHeader = Default Then $sHeader = ""
If $iMax_ColWidth = Default Then $iMax_ColWidth = 350
If $iAlt_Color = Default Then $iAlt_Color = 0
If $hUser_Function = Default Then $hUser_Function = 0
Local $iTranspose = BitAND($iFlags, 1)
Local $iColAlign = BitAND($iFlags, 6)
Local $iVerbose = BitAND($iFlags, 8)
Local $iButtonMargin =((BitAND($iFlags, 32)) ?(0) :((BitAND($iFlags, 16)) ?(20) :(40)))
Local $iNoRow = BitAND($iFlags, 64)
Local $sMsg = "", $iRet = 1
If IsArray($aArray) Then
Local $iDimension = UBound($aArray, $UBOUND_DIMENSIONS), $iRowCount = UBound($aArray, $UBOUND_ROWS), $iColCount = UBound($aArray, $UBOUND_COLUMNS)
If $iDimension > 2 Then
$sMsg = "Larger than 2D array passed to function"
$iRet = 2
EndIf
Else
$sMsg = "No array variable passed to function"
EndIf
If $sMsg Then
If $iVerbose And MsgBox($MB_SYSTEMMODAL + $MB_ICONERROR + $MB_YESNO, "ArrayDisplay Error: " & $sTitle, $sMsg & @CRLF & @CRLF & "Exit the script?") = $IDYES Then
Exit
Else
Return SetError($iRet, 0, "")
EndIf
EndIf
Local $iCW_ColWidth = Number($vUser_Separator)
Local $sAD_Separator = ChrW(0xFAB1)
Local $sCurr_Separator = Opt("GUIDataSeparatorChar", $sAD_Separator)
If $vUser_Separator = "" Then $vUser_Separator = $sCurr_Separator
Local $vTmp, $iRowLimit = 65525, $iColLimit = 250
Local $iDataRow = $iRowCount
Local $iDataCol = $iColCount
Local $iItem_Start = 0, $iItem_End = $iRowCount - 1, $iSubItem_Start = 0, $iSubItem_End =(($iDimension = 2) ?($iColCount - 1) :(0))
Local $bRange_Flag = False, $avRangeSplit
If $sArrayRange Then
Local $aArray_Range = StringRegExp($sArrayRange & "||", "(?U)(.*)\|", 3)
If $aArray_Range[0] Then
$avRangeSplit = StringSplit($aArray_Range[0], ":")
If @error Then
$iItem_End = Number($avRangeSplit[1])
Else
$iItem_Start = Number($avRangeSplit[1])
$iItem_End = Number($avRangeSplit[2])
EndIf
EndIf
If $iItem_Start > $iItem_End Then
$vTmp = $iItem_Start
$iItem_Start = $iItem_End
$iItem_End = $vTmp
EndIf
If $iItem_Start < 0 Then $iItem_Start = 0
If $iItem_End > $iRowCount - 1 Then $iItem_End = $iRowCount - 1
If $iItem_Start <> 0 Or $iItem_End <> $iRowCount - 1 Then $bRange_Flag = True
If $iDimension = 2 And $aArray_Range[1] Then
$avRangeSplit = StringSplit($aArray_Range[1], ":")
If @error Then
$iSubItem_End = Number($avRangeSplit[1])
Else
$iSubItem_Start = Number($avRangeSplit[1])
$iSubItem_End = Number($avRangeSplit[2])
EndIf
If $iSubItem_Start > $iSubItem_End Then
$vTmp = $iSubItem_Start
$iSubItem_Start = $iSubItem_End
$iSubItem_End = $vTmp
EndIf
If $iSubItem_Start < 0 Then $iSubItem_Start = 0
If $iSubItem_End > $iColCount - 1 Then $iSubItem_End = $iColCount - 1
If $iSubItem_Start <> 0 Or $iSubItem_End <> $iColCount - 1 Then $bRange_Flag = True
EndIf
EndIf
Local $sDisplayData = "[" & $iDataRow
Local $bTruncated = False
If $iTranspose Then
If $iItem_End - $iItem_Start > $iColLimit Then
$bTruncated = True
$iItem_End = $iItem_Start + $iColLimit - 1
EndIf
Else
If $iItem_End - $iItem_Start > $iRowLimit Then
$bTruncated = True
$iItem_End = $iItem_Start + $iRowLimit - 1
EndIf
EndIf
If $bTruncated Then
$sDisplayData &= "*]"
Else
$sDisplayData &= "]"
EndIf
If $iDimension = 2 Then
$sDisplayData &= " [" & $iDataCol
If $iTranspose Then
If $iSubItem_End - $iSubItem_Start > $iRowLimit Then
$bTruncated = True
$iSubItem_End = $iSubItem_Start + $iRowLimit - 1
EndIf
Else
If $iSubItem_End - $iSubItem_Start > $iColLimit Then
$bTruncated = True
$iSubItem_End = $iSubItem_Start + $iColLimit - 1
EndIf
EndIf
If $bTruncated Then
$sDisplayData &= "*]"
Else
$sDisplayData &= "]"
EndIf
EndIf
Local $sTipData = ""
If $bTruncated Then $sTipData &= "Truncated"
If $bRange_Flag Then
If $sTipData Then $sTipData &= " - "
$sTipData &= "Range set"
EndIf
If $iTranspose Then
If $sTipData Then $sTipData &= " - "
$sTipData &= "Transposed"
EndIf
Local $asHeader = StringSplit($sHeader, $sCurr_Separator, $STR_NOCOUNT)
If UBound($asHeader) = 0 Then Local $asHeader[1] = [""]
$sHeader = "Row"
Local $iIndex = $iSubItem_Start
If $iTranspose Then
For $j = $iItem_Start To $iItem_End
$sHeader &= $sAD_Separator & "Col " & $j
Next
Else
If $asHeader[0] Then
For $iIndex = $iSubItem_Start To $iSubItem_End
If $iIndex >= UBound($asHeader) Then ExitLoop
$sHeader &= $sAD_Separator & $asHeader[$iIndex]
Next
EndIf
For $j = $iIndex To $iSubItem_End
$sHeader &= $sAD_Separator & "Col " & $j
Next
EndIf
If $iNoRow Then $sHeader = StringTrimLeft($sHeader, 4)
If $iVerbose And($iItem_End - $iItem_Start + 1) *($iSubItem_End - $iSubItem_Start + 1) > 10000 Then
SplashTextOn("ArrayDisplay", "Preparing display" & @CRLF & @CRLF & "Please be patient", 300, 100)
EndIf
Local $iBuffer = 4094
If $iTranspose Then
$vTmp = $iItem_Start
$iItem_Start = $iSubItem_Start
$iSubItem_Start = $vTmp
$vTmp = $iItem_End
$iItem_End = $iSubItem_End
$iSubItem_End = $vTmp
EndIf
Local $avArrayText[$iItem_End - $iItem_Start + 1]
For $i = $iItem_Start To $iItem_End
If Not $iNoRow Then $avArrayText[$i - $iItem_Start] = "[" & $i & "]"
For $j = $iSubItem_Start To $iSubItem_End
If $iDimension = 1 Then
If $iTranspose Then
Switch VarGetType($aArray[$j])
Case "Array"
$vTmp = "{Array}"
Case Else
$vTmp = $aArray[$j]
EndSwitch
Else
Switch VarGetType($aArray[$i])
Case "Array"
$vTmp = "{Array}"
Case Else
$vTmp = $aArray[$i]
EndSwitch
EndIf
Else
If $iTranspose Then
Switch VarGetType($aArray[$j][$i])
Case "Array"
$vTmp = "{Array}"
Case Else
$vTmp = $aArray[$j][$i]
EndSwitch
Else
Switch VarGetType($aArray[$i][$j])
Case "Array"
$vTmp = "{Array}"
Case Else
$vTmp = $aArray[$i][$j]
EndSwitch
EndIf
EndIf
If StringLen($vTmp) > $iBuffer Then $vTmp = StringLeft($vTmp, $iBuffer)
$avArrayText[$i - $iItem_Start] &= $sAD_Separator & $vTmp
Next
If $iNoRow Then $avArrayText[$i - $iItem_Start] = StringTrimLeft($avArrayText[$i - $iItem_Start], 1)
Next
Local Const $_ARRAYCONSTANT_GUI_DOCKBOTTOM = 64
Local Const $_ARRAYCONSTANT_GUI_DOCKBORDERS = 102
Local Const $_ARRAYCONSTANT_GUI_DOCKHEIGHT = 512
Local Const $_ARRAYCONSTANT_GUI_DOCKLEFT = 2
Local Const $_ARRAYCONSTANT_GUI_DOCKRIGHT = 4
Local Const $_ARRAYCONSTANT_GUI_DOCKHCENTER = 8
Local Const $_ARRAYCONSTANT_GUI_EVENT_CLOSE = -3
Local Const $_ARRAYCONSTANT_GUI_FOCUS = 256
Local Const $_ARRAYCONSTANT_GUI_BKCOLOR_LV_ALTERNATE = 0xFE000000
Local Const $_ARRAYCONSTANT_SS_CENTER = 0x1
Local Const $_ARRAYCONSTANT_SS_CENTERIMAGE = 0x0200
Local Const $_ARRAYCONSTANT_LVM_GETITEMCOUNT =(0x1000 + 4)
Local Const $_ARRAYCONSTANT_LVM_GETITEMRECT =(0x1000 + 14)
Local Const $_ARRAYCONSTANT_LVM_GETCOLUMNWIDTH =(0x1000 + 29)
Local Const $_ARRAYCONSTANT_LVM_SETCOLUMNWIDTH =(0x1000 + 30)
Local Const $_ARRAYCONSTANT_LVM_GETITEMSTATE =(0x1000 + 44)
Local Const $_ARRAYCONSTANT_LVM_GETSELECTEDCOUNT =(0x1000 + 50)
Local Const $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE =(0x1000 + 54)
Local Const $_ARRAYCONSTANT_LVS_EX_GRIDLINES = 0x1
Local Const $_ARRAYCONSTANT_LVIS_SELECTED = 0x2
Local Const $_ARRAYCONSTANT_LVS_SHOWSELALWAYS = 0x8
Local Const $_ARRAYCONSTANT_LVS_EX_FULLROWSELECT = 0x20
Local Const $_ARRAYCONSTANT_WS_EX_CLIENTEDGE = 0x0200
Local Const $_ARRAYCONSTANT_WS_MAXIMIZEBOX = 0x00010000
Local Const $_ARRAYCONSTANT_WS_MINIMIZEBOX = 0x00020000
Local Const $_ARRAYCONSTANT_WS_SIZEBOX = 0x00040000
Local Const $_ARRAYCONSTANT_WM_SETREDRAW = 11
Local Const $_ARRAYCONSTANT_LVSCW_AUTOSIZE = -1
Local $iCoordMode = Opt("GUICoordMode", 1)
Local $iOrgWidth = 210, $iHeight = 200, $iMinSize = 250
Local $hGUI = GUICreate($sTitle, $iOrgWidth, $iHeight, Default, Default, BitOR($_ARRAYCONSTANT_WS_SIZEBOX, $_ARRAYCONSTANT_WS_MINIMIZEBOX, $_ARRAYCONSTANT_WS_MAXIMIZEBOX))
Local $aiGUISize = WinGetClientSize($hGUI)
Local $iButtonWidth_2 = $aiGUISize[0] / 2
Local $iButtonWidth_3 = $aiGUISize[0] / 3
Local $idListView = GUICtrlCreateListView($sHeader, 0, 0, $aiGUISize[0], $aiGUISize[1] - $iButtonMargin, $_ARRAYCONSTANT_LVS_SHOWSELALWAYS)
GUICtrlSetBkColor($idListView, $_ARRAYCONSTANT_GUI_BKCOLOR_LV_ALTERNATE)
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE, $_ARRAYCONSTANT_LVS_EX_GRIDLINES, $_ARRAYCONSTANT_LVS_EX_GRIDLINES)
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE, $_ARRAYCONSTANT_LVS_EX_FULLROWSELECT, $_ARRAYCONSTANT_LVS_EX_FULLROWSELECT)
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE, $_ARRAYCONSTANT_WS_EX_CLIENTEDGE, $_ARRAYCONSTANT_WS_EX_CLIENTEDGE)
Local $idCopy_ID = 9999, $idCopy_Data = 99999, $idData_Label = 99999, $idUser_Func = 99999, $idExit_Script = 99999
If $iButtonMargin Then
$idCopy_ID = GUICtrlCreateButton("Copy Data && Hdr/Row", 0, $aiGUISize[1] - $iButtonMargin, $iButtonWidth_2, 20)
$idCopy_Data = GUICtrlCreateButton("Copy Data Only", $iButtonWidth_2, $aiGUISize[1] - $iButtonMargin, $iButtonWidth_2, 20)
If $iButtonMargin = 40 Then
Local $iButtonWidth_Var = $iButtonWidth_2
Local $iOffset = $iButtonWidth_2
If IsFunc($hUser_Function) Then
$idUser_Func = GUICtrlCreateButton("Run User Func", $iButtonWidth_3, $aiGUISize[1] - 20, $iButtonWidth_3, 20)
$iButtonWidth_Var = $iButtonWidth_3
$iOffset = $iButtonWidth_3 * 2
EndIf
$idExit_Script = GUICtrlCreateButton("Exit Script", $iOffset, $aiGUISize[1] - 20, $iButtonWidth_Var, 20)
$idData_Label = GUICtrlCreateLabel($sDisplayData, 0, $aiGUISize[1] - 20, $iButtonWidth_Var, 18, BitOR($_ARRAYCONSTANT_SS_CENTER, $_ARRAYCONSTANT_SS_CENTERIMAGE))
Select
Case $bTruncated Or $iTranspose Or $bRange_Flag
GUICtrlSetColor($idData_Label, 0xFF0000)
GUICtrlSetTip($idData_Label, $sTipData)
EndSelect
EndIf
EndIf
GUICtrlSetResizing($idListView, $_ARRAYCONSTANT_GUI_DOCKBORDERS)
GUICtrlSetResizing($idCopy_ID, $_ARRAYCONSTANT_GUI_DOCKLEFT + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
GUICtrlSetResizing($idCopy_Data, $_ARRAYCONSTANT_GUI_DOCKRIGHT + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
GUICtrlSetResizing($idData_Label, $_ARRAYCONSTANT_GUI_DOCKLEFT + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
GUICtrlSetResizing($idUser_Func, $_ARRAYCONSTANT_GUI_DOCKHCENTER + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
GUICtrlSetResizing($idExit_Script, $_ARRAYCONSTANT_GUI_DOCKRIGHT + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_WM_SETREDRAW, 0, 0)
Local $idItem
For $i = 0 To UBound($avArrayText) - 1
$idItem = GUICtrlCreateListViewItem($avArrayText[$i], $idListView)
If $iAlt_Color Then
GUICtrlSetBkColor($idItem, $iAlt_Color)
EndIf
Next
If $iColAlign Then
Local Const $_ARRAYCONSTANT_LVCF_FMT = 0x01
Local Const $_ARRAYCONSTANT_LVM_SETCOLUMNW =(0x1000 + 96)
Local $tColumn = DllStructCreate("uint Mask;int Fmt;int CX;ptr Text;int TextMax;int SubItem;int Image;int Order;int cxMin;int cxDefault;int cxIdeal")
DllStructSetData($tColumn, "Mask", $_ARRAYCONSTANT_LVCF_FMT)
DllStructSetData($tColumn, "Fmt", $iColAlign / 2)
Local $pColumn = DllStructGetPtr($tColumn)
For $i = 1 To $iSubItem_End - $iSubItem_Start + 1
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_SETCOLUMNW, $i, $pColumn)
Next
EndIf
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_WM_SETREDRAW, 1, 0)
Local $iBorder = 45
If UBound($avArrayText) > 20 Then
$iBorder += 20
EndIf
Local $iWidth = $iBorder, $iColWidth = 0, $aiColWidth[$iSubItem_End - $iSubItem_Start + 2], $iMin_ColWidth = 55
For $i = 0 To $iSubItem_End - $iSubItem_Start + 1
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_SETCOLUMNWIDTH, $i, $_ARRAYCONSTANT_LVSCW_AUTOSIZE)
$iColWidth = GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_GETCOLUMNWIDTH, $i, 0)
If $iColWidth < $iMin_ColWidth Then
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_SETCOLUMNWIDTH, $i, $iMin_ColWidth)
$iColWidth = $iMin_ColWidth
EndIf
$iWidth += $iColWidth
$aiColWidth[$i] = $iColWidth
Next
If $iNoRow Then $iWidth -= 55
If $iWidth > @DesktopWidth - 100 Then
$iWidth = $iBorder
For $i = 0 To $iSubItem_End - $iSubItem_Start + 1
If $aiColWidth[$i] > $iMax_ColWidth Then
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_SETCOLUMNWIDTH, $i, $iMax_ColWidth)
$iWidth += $iMax_ColWidth
Else
$iWidth += $aiColWidth[$i]
EndIf
Next
EndIf
If $iWidth > @DesktopWidth - 100 Then
$iWidth = @DesktopWidth - 100
ElseIf $iWidth < $iMinSize Then
$iWidth = $iMinSize
EndIf
Local $tRECT = DllStructCreate("struct; long Left;long Top;long Right;long Bottom; endstruct")
DllCall("user32.dll", "struct*", "SendMessageW", "hwnd", GUICtrlGetHandle($idListView), "uint", $_ARRAYCONSTANT_LVM_GETITEMRECT, "wparam", 0, "struct*", $tRECT)
Local $aiWin_Pos = WinGetPos($hGUI)
Local $aiLV_Pos = ControlGetPos($hGUI, "", $idListView)
$iHeight =((UBound($avArrayText) + 2) *(DllStructGetData($tRECT, "Bottom") - DllStructGetData($tRECT, "Top"))) + $aiWin_Pos[3] - $aiLV_Pos[3]
If $iHeight > @DesktopHeight - 100 Then
$iHeight = @DesktopHeight - 100
ElseIf $iHeight < $iMinSize Then
$iHeight = $iMinSize
EndIf
If $iVerbose Then SplashOff()
GUISetState(@SW_HIDE, $hGUI)
WinMove($hGUI, "",(@DesktopWidth - $iWidth) / 2,(@DesktopHeight - $iHeight) / 2, $iWidth, $iHeight)
GUISetState(@SW_SHOW, $hGUI)
Local $iOnEventMode = Opt("GUIOnEventMode", 0), $iMsg
While 1
$iMsg = GUIGetMsg()
Switch $iMsg
Case $_ARRAYCONSTANT_GUI_EVENT_CLOSE
ExitLoop
Case $idCopy_ID, $idCopy_Data
Local $iSel_Count = GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_GETSELECTEDCOUNT, 0, 0)
If $iVerbose And(Not $iSel_Count) And($iItem_End - $iItem_Start) *($iSubItem_End - $iSubItem_Start) > 10000 Then
SplashTextOn("ArrayDisplay", "Copying data" & @CRLF & @CRLF & "Please be patient", 300, 100)
EndIf
Local $sClip = "", $sItem, $aSplit
For $i = 0 To $iItem_End - $iItem_Start
If $iSel_Count And Not(GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_GETITEMSTATE, $i, $_ARRAYCONSTANT_LVIS_SELECTED)) Then
ContinueLoop
EndIf
$sItem = $avArrayText[$i]
If $iMsg = $idCopy_Data Then
$sItem = StringRegExpReplace($sItem, "^\[\d+\].(.*)$", "$1")
EndIf
If $iCW_ColWidth Then
$aSplit = StringSplit($sItem, $sAD_Separator)
$sItem = ""
For $j = 1 To $aSplit[0]
$sItem &= StringFormat("%-" & $iCW_ColWidth + 1 & "s", StringLeft($aSplit[$j], $iCW_ColWidth))
Next
Else
$sItem = StringReplace($sItem, $sAD_Separator, $vUser_Separator)
EndIf
$sClip &= $sItem & @CRLF
Next
If $iMsg = $idCopy_ID Then
If $iCW_ColWidth Then
$aSplit = StringSplit($sHeader, $sAD_Separator)
$sItem = ""
For $j = 1 To $aSplit[0]
$sItem &= StringFormat("%-" & $iCW_ColWidth + 1 & "s", StringLeft($aSplit[$j], $iCW_ColWidth))
Next
Else
$sItem = StringReplace($sHeader, $sAD_Separator, $vUser_Separator)
EndIf
$sClip = $sItem & @CRLF & $sClip
EndIf
ClipPut($sClip)
SplashOff()
GUICtrlSetState($idListView, $_ARRAYCONSTANT_GUI_FOCUS)
Case $idUser_Func
Local $aiSelItems[$iRowLimit] = [0]
For $i = 0 To GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_GETITEMCOUNT, 0, 0)
If GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_GETITEMSTATE, $i, $_ARRAYCONSTANT_LVIS_SELECTED) Then
$aiSelItems[0] += 1
$aiSelItems[$aiSelItems[0]] = $i + $iItem_Start
EndIf
Next
ReDim $aiSelItems[$aiSelItems[0] + 1]
$hUser_Function($aArray, $aiSelItems)
GUICtrlSetState($idListView, $_ARRAYCONSTANT_GUI_FOCUS)
Case $idExit_Script
GUIDelete($hGUI)
Exit
EndSwitch
WEnd
GUIDelete($hGUI)
Opt("GUICoordMode", $iCoordMode)
Opt("GUIOnEventMode", $iOnEventMode)
Opt("GUIDataSeparatorChar", $sCurr_Separator)
Return 1
EndFunc
Func _ArrayMax(Const ByRef $aArray, $iCompNumeric = 0, $iStart = -1, $iEnd = -1, $iSubItem = 0)
Local $iResult = _ArrayMaxIndex($aArray, $iCompNumeric, $iStart, $iEnd, $iSubItem)
If @error Then Return SetError(@error, 0, "")
If UBound($aArray, $UBOUND_DIMENSIONS) = 1 Then
Return $aArray[$iResult]
Else
Return $aArray[$iResult][$iSubItem]
EndIf
EndFunc
Func _ArrayMaxIndex(Const ByRef $aArray, $iCompNumeric = 0, $iStart = -1, $iEnd = -1, $iSubItem = 0)
If $iCompNumeric = Default Then $iCompNumeric = 0
If $iStart = Default Then $iStart = -1
If $iEnd = Default Then $iEnd = -1
If $iSubItem = Default Then $iSubItem = 0
Local $iRet = __Array_MinMaxIndex($aArray, $iCompNumeric, $iStart, $iEnd, $iSubItem, __Array_GreaterThan)
Return SetError(@error, 0, $iRet)
EndFunc
Func _ArrayMinIndex(Const ByRef $aArray, $iCompNumeric = 0, $iStart = -1, $iEnd = -1, $iSubItem = 0)
If $iCompNumeric = Default Then $iCompNumeric = 0
If $iStart = Default Then $iStart = -1
If $iEnd = Default Then $iEnd = -1
If $iSubItem = Default Then $iSubItem = 0
Local $iRet = __Array_MinMaxIndex($aArray, $iCompNumeric, $iStart, $iEnd, $iSubItem, __Array_LessThan)
Return SetError(@error, 0, $iRet)
EndFunc
Func _ArrayPop(ByRef $aArray)
If(Not IsArray($aArray)) Then Return SetError(1, 0, "")
If UBound($aArray, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(2, 0, "")
Local $iUBound = UBound($aArray) - 1
If $iUBound = -1 Then Return SetError(3, 0, "")
Local $sLastVal = $aArray[$iUBound]
If $iUBound > -1 Then
ReDim $aArray[$iUBound]
EndIf
Return $sLastVal
EndFunc
Func _ArrayReverse(ByRef $aArray, $iStart = 0, $iEnd = 0)
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If Not IsArray($aArray) Then Return SetError(1, 0, 0)
If UBound($aArray, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(3, 0, 0)
If Not UBound($aArray) Then Return SetError(4, 0, 0)
Local $vTmp, $iUBound = UBound($aArray) - 1
If $iEnd < 1 Or $iEnd > $iUBound Then $iEnd = $iUBound
If $iStart < 0 Then $iStart = 0
If $iStart > $iEnd Then Return SetError(2, 0, 0)
For $i = $iStart To Int(($iStart + $iEnd - 1) / 2)
$vTmp = $aArray[$i]
$aArray[$i] = $aArray[$iEnd]
$aArray[$iEnd] = $vTmp
$iEnd -= 1
Next
Return 1
EndFunc
Func _ArraySearch(Const ByRef $aArray, $vValue, $iStart = 0, $iEnd = 0, $iCase = 0, $iCompare = 0, $iForward = 1, $iSubItem = -1, $bRow = False)
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If $iCase = Default Then $iCase = 0
If $iCompare = Default Then $iCompare = 0
If $iForward = Default Then $iForward = 1
If $iSubItem = Default Then $iSubItem = -1
If $bRow = Default Then $bRow = False
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray) - 1
If $iDim_1 = -1 Then Return SetError(3, 0, -1)
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
Local $bCompType = False
If $iCompare = 2 Then
$iCompare = 0
$bCompType = True
EndIf
If $bRow Then
If UBound($aArray, $UBOUND_DIMENSIONS) = 1 Then Return SetError(5, 0, -1)
If $iEnd < 1 Or $iEnd > $iDim_2 Then $iEnd = $iDim_2
If $iStart < 0 Then $iStart = 0
If $iStart > $iEnd Then Return SetError(4, 0, -1)
Else
If $iEnd < 1 Or $iEnd > $iDim_1 Then $iEnd = $iDim_1
If $iStart < 0 Then $iStart = 0
If $iStart > $iEnd Then Return SetError(4, 0, -1)
EndIf
Local $iStep = 1
If Not $iForward Then
Local $iTmp = $iStart
$iStart = $iEnd
$iEnd = $iTmp
$iStep = -1
EndIf
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If Not $iCompare Then
If Not $iCase Then
For $i = $iStart To $iEnd Step $iStep
If $bCompType And VarGetType($aArray[$i]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$i] = $vValue Then Return $i
Next
Else
For $i = $iStart To $iEnd Step $iStep
If $bCompType And VarGetType($aArray[$i]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$i] == $vValue Then Return $i
Next
EndIf
Else
For $i = $iStart To $iEnd Step $iStep
If $iCompare = 3 Then
If StringRegExp($aArray[$i], $vValue) Then Return $i
Else
If StringInStr($aArray[$i], $vValue, $iCase) > 0 Then Return $i
EndIf
Next
EndIf
Case 2
Local $iDim_Sub
If $bRow Then
$iDim_Sub = $iDim_1
If $iSubItem > $iDim_Sub Then $iSubItem = $iDim_Sub
If $iSubItem < 0 Then
$iSubItem = 0
Else
$iDim_Sub = $iSubItem
EndIf
Else
$iDim_Sub = $iDim_2
If $iSubItem > $iDim_Sub Then $iSubItem = $iDim_Sub
If $iSubItem < 0 Then
$iSubItem = 0
Else
$iDim_Sub = $iSubItem
EndIf
EndIf
For $j = $iSubItem To $iDim_Sub
If Not $iCompare Then
If Not $iCase Then
For $i = $iStart To $iEnd Step $iStep
If $bRow Then
If $bCompType And VarGetType($aArray[$j][$j]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$j][$i] = $vValue Then Return $i
Else
If $bCompType And VarGetType($aArray[$i][$j]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$i][$j] = $vValue Then Return $i
EndIf
Next
Else
For $i = $iStart To $iEnd Step $iStep
If $bRow Then
If $bCompType And VarGetType($aArray[$j][$i]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$j][$i] == $vValue Then Return $i
Else
If $bCompType And VarGetType($aArray[$i][$j]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$i][$j] == $vValue Then Return $i
EndIf
Next
EndIf
Else
For $i = $iStart To $iEnd Step $iStep
If $iCompare = 3 Then
If $bRow Then
If StringRegExp($aArray[$j][$i], $vValue) Then Return $i
Else
If StringRegExp($aArray[$i][$j], $vValue) Then Return $i
EndIf
Else
If $bRow Then
If StringInStr($aArray[$j][$i], $vValue, $iCase) > 0 Then Return $i
Else
If StringInStr($aArray[$i][$j], $vValue, $iCase) > 0 Then Return $i
EndIf
EndIf
Next
EndIf
Next
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return SetError(6, 0, -1)
EndFunc
Func _ArraySort(ByRef $aArray, $iDescending = 0, $iStart = 0, $iEnd = 0, $iSubItem = 0, $iPivot = 0)
If $iDescending = Default Then $iDescending = 0
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If $iSubItem = Default Then $iSubItem = 0
If $iPivot = Default Then $iPivot = 0
If Not IsArray($aArray) Then Return SetError(1, 0, 0)
Local $iUBound = UBound($aArray) - 1
If $iUBound = -1 Then Return SetError(5, 0, 0)
If $iEnd = Default Then $iEnd = 0
If $iEnd < 1 Or $iEnd > $iUBound Or $iEnd = Default Then $iEnd = $iUBound
If $iStart < 0 Or $iStart = Default Then $iStart = 0
If $iStart > $iEnd Then Return SetError(2, 0, 0)
If $iDescending = Default Then $iDescending = 0
If $iPivot = Default Then $iPivot = 0
If $iSubItem = Default Then $iSubItem = 0
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If $iPivot Then
__ArrayDualPivotSort($aArray, $iStart, $iEnd)
Else
__ArrayQuickSort1D($aArray, $iStart, $iEnd)
EndIf
If $iDescending Then _ArrayReverse($aArray, $iStart, $iEnd)
Case 2
If $iPivot Then Return SetError(6, 0, 0)
Local $iSubMax = UBound($aArray, $UBOUND_COLUMNS) - 1
If $iSubItem > $iSubMax Then Return SetError(3, 0, 0)
If $iDescending Then
$iDescending = -1
Else
$iDescending = 1
EndIf
__ArrayQuickSort2D($aArray, $iDescending, $iStart, $iEnd, $iSubItem, $iSubMax)
Case Else
Return SetError(4, 0, 0)
EndSwitch
Return 1
EndFunc
Func __ArrayQuickSort1D(ByRef $aArray, Const ByRef $iStart, Const ByRef $iEnd)
If $iEnd <= $iStart Then Return
Local $vTmp
If($iEnd - $iStart) < 15 Then
Local $vCur
For $i = $iStart + 1 To $iEnd
$vTmp = $aArray[$i]
If IsNumber($vTmp) Then
For $j = $i - 1 To $iStart Step -1
$vCur = $aArray[$j]
If($vTmp >= $vCur And IsNumber($vCur)) Or(Not IsNumber($vCur) And StringCompare($vTmp, $vCur) >= 0) Then ExitLoop
$aArray[$j + 1] = $vCur
Next
Else
For $j = $i - 1 To $iStart Step -1
If(StringCompare($vTmp, $aArray[$j]) >= 0) Then ExitLoop
$aArray[$j + 1] = $aArray[$j]
Next
EndIf
$aArray[$j + 1] = $vTmp
Next
Return
EndIf
Local $L = $iStart, $R = $iEnd, $vPivot = $aArray[Int(($iStart + $iEnd) / 2)], $bNum = IsNumber($vPivot)
Do
If $bNum Then
While($aArray[$L] < $vPivot And IsNumber($aArray[$L])) Or(Not IsNumber($aArray[$L]) And StringCompare($aArray[$L], $vPivot) < 0)
$L += 1
WEnd
While($aArray[$R] > $vPivot And IsNumber($aArray[$R])) Or(Not IsNumber($aArray[$R]) And StringCompare($aArray[$R], $vPivot) > 0)
$R -= 1
WEnd
Else
While(StringCompare($aArray[$L], $vPivot) < 0)
$L += 1
WEnd
While(StringCompare($aArray[$R], $vPivot) > 0)
$R -= 1
WEnd
EndIf
If $L <= $R Then
$vTmp = $aArray[$L]
$aArray[$L] = $aArray[$R]
$aArray[$R] = $vTmp
$L += 1
$R -= 1
EndIf
Until $L > $R
__ArrayQuickSort1D($aArray, $iStart, $R)
__ArrayQuickSort1D($aArray, $L, $iEnd)
EndFunc
Func __ArrayQuickSort2D(ByRef $aArray, Const ByRef $iStep, Const ByRef $iStart, Const ByRef $iEnd, Const ByRef $iSubItem, Const ByRef $iSubMax)
If $iEnd <= $iStart Then Return
Local $vTmp, $L = $iStart, $R = $iEnd, $vPivot = $aArray[Int(($iStart + $iEnd) / 2)][$iSubItem], $bNum = IsNumber($vPivot)
Do
If $bNum Then
While($iStep *($aArray[$L][$iSubItem] - $vPivot) < 0 And IsNumber($aArray[$L][$iSubItem])) Or(Not IsNumber($aArray[$L][$iSubItem]) And $iStep * StringCompare($aArray[$L][$iSubItem], $vPivot) < 0)
$L += 1
WEnd
While($iStep *($aArray[$R][$iSubItem] - $vPivot) > 0 And IsNumber($aArray[$R][$iSubItem])) Or(Not IsNumber($aArray[$R][$iSubItem]) And $iStep * StringCompare($aArray[$R][$iSubItem], $vPivot) > 0)
$R -= 1
WEnd
Else
While($iStep * StringCompare($aArray[$L][$iSubItem], $vPivot) < 0)
$L += 1
WEnd
While($iStep * StringCompare($aArray[$R][$iSubItem], $vPivot) > 0)
$R -= 1
WEnd
EndIf
If $L <= $R Then
For $i = 0 To $iSubMax
$vTmp = $aArray[$L][$i]
$aArray[$L][$i] = $aArray[$R][$i]
$aArray[$R][$i] = $vTmp
Next
$L += 1
$R -= 1
EndIf
Until $L > $R
__ArrayQuickSort2D($aArray, $iStep, $iStart, $R, $iSubItem, $iSubMax)
__ArrayQuickSort2D($aArray, $iStep, $L, $iEnd, $iSubItem, $iSubMax)
EndFunc
Func __ArrayDualPivotSort(ByRef $aArray, $iPivot_Left, $iPivot_Right, $bLeftMost = True)
If $iPivot_Left > $iPivot_Right Then Return
Local $iLength = $iPivot_Right - $iPivot_Left + 1
Local $i, $j, $k, $iAi, $iAk, $iA1, $iA2, $iLast
If $iLength < 45 Then
If $bLeftMost Then
$i = $iPivot_Left
While $i < $iPivot_Right
$j = $i
$iAi = $aArray[$i + 1]
While $iAi < $aArray[$j]
$aArray[$j + 1] = $aArray[$j]
$j -= 1
If $j + 1 = $iPivot_Left Then ExitLoop
WEnd
$aArray[$j + 1] = $iAi
$i += 1
WEnd
Else
While 1
If $iPivot_Left >= $iPivot_Right Then Return 1
$iPivot_Left += 1
If $aArray[$iPivot_Left] < $aArray[$iPivot_Left - 1] Then ExitLoop
WEnd
While 1
$k = $iPivot_Left
$iPivot_Left += 1
If $iPivot_Left > $iPivot_Right Then ExitLoop
$iA1 = $aArray[$k]
$iA2 = $aArray[$iPivot_Left]
If $iA1 < $iA2 Then
$iA2 = $iA1
$iA1 = $aArray[$iPivot_Left]
EndIf
$k -= 1
While $iA1 < $aArray[$k]
$aArray[$k + 2] = $aArray[$k]
$k -= 1
WEnd
$aArray[$k + 2] = $iA1
While $iA2 < $aArray[$k]
$aArray[$k + 1] = $aArray[$k]
$k -= 1
WEnd
$aArray[$k + 1] = $iA2
$iPivot_Left += 1
WEnd
$iLast = $aArray[$iPivot_Right]
$iPivot_Right -= 1
While $iLast < $aArray[$iPivot_Right]
$aArray[$iPivot_Right + 1] = $aArray[$iPivot_Right]
$iPivot_Right -= 1
WEnd
$aArray[$iPivot_Right + 1] = $iLast
EndIf
Return 1
EndIf
Local $iSeventh = BitShift($iLength, 3) + BitShift($iLength, 6) + 1
Local $iE1, $iE2, $iE3, $iE4, $iE5, $t
$iE3 = Ceiling(($iPivot_Left + $iPivot_Right) / 2)
$iE2 = $iE3 - $iSeventh
$iE1 = $iE2 - $iSeventh
$iE4 = $iE3 + $iSeventh
$iE5 = $iE4 + $iSeventh
If $aArray[$iE2] < $aArray[$iE1] Then
$t = $aArray[$iE2]
$aArray[$iE2] = $aArray[$iE1]
$aArray[$iE1] = $t
EndIf
If $aArray[$iE3] < $aArray[$iE2] Then
$t = $aArray[$iE3]
$aArray[$iE3] = $aArray[$iE2]
$aArray[$iE2] = $t
If $t < $aArray[$iE1] Then
$aArray[$iE2] = $aArray[$iE1]
$aArray[$iE1] = $t
EndIf
EndIf
If $aArray[$iE4] < $aArray[$iE3] Then
$t = $aArray[$iE4]
$aArray[$iE4] = $aArray[$iE3]
$aArray[$iE3] = $t
If $t < $aArray[$iE2] Then
$aArray[$iE3] = $aArray[$iE2]
$aArray[$iE2] = $t
If $t < $aArray[$iE1] Then
$aArray[$iE2] = $aArray[$iE1]
$aArray[$iE1] = $t
EndIf
EndIf
EndIf
If $aArray[$iE5] < $aArray[$iE4] Then
$t = $aArray[$iE5]
$aArray[$iE5] = $aArray[$iE4]
$aArray[$iE4] = $t
If $t < $aArray[$iE3] Then
$aArray[$iE4] = $aArray[$iE3]
$aArray[$iE3] = $t
If $t < $aArray[$iE2] Then
$aArray[$iE3] = $aArray[$iE2]
$aArray[$iE2] = $t
If $t < $aArray[$iE1] Then
$aArray[$iE2] = $aArray[$iE1]
$aArray[$iE1] = $t
EndIf
EndIf
EndIf
EndIf
Local $iLess = $iPivot_Left
Local $iGreater = $iPivot_Right
If(($aArray[$iE1] <> $aArray[$iE2]) And($aArray[$iE2] <> $aArray[$iE3]) And($aArray[$iE3] <> $aArray[$iE4]) And($aArray[$iE4] <> $aArray[$iE5])) Then
Local $iPivot_1 = $aArray[$iE2]
Local $iPivot_2 = $aArray[$iE4]
$aArray[$iE2] = $aArray[$iPivot_Left]
$aArray[$iE4] = $aArray[$iPivot_Right]
Do
$iLess += 1
Until $aArray[$iLess] >= $iPivot_1
Do
$iGreater -= 1
Until $aArray[$iGreater] <= $iPivot_2
$k = $iLess
While $k <= $iGreater
$iAk = $aArray[$k]
If $iAk < $iPivot_1 Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $iAk
$iLess += 1
ElseIf $iAk > $iPivot_2 Then
While $aArray[$iGreater] > $iPivot_2
$iGreater -= 1
If $iGreater + 1 = $k Then ExitLoop 2
WEnd
If $aArray[$iGreater] < $iPivot_1 Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $aArray[$iGreater]
$iLess += 1
Else
$aArray[$k] = $aArray[$iGreater]
EndIf
$aArray[$iGreater] = $iAk
$iGreater -= 1
EndIf
$k += 1
WEnd
$aArray[$iPivot_Left] = $aArray[$iLess - 1]
$aArray[$iLess - 1] = $iPivot_1
$aArray[$iPivot_Right] = $aArray[$iGreater + 1]
$aArray[$iGreater + 1] = $iPivot_2
__ArrayDualPivotSort($aArray, $iPivot_Left, $iLess - 2, True)
__ArrayDualPivotSort($aArray, $iGreater + 2, $iPivot_Right, False)
If($iLess < $iE1) And($iE5 < $iGreater) Then
While $aArray[$iLess] = $iPivot_1
$iLess += 1
WEnd
While $aArray[$iGreater] = $iPivot_2
$iGreater -= 1
WEnd
$k = $iLess
While $k <= $iGreater
$iAk = $aArray[$k]
If $iAk = $iPivot_1 Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $iAk
$iLess += 1
ElseIf $iAk = $iPivot_2 Then
While $aArray[$iGreater] = $iPivot_2
$iGreater -= 1
If $iGreater + 1 = $k Then ExitLoop 2
WEnd
If $aArray[$iGreater] = $iPivot_1 Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $iPivot_1
$iLess += 1
Else
$aArray[$k] = $aArray[$iGreater]
EndIf
$aArray[$iGreater] = $iAk
$iGreater -= 1
EndIf
$k += 1
WEnd
EndIf
__ArrayDualPivotSort($aArray, $iLess, $iGreater, False)
Else
Local $iPivot = $aArray[$iE3]
$k = $iLess
While $k <= $iGreater
If $aArray[$k] = $iPivot Then
$k += 1
ContinueLoop
EndIf
$iAk = $aArray[$k]
If $iAk < $iPivot Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $iAk
$iLess += 1
Else
While $aArray[$iGreater] > $iPivot
$iGreater -= 1
WEnd
If $aArray[$iGreater] < $iPivot Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $aArray[$iGreater]
$iLess += 1
Else
$aArray[$k] = $iPivot
EndIf
$aArray[$iGreater] = $iAk
$iGreater -= 1
EndIf
$k += 1
WEnd
__ArrayDualPivotSort($aArray, $iPivot_Left, $iLess - 1, True)
__ArrayDualPivotSort($aArray, $iGreater + 1, $iPivot_Right, False)
EndIf
EndFunc
Func _ArrayToString(Const ByRef $aArray, $sDelim_Col = "|", $iStart_Row = -1, $iEnd_Row = -1, $sDelim_Row = @CRLF, $iStart_Col = -1, $iEnd_Col = -1)
If $sDelim_Col = Default Then $sDelim_Col = "|"
If $sDelim_Row = Default Then $sDelim_Row = @CRLF
If $iStart_Row = Default Then $iStart_Row = -1
If $iEnd_Row = Default Then $iEnd_Row = -1
If $iStart_Col = Default Then $iStart_Col = -1
If $iEnd_Col = Default Then $iEnd_Col = -1
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
If $iStart_Row = -1 Then $iStart_Row = 0
If $iEnd_Row = -1 Then $iEnd_Row = $iDim_1
If $iStart_Row < -1 Or $iEnd_Row < -1 Then Return SetError(3, 0, -1)
If $iStart_Row > $iDim_1 Or $iEnd_Row > $iDim_1 Then Return SetError(3, 0, "")
If $iStart_Row > $iEnd_Row Then Return SetError(4, 0, -1)
Local $sRet = ""
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
For $i = $iStart_Row To $iEnd_Row
$sRet &= $aArray[$i] & $sDelim_Col
Next
Return StringTrimRight($sRet, StringLen($sDelim_Col))
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
If $iStart_Col = -1 Then $iStart_Col = 0
If $iEnd_Col = -1 Then $iEnd_Col = $iDim_2
If $iStart_Col < -1 Or $iEnd_Col < -1 Then Return SetError(5, 0, -1)
If $iStart_Col > $iDim_2 Or $iEnd_Col > $iDim_2 Then Return SetError(5, 0, -1)
If $iStart_Col > $iEnd_Col Then Return SetError(6, 0, -1)
For $i = $iStart_Row To $iEnd_Row
For $j = $iStart_Col To $iEnd_Col
$sRet &= $aArray[$i][$j] & $sDelim_Col
Next
$sRet = StringTrimRight($sRet, StringLen($sDelim_Col)) & $sDelim_Row
Next
Return StringTrimRight($sRet, StringLen($sDelim_Row))
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return 1
EndFunc
Func __Array_MinMaxIndex(Const ByRef $aArray, $iCompNumeric, $iStart, $iEnd, $iSubItem, $fuComparison)
If $iCompNumeric = Default Then $iCompNumeric = 0
If $iCompNumeric <> 1 Then $iCompNumeric = 0
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If $iSubItem = Default Then $iSubItem = 0
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
If $iDim_1 < 0 Then Return SetError(1, 0, -1)
If $iEnd = -1 Then $iEnd = $iDim_1
If $iStart = -1 Then $iStart = 0
If $iStart < -1 Or $iEnd < -1 Then Return SetError(3, 0, -1)
If $iStart > $iDim_1 Or $iEnd > $iDim_1 Then Return SetError(3, 0, -1)
If $iStart > $iEnd Then Return SetError(4, 0, -1)
If $iDim_1 < 0 Then Return SetError(5, 0, -1)
Local $iMaxMinIndex = $iStart
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If $iCompNumeric Then
For $i = $iStart To $iEnd
If $fuComparison(Number($aArray[$i]), Number($aArray[$iMaxMinIndex])) Then $iMaxMinIndex = $i
Next
Else
For $i = $iStart To $iEnd
If $fuComparison($aArray[$i], $aArray[$iMaxMinIndex]) Then $iMaxMinIndex = $i
Next
EndIf
Case 2
If $iSubItem < 0 Or $iSubItem > UBound($aArray, $UBOUND_COLUMNS) - 1 Then Return SetError(6, 0, -1)
If $iCompNumeric Then
For $i = $iStart To $iEnd
If $fuComparison(Number($aArray[$i][$iSubItem]), Number($aArray[$iMaxMinIndex][$iSubItem])) Then $iMaxMinIndex = $i
Next
Else
For $i = $iStart To $iEnd
If $fuComparison($aArray[$i][$iSubItem], $aArray[$iMaxMinIndex][$iSubItem]) Then $iMaxMinIndex = $i
Next
EndIf
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return $iMaxMinIndex
EndFunc
Func __Array_GreaterThan($vValue1, $vValue2)
Return $vValue1 > $vValue2
EndFunc
Func __Array_LessThan($vValue1, $vValue2)
Return $vValue1 < $vValue2
EndFunc
Global Const $DMW_SHORTNAME = 1
Global Const $DMW_LOCALE_LONGNAME = 2
Func _WinAPI_GetDateFormat($iLCID = 0, $tSYSTEMTIME = 0, $iFlags = 0, $sFormat = '')
If Not $iLCID Then $iLCID = 0x0400
Local $sTypeOfFormat = 'wstr'
If Not StringStripWS($sFormat, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfFormat = 'ptr'
$sFormat = 0
EndIf
Local $aRet = DllCall('kernel32.dll', 'int', 'GetDateFormatW', 'dword', $iLCID, 'dword', $iFlags, 'struct*', $tSYSTEMTIME, $sTypeOfFormat, $sFormat, 'wstr', '', 'int', 2048)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return $aRet[5]
EndFunc
Func _WinAPI_GetLocaleInfo($iLCID, $iType)
Local $aRet = DllCall('kernel32.dll', 'int', 'GetLocaleInfoW', 'dword', $iLCID, 'dword', $iType, 'wstr', '', 'int', 2048)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
Return $aRet[3]
EndFunc
Func _DateAdd($sType, $iNumber, $sDate)
Local $asTimePart[4]
Local $asDatePart[4]
Local $iJulianDate
$sType = StringLeft($sType, 1)
If StringInStr("D,M,Y,w,h,n,s", $sType) = 0 Or $sType = "" Then
Return SetError(1, 0, 0)
EndIf
If Not StringIsInt($iNumber) Then
Return SetError(2, 0, 0)
EndIf
If Not _DateIsValid($sDate) Then
Return SetError(3, 0, 0)
EndIf
_DateTimeSplit($sDate, $asDatePart, $asTimePart)
If $sType = "d" Or $sType = "w" Then
If $sType = "w" Then $iNumber = $iNumber * 7
$iJulianDate = _DateToDayValue($asDatePart[1], $asDatePart[2], $asDatePart[3]) + $iNumber
_DayValueToDate($iJulianDate, $asDatePart[1], $asDatePart[2], $asDatePart[3])
EndIf
If $sType = "m" Then
$asDatePart[2] = $asDatePart[2] + $iNumber
While $asDatePart[2] > 12
$asDatePart[2] = $asDatePart[2] - 12
$asDatePart[1] = $asDatePart[1] + 1
WEnd
While $asDatePart[2] < 1
$asDatePart[2] = $asDatePart[2] + 12
$asDatePart[1] = $asDatePart[1] - 1
WEnd
EndIf
If $sType = "y" Then
$asDatePart[1] = $asDatePart[1] + $iNumber
EndIf
If $sType = "h" Or $sType = "n" Or $sType = "s" Then
Local $iTimeVal = _TimeToTicks($asTimePart[1], $asTimePart[2], $asTimePart[3]) / 1000
If $sType = "h" Then $iTimeVal = $iTimeVal + $iNumber * 3600
If $sType = "n" Then $iTimeVal = $iTimeVal + $iNumber * 60
If $sType = "s" Then $iTimeVal = $iTimeVal + $iNumber
Local $iDay2Add = Int($iTimeVal /(24 * 60 * 60))
$iTimeVal = $iTimeVal - $iDay2Add * 24 * 60 * 60
If $iTimeVal < 0 Then
$iDay2Add = $iDay2Add - 1
$iTimeVal = $iTimeVal + 24 * 60 * 60
EndIf
$iJulianDate = _DateToDayValue($asDatePart[1], $asDatePart[2], $asDatePart[3]) + $iDay2Add
_DayValueToDate($iJulianDate, $asDatePart[1], $asDatePart[2], $asDatePart[3])
_TicksToTime($iTimeVal * 1000, $asTimePart[1], $asTimePart[2], $asTimePart[3])
EndIf
Local $iNumDays = _DaysInMonth($asDatePart[1])
If $iNumDays[$asDatePart[2]] < $asDatePart[3] Then $asDatePart[3] = $iNumDays[$asDatePart[2]]
$sDate = $asDatePart[1] & '/' & StringRight("0" & $asDatePart[2], 2) & '/' & StringRight("0" & $asDatePart[3], 2)
If $asTimePart[0] > 0 Then
If $asTimePart[0] > 2 Then
$sDate = $sDate & " " & StringRight("0" & $asTimePart[1], 2) & ':' & StringRight("0" & $asTimePart[2], 2) & ':' & StringRight("0" & $asTimePart[3], 2)
Else
$sDate = $sDate & " " & StringRight("0" & $asTimePart[1], 2) & ':' & StringRight("0" & $asTimePart[2], 2)
EndIf
EndIf
Return $sDate
EndFunc
Func _DateDayOfWeek($iDayNum, $iFormat = Default)
Local Const $MONDAY_IS_NO1 = 128
If $iFormat = Default Then $iFormat = 0
$iDayNum = Int($iDayNum)
If $iDayNum < 1 Or $iDayNum > 7 Then Return SetError(1, 0, "")
Local $tSYSTEMTIME = DllStructCreate($tagSYSTEMTIME)
DllStructSetData($tSYSTEMTIME, "Year", BitAND($iFormat, $MONDAY_IS_NO1) ? 2007 : 2006)
DllStructSetData($tSYSTEMTIME, "Month", 1)
DllStructSetData($tSYSTEMTIME, "Day", $iDayNum)
Return _WinAPI_GetDateFormat(BitAND($iFormat, $DMW_LOCALE_LONGNAME) ? $LOCALE_USER_DEFAULT : $LOCALE_INVARIANT, $tSYSTEMTIME, 0, BitAND($iFormat, $DMW_SHORTNAME) ? "ddd" : "dddd")
EndFunc
Func _DateDiff($sType, $sStartDate, $sEndDate)
$sType = StringLeft($sType, 1)
If StringInStr("d,m,y,w,h,n,s", $sType) = 0 Or $sType = "" Then
Return SetError(1, 0, 0)
EndIf
If Not _DateIsValid($sStartDate) Then
Return SetError(2, 0, 0)
EndIf
If Not _DateIsValid($sEndDate) Then
Return SetError(3, 0, 0)
EndIf
Local $asStartDatePart[4], $asStartTimePart[4], $asEndDatePart[4], $asEndTimePart[4]
_DateTimeSplit($sStartDate, $asStartDatePart, $asStartTimePart)
_DateTimeSplit($sEndDate, $asEndDatePart, $asEndTimePart)
Local $aDaysDiff = _DateToDayValue($asEndDatePart[1], $asEndDatePart[2], $asEndDatePart[3]) - _DateToDayValue($asStartDatePart[1], $asStartDatePart[2], $asStartDatePart[3])
Local $iTimeDiff, $iYearDiff, $iStartTimeInSecs, $iEndTimeInSecs
If $asStartTimePart[0] > 1 And $asEndTimePart[0] > 1 Then
$iStartTimeInSecs = $asStartTimePart[1] * 3600 + $asStartTimePart[2] * 60 + $asStartTimePart[3]
$iEndTimeInSecs = $asEndTimePart[1] * 3600 + $asEndTimePart[2] * 60 + $asEndTimePart[3]
$iTimeDiff = $iEndTimeInSecs - $iStartTimeInSecs
If $iTimeDiff < 0 Then
$aDaysDiff = $aDaysDiff - 1
$iTimeDiff = $iTimeDiff + 24 * 60 * 60
EndIf
Else
$iTimeDiff = 0
EndIf
Select
Case $sType = "d"
Return $aDaysDiff
Case $sType = "m"
$iYearDiff = $asEndDatePart[1] - $asStartDatePart[1]
Local $iMonthDiff = $asEndDatePart[2] - $asStartDatePart[2] + $iYearDiff * 12
If $asEndDatePart[3] < $asStartDatePart[3] Then $iMonthDiff = $iMonthDiff - 1
$iStartTimeInSecs = $asStartTimePart[1] * 3600 + $asStartTimePart[2] * 60 + $asStartTimePart[3]
$iEndTimeInSecs = $asEndTimePart[1] * 3600 + $asEndTimePart[2] * 60 + $asEndTimePart[3]
$iTimeDiff = $iEndTimeInSecs - $iStartTimeInSecs
If $asEndDatePart[3] = $asStartDatePart[3] And $iTimeDiff < 0 Then $iMonthDiff = $iMonthDiff - 1
Return $iMonthDiff
Case $sType = "y"
$iYearDiff = $asEndDatePart[1] - $asStartDatePart[1]
If $asEndDatePart[2] < $asStartDatePart[2] Then $iYearDiff = $iYearDiff - 1
If $asEndDatePart[2] = $asStartDatePart[2] And $asEndDatePart[3] < $asStartDatePart[3] Then $iYearDiff = $iYearDiff - 1
$iStartTimeInSecs = $asStartTimePart[1] * 3600 + $asStartTimePart[2] * 60 + $asStartTimePart[3]
$iEndTimeInSecs = $asEndTimePart[1] * 3600 + $asEndTimePart[2] * 60 + $asEndTimePart[3]
$iTimeDiff = $iEndTimeInSecs - $iStartTimeInSecs
If $asEndDatePart[2] = $asStartDatePart[2] And $asEndDatePart[3] = $asStartDatePart[3] And $iTimeDiff < 0 Then $iYearDiff = $iYearDiff - 1
Return $iYearDiff
Case $sType = "w"
Return Int($aDaysDiff / 7)
Case $sType = "h"
Return $aDaysDiff * 24 + Int($iTimeDiff / 3600)
Case $sType = "n"
Return $aDaysDiff * 24 * 60 + Int($iTimeDiff / 60)
Case $sType = "s"
Return $aDaysDiff * 24 * 60 * 60 + $iTimeDiff
EndSelect
EndFunc
Func _DateIsLeapYear($iYear)
If StringIsInt($iYear) Then
Select
Case Mod($iYear, 4) = 0 And Mod($iYear, 100) <> 0
Return 1
Case Mod($iYear, 400) = 0
Return 1
Case Else
Return 0
EndSelect
EndIf
Return SetError(1, 0, 0)
EndFunc
Func __DateIsMonth($iNumber)
$iNumber = Int($iNumber)
Return $iNumber >= 1 And $iNumber <= 12
EndFunc
Func _DateIsValid($sDate)
Local $asDatePart[4], $asTimePart[4]
_DateTimeSplit($sDate, $asDatePart, $asTimePart)
If Not StringIsInt($asDatePart[1]) Then Return 0
If Not StringIsInt($asDatePart[2]) Then Return 0
If Not StringIsInt($asDatePart[3]) Then Return 0
$asDatePart[1] = Int($asDatePart[1])
$asDatePart[2] = Int($asDatePart[2])
$asDatePart[3] = Int($asDatePart[3])
Local $iNumDays = _DaysInMonth($asDatePart[1])
If $asDatePart[1] < 1000 Or $asDatePart[1] > 2999 Then Return 0
If $asDatePart[2] < 1 Or $asDatePart[2] > 12 Then Return 0
If $asDatePart[3] < 1 Or $asDatePart[3] > $iNumDays[$asDatePart[2]] Then Return 0
If $asTimePart[0] < 1 Then Return 1
If $asTimePart[0] < 2 Then Return 0
If $asTimePart[0] = 2 Then $asTimePart[3] = "00"
If Not StringIsInt($asTimePart[1]) Then Return 0
If Not StringIsInt($asTimePart[2]) Then Return 0
If Not StringIsInt($asTimePart[3]) Then Return 0
$asTimePart[1] = Int($asTimePart[1])
$asTimePart[2] = Int($asTimePart[2])
$asTimePart[3] = Int($asTimePart[3])
If $asTimePart[1] < 0 Or $asTimePart[1] > 23 Then Return 0
If $asTimePart[2] < 0 Or $asTimePart[2] > 59 Then Return 0
If $asTimePart[3] < 0 Or $asTimePart[3] > 59 Then Return 0
Return 1
EndFunc
Func _DateTimeFormat($sDate, $sType)
Local $asDatePart[4], $asTimePart[4]
Local $sTempDate = "", $sTempTime = ""
Local $sAM, $sPM, $sTempString = ""
If Not _DateIsValid($sDate) Then
Return SetError(1, 0, "")
EndIf
If $sType < 0 Or $sType > 5 Or Not IsInt($sType) Then
Return SetError(2, 0, "")
EndIf
_DateTimeSplit($sDate, $asDatePart, $asTimePart)
Switch $sType
Case 0
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_SSHORTDATE)
If Not @error And Not($sTempString = '') Then
$sTempDate = $sTempString
Else
$sTempDate = "M/d/yyyy"
EndIf
If $asTimePart[0] > 1 Then
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_STIMEFORMAT)
If Not @error And Not($sTempString = '') Then
$sTempTime = $sTempString
Else
$sTempTime = "h:mm:ss tt"
EndIf
EndIf
Case 1
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_SLONGDATE)
If Not @error And Not($sTempString = '') Then
$sTempDate = $sTempString
Else
$sTempDate = "dddd, MMMM dd, yyyy"
EndIf
Case 2
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_SSHORTDATE)
If Not @error And Not($sTempString = '') Then
$sTempDate = $sTempString
Else
$sTempDate = "M/d/yyyy"
EndIf
Case 3
If $asTimePart[0] > 1 Then
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_STIMEFORMAT)
If Not @error And Not($sTempString = '') Then
$sTempTime = $sTempString
Else
$sTempTime = "h:mm:ss tt"
EndIf
EndIf
Case 4
If $asTimePart[0] > 1 Then
$sTempTime = "hh:mm"
EndIf
Case 5
If $asTimePart[0] > 1 Then
$sTempTime = "hh:mm:ss"
EndIf
EndSwitch
If $sTempDate <> "" Then
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_SDATE)
If Not @error And Not($sTempString = '') Then
$sTempDate = StringReplace($sTempDate, "/", $sTempString)
EndIf
Local $iWday = _DateToDayOfWeek($asDatePart[1], $asDatePart[2], $asDatePart[3])
$asDatePart[3] = StringRight("0" & $asDatePart[3], 2)
$asDatePart[2] = StringRight("0" & $asDatePart[2], 2)
$sTempDate = StringReplace($sTempDate, "d", "@")
$sTempDate = StringReplace($sTempDate, "m", "#")
$sTempDate = StringReplace($sTempDate, "y", "&")
$sTempDate = StringReplace($sTempDate, "@@@@", _DateDayOfWeek($iWday, 0))
$sTempDate = StringReplace($sTempDate, "@@@", _DateDayOfWeek($iWday, 1))
$sTempDate = StringReplace($sTempDate, "@@", $asDatePart[3])
$sTempDate = StringReplace($sTempDate, "@", StringReplace(StringLeft($asDatePart[3], 1), "0", "") & StringRight($asDatePart[3], 1))
$sTempDate = StringReplace($sTempDate, "####", _DateToMonth($asDatePart[2], 0))
$sTempDate = StringReplace($sTempDate, "###", _DateToMonth($asDatePart[2], 1))
$sTempDate = StringReplace($sTempDate, "##", $asDatePart[2])
$sTempDate = StringReplace($sTempDate, "#", StringReplace(StringLeft($asDatePart[2], 1), "0", "") & StringRight($asDatePart[2], 1))
$sTempDate = StringReplace($sTempDate, "&&&&", $asDatePart[1])
$sTempDate = StringReplace($sTempDate, "&&", StringRight($asDatePart[1], 2))
EndIf
If $sTempTime <> "" Then
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_S1159)
If Not @error And Not($sTempString = '') Then
$sAM = $sTempString
Else
$sAM = "AM"
EndIf
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_S2359)
If Not @error And Not($sTempString = '') Then
$sPM = $sTempString
Else
$sPM = "PM"
EndIf
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_STIME)
If Not @error And Not($sTempString = '') Then
$sTempTime = StringReplace($sTempTime, ":", $sTempString)
EndIf
If StringInStr($sTempTime, "tt") Then
If $asTimePart[1] < 12 Then
$sTempTime = StringReplace($sTempTime, "tt", $sAM)
If $asTimePart[1] = 0 Then $asTimePart[1] = 12
Else
$sTempTime = StringReplace($sTempTime, "tt", $sPM)
If $asTimePart[1] > 12 Then $asTimePart[1] = $asTimePart[1] - 12
EndIf
EndIf
$asTimePart[1] = StringRight("0" & $asTimePart[1], 2)
$asTimePart[2] = StringRight("0" & $asTimePart[2], 2)
$asTimePart[3] = StringRight("0" & $asTimePart[3], 2)
$sTempTime = StringReplace($sTempTime, "hh", StringFormat("%02d", $asTimePart[1]))
$sTempTime = StringReplace($sTempTime, "h", StringReplace(StringLeft($asTimePart[1], 1), "0", "") & StringRight($asTimePart[1], 1))
$sTempTime = StringReplace($sTempTime, "mm", StringFormat("%02d", $asTimePart[2]))
$sTempTime = StringReplace($sTempTime, "ss", StringFormat("%02d", $asTimePart[3]))
$sTempDate = StringStripWS($sTempDate & " " & $sTempTime, $STR_STRIPLEADING + $STR_STRIPTRAILING)
EndIf
Return $sTempDate
EndFunc
Func _DateTimeSplit($sDate, ByRef $aDatePart, ByRef $iTimePart)
Local $sDateTime = StringSplit($sDate, " T")
If $sDateTime[0] > 0 Then $aDatePart = StringSplit($sDateTime[1], "/-.")
If $sDateTime[0] > 1 Then
$iTimePart = StringSplit($sDateTime[2], ":")
If UBound($iTimePart) < 4 Then ReDim $iTimePart[4]
Else
Dim $iTimePart[4]
EndIf
If UBound($aDatePart) < 4 Then ReDim $aDatePart[4]
For $x = 1 To 3
If StringIsInt($aDatePart[$x]) Then
$aDatePart[$x] = Int($aDatePart[$x])
Else
$aDatePart[$x] = -1
EndIf
If StringIsInt($iTimePart[$x]) Then
$iTimePart[$x] = Int($iTimePart[$x])
Else
$iTimePart[$x] = 0
EndIf
Next
Return 1
EndFunc
Func _DateToDayOfWeek($iYear, $iMonth, $iDay)
If Not _DateIsValid($iYear & "/" & $iMonth & "/" & $iDay) Then
Return SetError(1, 0, "")
EndIf
Local $i_FactorA = Int((14 - $iMonth) / 12)
Local $i_FactorY = $iYear - $i_FactorA
Local $i_FactorM = $iMonth +(12 * $i_FactorA) - 2
Local $i_FactorD = Mod($iDay + $i_FactorY + Int($i_FactorY / 4) - Int($i_FactorY / 100) + Int($i_FactorY / 400) + Int((31 * $i_FactorM) / 12), 7)
Return $i_FactorD + 1
EndFunc
Func _DateToDayValue($iYear, $iMonth, $iDay)
If Not _DateIsValid(StringFormat("%04d/%02d/%02d", $iYear, $iMonth, $iDay)) Then
Return SetError(1, 0, "")
EndIf
If $iMonth < 3 Then
$iMonth = $iMonth + 12
$iYear = $iYear - 1
EndIf
Local $i_FactorA = Int($iYear / 100)
Local $i_FactorB = Int($i_FactorA / 4)
Local $i_FactorC = 2 - $i_FactorA + $i_FactorB
Local $i_FactorE = Int(1461 *($iYear + 4716) / 4)
Local $i_FactorF = Int(153 *($iMonth + 1) / 5)
Local $iJulianDate = $i_FactorC + $iDay + $i_FactorE + $i_FactorF - 1524.5
Return $iJulianDate
EndFunc
Func _DateToMonth($iMonNum, $iFormat = Default)
If $iFormat = Default Then $iFormat = 0
$iMonNum = Int($iMonNum)
If Not __DateIsMonth($iMonNum) Then Return SetError(1, 0, "")
Local $tSYSTEMTIME = DllStructCreate($tagSYSTEMTIME)
DllStructSetData($tSYSTEMTIME, "Year", @YEAR)
DllStructSetData($tSYSTEMTIME, "Month", $iMonNum)
DllStructSetData($tSYSTEMTIME, "Day", 1)
Return _WinAPI_GetDateFormat(BitAND($iFormat, $DMW_LOCALE_LONGNAME) ? $LOCALE_USER_DEFAULT : $LOCALE_INVARIANT, $tSYSTEMTIME, 0, BitAND($iFormat, $DMW_SHORTNAME) ? "MMM" : "MMMM")
EndFunc
Func _DayValueToDate($iJulianDate, ByRef $iYear, ByRef $iMonth, ByRef $iDay)
If $iJulianDate < 0 Or Not IsNumber($iJulianDate) Then
Return SetError(1, 0, 0)
EndIf
Local $i_FactorZ = Int($iJulianDate + 0.5)
Local $i_FactorW = Int(($i_FactorZ - 1867216.25) / 36524.25)
Local $i_FactorX = Int($i_FactorW / 4)
Local $i_FactorA = $i_FactorZ + 1 + $i_FactorW - $i_FactorX
Local $i_FactorB = $i_FactorA + 1524
Local $i_FactorC = Int(($i_FactorB - 122.1) / 365.25)
Local $i_FactorD = Int(365.25 * $i_FactorC)
Local $i_FactorE = Int(($i_FactorB - $i_FactorD) / 30.6001)
Local $i_FactorF = Int(30.6001 * $i_FactorE)
$iDay = $i_FactorB - $i_FactorD - $i_FactorF
If $i_FactorE - 1 < 13 Then
$iMonth = $i_FactorE - 1
Else
$iMonth = $i_FactorE - 13
EndIf
If $iMonth < 3 Then
$iYear = $i_FactorC - 4715
Else
$iYear = $i_FactorC - 4716
EndIf
$iYear = StringFormat("%04d", $iYear)
$iMonth = StringFormat("%02d", $iMonth)
$iDay = StringFormat("%02d", $iDay)
Return $iYear & "/" & $iMonth & "/" & $iDay
EndFunc
Func _Now()
Return _DateTimeFormat(@YEAR & "/" & @MON & "/" & @MDAY & " " & @HOUR & ":" & @MIN & ":" & @SEC, 0)
EndFunc
Func _NowCalc()
Return @YEAR & "/" & @MON & "/" & @MDAY & " " & @HOUR & ":" & @MIN & ":" & @SEC
EndFunc
Func _NowCalcDate()
Return @YEAR & "/" & @MON & "/" & @MDAY
EndFunc
Func _NowDate()
Return _DateTimeFormat(@YEAR & "/" & @MON & "/" & @MDAY, 0)
EndFunc
Func _NowTime($sType = 3)
If $sType < 3 Or $sType > 5 Then $sType = 3
Return _DateTimeFormat(@YEAR & "/" & @MON & "/" & @MDAY & " " & @HOUR & ":" & @MIN & ":" & @SEC, $sType)
EndFunc
Func _TicksToTime($iTicks, ByRef $iHours, ByRef $iMins, ByRef $iSecs)
If Number($iTicks) > 0 Then
$iTicks = Int($iTicks / 1000)
$iHours = Int($iTicks / 3600)
$iTicks = Mod($iTicks, 3600)
$iMins = Int($iTicks / 60)
$iSecs = Mod($iTicks, 60)
Return 1
ElseIf Number($iTicks) = 0 Then
$iHours = 0
$iTicks = 0
$iMins = 0
$iSecs = 0
Return 1
Else
Return SetError(1, 0, 0)
EndIf
EndFunc
Func _TimeToTicks($iHours = @HOUR, $iMins = @MIN, $iSecs = @SEC)
If StringIsInt($iHours) And StringIsInt($iMins) And StringIsInt($iSecs) Then
Local $iTicks = 1000 *((3600 * $iHours) +(60 * $iMins) + $iSecs)
Return $iTicks
Else
Return SetError(1, 0, 0)
EndIf
EndFunc
Func _DaysInMonth($iYear)
Local $aDays = [12, 31,(_DateIsLeapYear($iYear) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
Return $aDays
EndFunc
Func _Date_Time_EncodeFileTime($iMonth, $iDay, $iYear, $iHour = 0, $iMinute = 0, $iSecond = 0, $iMSeconds = 0)
Local $tSYSTEMTIME = _Date_Time_EncodeSystemTime($iMonth, $iDay, $iYear, $iHour, $iMinute, $iSecond, $iMSeconds)
Return _Date_Time_SystemTimeToFileTime($tSYSTEMTIME)
EndFunc
Func _Date_Time_EncodeSystemTime($iMonth, $iDay, $iYear, $iHour = 0, $iMinute = 0, $iSecond = 0, $iMSeconds = 0)
Local $tSYSTEMTIME = DllStructCreate($tagSYSTEMTIME)
DllStructSetData($tSYSTEMTIME, "Month", $iMonth)
DllStructSetData($tSYSTEMTIME, "Day", $iDay)
DllStructSetData($tSYSTEMTIME, "Year", $iYear)
DllStructSetData($tSYSTEMTIME, "Hour", $iHour)
DllStructSetData($tSYSTEMTIME, "Minute", $iMinute)
DllStructSetData($tSYSTEMTIME, "Second", $iSecond)
DllStructSetData($tSYSTEMTIME, "MSeconds", $iMSeconds)
Return $tSYSTEMTIME
EndFunc
Func _Date_Time_GetLocalTime()
Local $tSystTime = DllStructCreate($tagSYSTEMTIME)
DllCall("kernel32.dll", "none", "GetLocalTime", "struct*", $tSystTime)
If @error Then Return SetError(@error, @extended, 0)
Return $tSystTime
EndFunc
Func _Date_Time_LocalFileTimeToFileTime($tLocalTime)
Local $tFileTime = DllStructCreate($tagFILETIME)
Local $aResult = DllCall("kernel32.dll", "bool", "LocalFileTimeToFileTime", "struct*", $tLocalTime, "struct*", $tFileTime)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tFileTime)
EndFunc
Func _Date_Time_SystemTimeToArray(ByRef $tSYSTEMTIME)
Local $aInfo[8]
$aInfo[0] = DllStructGetData($tSYSTEMTIME, "Month")
$aInfo[1] = DllStructGetData($tSYSTEMTIME, "Day")
$aInfo[2] = DllStructGetData($tSYSTEMTIME, "Year")
$aInfo[3] = DllStructGetData($tSYSTEMTIME, "Hour")
$aInfo[4] = DllStructGetData($tSYSTEMTIME, "Minute")
$aInfo[5] = DllStructGetData($tSYSTEMTIME, "Second")
$aInfo[6] = DllStructGetData($tSYSTEMTIME, "MSeconds")
$aInfo[7] = DllStructGetData($tSYSTEMTIME, "DOW")
Return $aInfo
EndFunc
Func _Date_Time_SystemTimeToDateTimeStr(ByRef $tSYSTEMTIME, $iFmt = 0)
Local $aInfo = _Date_Time_SystemTimeToArray($tSYSTEMTIME)
If @error Then Return SetError(@error, @extended, "")
If $iFmt Then
Return StringFormat("%04d/%02d/%02d %02d:%02d:%02d", $aInfo[2], $aInfo[0], $aInfo[1], $aInfo[3], $aInfo[4], $aInfo[5])
Else
Return StringFormat("%02d/%02d/%04d %02d:%02d:%02d", $aInfo[0], $aInfo[1], $aInfo[2], $aInfo[3], $aInfo[4], $aInfo[5])
EndIf
EndFunc
Func _Date_Time_SystemTimeToFileTime($tSYSTEMTIME)
Local $tFileTime = DllStructCreate($tagFILETIME)
Local $aResult = DllCall("kernel32.dll", "bool", "SystemTimeToFileTime", "struct*", $tSYSTEMTIME, "struct*", $tFileTime)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tFileTime)
EndFunc
Func _Date_Time_TzSpecificLocalTimeToSystemTime($tLocalTime, $tTimeZone = 0)
Local $tUTC = DllStructCreate($tagSYSTEMTIME)
Local $aResult = DllCall("kernel32.dll", "bool", "TzSpecificLocalTimeToSystemTime", "struct*", $tTimeZone, "struct*", $tLocalTime, "struct*", $tUTC)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tUTC)
EndFunc
Global Const $FW_MEDIUM = 500
Global Const $FW_BOLD = 700
Global Const $CLEARTYPE_QUALITY = 5
Func _Singleton($sOccurrenceName, $iFlag = 0)
Local Const $ERROR_ALREADY_EXISTS = 183
Local Const $SECURITY_DESCRIPTOR_REVISION = 1
Local $tSecurityAttributes = 0
If BitAND($iFlag, 2) Then
Local $tSecurityDescriptor = DllStructCreate("byte;byte;word;ptr[4]")
Local $aRet = DllCall("advapi32.dll", "bool", "InitializeSecurityDescriptor", "struct*", $tSecurityDescriptor, "dword", $SECURITY_DESCRIPTOR_REVISION)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then
$aRet = DllCall("advapi32.dll", "bool", "SetSecurityDescriptorDacl", "struct*", $tSecurityDescriptor, "bool", 1, "ptr", 0, "bool", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then
$tSecurityAttributes = DllStructCreate($tagSECURITY_ATTRIBUTES)
DllStructSetData($tSecurityAttributes, 1, DllStructGetSize($tSecurityAttributes))
DllStructSetData($tSecurityAttributes, 2, DllStructGetPtr($tSecurityDescriptor))
DllStructSetData($tSecurityAttributes, 3, 0)
EndIf
EndIf
EndIf
Local $aHandle = DllCall("kernel32.dll", "handle", "CreateMutexW", "struct*", $tSecurityAttributes, "bool", 1, "wstr", $sOccurrenceName)
If @error Then Return SetError(@error, @extended, 0)
Local $aLastError = DllCall("kernel32.dll", "dword", "GetLastError")
If @error Then Return SetError(@error, @extended, 0)
If $aLastError[0] = $ERROR_ALREADY_EXISTS Then
If BitAND($iFlag, 1) Then
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $aHandle[0])
If @error Then Return SetError(@error, @extended, 0)
Return SetError($aLastError[0], $aLastError[0], 0)
Else
Exit -1
EndIf
EndIf
Return $aHandle[0]
EndFunc
Func _IsPressed($sHexKey, $vDLL = 'user32.dll')
Local $a_R = DllCall($vDLL, "short", "GetAsyncKeyState", "int", '0x' & $sHexKey)
If @error Then Return SetError(@error, @extended, False)
Return BitAND($a_R[0], 0x8000) <> 0
EndFunc
Func _VersionCompare($sVersion1, $sVersion2)
If $sVersion1 = $sVersion2 Then Return 0
Local $sSubVersion1 = "", $sSubVersion2 = ""
If StringIsAlpha(StringRight($sVersion1, 1)) Then
$sSubVersion1 = StringRight($sVersion1, 1)
$sVersion1 = StringTrimRight($sVersion1, 1)
EndIf
If StringIsAlpha(StringRight($sVersion2, 1)) Then
$sSubVersion2 = StringRight($sVersion2, 1)
$sVersion2 = StringTrimRight($sVersion2, 1)
EndIf
Local $aVersion1 = StringSplit($sVersion1, ".,"), $aVersion2 = StringSplit($sVersion2, ".,")
Local $iPartDifference =($aVersion1[0] - $aVersion2[0])
If $iPartDifference < 0 Then
ReDim $aVersion1[UBound($aVersion2)]
$aVersion1[0] = UBound($aVersion1) - 1
For $i =(UBound($aVersion1) - Abs($iPartDifference)) To $aVersion1[0]
$aVersion1[$i] = "0"
Next
ElseIf $iPartDifference > 0 Then
ReDim $aVersion2[UBound($aVersion1)]
$aVersion2[0] = UBound($aVersion2) - 1
For $i =(UBound($aVersion2) - Abs($iPartDifference)) To $aVersion2[0]
$aVersion2[$i] = "0"
Next
EndIf
For $i = 1 To $aVersion1[0]
If StringIsDigit($aVersion1[$i]) And StringIsDigit($aVersion2[$i]) Then
If Number($aVersion1[$i]) > Number($aVersion2[$i]) Then
Return SetExtended(2, 1)
ElseIf Number($aVersion1[$i]) < Number($aVersion2[$i]) Then
Return SetExtended(2, -1)
ElseIf $i = $aVersion1[0] Then
If $sSubVersion1 > $sSubVersion2 Then
Return SetExtended(3, 1)
ElseIf $sSubVersion1 < $sSubVersion2 Then
Return SetExtended(3, -1)
EndIf
EndIf
Else
If $aVersion1[$i] > $aVersion2[$i] Then
Return SetExtended(1, 1)
ElseIf $aVersion1[$i] < $aVersion2[$i] Then
Return SetExtended(1, -1)
EndIf
EndIf
Next
Return SetExtended(Abs($iPartDifference), 0)
EndFunc
Func _FileCreate($sFilePath)
Local $hFileOpen = FileOpen($sFilePath, BitOR($FO_OVERWRITE, $FO_CREATEPATH))
If $hFileOpen = -1 Then Return SetError(1, 0, 0)
Local $iFileWrite = FileWrite($hFileOpen, "")
FileClose($hFileOpen)
If Not $iFileWrite Then Return SetError(2, 0, 0)
Return 1
EndFunc
Func _FileListToArray($sFilePath, $sFilter = "*", $iFlag = $FLTA_FILESFOLDERS, $bReturnPath = False)
Local $sDelimiter = "|", $sFileList = "", $sFileName = "", $sFullPath = ""
$sFilePath = StringRegExpReplace($sFilePath, "[\\/]+$", "") & "\"
If $iFlag = Default Then $iFlag = $FLTA_FILESFOLDERS
If $bReturnPath Then $sFullPath = $sFilePath
If $sFilter = Default Then $sFilter = "*"
If Not FileExists($sFilePath) Then Return SetError(1, 0, 0)
If StringRegExp($sFilter, "[\\/:><\|]|(?s)^\s*$") Then Return SetError(2, 0, 0)
If Not($iFlag = 0 Or $iFlag = 1 Or $iFlag = 2) Then Return SetError(3, 0, 0)
Local $hSearch = FileFindFirstFile($sFilePath & $sFilter)
If @error Then Return SetError(4, 0, 0)
While 1
$sFileName = FileFindNextFile($hSearch)
If @error Then ExitLoop
If($iFlag + @extended = 2) Then ContinueLoop
$sFileList &= $sDelimiter & $sFullPath & $sFileName
WEnd
FileClose($hSearch)
If $sFileList = "" Then Return SetError(4, 0, 0)
Return StringSplit(StringTrimLeft($sFileList, 1), $sDelimiter)
EndFunc
Func _FileListToArrayRec($sFilePath, $sMask = "*", $iReturn = $FLTAR_FILESFOLDERS, $iRecur = $FLTAR_NORECUR, $iSort = $FLTAR_NOSORT, $iReturnPath = $FLTAR_RELPATH)
If Not FileExists($sFilePath) Then Return SetError(1, 1, "")
If $sMask = Default Then $sMask = "*"
If $iReturn = Default Then $iReturn = $FLTAR_FILESFOLDERS
If $iRecur = Default Then $iRecur = $FLTAR_NORECUR
If $iSort = Default Then $iSort = $FLTAR_NOSORT
If $iReturnPath = Default Then $iReturnPath = $FLTAR_RELPATH
If $iRecur > 1 Or Not IsInt($iRecur) Then Return SetError(1, 6, "")
Local $bLongPath = False
If StringLeft($sFilePath, 4) == "\\?\" Then
$bLongPath = True
EndIf
Local $sFolderSlash = ""
If StringRight($sFilePath, 1) = "\" Then
$sFolderSlash = "\"
Else
$sFilePath = $sFilePath & "\"
EndIf
Local $asFolderSearchList[100] = [1]
$asFolderSearchList[1] = $sFilePath
Local $iHide_HS = 0, $sHide_HS = ""
If BitAND($iReturn, 4) Then
$iHide_HS += 2
$sHide_HS &= "H"
$iReturn -= 4
EndIf
If BitAND($iReturn, 8) Then
$iHide_HS += 4
$sHide_HS &= "S"
$iReturn -= 8
EndIf
Local $iHide_Link = 0
If BitAND($iReturn, 16) Then
$iHide_Link = 0x400
$iReturn -= 16
EndIf
Local $iMaxLevel = 0
If $iRecur < 0 Then
StringReplace($sFilePath, "\", "", 0, $STR_NOCASESENSEBASIC)
$iMaxLevel = @extended - $iRecur
EndIf
Local $sExclude_List = "", $sExclude_List_Folder = "", $sInclude_List = "*"
Local $aMaskSplit = StringSplit($sMask, "|")
Switch $aMaskSplit[0]
Case 3
$sExclude_List_Folder = $aMaskSplit[3]
ContinueCase
Case 2
$sExclude_List = $aMaskSplit[2]
ContinueCase
Case 1
$sInclude_List = $aMaskSplit[1]
EndSwitch
Local $sInclude_File_Mask = ".+"
If $sInclude_List <> "*" Then
If Not __FLTAR_ListToMask($sInclude_File_Mask, $sInclude_List) Then Return SetError(1, 2, "")
EndIf
Local $sInclude_Folder_Mask = ".+"
Switch $iReturn
Case 0
Switch $iRecur
Case 0
$sInclude_Folder_Mask = $sInclude_File_Mask
EndSwitch
Case 2
$sInclude_Folder_Mask = $sInclude_File_Mask
EndSwitch
Local $sExclude_File_Mask = ":"
If $sExclude_List <> "" Then
If Not __FLTAR_ListToMask($sExclude_File_Mask, $sExclude_List) Then Return SetError(1, 3, "")
EndIf
Local $sExclude_Folder_Mask = ":"
If $iRecur Then
If $sExclude_List_Folder Then
If Not __FLTAR_ListToMask($sExclude_Folder_Mask, $sExclude_List_Folder) Then Return SetError(1, 4, "")
EndIf
If $iReturn = 2 Then
$sExclude_Folder_Mask = $sExclude_File_Mask
EndIf
Else
$sExclude_Folder_Mask = $sExclude_File_Mask
EndIf
If Not($iReturn = 0 Or $iReturn = 1 Or $iReturn = 2) Then Return SetError(1, 5, "")
If Not($iSort = 0 Or $iSort = 1 Or $iSort = 2) Then Return SetError(1, 7, "")
If Not($iReturnPath = 0 Or $iReturnPath = 1 Or $iReturnPath = 2) Then Return SetError(1, 8, "")
If $iHide_Link Then
Local $tFile_Data = DllStructCreate("struct;align 4;dword FileAttributes;uint64 CreationTime;uint64 LastAccessTime;uint64 LastWriteTime;" & "dword FileSizeHigh;dword FileSizeLow;dword Reserved0;dword Reserved1;wchar FileName[260];wchar AlternateFileName[14];endstruct")
Local $hDLL = DllOpen('kernel32.dll'), $aDLL_Ret
EndIf
Local $asReturnList[100] = [0]
Local $asFileMatchList = $asReturnList, $asRootFileMatchList = $asReturnList, $asFolderMatchList = $asReturnList
Local $bFolder = False, $hSearch = 0, $sCurrentPath = "", $sName = "", $sRetPath = ""
Local $iAttribs = 0, $sAttribs = ''
Local $asFolderFileSectionList[100][2] = [[0, 0]]
While $asFolderSearchList[0] > 0
$sCurrentPath = $asFolderSearchList[$asFolderSearchList[0]]
$asFolderSearchList[0] -= 1
Switch $iReturnPath
Case 1
$sRetPath = StringReplace($sCurrentPath, $sFilePath, "")
Case 2
If $bLongPath Then
$sRetPath = StringTrimLeft($sCurrentPath, 4)
Else
$sRetPath = $sCurrentPath
EndIf
EndSwitch
If $iHide_Link Then
$aDLL_Ret = DllCall($hDLL, 'handle', 'FindFirstFileW', 'wstr', $sCurrentPath & "*", 'struct*', $tFile_Data)
If @error Or Not $aDLL_Ret[0] Then
ContinueLoop
EndIf
$hSearch = $aDLL_Ret[0]
Else
$hSearch = FileFindFirstFile($sCurrentPath & "*")
If $hSearch = -1 Then
ContinueLoop
EndIf
EndIf
If $iReturn = 0 And $iSort And $iReturnPath Then
__FLTAR_AddToList($asFolderFileSectionList, $sRetPath, $asFileMatchList[0] + 1)
EndIf
$sAttribs = ''
While 1
If $iHide_Link Then
$aDLL_Ret = DllCall($hDLL, 'int', 'FindNextFileW', 'handle', $hSearch, 'struct*', $tFile_Data)
If @error Or Not $aDLL_Ret[0] Then
ExitLoop
EndIf
$sName = DllStructGetData($tFile_Data, "FileName")
If $sName = ".." Then
ContinueLoop
EndIf
$iAttribs = DllStructGetData($tFile_Data, "FileAttributes")
If $iHide_HS And BitAND($iAttribs, $iHide_HS) Then
ContinueLoop
EndIf
If BitAND($iAttribs, $iHide_Link) Then
ContinueLoop
EndIf
$bFolder = False
If BitAND($iAttribs, 16) Then
$bFolder = True
EndIf
Else
$bFolder = False
$sName = FileFindNextFile($hSearch, 1)
If @error Then
ExitLoop
EndIf
$sAttribs = @extended
If StringInStr($sAttribs, "D") Then
$bFolder = True
EndIf
If StringRegExp($sAttribs, "[" & $sHide_HS & "]") Then
ContinueLoop
EndIf
EndIf
If $bFolder Then
Select
Case $iRecur < 0
StringReplace($sCurrentPath, "\", "", 0, $STR_NOCASESENSEBASIC)
If @extended < $iMaxLevel Then
ContinueCase
EndIf
Case $iRecur = 1
If Not StringRegExp($sName, $sExclude_Folder_Mask) Then
__FLTAR_AddToList($asFolderSearchList, $sCurrentPath & $sName & "\")
EndIf
EndSelect
EndIf
If $iSort Then
If $bFolder Then
If StringRegExp($sName, $sInclude_Folder_Mask) And Not StringRegExp($sName, $sExclude_Folder_Mask) Then
__FLTAR_AddToList($asFolderMatchList, $sRetPath & $sName & $sFolderSlash)
EndIf
Else
If StringRegExp($sName, $sInclude_File_Mask) And Not StringRegExp($sName, $sExclude_File_Mask) Then
If $sCurrentPath = $sFilePath Then
__FLTAR_AddToList($asRootFileMatchList, $sRetPath & $sName)
Else
__FLTAR_AddToList($asFileMatchList, $sRetPath & $sName)
EndIf
EndIf
EndIf
Else
If $bFolder Then
If $iReturn <> 1 And StringRegExp($sName, $sInclude_Folder_Mask) And Not StringRegExp($sName, $sExclude_Folder_Mask) Then
__FLTAR_AddToList($asReturnList, $sRetPath & $sName & $sFolderSlash)
EndIf
Else
If $iReturn <> 2 And StringRegExp($sName, $sInclude_File_Mask) And Not StringRegExp($sName, $sExclude_File_Mask) Then
__FLTAR_AddToList($asReturnList, $sRetPath & $sName)
EndIf
EndIf
EndIf
WEnd
If $iHide_Link Then
DllCall($hDLL, 'int', 'FindClose', 'ptr', $hSearch)
Else
FileClose($hSearch)
EndIf
WEnd
If $iHide_Link Then
DllClose($hDLL)
EndIf
If $iSort Then
Switch $iReturn
Case 2
If $asFolderMatchList[0] = 0 Then Return SetError(1, 9, "")
ReDim $asFolderMatchList[$asFolderMatchList[0] + 1]
$asReturnList = $asFolderMatchList
__ArrayDualPivotSort($asReturnList, 1, $asReturnList[0])
Case 1
If $asRootFileMatchList[0] = 0 And $asFileMatchList[0] = 0 Then Return SetError(1, 9, "")
If $iReturnPath = 0 Then
__FLTAR_AddFileLists($asReturnList, $asRootFileMatchList, $asFileMatchList)
__ArrayDualPivotSort($asReturnList, 1, $asReturnList[0])
Else
__FLTAR_AddFileLists($asReturnList, $asRootFileMatchList, $asFileMatchList, 1)
EndIf
Case 0
If $asRootFileMatchList[0] = 0 And $asFolderMatchList[0] = 0 Then Return SetError(1, 9, "")
If $iReturnPath = 0 Then
__FLTAR_AddFileLists($asReturnList, $asRootFileMatchList, $asFileMatchList)
$asReturnList[0] += $asFolderMatchList[0]
ReDim $asFolderMatchList[$asFolderMatchList[0] + 1]
_ArrayConcatenate($asReturnList, $asFolderMatchList, 1)
__ArrayDualPivotSort($asReturnList, 1, $asReturnList[0])
Else
Local $asReturnList[$asFileMatchList[0] + $asRootFileMatchList[0] + $asFolderMatchList[0] + 1]
$asReturnList[0] = $asFileMatchList[0] + $asRootFileMatchList[0] + $asFolderMatchList[0]
__ArrayDualPivotSort($asRootFileMatchList, 1, $asRootFileMatchList[0])
For $i = 1 To $asRootFileMatchList[0]
$asReturnList[$i] = $asRootFileMatchList[$i]
Next
Local $iNextInsertionIndex = $asRootFileMatchList[0] + 1
__ArrayDualPivotSort($asFolderMatchList, 1, $asFolderMatchList[0])
Local $sFolderToFind = ""
For $i = 1 To $asFolderMatchList[0]
$asReturnList[$iNextInsertionIndex] = $asFolderMatchList[$i]
$iNextInsertionIndex += 1
If $sFolderSlash Then
$sFolderToFind = $asFolderMatchList[$i]
Else
$sFolderToFind = $asFolderMatchList[$i] & "\"
EndIf
Local $iFileSectionEndIndex = 0, $iFileSectionStartIndex = 0
For $j = 1 To $asFolderFileSectionList[0][0]
If $sFolderToFind = $asFolderFileSectionList[$j][0] Then
$iFileSectionStartIndex = $asFolderFileSectionList[$j][1]
If $j = $asFolderFileSectionList[0][0] Then
$iFileSectionEndIndex = $asFileMatchList[0]
Else
$iFileSectionEndIndex = $asFolderFileSectionList[$j + 1][1] - 1
EndIf
If $iSort = 1 Then
__ArrayDualPivotSort($asFileMatchList, $iFileSectionStartIndex, $iFileSectionEndIndex)
EndIf
For $k = $iFileSectionStartIndex To $iFileSectionEndIndex
$asReturnList[$iNextInsertionIndex] = $asFileMatchList[$k]
$iNextInsertionIndex += 1
Next
ExitLoop
EndIf
Next
Next
EndIf
EndSwitch
Else
If $asReturnList[0] = 0 Then Return SetError(1, 9, "")
ReDim $asReturnList[$asReturnList[0] + 1]
EndIf
Return $asReturnList
EndFunc
Func __FLTAR_AddFileLists(ByRef $asTarget, $asSource_1, $asSource_2, $iSort = 0)
ReDim $asSource_1[$asSource_1[0] + 1]
If $iSort = 1 Then __ArrayDualPivotSort($asSource_1, 1, $asSource_1[0])
$asTarget = $asSource_1
$asTarget[0] += $asSource_2[0]
ReDim $asSource_2[$asSource_2[0] + 1]
If $iSort = 1 Then __ArrayDualPivotSort($asSource_2, 1, $asSource_2[0])
_ArrayConcatenate($asTarget, $asSource_2, 1)
EndFunc
Func __FLTAR_AddToList(ByRef $aList, $vValue_0, $vValue_1 = -1)
If $vValue_1 = -1 Then
$aList[0] += 1
If UBound($aList) <= $aList[0] Then ReDim $aList[UBound($aList) * 2]
$aList[$aList[0]] = $vValue_0
Else
$aList[0][0] += 1
If UBound($aList) <= $aList[0][0] Then ReDim $aList[UBound($aList) * 2][2]
$aList[$aList[0][0]][0] = $vValue_0
$aList[$aList[0][0]][1] = $vValue_1
EndIf
EndFunc
Func __FLTAR_ListToMask(ByRef $sMask, $sList)
If StringRegExp($sList, "\\|/|:|\<|\>|\|") Then Return 0
$sList = StringReplace(StringStripWS(StringRegExpReplace($sList, "\s*;\s*", ";"), $STR_STRIPLEADING + $STR_STRIPTRAILING), ";", "|")
$sList = StringReplace(StringReplace(StringRegExpReplace($sList, "[][$^.{}()+\-]", "\\$0"), "?", "."), "*", ".*?")
$sMask = "(?i)^(" & $sList & ")\z"
Return 1
EndFunc
Func _FileWriteLog($sLogPath, $sLogMsg, $iFlag = -1)
Local $iOpenMode = $FO_APPEND
Local $sDateNow = @YEAR & "-" & @MON & "-" & @MDAY
Local $sTimeNow = @HOUR & ":" & @MIN & ":" & @SEC
Local $sMsg = $sDateNow & " " & $sTimeNow & " : " & $sLogMsg
If $iFlag = Default Then $iFlag = -1
If $iFlag <> -1 Then
$iOpenMode = $FO_OVERWRITE
$sMsg &= @CRLF & FileRead($sLogPath)
EndIf
Local $hFileOpen = $sLogPath
If IsString($sLogPath) Then
$hFileOpen = FileOpen($sLogPath, $iOpenMode)
EndIf
If $hFileOpen = -1 Then Return SetError(1, 0, 0)
Local $iReturn = FileWriteLine($hFileOpen, $sMsg)
If IsString($sLogPath) Then $iReturn = FileClose($hFileOpen)
If $iReturn <= 0 Then Return SetError(2, $iReturn, 0)
Return $iReturn
EndFunc
Global Const $TRAY_CHECKED = 1
Global Const $TRAY_UNCHECKED = 4
Global Const $TIP_ICONASTERISK = 1
Global Const $TIP_ICONEXCLAMATION = 2
Global Const $TIP_NOSOUND = 16
Global Const $MF_BYPOSITION = 0x00000400
Global Const $MIIM_DATAMASK = 0x0000003F
Global Const $SC_MINIMIZE = 0xF020
Global Const $SC_MAXIMIZE = 0xF030
Global Const $SC_CLOSE = 0xF060
Global Const $SC_RESTORE = 0xF120
Func _GUICtrlMenu_DrawMenuBar($hWnd)
Local $aResult = DllCall("user32.dll", "bool", "DrawMenuBar", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _GUICtrlMenu_FindParent($hMenu)
Local $hList = _WinAPI_EnumWindowsTop()
For $iI = 1 To $hList[0][0]
If _GUICtrlMenu_GetMenu($hList[$iI][0]) = $hMenu Then Return $hList[$iI][0]
Next
EndFunc
Func _GUICtrlMenu_GetItemCount($hMenu)
Local $aResult = DllCall("user32.dll", "int", "GetMenuItemCount", "handle", $hMenu)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _GUICtrlMenu_GetItemID($hMenu, $iItem, $bByPos = True)
Local $tInfo = _GUICtrlMenu_GetItemInfo($hMenu, $iItem, $bByPos)
Return DllStructGetData($tInfo, "ID")
EndFunc
Func _GUICtrlMenu_GetItemInfo($hMenu, $iItem, $bByPos = True)
Local $tInfo = DllStructCreate($tagMENUITEMINFO)
DllStructSetData($tInfo, "Size", DllStructGetSize($tInfo))
DllStructSetData($tInfo, "Mask", $MIIM_DATAMASK)
Local $aResult = DllCall("user32.dll", "bool", "GetMenuItemInfo", "handle", $hMenu, "uint", $iItem, "bool", $bByPos, "struct*", $tInfo)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tInfo)
EndFunc
Func _GUICtrlMenu_GetMenu($hWnd)
Local $aResult = DllCall("user32.dll", "handle", "GetMenu", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _GUICtrlMenu_GetSystemMenu($hWnd, $bRevert = False)
Local $aResult = DllCall("user32.dll", "hwnd", "GetSystemMenu", "hwnd", $hWnd, "int", $bRevert)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _GUICtrlMenu_RemoveMenu($hMenu, $iItem, $bByPos = True)
Local $iByPos = 0
If $bByPos Then $iByPos = $MF_BYPOSITION
Local $aResult = DllCall("user32.dll", "bool", "RemoveMenu", "handle", $hMenu, "uint", $iItem, "uint", $iByPos)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] = 0 Then Return SetError(10, 0, False)
_GUICtrlMenu_DrawMenuBar(_GUICtrlMenu_FindParent($hMenu))
Return True
EndFunc
Func _ClipBoard_RegisterFormat($sFormat)
Local $aResult = DllCall("user32.dll", "uint", "RegisterClipboardFormatW", "wstr", $sFormat)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Global Const $__RICHEDITCONSTANT_WM_USER = 0x400
Global Const $EM_GETTEXTEX = $__RICHEDITCONSTANT_WM_USER + 94
Global Const $EM_GETTEXTLENGTHEX = $__RICHEDITCONSTANT_WM_USER + 95
Global Const $EM_HIDESELECTION = $__RICHEDITCONSTANT_WM_USER + 63
Global Const $EM_SETCHARFORMAT = $__RICHEDITCONSTANT_WM_USER + 68
Global Const $EM_SETTEXTEX = $__RICHEDITCONSTANT_WM_USER + 97
Global Const $ST_DEFAULT = 0
Global Const $ST_SELECTION = 2
Global Const $GT_USECRLF = 1
Global Const $GTL_CLOSE = 4
Global Const $GTL_DEFAULT = 0
Global Const $GTL_NUMBYTES = 16
Global Const $GTL_PRECISE = 2
Global Const $GTL_USECRLF = 1
Global Const $CP_ACP = 0
Global Const $CP_UNICODE = 1200
Global Const $CFE_SUBSCRIPT = 0x00010000
Global Const $CFE_SUPERSCRIPT = 0x00020000
Global Const $CFM_CHARSET = 0x8000000
Global Const $CFM_COLOR = 0x40000000
Global Const $CFM_FACE = 0x20000000
Global Const $CFM_LCID = 0x2000000
Global Const $CFM_SIZE = 0x80000000
Global Const $CFE_AUTOCOLOR = $CFM_COLOR
Global Const $SCF_SELECTION = 0x1
Global Const $LF_FACESIZE = 32
Global $__g_sRTFClassName, $__g_sRTFVersion, $__g_iRTFTwipsPeSpaceUnit = 1440
Global $__g_sGRE_CF_RTF, $__g_sGRE_CF_RETEXTOBJ
Global $__g_pGRC_StreamFromFileCallback = DllCallbackRegister("__GCR_StreamFromFileCallback", "dword", "long_ptr;ptr;long;ptr")
Global $__g_pGRC_StreamFromVarCallback = DllCallbackRegister("__GCR_StreamFromVarCallback", "dword", "long_ptr;ptr;long;ptr")
Global $__g_pGRC_StreamToFileCallback = DllCallbackRegister("__GCR_StreamToFileCallback", "dword", "long_ptr;ptr;long;ptr")
Global $__g_pGRC_StreamToVarCallback = DllCallbackRegister("__GCR_StreamToVarCallback", "dword", "long_ptr;ptr;long;ptr")
Global $__g_pGRC_sStreamVar
Global $__g_hRELastWnd
Global $__g_tObj_RichComObject = DllStructCreate("ptr pIntf; dword  Refcount")
Global $__g_tCall_RichCom, $__g_pObj_RichCom
Global $__g_hLib_RichCom_OLE32 = DllOpen("OLE32.DLL")
Global $__g_pRichCom_Object_QueryInterface = DllCallbackRegister("__RichCom_Object_QueryInterface", "long", "ptr;dword;dword")
Global $__g_pRichCom_Object_AddRef = DllCallbackRegister("__RichCom_Object_AddRef", "long", "ptr")
Global $__g_pRichCom_Object_Release = DllCallbackRegister("__RichCom_Object_Release", "long", "ptr")
Global $__g_pRichCom_Object_GetNewStorage = DllCallbackRegister("__RichCom_Object_GetNewStorage", "long", "ptr;ptr")
Global $__g_pRichCom_Object_GetInPlaceContext = DllCallbackRegister("__RichCom_Object_GetInPlaceContext", "long", "ptr;dword;dword;dword")
Global $__g_pRichCom_Object_ShowContainerUI = DllCallbackRegister("__RichCom_Object_ShowContainerUI", "long", "ptr;long")
Global $__g_pRichCom_Object_QueryInsertObject = DllCallbackRegister("__RichCom_Object_QueryInsertObject", "long", "ptr;dword;ptr;long")
Global $__g_pRichCom_Object_DeleteObject = DllCallbackRegister("__RichCom_Object_DeleteObject", "long", "ptr;ptr")
Global $__g_pRichCom_Object_QueryAcceptData = DllCallbackRegister("__RichCom_Object_QueryAcceptData", "long", "ptr;ptr;dword;dword;dword;ptr")
Global $__g_pRichCom_Object_ContextSensitiveHelp = DllCallbackRegister("__RichCom_Object_ContextSensitiveHelp", "long", "ptr;long")
Global $__g_pRichCom_Object_GetClipboardData = DllCallbackRegister("__RichCom_Object_GetClipboardData", "long", "ptr;ptr;dword;ptr")
Global $__g_pRichCom_Object_GetDragDropEffect = DllCallbackRegister("__RichCom_Object_GetDragDropEffect", "long", "ptr;dword;dword;dword")
Global $__g_pRichCom_Object_GetContextMenu = DllCallbackRegister("__RichCom_Object_GetContextMenu", "long", "ptr;short;ptr;ptr;ptr")
Global Const $__RICHEDITCONSTANT_WM_SETFONT = 0x0030
Global Const $_GCR_S_OK = 0
Global Const $_GCR_E_NOTIMPL = 0x80004001
Global Const $tagCHARFORMAT = "struct;uint cbSize;dword dwMask;dword dwEffects;long yHeight;long yOffset;INT crCharColor;" & "byte bCharSet;byte bPitchAndFamily;wchar szFaceName[32];endstruct"
Global Const $tagCHARFORMAT2 = $tagCHARFORMAT & ";word wWeight;short sSpacing;INT crBackColor;dword lcid;dword dwReserved;" & "short sStyle;word wKerning;byte bUnderlineType;byte bAnimation;byte bRevAuthor;byte bReserved1"
Global Const $tagGETTEXTEX = "align 4;dword cb;dword flags;uint codepage;ptr lpDefaultChar;ptr lpbUsedDefChar"
Global Const $tagGETTEXTLENGTHEX = "dword flags;uint codepage"
Global Const $tagSETTEXTEX = "dword flags;uint codepage"
Func _GUICtrlRichEdit_AppendText($hWnd, $sText)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $iLength = _GUICtrlRichEdit_GetTextLength($hWnd)
_GUICtrlRichEdit_SetSel($hWnd, $iLength, $iLength)
Local $tSetText = DllStructCreate($tagSETTEXTEX)
DllStructSetData($tSetText, 1, $ST_SELECTION)
Local $iRet
If StringLeft($sText, 5) <> "{\rtf" And StringLeft($sText, 5) <> "{urtf" Then
DllStructSetData($tSetText, 2, $CP_UNICODE)
$iRet = _SendMessage($hWnd, $EM_SETTEXTEX, $tSetText, $sText, 0, "struct*", "wstr")
Else
DllStructSetData($tSetText, 2, $CP_ACP)
$iRet = _SendMessage($hWnd, $EM_SETTEXTEX, $tSetText, $sText, 0, "struct*", "STR")
EndIf
If Not $iRet Then Return SetError(700, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_Create($hWnd, $sText, $iLeft, $iTop, $iWidth = 150, $iHeight = 150, $iStyle = -1, $iExStyle = -1)
If Not IsHWnd($hWnd) Then Return SetError(1, 0, 0)
If Not IsString($sText) Then Return SetError(2, 0, 0)
If Not __GCR_IsNumeric($iWidth, ">0,-1") Then Return SetError(105, 0, 0)
If Not __GCR_IsNumeric($iHeight, ">0,-1") Then Return SetError(106, 0, 0)
If Not __GCR_IsNumeric($iStyle, ">=0,-1") Then Return SetError(107, 0, 0)
If Not __GCR_IsNumeric($iExStyle, ">=0,-1") Then Return SetError(108, 0, 0)
If $iWidth = -1 Then $iWidth = 150
If $iHeight = -1 Then $iHeight = 150
If $iStyle = -1 Then $iStyle = BitOR($ES_WANTRETURN, $ES_MULTILINE)
If BitAND($iStyle, $ES_MULTILINE) <> 0 Then $iStyle = BitOR($iStyle, $ES_WANTRETURN)
If $iExStyle = -1 Then $iExStyle = 0x200
$iStyle = BitOR($iStyle, $__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE)
If BitAND($iStyle, $ES_READONLY) = 0 Then $iStyle = BitOR($iStyle, $__UDFGUICONSTANT_WS_TABSTOP)
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
__GCR_Init()
Local $hRichEdit = _WinAPI_CreateWindowEx($iExStyle, $__g_sRTFClassName, "", $iStyle, $iLeft, $iTop, $iWidth, $iHeight, $hWnd, $nCtrlID)
If $hRichEdit = 0 Then Return SetError(700, 0, False)
__GCR_SetOLECallback($hRichEdit)
_SendMessage($hRichEdit, $__RICHEDITCONSTANT_WM_SETFONT, _WinAPI_GetStockObject($DEFAULT_GUI_FONT), True)
_GUICtrlRichEdit_AppendText($hRichEdit, $sText)
Return $hRichEdit
EndFunc
Func _GUICtrlRichEdit_Destroy(ByRef $hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(2, 2, False)
Local $iDestroyed = 0
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hRELastWnd) Then
Local $nCtrlID = _WinAPI_GetDlgCtrlID($hWnd)
Local $hParent = _WinAPI_GetParent($hWnd)
$iDestroyed = _WinAPI_DestroyWindow($hWnd)
Local $iRet = __UDF_FreeGlobalID($hParent, $nCtrlID)
If Not $iRet Then
EndIf
Else
Return SetError(1, 1, False)
EndIf
Else
$iDestroyed = GUICtrlDelete($hWnd)
EndIf
If $iDestroyed Then $hWnd = 0
Return $iDestroyed <> 0
EndFunc
Func _GUICtrlRichEdit_GetText($hWnd, $bCrToCrLf = False, $iCodePage = 0, $sReplChar = "")
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
If Not IsBool($bCrToCrLf) Then Return SetError(102, 0, "")
If Not __GCR_IsNumeric($iCodePage) Then Return SetError(103, 0, "")
Local $iLen = _GUICtrlRichEdit_GetTextLength($hWnd, False, True) + 1
Local $sUni = ''
If $iCodePage = $CP_UNICODE Or Not $iCodePage Then $sUni = "w"
Local $tText = DllStructCreate($sUni & "char[" & $iLen & "]")
Local $tGetTextEx = DllStructCreate($tagGETTEXTEX)
DllStructSetData($tGetTextEx, "cb", DllStructGetSize($tText))
Local $iFlags = 0
If $bCrToCrLf Then $iFlags = $GT_USECRLF
DllStructSetData($tGetTextEx, "flags", $iFlags)
If $iCodePage = 0 Then $iCodePage = $CP_UNICODE
DllStructSetData($tGetTextEx, "codepage", $iCodePage)
Local $pUsedDefChar = 0, $pDefaultChar = 0
If $sReplChar <> "" Then
Local $tDefaultChar = DllStructCreate("char")
$pDefaultChar = DllStructGetPtr($tDefaultChar, 1)
DllStructSetData($tDefaultChar, 1, $sReplChar)
Local $tUsedDefChar = DllStructCreate("bool")
$pUsedDefChar = DllStructGetPtr($tUsedDefChar, 1)
EndIf
DllStructSetData($tGetTextEx, "lpDefaultChar", $pDefaultChar)
DllStructSetData($tGetTextEx, "lpbUsedDefChar", $pUsedDefChar)
Local $iRet = _SendMessage($hWnd, $EM_GETTEXTEX, $tGetTextEx, $tText, 0, "struct*", "struct*")
If $iRet = 0 Then Return SetError(700, 0, "")
If $sReplChar <> "" Then SetExtended(DllStructGetData($tUsedDefChar, 1) <> 0)
Return DllStructGetData($tText, 1)
EndFunc
Func _GUICtrlRichEdit_GetTextLength($hWnd, $bExact = True, $bChars = False)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
If Not IsBool($bExact) Then Return SetError(102, 0, 0)
If Not IsBool($bChars) Then Return SetError(103, 0, 0)
Local $tGetTextLen = DllStructCreate($tagGETTEXTLENGTHEX)
Local $iFlags = BitOR($GTL_USECRLF,($bExact ? $GTL_PRECISE : $GTL_CLOSE))
$iFlags = BitOR($iFlags,($bChars ? $GTL_DEFAULT : $GTL_NUMBYTES))
DllStructSetData($tGetTextLen, 1, $iFlags)
DllStructSetData($tGetTextLen, 2,($bChars ? $CP_ACP : $CP_UNICODE))
Local $iRet = _SendMessage($hWnd, $EM_GETTEXTLENGTHEX, $tGetTextLen, 0, 0, "struct*")
Return $iRet
EndFunc
Func _GUICtrlRichEdit_SetCharColor($hWnd, $iColor = Default)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $tCharFormat = DllStructCreate($tagCHARFORMAT)
DllStructSetData($tCharFormat, 1, DllStructGetSize($tCharFormat))
If $iColor = Default Then
DllStructSetData($tCharFormat, 3, $CFE_AUTOCOLOR)
$iColor = 0
Else
If BitAND($iColor, 0xff000000) Then Return SetError(1022, 0, False)
EndIf
DllStructSetData($tCharFormat, 2, $CFM_COLOR)
DllStructSetData($tCharFormat, 6, $iColor)
Return _SendMessage($hWnd, $EM_SETCHARFORMAT, $SCF_SELECTION, $tCharFormat, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlRichEdit_SetFont($hWnd, $iPoints = Default, $sName = Default, $iCharset = Default, $iLcid = Default)
Local $iDwMask = 0
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not($iPoints = Default Or __GCR_IsNumeric($iPoints, ">0")) Then Return SetError(102, 0, False)
If $sName <> Default Then
Local $aS = StringSplit($sName, " ")
For $i = 1 To UBound($aS) - 1
If Not StringIsAlpha($aS[$i]) Then Return SetError(103, 0, False)
Next
EndIf
If Not($iCharset = Default Or __GCR_IsNumeric($iCharset)) Then Return SetError(104, 0, False)
If Not($iLcid = Default Or __GCR_IsNumeric($iLcid)) Then Return SetError(105, 0, False)
Local $tCharFormat = DllStructCreate($tagCHARFORMAT2)
DllStructSetData($tCharFormat, 1, DllStructGetSize($tCharFormat))
If $iPoints <> Default Then
$iDwMask = $CFM_SIZE
DllStructSetData($tCharFormat, 4, Int($iPoints * 20))
EndIf
If $sName <> Default Then
If StringLen($sName) > $LF_FACESIZE - 1 Then SetError(-1, 0, False)
$iDwMask = BitOR($iDwMask, $CFM_FACE)
DllStructSetData($tCharFormat, 9, $sName)
EndIf
If $iCharset <> Default Then
$iDwMask = BitOR($iDwMask, $CFM_CHARSET)
DllStructSetData($tCharFormat, 7, $iCharset)
EndIf
If $iLcid <> Default Then
$iDwMask = BitOR($iDwMask, $CFM_LCID)
DllStructSetData($tCharFormat, 13, $iLcid)
EndIf
DllStructSetData($tCharFormat, 2, $iDwMask)
Local $iRet = _SendMessage($hWnd, $EM_SETCHARFORMAT, $SCF_SELECTION, $tCharFormat, 0, "wparam", "struct*")
If Not $iRet Then Return SetError(@error + 200, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_SetSel($hWnd, $iAnchor, $iActive, $bHideSel = False)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not __GCR_IsNumeric($iAnchor, ">=0,-1") Then Return SetError(102, 0, False)
If Not __GCR_IsNumeric($iActive, ">=0,-1") Then Return SetError(103, 0, False)
If Not IsBool($bHideSel) Then Return SetError(104, 0, False)
_SendMessage($hWnd, $EM_SETSEL, $iAnchor, $iActive)
If $bHideSel Then _SendMessage($hWnd, $EM_HIDESELECTION, $bHideSel)
_WinAPI_SetFocus($hWnd)
Return True
EndFunc
Func _GUICtrlRichEdit_SetText($hWnd, $sText)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $tSetText = DllStructCreate($tagSETTEXTEX)
DllStructSetData($tSetText, 1, $ST_DEFAULT)
DllStructSetData($tSetText, 2, $CP_ACP)
Local $iRet
If StringLeft($sText, 5) <> "{\rtf" And StringLeft($sText, 5) <> "{urtf" Then
DllStructSetData($tSetText, 2, $CP_UNICODE)
$iRet = _SendMessage($hWnd, $EM_SETTEXTEX, $tSetText, $sText, 0, "struct*", "wstr")
Else
$iRet = _SendMessage($hWnd, $EM_SETTEXTEX, $tSetText, $sText, 0, "struct*", "STR")
EndIf
If Not $iRet Then Return SetError(700, 0, False)
Return True
EndFunc
Func __GCR_Init()
Local $ah_GUICtrlRTF_lib = DllCall("kernel32.dll", "ptr", "LoadLibraryW", "wstr", "MSFTEDIT.DLL")
If $ah_GUICtrlRTF_lib[0] <> 0 Then
$__g_sRTFClassName = "RichEdit50W"
$__g_sRTFVersion = 4.1
Else
$ah_GUICtrlRTF_lib = DllCall("kernel32.dll", "ptr", "LoadLibraryW", "wstr", "RICHED20.DLL")
$__g_sRTFVersion = FileGetVersion(@SystemDir & "\riched20.dll", "ProductVersion")
Switch $__g_sRTFVersion
Case 3.0
$__g_sRTFClassName = "RichEdit20W"
Case 5.0
$__g_sRTFClassName = "RichEdit50W"
Case 6.0
$__g_sRTFClassName = "RichEdit60W"
EndSwitch
EndIf
$__g_sGRE_CF_RTF = _ClipBoard_RegisterFormat("Rich Text Format")
$__g_sGRE_CF_RETEXTOBJ = _ClipBoard_RegisterFormat("Rich Text Format with Objects")
EndFunc
Func __GCR_StreamFromFileCallback($hFile, $pBuf, $iBuflen, $pQbytes)
Local $tQbytes = DllStructCreate("long", $pQbytes)
DllStructSetData($tQbytes, 1, 0)
Local $tBuf = DllStructCreate("char[" & $iBuflen & "]", $pBuf)
Local $sBuf = FileRead($hFile, $iBuflen - 1)
If @error Then Return 1
DllStructSetData($tBuf, 1, $sBuf)
DllStructSetData($tQbytes, 1, StringLen($sBuf))
Return 0
EndFunc
Func __GCR_StreamFromVarCallback($iCookie, $pBuf, $iBuflen, $pQbytes)
#forceref $iCookie
Local $tQbytes = DllStructCreate("long", $pQbytes)
DllStructSetData($tQbytes, 1, 0)
Local $tCtl = DllStructCreate("char[" & $iBuflen & "]", $pBuf)
Local $sCtl = StringLeft($__g_pGRC_sStreamVar, $iBuflen - 1)
If $sCtl = "" Then Return 1
DllStructSetData($tCtl, 1, $sCtl)
Local $iLen = StringLen($sCtl)
DllStructSetData($tQbytes, 1, $iLen)
$__g_pGRC_sStreamVar = StringMid($__g_pGRC_sStreamVar, $iLen + 1)
Return 0
EndFunc
Func __GCR_StreamToFileCallback($hFile, $pBuf, $iBuflen, $pQbytes)
Local $tQbytes = DllStructCreate("long", $pQbytes)
DllStructSetData($tQbytes, 1, 0)
Local $tBuf = DllStructCreate("char[" & $iBuflen & "]", $pBuf)
Local $s = DllStructGetData($tBuf, 1)
FileWrite($hFile, $s)
DllStructSetData($tQbytes, 1, StringLen($s))
Return 0
EndFunc
Func __GCR_StreamToVarCallback($iCookie, $pBuf, $iBuflen, $pQbytes)
#forceref $iCookie
Local $tQbytes = DllStructCreate("long", $pQbytes)
DllStructSetData($tQbytes, 1, 0)
Local $tBuf = DllStructCreate("char[" & $iBuflen & "]", $pBuf)
Local $s = DllStructGetData($tBuf, 1)
$__g_pGRC_sStreamVar &= $s
Return 0
EndFunc
Func __GCR_IsNumeric($vN, $sRange = "")
If Not(IsNumber($vN) Or StringIsInt($vN) Or StringIsFloat($vN)) Then Return False
Switch $sRange
Case ">0"
If $vN <= 0 Then Return False
Case ">=0"
If $vN < 0 Then Return False
Case ">0,-1"
If Not($vN > 0 Or $vN = -1) Then Return False
Case ">=0,-1"
If Not($vN >= 0 Or $vN = -1) Then Return False
EndSwitch
Return True
EndFunc
Func __GCR_SetOLECallback($hWnd)
If Not IsHWnd($hWnd) Then Return SetError(101, 0, False)
If Not $__g_pObj_RichCom Then
$__g_tCall_RichCom = DllStructCreate("ptr[20]")
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_QueryInterface), 1)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_AddRef), 2)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_Release), 3)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_GetNewStorage), 4)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_GetInPlaceContext), 5)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_ShowContainerUI), 6)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_QueryInsertObject), 7)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_DeleteObject), 8)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_QueryAcceptData), 9)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_ContextSensitiveHelp), 10)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_GetClipboardData), 11)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_GetDragDropEffect), 12)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_GetContextMenu), 13)
DllStructSetData($__g_tObj_RichComObject, 1, DllStructGetPtr($__g_tCall_RichCom))
DllStructSetData($__g_tObj_RichComObject, 2, 1)
$__g_pObj_RichCom = DllStructGetPtr($__g_tObj_RichComObject)
EndIf
Local Const $EM_SETOLECALLBACK = 0x400 + 70
If _SendMessage($hWnd, $EM_SETOLECALLBACK, 0, $__g_pObj_RichCom) = 0 Then Return SetError(700, 0, False)
Return True
EndFunc
Func __RichCom_Object_QueryInterface($pObject, $iREFIID, $pPvObj)
#forceref $pObject, $iREFIID, $pPvObj
Return $_GCR_S_OK
EndFunc
Func __RichCom_Object_AddRef($pObject)
Local $tData = DllStructCreate("ptr;dword", $pObject)
DllStructSetData($tData, 2, DllStructGetData($tData, 2) + 1)
Return DllStructGetData($tData, 2)
EndFunc
Func __RichCom_Object_Release($pObject)
Local $tData = DllStructCreate("ptr;dword", $pObject)
If DllStructGetData($tData, 2) > 0 Then
DllStructSetData($tData, 2, DllStructGetData($tData, 2) - 1)
Return DllStructGetData($tData, 2)
EndIf
EndFunc
Func __RichCom_Object_GetInPlaceContext($pObject, $pPFrame, $pPDoc, $pFrameInfo)
#forceref $pObject, $pPFrame, $pPDoc, $pFrameInfo
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_ShowContainerUI($pObject, $bShow)
#forceref $pObject, $bShow
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_QueryInsertObject($pObject, $pClsid, $tStg, $vCp)
#forceref $pObject, $pClsid, $tStg, $vCp
Return $_GCR_S_OK
EndFunc
Func __RichCom_Object_DeleteObject($pObject, $pOleobj)
#forceref $pObject, $pOleobj
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_QueryAcceptData($pObject, $pDataobj, $pCfFormat, $vReco, $bReally, $hMetaPict)
#forceref $pObject, $pDataobj, $pCfFormat, $vReco, $bReally, $hMetaPict
Return $_GCR_S_OK
EndFunc
Func __RichCom_Object_ContextSensitiveHelp($pObject, $bEnterMode)
#forceref $pObject, $bEnterMode
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_GetClipboardData($pObject, $pChrg, $vReco, $pPdataobj)
#forceref $pObject, $pChrg, $vReco, $pPdataobj
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_GetDragDropEffect($pObject, $bDrag, $iGrfKeyState, $piEffect)
#forceref $pObject, $bDrag, $iGrfKeyState, $piEffect
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_GetContextMenu($pObject, $iSeltype, $pOleobj, $pChrg, $pHmenu)
#forceref $pObject, $iSeltype, $pOleobj, $pChrg, $pHmenu
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_GetNewStorage($pObject, $pPstg)
#forceref $pObject
Local $aSc = DllCall($__g_hLib_RichCom_OLE32, "dword", "CreateILockBytesOnHGlobal", "hwnd", 0, "int", 1, "ptr*", 0)
Local $pLockBytes = $aSc[3]
$aSc = $aSc[0]
If $aSc Then Return $aSc
$aSc = DllCall($__g_hLib_RichCom_OLE32, "dword", "StgCreateDocfileOnILockBytes", "ptr", $pLockBytes, "dword", BitOR(0x10, 2, 0x1000), "dword", 0, "ptr*", 0)
Local $tStg = DllStructCreate("ptr", $pPstg)
DllStructSetData($tStg, 1, $aSc[4])
$aSc = $aSc[0]
If $aSc Then
Local $tObj = DllStructCreate("ptr", $pLockBytes)
Local $tUnknownFuncTable = DllStructCreate("ptr[3]", DllStructGetData($tObj, 1))
Local $pReleaseFunc = DllStructGetData($tUnknownFuncTable, 3)
DllCallAddress("long", $pReleaseFunc, "ptr", $pLockBytes)
EndIf
Return $aSc
EndFunc
Global Const $INET_DOWNLOADCOMPLETE = 2
Global $__g_hTabLastWnd
Func _GUICtrlTab_ClickTab($hWnd, $iIndex, $sButton = "left", $bMove = False, $iClicks = 1, $iSpeed = 1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iX, $iY
If Not $bMove Then
Local $hWinParent = _WinAPI_GetParent($hWnd)
Local $avTabPos = _GUICtrlTab_GetItemRect($hWnd, $iIndex)
$iX = $avTabPos[0] +(($avTabPos[2] - $avTabPos[0]) / 2)
$iY = $avTabPos[1] +(($avTabPos[3] - $avTabPos[1]) / 2)
ControlClick($hWinParent, "", $hWnd, $sButton, $iClicks, $iX, $iY)
Else
Local $tRECT = _GUICtrlTab_GetItemRectEx($hWnd, $iIndex)
Local $tPoint = _WinAPI_PointFromRect($tRECT, True)
$tPoint = _WinAPI_ClientToScreen($hWnd, $tPoint)
_WinAPI_GetXYFromPoint($tPoint, $iX, $iY)
Local $iMode = Opt("MouseCoordMode", 1)
MouseClick($sButton, $iX, $iY, $iClicks, $iSpeed)
Opt("MouseCoordMode", $iMode)
EndIf
EndFunc
Func _GUICtrlTab_GetItemRect($hWnd, $iIndex)
Local $aRect[4]
Local $tRECT = _GUICtrlTab_GetItemRectEx($hWnd, $iIndex)
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlTab_GetItemRectEx($hWnd, $iIndex)
Local $tRECT = DllStructCreate($tagRECT)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hTabLastWnd) Then
_SendMessage($hWnd, $TCM_GETITEMRECT, $iIndex, $tRECT, 0, "wparam", "struct*")
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
_SendMessage($hWnd, $TCM_GETITEMRECT, $iIndex, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tRECT, $iRect)
_MemFree($tMemMap)
EndIf
Else
GUICtrlSendMsg($hWnd, $TCM_GETITEMRECT, $iIndex, DllStructGetPtr($tRECT))
EndIf
Return $tRECT
EndFunc
Func _GUICtrlTab_SetCurFocus($hWnd, $iIndex)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $TCM_SETCURFOCUS, $iIndex)
Else
GUICtrlSendMsg($hWnd, $TCM_SETCURFOCUS, $iIndex, 0)
EndIf
EndFunc
Func _StringBetween($sString, $sStart, $sEnd, $iMode = $STR_ENDISSTART, $bCase = False)
$sStart = $sStart ? "\Q" & $sStart & "\E" : "\A"
If $iMode <> $STR_ENDNOTSTART Then $iMode = $STR_ENDISSTART
If $iMode = $STR_ENDISSTART Then
$sEnd = $sEnd ? "(?=\Q" & $sEnd & "\E)" : "\z"
Else
$sEnd = $sEnd ? "\Q" & $sEnd & "\E" : "\z"
EndIf
If $bCase = Default Then
$bCase = False
EndIf
Local $aReturn = StringRegExp($sString, "(?s" &(Not $bCase ? "i" : "") & ")" & $sStart & "(.*?)" & $sEnd, $STR_REGEXPARRAYGLOBALMATCH)
If @error Then Return SetError(1, 0, 0)
Return $aReturn
EndFunc
Func _StringRepeat($sString, $iRepeatCount)
$iRepeatCount = Int($iRepeatCount)
If $iRepeatCount = 0 Then Return ""
If StringLen($sString) < 1 Or $iRepeatCount < 0 Then Return SetError(1, 0, "")
Local $sResult = ""
While $iRepeatCount > 1
If BitAND($iRepeatCount, 1) Then $sResult &= $sString
$sString &= $sString
$iRepeatCount = BitShift($iRepeatCount, 1)
WEnd
Return $sString & $sResult
EndFunc
Global Const $HDM_FIRST = 0x1200
Global Const $HDM_LAYOUT = $HDM_FIRST + 5
Global $__g_hHDRLastWnd
Global Const $tagHDLAYOUT = "ptr Rect;ptr WindowPos"
Func _GUICtrlHeader_Layout($hWnd, ByRef $tRECT)
Local $tLayout = DllStructCreate($tagHDLAYOUT)
Local $tWindowPos = DllStructCreate($tagWINDOWPOS)
If _WinAPI_InProcess($hWnd, $__g_hHDRLastWnd) Then
DllStructSetData($tLayout, "Rect", DllStructGetPtr($tRECT))
DllStructSetData($tLayout, "WindowPos", DllStructGetPtr($tWindowPos))
_SendMessage($hWnd, $HDM_LAYOUT, 0, $tLayout, 0, "wparam", "struct*")
Else
Local $iLayout = DllStructGetSize($tLayout)
Local $iRect = DllStructGetSize($tRECT)
Local $iWindowPos = DllStructGetSize($tWindowPos)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iLayout + $iRect + $iWindowPos, $tMemMap)
DllStructSetData($tLayout, "Rect", $pMemory + $iLayout)
DllStructSetData($tLayout, "WindowPos", $pMemory + $iLayout + $iRect)
_MemWrite($tMemMap, $tLayout, $pMemory, $iLayout)
_MemWrite($tMemMap, $tRECT, $pMemory + $iLayout, $iRect)
_SendMessage($hWnd, $HDM_LAYOUT, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory + $iLayout + $iRect, $tWindowPos, $iWindowPos)
_MemFree($tMemMap)
EndIf
Return $tWindowPos
EndFunc
Global Const $LVM_FIRST = 0x1000
Global Const $LVM_GETHEADER =($LVM_FIRST + 31)
Global Const $LVM_GETITEMRECT =($LVM_FIRST + 14)
Global Const $LVN_FIRST = -100
Global $__g_hLVLastWnd
Func _GUICtrlListView_GetHeader($hWnd)
If IsHWnd($hWnd) Then
Return HWnd(_SendMessage($hWnd, $LVM_GETHEADER))
Else
Return HWnd(GUICtrlSendMsg($hWnd, $LVM_GETHEADER, 0, 0))
EndIf
EndFunc
Func _GUICtrlListView_GetItemRect($hWnd, $iIndex, $iPart = 3)
Local $tRECT = _GUICtrlListView_GetItemRectEx($hWnd, $iIndex, $iPart)
Local $aRect[4]
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlListView_GetItemRectEx($hWnd, $iIndex, $iPart = 3)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Left", $iPart)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
_SendMessage($hWnd, $LVM_GETITEMRECT, $iIndex, $tRECT, 0, "wparam", "struct*")
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
_MemWrite($tMemMap, $tRECT, $pMemory, $iRect)
_SendMessage($hWnd, $LVM_GETITEMRECT, $iIndex, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tRECT, $iRect)
_MemFree($tMemMap)
EndIf
Else
GUICtrlSendMsg($hWnd, $LVM_GETITEMRECT, $iIndex, DllStructGetPtr($tRECT))
EndIf
Return $tRECT
EndFunc
Global $__g_hTTLastWnd
Global Const $_TOOLTIPCONSTANTS_ClassName = "tooltips_class32"
Global Const $_TT_ghTTDefaultStyle = BitOR($TTS_ALWAYSTIP, $TTS_NOPREFIX)
Global Const $tagTOOLINFO = "uint Size;uint Flags;hwnd hWnd;uint_ptr ID;" & $tagRECT & ";handle hInst;ptr Text;lparam Param;ptr Reserved"
Func _GUIToolTip_AddTool($hTool, $hWnd, $sText, $iID = 0, $iLeft = 0, $iTop = 0, $iRight = 0, $iBottom = 0, $iFlags = Default, $iParam = 0)
Local $iBuffer, $tBuffer, $pBuffer
If $iFlags = Default Then $iFlags = BitOR($TTF_SUBCLASS, $TTF_IDISHWND)
If $sText <> -1 Then
$iBuffer = StringLen($sText) + 1
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
$pBuffer = DllStructGetPtr($tBuffer)
DllStructSetData($tBuffer, "Text", $sText)
Else
$iBuffer = 0
$pBuffer = -1
EndIf
Local $tToolInfo = DllStructCreate($tagTOOLINFO)
Local $iToolInfo = DllStructGetSize($tToolInfo)
DllStructSetData($tToolInfo, "Size", $iToolInfo)
DllStructSetData($tToolInfo, "Flags", $iFlags)
DllStructSetData($tToolInfo, "hWnd", $hWnd)
DllStructSetData($tToolInfo, "ID", $iID)
DllStructSetData($tToolInfo, "Left", $iLeft)
DllStructSetData($tToolInfo, "Top", $iTop)
DllStructSetData($tToolInfo, "Right", $iRight)
DllStructSetData($tToolInfo, "Bottom", $iBottom)
DllStructSetData($tToolInfo, "Param", $iParam)
Local $iRet
If _WinAPI_InProcess($hTool, $__g_hTTLastWnd) Then
DllStructSetData($tToolInfo, "Text", $pBuffer)
$iRet = _SendMessage($hTool, $TTM_ADDTOOLW, 0, $tToolInfo, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hTool, $iToolInfo + $iBuffer, $tMemMap)
If $sText <> -1 Then
Local $pText = $pMemory + $iToolInfo
DllStructSetData($tToolInfo, "Text", $pText)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
Else
DllStructSetData($tToolInfo, "Text", -1)
EndIf
_MemWrite($tMemMap, $tToolInfo, $pMemory, $iToolInfo)
$iRet = _SendMessage($hTool, $TTM_ADDTOOLW, 0, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
Return $iRet <> 0
EndFunc
Func _GUIToolTip_Create($hWnd, $iStyle = $_TT_ghTTDefaultStyle)
Return _WinAPI_CreateWindowEx(0, $_TOOLTIPCONSTANTS_ClassName, "", $iStyle, 0, 0, 0, 0, $hWnd)
EndFunc
Func _GUIToolTip_GetText($hWnd, $hTool, $iID)
Local $tBuffer = DllStructCreate("wchar Text[4096]")
Local $tToolInfo = DllStructCreate($tagTOOLINFO)
Local $iToolInfo = DllStructGetSize($tToolInfo)
DllStructSetData($tToolInfo, "Size", $iToolInfo)
DllStructSetData($tToolInfo, "hWnd", $hTool)
DllStructSetData($tToolInfo, "ID", $iID)
If _WinAPI_InProcess($hWnd, $__g_hTTLastWnd) Then
DllStructSetData($tToolInfo, "Text", DllStructGetPtr($tBuffer))
_SendMessage($hWnd, $TTM_GETTEXTW, 0, $tToolInfo, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iToolInfo + 4096, $tMemMap)
Local $pText = $pMemory + $iToolInfo
DllStructSetData($tToolInfo, "Text", $pText)
_MemWrite($tMemMap, $tToolInfo, $pMemory, $iToolInfo)
_SendMessage($hWnd, $TTM_GETTEXTW, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pText, $tBuffer, 81)
_MemFree($tMemMap)
EndIf
Return DllStructGetData($tBuffer, "Text")
EndFunc
Func _GUIToolTip_SetMaxTipWidth($hWnd, $iWidth)
Return _SendMessage($hWnd, $TTM_SETMAXTIPWIDTH, 0, $iWidth)
EndFunc
Global Const $PROV_RSA_AES = 24
Global Const $CRYPT_VERIFYCONTEXT = 0xF0000000
Global Const $HP_HASHSIZE = 0x0004
Global Const $HP_HASHVAL = 0x0002
Global Const $CRYPT_USERDATA = 1
Global Const $CALG_SHA1 = 0x00008004
Global $__g_aCryptInternalData[3]
Func _Crypt_Startup()
If __Crypt_RefCount() = 0 Then
Local $hAdvapi32 = DllOpen("Advapi32.dll")
If $hAdvapi32 = -1 Then Return SetError(1, 0, False)
__Crypt_DllHandleSet($hAdvapi32)
Local $iProviderID = $PROV_RSA_AES
Local $aRet = DllCall(__Crypt_DllHandle(), "bool", "CryptAcquireContext", "handle*", 0, "ptr", 0, "ptr", 0, "dword", $iProviderID, "dword", $CRYPT_VERIFYCONTEXT)
If @error Or Not $aRet[0] Then
Local $iError = @error + 10, $iExtended = @extended
DllClose(__Crypt_DllHandle())
Return SetError($iError, $iExtended, False)
Else
__Crypt_ContextSet($aRet[1])
EndIf
EndIf
__Crypt_RefCountInc()
Return True
EndFunc
Func _Crypt_Shutdown()
__Crypt_RefCountDec()
If __Crypt_RefCount() = 0 Then
DllCall(__Crypt_DllHandle(), "bool", "CryptReleaseContext", "handle", __Crypt_Context(), "dword", 0)
DllClose(__Crypt_DllHandle())
EndIf
EndFunc
Func _Crypt_HashData($vData, $iAlgID, $bFinal = True, $hCryptHash = 0)
Local $aRet = 0, $hBuff = 0, $iError = 0, $iExtended = 0, $iHashSize = 0, $vReturn = 0
_Crypt_Startup()
Do
If $hCryptHash = 0 Then
$aRet = DllCall(__Crypt_DllHandle(), "bool", "CryptCreateHash", "handle", __Crypt_Context(), "uint", $iAlgID, "ptr", 0, "dword", 0, "handle*", 0)
If @error Or Not $aRet[0] Then
$iError = @error + 10
$iExtended = @extended
$vReturn = -1
ExitLoop
EndIf
$hCryptHash = $aRet[5]
EndIf
$hBuff = DllStructCreate("byte[" & BinaryLen($vData) & "]")
DllStructSetData($hBuff, 1, $vData)
$aRet = DllCall(__Crypt_DllHandle(), "bool", "CryptHashData", "handle", $hCryptHash, "struct*", $hBuff, "dword", DllStructGetSize($hBuff), "dword", $CRYPT_USERDATA)
If @error Or Not $aRet[0] Then
$iError = @error + 20
$iExtended = @extended
$vReturn = -1
ExitLoop
EndIf
If $bFinal Then
$aRet = DllCall(__Crypt_DllHandle(), "bool", "CryptGetHashParam", "handle", $hCryptHash, "dword", $HP_HASHSIZE, "dword*", 0, "dword*", 4, "dword", 0)
If @error Or Not $aRet[0] Then
$iError = @error + 30
$iExtended = @extended
$vReturn = -1
ExitLoop
EndIf
$iHashSize = $aRet[3]
$hBuff = DllStructCreate("byte[" & $iHashSize & "]")
$aRet = DllCall(__Crypt_DllHandle(), "bool", "CryptGetHashParam", "handle", $hCryptHash, "dword", $HP_HASHVAL, "struct*", $hBuff, "dword*", DllStructGetSize($hBuff), "dword", 0)
If @error Or Not $aRet[0] Then
$iError = @error + 40
$iExtended = @extended
$vReturn = -1
ExitLoop
EndIf
$vReturn = DllStructGetData($hBuff, 1)
Else
$vReturn = $hCryptHash
EndIf
Until True
If $hCryptHash <> 0 And $bFinal Then DllCall(__Crypt_DllHandle(), "bool", "CryptDestroyHash", "handle", $hCryptHash)
_Crypt_Shutdown()
Return SetError($iError, $iExtended, $vReturn)
EndFunc
Func __Crypt_RefCount()
Return $__g_aCryptInternalData[0]
EndFunc
Func __Crypt_RefCountInc()
$__g_aCryptInternalData[0] += 1
EndFunc
Func __Crypt_RefCountDec()
If $__g_aCryptInternalData[0] > 0 Then $__g_aCryptInternalData[0] -= 1
EndFunc
Func __Crypt_DllHandle()
Return $__g_aCryptInternalData[1]
EndFunc
Func __Crypt_DllHandleSet($hAdvapi32)
$__g_aCryptInternalData[1] = $hAdvapi32
EndFunc
Func __Crypt_Context()
Return $__g_aCryptInternalData[2]
EndFunc
Func __Crypt_ContextSet($hCryptContext)
$__g_aCryptInternalData[2] = $hCryptContext
EndFunc
Global Const $g_sLogoPath = @ScriptDir & "\Images\Logo.png"
Global Const $g_sLogoUrlPath = @ScriptDir & "\Images\LogoURL.png"
Global Const $g_iGAME_WIDTH = 860
Global Const $g_iGAME_HEIGHT = 732
Global Const $g_iDEFAULT_HEIGHT = 780
Global Const $g_iDEFAULT_WIDTH = 860
Global Const $g_iMidOffsetY = Int(($g_iDEFAULT_HEIGHT - 720) / 2)
Global Const $g_iBottomOffsetY = $g_iDEFAULT_HEIGHT - 720
Global $g_iBotLaunchTime = 0
Global $g_iVILLAGE_OFFSET[3] = [0, 0, 1]
Global $g_aiSearchEnableDebugDeadBaseImage = 200
Global $g_aZombie = ["" , 0 , 0 , 0 , 0 , "" , "" , 30 , 300 , 600 , 150 ]
Global $g_iDebugSearchArea = 0, $g_iDebugRedArea = 0, $g_iDebugWalls = 0, $g_iDebugVillageSearchImages = 0
Global $g_iDebugMultilanguage = 0
Global $g_iDebugGetLocation = 0
Global $g_iDebugAndroidEmbedded = 0
Global $g_iDebugWindowMessages = 0
Global $g_iDebugGDICount = 0
Global $g_iDebugGDICountMax = 0
Global $g_oDebugGDIHandles = ObjCreate("Scripting.Dictionary")
Global $g_iDebugResourcesOffset = 0
Global $g_iDebugMilkingIMGmake = 0
Global $g_iDebugContinueSearchElixir = 0
Global $g_iDebugClick = 0
Global $g_iDebugSetlog = 0, $g_iDebugOcr = 0, $g_iDebugImageSave = 0, $g_iDebugBuildingPos = 0, $g_iDebugSetlogTrain = 0, $g_iDebugDisableZoomout = 0, $g_iDebugDisableVillageCentering = 0
Global $g_iDebugOCRdonate = 0
Global $g_iDebugAttackCSV = 0, $g_iDebugMakeIMGCSV = 0
Global $g_iDebugDeadBaseImage = 0
Global Const $COLOR_ORANGE = 0xFF7700
Global Const $COLOR_ERROR = $COLOR_RED
Global Const $COLOR_WARNING = $COLOR_MAROON
Global Const $COLOR_INFO = $COLOR_BLUE
Global Const $COLOR_SUCCESS = 0x006600
Global Const $COLOR_SUCCESS1 = 0x009900
Global Const $COLOR_DEBUG = $COLOR_PURPLE
Global Const $COLOR_DEBUG1 = 0x7a00cc
Global Const $COLOR_DEBUG2 = 0xaa80ff
Global Const $COLOR_DEBUGS = $COLOR_MEDGRAY
Global Const $COLOR_ACTION = 0xFF8000
Global Const $COLOR_ACTION1 = 0xcc80ff
Global Const $g_bCapturePixel = True, $g_bNoCapturePixel = False
Global $g_bCriticalMessageProcessing = False
Global $g_hHBitmapTest = 0
Global $hBitmap
Global $hHBitmap
Global $hHBitmap2
Global $g_bOcrForceCaptureRegion = True
Global Const $g_b64Bit = StringInStr(@OSArch, "64") > 0
Global Const $g_sHKLM = "HKLM" &($g_b64Bit ? "64" : "")
Global Const $g_sWow6432Node =($g_b64Bit ? "\Wow6432Node" : "")
Global Const $g_sGoogle = "Google"
Global $g_sAndroidGameDistributor = "Google"
Global $g_sAndroidGamePackage = "com.supercell.clashofclans"
Global $g_sAndroidGameClass = ".GameApp"
Global $g_sUserGameDistributor = "Google"
Global $g_sUserGamePackage = "com.supercell.clashofclans"
Global $g_sUserGameClass = ".GameApp"
Global Const $g_bAndroidShieldPreWin8 =(_WinAPI_GetVersion() < 6.2)
Global $g_avAndroidShieldDelay[4] = [0, 0, Default, Default]
Global $g_bAndroidShieldForceDown = False
Global $g_iAndroidShieldColor = $COLOR_WHITE
Global $g_iAndroidShieldTransparency = 48
Global $g_iAndroidActiveColor = $COLOR_BLACK
Global $g_iAndroidActiveTransparency = 1
Global $g_iAndroidInactiveColor = $COLOR_WHITE
Global $g_iAndroidInactiveTransparency = 24
Global $g_bAndroidShieldEnabled = True
Global $g_bAndroidEmbedEnabled = True
Global $g_bAndroidEmbedded = False
Global $g_aiAndroidEmbeddedCtrlTarget[10] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_avAndroidShieldStatus[5] = [Default, 0, 0, Default, Default]
Global Const $g_bAndroidBackgroundLaunchEnabled = False
Global $g_bAndroidCheckTimeLagEnabled = True
Global $g_iAndroidAdbAutoTerminate = 0
Global $g_bAndroidAdbScreencapEnabled = True
Global $g_bAndroidAdbScreencapPngEnabled = False
Global $g_bAndroidAdbZoomoutEnabled = True
Global $g_bAndroidAdbClickDragEnabled = True
Global $g_bAndroidAdbInputEnabled = True
Global $g_iAndroidAdbInputWordsCharLimit = 0
Global $g_bAndroidAdbClickEnabled = False
Global $g_bAndroidAdbClicksEnabled = False
Global $g_iAndroidAdbClicksTroopDeploySize = 0
Global $g_bAndroidAdbInstanceEnabled = True
Global $g_bAndroidSuspendedEnabled = False
Global $g_bNoFocusTampering = False
Global $g_iAndroidRecoverStrategy = 1
Global $__BlueStacks2Version_2_5_or_later = False
Global $__MEmu_ToolBar_Width = 45
Global $__MEmu_SystemBar = 36
Global $__MEmu_PhoneLayout = "0"
Global $__MEmu_Window[3][4] = [ ["2.6.2",$g_iDEFAULT_WIDTH + 48,$g_iDEFAULT_HEIGHT + 26,40], ["2.5.0",$g_iDEFAULT_WIDTH + 51,$g_iDEFAULT_HEIGHT + 24,40], ["2.2.1",$g_iDEFAULT_WIDTH + 51,$g_iDEFAULT_HEIGHT + 24,45] ]
Global $__Droid4X_Window[3][3] = [ ["0.10.0",$g_iDEFAULT_WIDTH + 6,$g_iDEFAULT_HEIGHT + 53], ["0.8.6" ,$g_iDEFAULT_WIDTH + 10,$g_iDEFAULT_HEIGHT + 50] ]
Global $g_avAndroidAppConfig[8][15] = [ ["MEmu", "MEmu", "MEmu ", "[CLASS:subWin; INSTANCE:1]", "", $g_iDEFAULT_WIDTH, $g_iDEFAULT_HEIGHT - 12,$g_iDEFAULT_WIDTH + 51,$g_iDEFAULT_HEIGHT + 24,0, "127.0.0.1:21503", 0+2+4+8+16+32 , '# ', 'Microvirt Virtual Input', 0], ["BlueStacks2","", "BlueStacks ", "[CLASS:BlueStacksApp; INSTANCE:1]","_ctl.Window", $g_iDEFAULT_WIDTH, $g_iDEFAULT_HEIGHT - 48,$g_iDEFAULT_WIDTH, $g_iDEFAULT_HEIGHT - 48,0, "127.0.0.1:5555", 1 +8+16+32 , '$ ', 'BlueStacks Virtual Touch', 0], ["BlueStacks", "", "BlueStacks App Player", "[CLASS:BlueStacksApp; INSTANCE:1]","_ctl.Window", $g_iDEFAULT_WIDTH, $g_iDEFAULT_HEIGHT - 48,$g_iDEFAULT_WIDTH, $g_iDEFAULT_HEIGHT - 48,0, "127.0.0.1:5555", 1 +8+16+32 , '$ ', 'BlueStacks Virtual Touch', 0], ["KOPLAYER", "KOPLAYER", "KOPLAYER", "[CLASS:subWin; INSTANCE:1]", "", $g_iDEFAULT_WIDTH, $g_iDEFAULT_HEIGHT - 48,$g_iDEFAULT_WIDTH + 64,$g_iDEFAULT_HEIGHT - 8,0, "127.0.0.1:6555" , 0+2+4+8+16+32 , '# ', 'ttVM Virtual Input', 0], ["LeapDroid", "vm1", "Leapd", "[CLASS:subWin; INSTANCE:1]", "", $g_iDEFAULT_WIDTH, $g_iDEFAULT_HEIGHT - 48,$g_iDEFAULT_WIDTH ,$g_iDEFAULT_HEIGHT - 48,0, "emulator-5554", 1+ 8+16+32 , '# ', 'qwerty2', 1], ["iTools", "iToolsVM", "iTools ", "[CLASS:subWin; INSTANCE:1]", "", $g_iDEFAULT_WIDTH, $g_iDEFAULT_HEIGHT - 48,$g_iDEFAULT_WIDTH + 2,$g_iDEFAULT_HEIGHT - 13,0, "127.0.0.1:54001", 1 +8+16+32 , '# ', 'iTools Virtual PassThrough Input', 0], ["Droid4X", "droid4x", "Droid4X ", "[CLASS:subWin; INSTANCE:1]", "", $g_iDEFAULT_WIDTH, $g_iDEFAULT_HEIGHT - 48,$g_iDEFAULT_WIDTH + 10,$g_iDEFAULT_HEIGHT + 50,0, "127.0.0.1:26944", 0+2+4+8+16+32 , '# ', 'droid4x Virtual Input', 0], ["Nox", "nox", "No", "[CLASS:Qt5QWindowIcon;INSTANCE:4]","", $g_iDEFAULT_WIDTH, $g_iDEFAULT_HEIGHT - 48,$g_iDEFAULT_WIDTH + 4,$g_iDEFAULT_HEIGHT - 10,0, "127.0.0.1:62001", 0+2+4+8+16+32 , '# ', '(nox Virtual Input|Android Input)',-1] ]
Global $g_bOnlyInstance = True
Global $g_bFoundRunningAndroid = False
Global $g_bFoundInstalledAndroid = False
Global Const $g_iOpenAndroidActiveMaxTry = 3
Global $g_iAndroidConfig = 0
Global $g_sAndroidVersion
Global $g_sAndroidEmulator
Global $g_sAndroidInstance
Global $Title
Global $g_bUpdateAndroidWindowTitle = False
Global $g_sAppClassInstance
Global $g_sAppPaneName
Global $g_iAndroidClientWidth
Global $g_iAndroidClientHeight
Global $g_iAndroidWindowWidth
Global $g_iAndroidWindowHeight
Global $g_sAndroidAdbPath
Global $g_sAndroidAdbDevice
Global $g_iAndroidSupportFeature
Global $g_sAndroidShellPrompt
Global $g_sAndroidMouseDevice
Global $g_bAndroidAdbScreencap
Global $g_bAndroidAdbClick
Global $g_bAndroidAdbInput
Global $g_bAndroidAdbInstance
Global $g_bAndroidAdbClickDrag
Global $g_bAndroidEmbed
Global $g_iAndroidEmbedMode
Global $g_bAndroidBackgroundLaunch
Global $g_bAndroidBackgroundLaunched
Global $g_iAndroidControlClickWindow = 0
Global $g_iAndroidControlClickMode = 0
Global $g_bInitAndroidActive = False
Global $g_sAndroidProgramPath = ""
Global $g_avAndroidProgramFileVersionInfo = 0
Global $g_bAndroidHasSystemBar = False
Global $g_iAndroidLaunchWaitSec = 240
Global $g_iAndroidAdbPid = 0
Global $g_sAndroidAdbPrompt = "mybot.run:"
Global $g_sAndroidPicturesPath = ""
Global $g_sAndroidPicturesHostPath = ""
Global $g_bAndroidSharedFolderAvailable = True
Global Const $AndroidSecureFlags = 3
Global $g_sAndroidPicturesHostFolder = ""
Global $g_bAndroidPicturesPathAutoConfig = True
Global $g_iAndroidAdbAutoTerminateCount = 0
Global $g_aiAndroidAdbScreencapBuffer = DllStructCreate("byte[" &($g_iDEFAULT_WIDTH * $g_iDEFAULT_HEIGHT * 4) & "]")
Global $g_hAndroidAdbScreencapBufferPngHandle = 0
Global Const $g_iAndroidAdbScreencapWaitAdbTimeout = 10000
Global Const $g_iAndroidAdbScreencapWaitFileTimeout = 10000
Global $g_iAndroidAdbScreencapTimer = 0
Global $g_iAndroidAdbScreencapTimeoutMin = 200
Global $g_iAndroidAdbScreencapTimeoutMax = 1000
Global $g_iAndroidAdbScreencapTimeout = $g_iAndroidAdbScreencapTimeoutMax
Global $g_iAndroidAdbScreencapTimeoutDynamic = 3
Global $g_iAndroidAdbScreencapWidth = 0
Global $g_iAndroidAdbScreencapHeight = 0
Global $g_iAndroidAdbClickGroup = 10
Global Const $g_iAndroidAdbClickGroupDelay = 50
Global $g_bAndroidAdbKeepClicksActive = False
Global $g_aiAndroidTimeLag[4] = [0,0,0,0]
Global Const $g_iAndroidTimeLagThreshold = 5
Global Const $g_iAndroidRebootPageErrorCount = 5
Global Const $g_iAndroidRebootPageErrorPerMinutes = 10
Global $g_hProcShieldInput[5] = [0, 0, False, False, 0]
Global $g_bSkipFirstZoomout = False
Global $g_bForceCapture = False
Global $HWnD = 0
Global $HWnDCtrl = 0
Global $g_bInitAndroid = True
Global Const $g_iCoCReconnectingTimeout = 60000
Global $__BlueStacks_Version
Global $__BlueStacks_Path
Global $__Droid4X_Version
Global $__Droid4X_Path
Global $__MEmu_Path
Global $__LeapDroid_Path
Global $__Nox_Path
Global $__KOPLAYER_Path
Global $__iTools_Path
Global $__VBoxManage_Path
Global $__VBoxVMinfo
Global $__VBoxGuestProperties
Global $g_iThreads = -1
Global Const $g_sProfilePath = @ScriptDir & "\Profiles"
Global Const $g_sProfilePresetPath = @ScriptDir & "\Strategies"
Global $g_sProfileCurrentName = ""
Global $g_sProfileConfigPath = ""
Global $g_sProfileWeakBasePath = ""
Global $g_sProfileBuildingPath = ""
Global $g_sProfileLogsPath = "", $g_sProfileLootsPath = "", $g_sProfileTempPath = "", $g_sProfileTempDebugPath = ""
Global $g_sProfileDonateCapturePath = "", $g_sProfileDonateCaptureWhitelistPath = "", $g_sProfileDonateCaptureBlacklistPath = ""
Global $g_sProfileSecondaryInputFileName = ""
Global $g_sProfileSecondaryOutputFileName = ""
Global $g_hTxtLogTimer = TimerInit()
Global Const $g_iTxtLogTimerTimeout = 500
Global $g_bMoveDivider = False
Global $g_bSilentSetLog = False
Global $g_sLogFileName = ""
Global $g_hLogFile = 0
Global $g_hAttackLogFile = 0
Global $hStruct_SleepMicro = DllStructCreate("int64 time;")
Global $pStruct_SleepMicro = DllStructGetPtr($hStruct_SleepMicro)
Global Const $g_iEmptyWorkingSetAndroid = 60000
Global Const $g_iEmptyWorkingSetBot = 60000
Global Const $g_bMoveMouseOutBS = False
Global $g_bDevMode = False
Global $g_bBotLaunchOption_Restart = False
Global $g_bBotLaunchOption_Autostart = False
Global $g_asCmdLine[1] = [0]
Global Const $g_sWorkingDir = @WorkingDir
Global $g_hMutex_BotTitle = 0
Global $g_hMutex_Profile = 0
Global $g_hMutex_MyBot = 0
Global $aWeakBaseStats
Global Const $g_sLibPath = @ScriptDir & "\lib"
Global Const $g_sLibImageSearchPath = $g_sLibPath & "\ImageSearchDLL.dll"
Global Const $g_sLibImgLocPath = $g_sLibPath & "\MyBotRunImgLoc.dll"
Global $g_hLibImgLoc
Global Const $g_sLibFunctionsPath = $g_sLibPath & "\MBRFunctions.dll"
Global $g_hLibFunctions = -1
Global $g_hLibNTDLL = -1
Global $g_hLibUser32DLL = -1
Global Const $g_sLibIconPath = $g_sLibPath & "\MBRBOT.dll"
Global Const $g_sTHSnipeAttacksPath = @ScriptDir & "\CSV\THSnipe"
Global Const $g_sCSVAttacksPath = @ScriptDir & "\CSV\Attack"
Global $g_iRedrawBotWindowMode = 2
Global Enum $eIcnArcher = 1, $eIcnDonArcher, $eIcnBalloon, $eIcnDonBalloon, $eIcnBarbarian, $eIcnDonBarbarian, $eEmpty1, $eIcnBuilder, $eIcnCC, $eIcnGUI, $eIcnDark, $eIcnDragon, $eIcnDonDragon, $eIcnDrill, $eIcnElixir, $eIcnCollector, $eIcnFreezeSpell, $eIcnGem, $eIcnGiant, $eIcnDonGiant, $eIcnTrap, $eIcnGoblin, $eIcnDonGoblin, $eIcnGold, $eIcnGolem, $eIcnDonGolem, $eIcnHealer, $eIcnDonHealer, $eIcnHogRider, $eIcnDonHogRider, $eIcnHealSpell, $eIcnInferno, $eIcnJumpSpell, $eIcnLavaHound, $eIcnDonLavaHound, $eIcnLightSpell, $eIcnMinion, $eIcnDonMinion, $eIcnPekka, $eIcnDonPekka, $eEmpty2, $eIcnRageSpell, $eIcnTroops, $eIcnHourGlass, $eIcnTH1, $eIcnTH10, $eIcnTrophy, $eIcnValkyrie, $eIcnDonValkyrie, $eIcnWall, $eIcnWallBreaker, $eIcnDonWallBreaker, $eIcnWitch, $eIcnDonWitch, $eIcnWizard, $eIcnDonWizard, $eIcnXbow, $eIcnBarrackBoost, $eIcnMine, $eIcnCamp, $eIcnBarrack, $eIcnSpellFactory, $eIcnDonBlacklist, $eIcnSpellFactoryBoost, $eIcnMortar, $eIcnWizTower, $eIcnPayPal, $eIcnNotify, $eIcnGreenLight, $eIcnLaboratory, $eIcnRedLight, $eIcnBlank, $eIcnYellowLight, $eIcnDonCustom, $eIcnTombstone, $eIcnSilverStar, $eIcnGoldStar, $eIcnDarkBarrack, $eIcnCollectorLocate, $eIcnDrillLocate, $eIcnMineLocate, $eIcnBarrackLocate, $eIcnDarkBarrackLocate, $eIcnDarkSpellFactoryLocate, $eIcnDarkSpellFactory, $eIcnEarthQuakeSpell, $eIcnHasteSpell, $eIcnPoisonSpell, $eIcnBldgTarget, $eIcnBldgX, $eIcnRecycle, $eIcnHeroes, $eIcnBldgElixir, $eIcnBldgGold, $eIcnMagnifier, $eIcnWallElixir, $eIcnWallGold, $eIcnKing, $eIcnQueen, $eIcnDarkSpellBoost, $eIcnQueenBoostLocate, $eIcnKingBoostLocate, $eIcnKingUpgr, $eIcnQueenUpgr, $eIcnWardenUpgr, $eIcnWarden, $eIcnWardenBoostLocate, $eIcnKingBoost, $eIcnQueenBoost, $eIcnWardenBoost, $eEmpty3, $eIcnReload, $eIcnCopy, $eIcnAddcvs, $eIcnEdit, $eIcnTreeSnow, $eIcnSleepingQueen, $eIcnSleepingKing, $eIcnGoldElixir, $eIcnBowler, $eIcnDonBowler, $eIcnCCDonate, $eIcnEagleArt, $eIcnGembox, $eIcnInferno4, $eIcnInfo, $eIcnMain, $eIcnTree, $eIcnProfile, $eIcnCCRequest, $eIcnTelegram, $eIcnTiles, $eIcnXbow3, $eIcnBark, $eIcnDailyProgram, $eIcnLootCart, $eIcnSleepMode, $eIcnTH11, $eIcnTrainMode, $eIcnSleepingWarden, $eIcnCloneSpell, $eIcnSkeletonSpell, $eIcnBabyDragon, $eIcnDonBabyDragon, $eIcnMiner, $eIcnDonMiner, $eIcnNoShield, $eIcnDonCustomB, $eIcnAirdefense, $eIcnDarkBarrackBoost, $eIcnDarkElixirStorage, $eIcnSpellsCost , $eIcnTroopsCost , $eIcnResetButton, $eIcnNewSmartZap, $eIcnTrain, $eIcnAttack, $eIcnDelay, $eIcnReOrder, $eIcn2Arrow, $eIcnArrowLeft, $eIcnArrowRight, $eIcnAndroid, $eHdV04, $eHdV05, $eHdV06, $eHdV07, $eHdV08, $eHdV09, $eHdV10, $eHdV11, $eUnranked, $eBronze, $eSilver, $eGold, $eCrystal, $eMaster, $eChampion, $eTitan, $eLegend, $eWall04, $eWall05, $eWall06, $eWall07, $eWall08, $eWall09, $eWall10, $eWall11, $eIcnPBNotify, $eIcnCCTroops, $eIcnCCSpells, $eIcnSpellsGroup, $eBahasaIND, $eChinese_S, $eChinese_T, $eEnglish, $eFrench, $eGerman, $eItalian, $ePersian, $eRussian, $eSpanish, $eTurkish, $eMissingLangIcon, $eWall12, $ePortuguese, $eIcnDonPoisonSpell, $eIcnDonEarthQuakeSpell, $eIcnDonHasteSpell, $eIcnDonSkeletonSpell, $eVietnamese, $eKorean, $eModIcon, $eIcnBrain, $eIcnChat, $eIcnSwords, $eIcnLoop, $eIcnRepeat, $eIcnClan, $eIcnBug, $eIcnDelete, $eIcnMultiStat, $eIcnMove, $eIcnStats
Global $eIcnDonBlank = $eIcnDonBlacklist
Global $eIcnOptions = $eIcnDonBlacklist
Global $eIcnAchievements = $eIcnMain
Global $eIcnStrategies = $eIcnBlank
Global Const $g_iCollectAtCount = 10
Global Enum $eBotNoAction, $eBotStart, $eBotStop, $eBotSearchMode, $eBotClose
Global $g_iBotAction = $eBotNoAction
Global $g_bRestart = False
Global $g_bRunState = False
Global $g_bBtnAttackNowPressed = False
Global $g_iCommandStop = -1
Global $g_bMeetCondStop = False
Global $g_bRestarted =($g_bBotLaunchOption_Autostart ? True : False)
Global $g_bFirstStart = True
Global $g_iFirstRun = 1
Global $g_iFirstAttack = 0
Global $g_hTimerSinceStarted = 0
Global $g_iTimePassed = 0
Global $g_bBotPaused = False
Global $g_bTogglePauseUpdateState = False
Global $g_bTogglePauseAllowed = True
Global $g_bWaitShield = False
Global $g_bGForcePBTUpdate = False
Global $g_bQuicklyFirstStart = true
Global $g_bQuickAttack = False
Global $g_iTimeBeforeTrain = 0
Global Const $REDLINE_IMGLOC_RAW = 0
Global Const $REDLINE_IMGLOC = 1
Global Const $REDLINE_ORIGINAL = 2
Global Const $REDLINE_NONE = 3
Global Const $DROPLINE_EDGE_FIXED = 0
Global Const $DROPLINE_EDGE_FIRST = 1
Global Const $DROPLINE_FULL_EDGE_FIXED = 2
Global Const $DROPLINE_FULL_EDGE_FIRST = 3
Global Const $DROPLINE_DROPPOINTS_ONLY = 4
Global Enum $eBarb, $eArch, $eGiant, $eGobl, $eWall, $eBall, $eWiza, $eHeal, $eDrag, $ePekk, $eBabyD, $eMine, $eMini, $eHogs, $eValk, $eGole, $eWitc, $eLava, $eBowl, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell
Global Enum $DB, $LB, $TS, $MA, $TB, $DT
Global Const $g_iModeCount = 3
Global $g_iMatchMode = 0
Global Const $g_asModeText[6] = ["Dead Base", "Live Base", "TH Snipe", "Milking Attack", "TH Bully", "Drop Trophy"]
Global Enum $eTroopBarbarian, $eTroopArcher, $eTroopGiant, $eTroopGoblin, $eTroopWallBreaker, $eTroopBalloon, $eTroopWizard, $eTroopHealer, $eTroopDragon, $eTroopPekka, $eTroopBabyDragon, $eTroopMiner, $eTroopMinion, $eTroopHogRider, $eTroopValkyrie, $eTroopGolem, $eTroopWitch, $eTroopLavaHound, $eTroopBowler, $eTroopCount
Global Const $g_asTroopNames[$eTroopCount] = [ "Barbarian", "Archer", "Giant", "Goblin", "Wall Breaker", "Balloon", "Wizard", "Healer", "Dragon", "Pekka", "Baby Dragon", "Miner", "Minion", "Hog Rider", "Valkyrie", "Golem", "Witch", "Lava Hound", "Bowler"]
Global Const $g_asTroopNamesPlural[$eTroopCount] = [ "Barbarians", "Archers", "Giants", "Goblins", "Wall Breakers", "Balloons", "Wizards", "Healers", "Dragons", "Pekkas", "Baby Dragons", "Miners", "Minions", "Hog Riders", "Valkyries", "Golems", "Witches", "Lava Hounds", "Bowlers"]
Global Const $g_asTroopShortNames[$eTroopCount] = [ "Barb", "Arch", "Giant", "Gobl", "Wall", "Ball", "Wiza", "Heal", "Drag", "Pekk", "BabyD", "Mine", "Mini", "Hogs", "Valk", "Gole", "Witc", "Lava", "Bowl"]
Global Const $g_aiTroopSpace[$eTroopCount] = [ 1, 1, 5, 1, 2, 5, 4, 14, 20, 25, 10, 5, 2, 5, 8, 30, 12, 30, 6 ]
Global Const $g_aiTroopTrainTime[$eTroopCount] = [ 20, 24, 120, 28, 60, 120, 120, 480, 720, 720, 360, 120, 36, 90, 180, 600, 360, 600, 120 ]
Global Const $g_aiTroopCostPerLevel[$eTroopCount][9] = [ [7, 25, 40, 60, 100, 150, 200, 250], [7, 50, 80, 120, 200, 300, 400, 500], [8, 250, 750, 1250, 1750, 2250, 3000, 3500, 4000], [7, 25, 40, 60, 80, 100, 150, 200], [6, 1000, 1500, 2000, 2500, 3000, 3500], [7, 2000, 2500, 3000, 3500, 4000, 4500, 5000], [7, 1500, 2000, 2500, 3000, 3500, 4000, 4500], [4, 5000, 6000, 8000, 10000], [6, 25000, 29000, 33000, 37000, 42000, 46000], [5, 28000, 32000, 36000, 40000, 45000], [5, 15000, 16000, 17000, 18000, 19000], [4, 4200, 4800, 5400, 6000], [7, 6, 7, 8, 9, 10, 11, 12], [7, 40, 45, 52, 58, 65, 90, 115], [5, 70, 100, 130, 160, 190], [6, 450, 525, 600, 675, 750, 825], [3, 250, 350, 450], [4, 390, 450, 510, 570], [3, 130, 150, 170] ]
Global Const $g_aiTroopDonateXP[$eTroopCount] = [1,1,5,1,2,5,4,14,20,25,10,5,2,5,8,30,12,30,6]
Global Enum $eSpellLightning, $eSpellHeal, $eSpellRage, $eSpellJump, $eSpellFreeze, $eSpellClone, $eSpellPoison, $eSpellEarthquake, $eSpellHaste, $eSpellSkeleton, $eSpellCount
Global Const $g_asSpellNames[$eSpellCount] = ["Lightning", "Heal", "Rage", "Jump", "Freeze", "Clone", "Poison", "Earthquake", "Haste", "Skeleton"]
Global Const $g_asSpellShortNames[$eSpellCount] = ["LSpell", "HSpell", "RSpell", "JSpell", "FSpell", "CSpell", "PSpell", "ESpell", "HaSpell", "SkSpell"]
Global Const $g_aiSpellSpace[$eSpellCount] = [ 2, 2, 2, 2, 2, 4, 1, 1, 1, 1 ]
Global Const $g_aiSpellTrainTime[$eSpellCount] = [ 360, 360, 360, 360, 360, 720, 180, 180, 180, 180 ]
Global Const $g_aiSpellCostPerLevel[$eSpellCount][8] = [ [7, 15000, 16500, 18000, 20000, 22000, 24000, 26000], [6, 15000, 16500, 18000, 20000, 22000, 24000], [5, 23000, 25000, 27000, 30000, 33000], [3, 23000, 27000, 31000], [5, 26000, 29000, 31000, 33000, 35000], [4, 38000, 40000, 42000, 44000], [5, 95, 110, 125, 140, 155], [4, 125, 140, 160, 180], [4, 80, 85, 60, 95], [4, 110, 120, 130, 140] ]
Global Const $g_aiSpellDonateXP[$eSpellCount] = [10, 10, 10, 10, 10, 0, 5, 5, 5, 5]
Global Enum $eHeroNone=0, $eHeroKing=1, $eHeroQueen=2, $eHeroWarden=4
Global Enum $eHeroBarbarianKing, $eHeroArcherQueen, $eHeroGrandWarden, $eHeroCount
Global Const $g_asHeroNames[$eHeroCount] = ["Barbarian King", "Archer Queen", "Grand Warden"]
Global Const $g_asHeroShortNames[$eHeroCount] = ["King", "Queen", "Warden"]
Global Enum $eLeagueUnranked, $eLeagueBronze, $eLeagueSilver, $eLeagueGold, $eLeagueCrystal, $eLeagueMaster, $eLeagueChampion, $eLeagueTitan, $eLeagueLegend, $eLeagueCount
Global Enum $eLootGold, $eLootElixir, $eLootDarkElixir, $eLootTrophy, $eLootCount
Func TroopIndexLookup(Const $sName)
For $i = 0 To UBound($g_asTroopShortNames) - 1
If $sName = $g_asTroopShortNames[$i] Then
Return $i
EndIf
Next
For $i = 0 To UBound($g_asSpellShortNames) - 1
If $sName = $g_asSpellShortNames[$i] Then
Return $i + $eLSpell
EndIf
Next
For $i = 0 To UBound($g_asHeroShortNames) - 1
If $sName = $g_asHeroShortNames[$i] Then
Return $i + $eKing
EndIf
Next
If $sName = "castle" Then Return $eCastle
SetDebugLog("TroopIndexLookup() Error: Index for troop name '" & $sName & "' not found.")
Return -1
EndFunc
Func GetTroopName(Const $iIndex)
If $iIndex >= $eBarb And $iIndex <= $eBowl Then
Return $g_asTroopNames[$iIndex]
ElseIf $iIndex >= $eLSpell And $iIndex <= $eSkSpell Then
Return $g_asSpellNames[$iIndex - $eLSpell]
ElseIf $iIndex >= $eKing And $iIndex <= $eWarden Then
Return $g_asHeroNames[$iIndex - $eKing]
ElseIf $iIndex = $eCastle Then
Return "Clan Castle"
EndIf
EndFunc
Global $g_iLogDividerY = 385
Global Const $g_iLogDividerHeight = 4
Global $g_iCmbLogDividerOption = 0
Global $g_bChkBackgroundMode
Global $g_bMakeScreenshotNow = False
Global $g_bChkBotStop = False, $g_iCmbBotCommand = 0, $g_iCmbBotCond = 0, $g_iCmbHoursStop = 0
Global $g_iTxtRestartGold = 10000
Global $g_iTxtRestartElixir = 25000
Global $g_iTxtRestartDark = 500
Global $g_bChkTrap = False, $g_bChkCollect = False, $g_bChkTombstones = False, $g_bChkCleanYard = False, $g_bChkGemsBox = False
Global $g_bRequestTroopsEnable = False
Global $g_sRequestTroopsText = ""
Global $g_abRequestCCHours[24] = [False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False]
Global $g_bChkDonate = True
Global Enum $eCustomA = $eTroopCount, $eCustomB = $eTroopCount+1
Global Const $g_iCustomDonateConfigs = 2
Global $g_abChkDonateTroop[$eTroopCount+$g_iCustomDonateConfigs] = [False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False]
Global $g_abChkDonateAllTroop[$eTroopCount+$g_iCustomDonateConfigs] = [False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False]
Global $g_asTxtDonateTroop[$eTroopCount+$g_iCustomDonateConfigs] = ["","","","","","","","","","","","","","","","","","","","",""]
Global $g_asTxtBlacklistTroop[$eTroopCount+$g_iCustomDonateConfigs] = ["","","","","","","","","","","","","","","","","","","","",""]
Global $g_abChkDonateSpell[$eSpellCount] = [False,False,False,False,False,False,False,False,False,False]
Global $g_abChkDonateAllSpell[$eSpellCount] = [False,False,False,False,False,False,False,False,False,False]
Global $g_asTxtDonateSpell[$eSpellCount] = ["","","","","","","","","",""]
Global $g_asTxtBlacklistSpell[$eSpellCount] = ["","","","","","","","","",""]
Global $g_aiDonateCustomTrpNumA[3][2] = [[0,0], [0,0], [0,0]], $g_aiDonateCustomTrpNumB[3][2] = [[0,0], [0,0], [0,0]]
Global $g_bChkExtraAlphabets = False
Global $g_bChkExtraChinese = False
Global $g_bChkExtraKorean = False
Global $g_sTxtGeneralBlacklist = ""
Global $g_bDonateHoursEnable = False
Global $g_abDonateHours[24] = [False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False]
Global $g_iCmbDonateFilter = 0
Global $g_bDonateSkipNearFullEnable = 1
Global $g_iDonateSkipNearFullPercent = 90
Global $g_bAutoLabUpgradeEnable = False, $g_iCmbLaboratory = 0
Global $g_bUpgradeKingEnable = False, $g_bUpgradeQueenEnable = False, $g_bUpgradeWardenEnable = False
Global Const $g_iUpgradeSlots = 14
Global $g_aiPicUpgradeStatus[$g_iUpgradeSlots] = [$eIcnTroops,$eIcnTroops,$eIcnTroops,$eIcnTroops,$eIcnTroops,$eIcnTroops,$eIcnTroops, $eIcnTroops,$eIcnTroops,$eIcnTroops,$eIcnTroops,$eIcnTroops,$eIcnTroops,$eIcnTroops]
Global $g_abBuildingUpgradeEnable[$g_iUpgradeSlots] = [False,False,False,False,False,False,False,False,False,False,False,False,False,False]
Global $g_avBuildingUpgrades[$g_iUpgradeSlots][8]
For $i = 0 To $g_iUpgradeSlots - 1
$g_avBuildingUpgrades[$i][0] = -1
$g_avBuildingUpgrades[$i][1] = -1
$g_avBuildingUpgrades[$i][2] = -1
$g_avBuildingUpgrades[$i][3] = ""
$g_avBuildingUpgrades[$i][4] = ""
$g_avBuildingUpgrades[$i][5] = ""
$g_avBuildingUpgrades[$i][6] = ""
$g_avBuildingUpgrades[$i][7] = ""
Next
Global $g_iUpgradeMinGold = 100000, $g_iUpgradeMinElixir = 100000, $g_iUpgradeMinDark = 3000
Global $g_abUpgradeRepeatEnable[$g_iUpgradeSlots] = [False,False,False,False,False,False,False,False,False,False,False,False,False,False]
Global $g_bAutoUpgradeWallsEnable = 0
Global $g_iUpgradeWallMinGold = 0, $g_iUpgradeWallMinElixir = 0
Global $g_iUpgradeWallLootType = 0, $g_bUpgradeWallSaveBuilder = False
Global $g_iCmbUpgradeWallsLevel = 6
Global $g_aiWallsCurrentCount[13] = [-1,-1,-1,-1,0,0,0,0,0,0,0,0,0]
Global $g_iUnbrkMode = 0, $g_iUnbrkWait = 5
Global $g_iUnbrkMinGold = 50000, $g_iUnbrkMinElixir = 50000, $g_iUnbrkMaxGold = 600000, $g_iUnbrkMaxElixir = 600000, $g_iUnbrkMinDark = 5000, $g_iUnbrkMaxDark = 6000
Global $g_bNotifyPBEnable = False, $g_sNotifyPBToken = ""
Global $g_bNotifyTGEnable = False, $g_sNotifyTGToken = ""
Global $g_bNotifyRemoteEnable = False, $g_sNotifyOrigin = "", $g_bNotifyDeleteAllPushesOnStart = False, $g_bNotifyDeletePushesOlderThan = False, $g_iNotifyDeletePushesOlderThanHours = 4
Global $g_bNotifyAlertMatchFound = False, $g_bNotifyAlerLastRaidIMG = False, $g_bNotifyAlerLastRaidTXT = False, $g_bNotifyAlertCampFull = False, $g_bNotifyAlertUpgradeWalls = False, $g_bNotifyAlertOutOfSync = False, $g_bNotifyAlertTakeBreak = False, $g_bNotifyAlertBulderIdle = False, $g_bNotifyAlertVillageReport = False, $g_bNotifyAlertLastAttack = False, $g_bNotifyAlertAnotherDevice = False, $g_bNotifyAlertMaintenance = False, $g_bNotifyAlertBAN = False, $g_bNotifyAlertBOTUpdate = False
Global $g_bNotifyScheduleHoursEnable = False, $g_bNotifyScheduleWeekDaysEnable = False
Global $g_abNotifyScheduleHours[24] = [False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False,False]
Global $g_abNotifyScheduleWeekDays[7] = [False,False,False,False,False,False,False]
Global $g_bQuickTrainEnable = False
Global $g_iQuickTrainArmyNum = 1
Global $g_aiArmyCompTroops[$eTroopCount] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Global $g_aiArmyCompSpells[$eSpellCount] = [0,0,0,0,0,0,0,0,0,0]
Global $g_aiTrainArmyTroopLevel[$eTroopCount] = [1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Global $g_aiTrainArmySpellLevel[$eSpellCount] = [0,0,0,0,0,0,0,0,0,0]
Global $g_iTrainArmyFullTroopPct = 100
Global $g_bTotalCampForced = False, $g_iTotalCampForcedValue = 200
Global $g_bForceBrewSpells = False
Global $g_iTotalSpellValue = 0
Global $g_iCmbBoostBarracks = 0, $g_iCmbBoostSpellFactory = 0, $g_iCmbBoostBarbarianKing = 0, $g_iCmbBoostArcherQueen = 0, $g_iCmbBoostWarden = 0
Global $g_abBoostBarracksHours[24] = [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,True]
Global Const $g_aiTroopOrderIcon[21] = [ $eIcnOptions, $eIcnBarbarian, $eIcnArcher, $eIcnGiant, $eIcnGoblin, $eIcnWallBreaker, $eIcnBalloon, $eIcnWizard, $eIcnHealer, $eIcnDragon, $eIcnPekka, $eIcnBabyDragon, $eIcnMiner, $eIcnMinion, $eIcnHogRider, $eIcnValkyrie, $eIcnGolem, $eIcnWitch, $eIcnLavaHound, $eIcnBowler]
Global $g_bCustomTrainOrderEnable = False, $g_aiCmbCustomTrainOrder[$eTroopCount] = [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]
Global $g_aiTrainOrder[$eTroopCount] = [ $eTroopArcher, $eTroopGiant, $eTroopWallBreaker, $eTroopBarbarian, $eTroopGoblin, $eTroopHealer, $eTroopPekka, $eTroopBalloon, $eTroopWizard, $eTroopDragon, $eTroopBabyDragon, $eTroopMiner, $eTroopMinion, $eTroopHogRider, $eTroopValkyrie, $eTroopGolem, $eTroopWitch, $eTroopLavaHound, $eTroopBowler ]
Global $g_bCloseWhileTrainingEnable = True, $g_bCloseWithoutShield = False, $g_bCloseEmulator = False, $g_bCloseRandom = False, $g_bCloseExactTime = False, $g_bCloseRandomTime = True, $g_iCloseRandomTimePercent = 10, $g_iCloseMinimumTime = 2
Global $g_iTrainClickDelay = 40
Global $g_bTrainAddRandomDelayEnable = False, $g_iTrainAddRandomDelayMin = 5, $g_iTrainAddRandomDelayMax = 60
Global $g_abAttackTypeEnable[$g_iModeCount + 3] = [True, False, False, -1, False, -1]
Global $g_abSearchSearchesEnable[$g_iModeCount] = [True,False,False], $g_aiSearchSearchesMin[$g_iModeCount] = [0,0,0], $g_aiSearchSearchesMax[$g_iModeCount] = [0,0,0]
Global $g_abSearchTropiesEnable[$g_iModeCount] = [False,False,False], $g_aiSearchTrophiesMin[$g_iModeCount] = [0,0,0], $g_aiSearchTrophiesMax[$g_iModeCount] = [0,0,0]
Global $g_abSearchCampsEnable[$g_iModeCount] = [False,False,False], $g_aiSearchCampsPct[$g_iModeCount] = [0,0,0]
Global $g_aiSearchHeroWaitEnable[$g_iModeCount] = [0,0,0]
Global $g_abSearchSpellsWaitEnable[$g_iModeCount] = [False,False,False]
Global $g_abSearchCastleSpellsWaitEnable[$g_iModeCount] = [False,False,False], $g_aiSearchCastleSpellsWaitRegular[$g_iModeCount] = [0,0,0], $g_aiSearchCastleSpellsWaitDark[$g_iModeCount] = [0,0,0]
Global $g_abSearchCastleTroopsWaitEnable[$g_iModeCount] = [False,False,False]
Global $g_aiFilterMeetGE[$g_iModeCount] = [0,0,0], $g_aiFilterMinGold[$g_iModeCount] = [0,0,0], $g_aiFilterMinElixir[$g_iModeCount] = [0,0,0], $g_aiFilterMinGoldPlusElixir[$g_iModeCount] = [0,0,0]
Global $g_abFilterMeetDEEnable[$g_iModeCount] = [False,False,False], $g_aiFilterMeetDEMin[$g_iModeCount] = [0,0,0]
Global $g_abFilterMeetTrophyEnable[$g_iModeCount] = [False,False,False], $g_aiFilterMeetTrophyMin[$g_iModeCount] = [0,0,0]
Global $g_abFilterMeetTH[$g_iModeCount] = [False,False,False], $g_aiFilterMeetTHMin[$g_iModeCount] = [0,0,0]
Global $g_abFilterMeetTHOutsideEnable[$g_iModeCount] = [False,False,False]
Global $g_abFilterMaxMortarEnable[$g_iModeCount] = [False,False,False], $g_abFilterMaxWizTowerEnable[$g_iModeCount] = [False,False,False], $g_abFilterMaxAirDefenseEnable[$g_iModeCount] = [False,False,False], $g_abFilterMaxXBowEnable[$g_iModeCount] = [False,False,False], $g_abFilterMaxInfernoEnable[$g_iModeCount] = [False,False,False], $g_abFilterMaxEagleEnable[$g_iModeCount] = [False,False,False]
Global $g_aiFilterMaxMortarLevel[$g_iModeCount] = [5,5,0], $g_aiFilterMaxWizTowerLevel[$g_iModeCount] = [4,4,0], $g_aiFilterMaxAirDefenseLevel[$g_iModeCount] = [0,0,0], $g_aiFilterMaxXBowLevel[$g_iModeCount] = [0,0,0], $g_aiFilterMaxInfernoLevel[$g_iModeCount] = [0,0,0], $g_aiFilterMaxEagleLevel[$g_iModeCount] = [0,0,0]
Global $g_abFilterMeetOneConditionEnable[$g_iModeCount] = [False,False,False]
Global $g_aiAttackAlgorithm[$g_iModeCount] = [0,0,0], $g_aiAttackTroopSelection[$g_iModeCount+3] = [0,0,0,0,0,0], $g_aiAttackUseHeroes[$g_iModeCount] = [0,0,0], $g_abAttackDropCC[$g_iModeCount] = [0,0,0]
Global $g_abAttackUseLightSpell[$g_iModeCount] = [0,0,0], $g_abAttackUseHealSpell[$g_iModeCount] = [0,0,0], $g_abAttackUseRageSpell[$g_iModeCount] = [0,0,0], $g_abAttackUseJumpSpell[$g_iModeCount] = [0,0,0], $g_abAttackUseFreezeSpell[$g_iModeCount] = [0,0,0], $g_abAttackUseCloneSpell[$g_iModeCount] = [0,0,0], $g_abAttackUsePoisonSpell[$g_iModeCount] = [0,0,0], $g_abAttackUseEarthquakeSpell[$g_iModeCount] = [0,0,0], $g_abAttackUseHasteSpell[$g_iModeCount] = [0,0,0], $g_abAttackUseSkeletonSpell[$g_iModeCount] = [0,0,0]
Global $g_bTHSnipeBeforeEnable[$g_iModeCount] = [False,False,False], $g_iTHSnipeBeforeTiles[$g_iModeCount] = [0,0,0], $g_iTHSnipeBeforeScript[$g_iModeCount] = [0,0,0]
Global $g_aiAttackStdDropOrder[$g_iModeCount+1] = [0,0,0,0], $g_aiAttackStdDropSides[$g_iModeCount+1] = [3,3,0,1], $g_aiAttackStdUnitDelay[$g_iModeCount+1] = [4,4,0,4], $g_aiAttackStdWaveDelay[$g_iModeCount+1] = [4,4,0,4], $g_abAttackStdRandomizeDelay[$g_iModeCount+1] = [True,True,False,True], $g_abAttackStdSmartAttack[$g_iModeCount+3] = [True,True,False,True,False,False], $g_aiAttackStdSmartDeploy[$g_iModeCount+3] = [0,0,0,0,0,0]
Global $g_abAttackStdSmartNearCollectors[$g_iModeCount+3][3] = [ [False,False,False], [False,False,False], [False,False,False], [False,False,False], [False,False,False], [False,False,False] ]
Global $g_aiAttackScrRedlineRoutine[$g_iModeCount+3] = [$REDLINE_IMGLOC_RAW, $REDLINE_IMGLOC_RAW, 0, 0, 0, 0]
Global $g_aiAttackScrDroplineEdge[$g_iModeCount+3] = [$DROPLINE_EDGE_FIRST, $DROPLINE_EDGE_FIRST, 0, 0, 0, 0]
Global $g_sAttackScrScriptName[$g_iModeCount] = ["Barch four fingers", "Barch four fingers", ""]
Global $g_abStopAtkNoLoot1Enable[$g_iModeCount] = [True,True,False], $g_aiStopAtkNoLoot1Time[$g_iModeCount] = [0,0,0], $g_abStopAtkNoLoot2Enable[$g_iModeCount] = [False,False,False], $g_aiStopAtkNoLoot2Time[$g_iModeCount] = [0,0,0]
Global $g_aiStopAtkNoLoot2MinGold[$g_iModeCount] = [0,0,0], $g_aiStopAtkNoLoot2MinElixir[$g_iModeCount] = [0,0,0], $g_aiStopAtkNoLoot2MinDark[$g_iModeCount] = [0,0,0]
Global $g_abStopAtkNoResources[$g_iModeCount] = [False,False,False], $g_abStopAtkOneStar[$g_iModeCount] = [False,False,False], $g_abStopAtkTwoStars[$g_iModeCount] = [False,False,False]
Global $g_abStopAtkPctHigherEnable[$g_iModeCount] = [False,False,False], $g_aiStopAtkPctHigherAmt[$g_iModeCount] = [0,0,0]
Global $g_abStopAtkPctNoChangeEnable[$g_iModeCount] = [False,False,False], $g_aiStopAtkPctNoChangeTime[$g_iModeCount] = [0,0,0]
Global $g_iMilkAttackType=1, $g_aiMilkFarmElixirParam[9] = [-1,-1,-1,-1,-1,-1,2,2,2]
Global $g_bMilkFarmLocateElixir = True, $g_bMilkFarmLocateMine = True, $g_bMilkFarmLocateDrill = True
Global $g_iMilkFarmMineParam = 5
Global $g_iMilkFarmDrillParam = 1
Global $g_iMilkFarmResMaxTilesFromBorder = 0, $g_bMilkFarmAttackGoldMines = True, $g_bMilkFarmAttackElixirExtractors = True, $g_bMilkFarmAttackDarkDrills = True, $g_iMilkFarmLimitGold = 9995000, $g_iMilkFarmLimitElixir = 9995000, $g_iMilkFarmLimitDark = 200000
Global $g_iMilkFarmTroopForWaveMin = 4, $g_iMilkFarmTroopForWaveMax = 6, $g_iMilkFarmTroopMaxWaves = 3, $g_iMilkFarmDelayFromWavesMin = 3000, $g_iMilkFarmDelayFromWavesMax = 5000
Global $g_iMilkingAttackDropGoblinAlgorithm = 1
Global $g_iMilkingAttackStructureOrder = 1, $g_bMilkingAttackCheckStructureDestroyedBeforeAttack = False, $g_bMilkingAttackCheckStructureDestroyedAfterAttack = False
Global $g_bMilkAttackAfterTHSnipeEnable = False, $g_iMilkFarmTHMaxTilesFromBorder = 1, $g_sMilkFarmAlgorithmTh = "Queen&GobTakeTH", $g_bMilkFarmSnipeEvenIfNoExtractorsFound = False, $g_bMilkAttackAfterScriptedAtkEnable = False, $g_sMilkAttackCSVscript = "Barch four fingers"
Global $g_bMilkFarmForceToleranceEnable = False, $g_iMilkFarmForceToleranceNormal = 31, $g_iMilkFarmForceToleranceBoosted = 31, $g_iMilkFarmForceToleranceDestroyed = 31
Global $g_abCollectorLevelEnabled[13] = [-1, -1, -1, -1, -1, -1, True, True, True, True, True, True, True]
Global $g_aiCollectorLevelFill[13] = [-1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1]
Global $g_bCollectorFilterDisable = False
Global $g_iCollectorMatchesMin = 3
Global $g_iCollectorToleranceOffset = 0
Global $g_bDESideEndEnable = False, $g_iDESideEndMin = 25, $g_bDESideDisableOther = False, $g_bDESideEndAQWeak = False, $g_bDESideEndBKWeak = False, $g_bDESideEndOneStar = False
Global $g_iAtkTSAddTilesWhileTrain = 1, $g_iAtkTSAddTilesFullTroops = 0
Global $g_sAtkTSType = "Bam"
Global $g_bEndTSCampsEnable = False, $g_iEndTSCampsPct = 0
Global $g_iAtkTBEnableCount = 150, $g_iAtkTBMaxTHLevel = 0, $g_iAtkTBMode = 0
Global $g_bSearchReductionEnable = False, $g_iSearchReductionCount = 20, $g_iSearchReductionGold = 2000, $g_iSearchReductionElixir = 2000, $g_iSearchReductionGoldPlusElixir = 4000, $g_iSearchReductionDark = 100, $g_iSearchReductionTrophy = 2
Global $g_iSearchDelayMin = 0, $g_iSearchDelayMax = 0
Global $g_bSearchAttackNowEnable = False, $g_iSearchAttackNowDelay = 0, $g_bSearchRestartEnable = False, $g_iSearchRestartLimit = 25, $g_bSearchAlertMe = True
Global $iActivateKQCondition = 0, $iActivateWardenCondition = 0, $delayActivateKQ = 0, $delayActivateW = 0
Global $ichkAttackPlannerEnable = 0, $ichkAttackPlannerCloseCoC = 0, $ichkAttackPlannerCloseAll = 0, $ichkAttackPlannerRandom = 0, $icmbAttackPlannerRandom = 0, $ichkAttackPlannerDayLimit = 0, $icmbAttackPlannerDayMin = 12, $icmbAttackPlannerDayMax = 15
Global $iPlannedAttackWeekDays[7] = [1,1,1,1,1,1,1], $iPlannedattackHours[24] = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
Global $iPlannedDropCCHoursEnable = 0, $iChkUseCCBalanced = 0, $iCmbCCDonated = 0, $iCmbCCReceived = 0
Global $iPlannedDropCCHours[24] = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
Global $ichkSmartZap = 0, $ichkEarthQuakeZap = 0, $ichkNoobZap = 0, $ichkSmartZapDB = 1, $ichkSmartZapSaveHeroes = 1, $itxtMinDE = 350, $itxtExpectedDE = 320, $DebugSmartZap = 0
Global $iShareAttack = 0, $iShareminGold = 300000, $iShareminElixir = 300000, $iSharemindark = 0, $sShareMessage = StringReplace("Nice|Good|Thanks|Wowwww", "|", @CRLF), $TakeLootSnapShot = True, $ScreenshotLootInfo = False, $iShareAttackNow = 0
Global $iChkTrophyRange = 0, $itxtMaxTrophy = 1200, $itxtdropTrophy = 800, $iChkTrophyHeroes = 0, $iCmbTrophyHeroesPriority = 0, $iChkTrophyAtkDead = 0, $itxtDTArmyMin = 70
Global $sLanguage = "English"
Global $ichkDisableSplash = 0
Global $ichkVersion = 1
Global $ichkDeleteLogs = 1, $iDeleteLogsDays = 2, $ichkDeleteTemp = 1, $iDeleteTempDays = 2, $ichkDeleteLoots = 1, $iDeleteLootsDays = 2
Global $ichkAutoStart, $ichkAutoStartDelay = 10
Global $ichklanguage = 1
Global $idisposewindows = 1, $icmbDisposeWindowsPos = 0, $iWAOffsetX = 10, $iWAOffsetY = 10
Global $iUpdatingWhenMinimized = 1
Global $iHideWhenMinimized = 0
Global $iUseRandomClick = 0
Global $iScreenshotType = 0, $ichkScreenshotHideName = 1
Global $sTimeWakeUp = 120
Global $ichkSinglePBTForced = 0, $iValueSinglePBTimeForced = 18, $iValuePBTimeForcedExit = 15
Global $iChkAutoResume = 0, $iAutoResumeTime = 5
Global $ichkFixClanCastle = 0
Global $frmBotPosX = -1
Global $frmBotPosY = -1
Global $AndroidPosX = -1
Global $AndroidPosY = -1
Global $frmBotDockedPosX = -1
Global $frmBotDockedPosY = -1
Global $frmBotAddH = 0
Global $Hide = False
Global $g_aiBSpos[2]
Global $g_aiBSrpos[2]
Global $GUIControl_Disabled = False
Global Const $dirLanguages = @ScriptDir & "\Languages\"
Global Const $sDefaultLanguage = "English"
Global $aLanguage[1][1]
Global Const $g_sNotifyVersion = "Revamp v1.5.1"
Global Const $g_iPBRemoteControlInterval = 60000
Global Const $g_iPBDeleteOldPushesInterval = 1800000
Global $g_bNotifyDeleteAllPushesNow = False
Global $LootFileName = ""
Global $iFreeBuilderCount = 0, $iTotalBuilderCount = 0, $iGemAmount = 0
Global $iTestFreeBuilderCount = -1
Global $iNbrOfOoS
Global $iAttackedCount = 0
Global $SearchCount = 0
Global Const $max_train_skip = 40
Global $actual_train_skip = 0
Global $iGoldCurrent = 0, $iElixirCurrent = 0, $iDarkCurrent = 0, $iTrophyCurrent = 0
Global $iTownHallLevel = 0
Global $TownHallPos[2] = [-1, -1]
Global $KingAltarPos[2] = [-1, -1]
Global $QueenAltarPos[2] = [-1, -1]
Global $WardenAltarPos[2] = [-1, -1]
Global $aLabPos[2] = [-1, -1]
Global $aCCPos[2] = [-1, -1]
Global $iDetectedImageType = 0
Global $NotNeedAllTime[2] = [1, 1]
Global $ArmyCapacity = 0
Global $ArmyComp
Global $aCurTotalSpell[2]
Global $iTotalTrainSpaceSpell = 0
Global $CurSFactory = 0
Global $bFullArmySpells = False
Global $CurCamp = 0, $TotalCamp = 0
Global Const $btnpos = [[114, 535 + $g_iMidOffsetY], [228, 535 + $g_iMidOffsetY], [288, 535 + $g_iMidOffsetY], [348, 535 + $g_iMidOffsetY], [409, 535 + $g_iMidOffsetY], [494, 535 + $g_iMidOffsetY], [555, 535 + $g_iMidOffsetY], [637, 535 + $g_iMidOffsetY], [698, 535 + $g_iMidOffsetY]]
Global $iLaboratoryElixirCost = 0
Global $iFirstTimeLab
Global $sLabUpgradeTime = ""
Global $g_iWallCost = 0
Global Const $g_iaWallCost[8] = [30000, 75000, 200000, 500000, 1000000, 2000000, 3000000, 4000000]
Global $iNbrOfWallsUpped = 0
Global Const $iMaxKingLevel = 45
Global Const $iMaxQueenLevel = 45
Global Const $iMaxWardenLevel = 20
Global Const $aKingUpgCost[45] = [10, 12.5, 15, 17.5, 20, 22.5, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, 105, 110, 115, 120, 125, 130, 135, 140, 144, 148, 152, 156, 160, 164, 168, 172, 176, 180, 185, 188, 191, 194, 197]
Global Const $aQueenUpgCost[45] = [40, 22.5, 25, 27.5, 30, 32.5, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, 105, 110, 115, 120, 125, 129, 133, 137, 141, 145, 149, 153, 157, 161, 165, 169, 173, 177, 181, 185, 190, 192, 194, 196, 198]
Global Const $aWardenUpgCost[20] = [6, 2.5, 3, 3.5, 4, 4.5, 5, 5.5, 6, 6.5, 7, 7.5, 8, 8.4, 8.8, 9.1, 9.4, 9.6, 9.8, 10]
Global $bSearchMode = False
Global $Is_ClientSyncError = False
Global $searchGold = 0, $searchElixir = 0, $searchDark = 0, $searchTrophy = 0, $searchTH = 0
Global $SearchGold2 = 0, $SearchElixir2 = 0
Global $iMaxTH[$g_iModeCount] = [0,0,0]
Global $iAimGold[$g_iModeCount] = [0,0,0], $iAimElixir[$g_iModeCount] = [0,0,0], $iAimGoldPlusElixir[$g_iModeCount] = [0,0,0], $iAimDark[$g_iModeCount] = [0,0,0], $iAimTrophy[$g_iModeCount] = [0,0,0], $iAimTHtext[$g_iModeCount] = [0,0,0]
Global $THLocation = 0
Global $THx = 0, $THy = 0
Global Const $THText[6] = ["4-6", "7", "8", "9", "10", "11"]
Global $OutOfGold = 0
Global Const $aSearchCost[11] = [10, 50, 75, 110, 170, 250, 380, 580, 750, 900, 1000]
Global $Is_SearchLimit = False
Global $iChkEnableAfter[$g_iModeCount]
Global $THside = 0, $THi = 0
Global $SearchTHLResult = 0
Global $THLoc
Global $IMGLOCREDLINE
Global $IMGLOCTHLEVEL
Global $THusedKing = 0
Global $THusedQueen = 0
Global $THusedWarden = 0
Global $atkTroops[12][2]
Global $fullArmy
Global Const $useAllTroops[33] = [$eBarb, $eArch, $eGiant, $eGobl, $eWall, $eBall, $eWiza, $eHeal, $eDrag, $ePekk, $eBabyD, $eMine, $eMini, $eHogs, $eValk, $eGole, $eWitc, $eLava, $eBowl, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell]
Global Const $useBarracks[26] = [$eBarb, $eArch, $eGiant, $eGobl, $eWall, $eBall, $eWiza, $eHeal, $eDrag, $ePekk, $eBabyD, $eMine, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell]
Global Const $useBarbs[15] = [$eBarb, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell]
Global Const $useArchs[15] = [$eArch, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell]
Global Const $useBarcher[16] = [$eBarb, $eArch, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell]
Global Const $useBarbGob[16] = [$eBarb, $eGobl, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell]
Global Const $useArchGob[16] = [$eArch, $eGobl, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell]
Global Const $useBarcherGiant[17] = [$eBarb, $eArch, $eGiant, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell]
Global Const $useBarcherGobGiant[18] = [$eBarb, $eArch, $eGiant, $eGobl, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell]
Global Const $useBarcherHog[17] = [$eBarb, $eArch, $eHogs, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell]
Global Const $useBarcherMinion[17] = [$eBarb, $eArch, $eMini, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell]
Global Const $troopsToBeUsed[12] = [$useAllTroops, $useBarracks, $useBarbs, $useArchs, $useBarcher, $useBarbGob, $useArchGob, $useBarcherGiant, $useBarcherGobGiant, $useBarcherHog, $useBarcherMinion]
Global $King, $Queen, $Warden
Global $CC, $Barb, $Arch
Global $iHeroWaitAttackNoBit[$g_iModeCount][3]
Global $iHeroAvailable = $eHeroNone
Global $iHeroUpgrading[3] = [0, 0, 0]
Global $iHeroUpgradingBit = $eHeroNone
Global $bHaveAnyHero = -1
Global $bFullArmyHero = False
Global $checkKPower = False
Global $checkQPower = False
Global $checkWPower = False
Global $g_aiSlotInArmy[$eTroopCount] = [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]
Global $PixelTopLeft[0]
Global $PixelBottomLeft[0]
Global $PixelTopRight[0]
Global $PixelBottomRight[0]
Global $PixelTopLeftFurther[0]
Global $PixelBottomLeftFurther[0]
Global $PixelTopRightFurther[0]
Global $PixelBottomRightFurther[0]
Global $PixelMine[0]
Global $PixelElixir[0]
Global $PixelDarkElixir[0]
Global $PixelNearCollector[0]
Global $PixelRedArea[0]
Global $PixelRedAreaFurther[0]
Global Enum $eVectorLeftTop, $eVectorRightTop, $eVectorLeftBottom, $eVectorRightBottom
Global $isCCDropped = False
Global $isHeroesDropped = False
Global $DeployCCPosition[2] = [-1, -1]
Global $DeployHeroesPosition[2] = [-1, -1]
Global $PixelMine[0]
Global $PixelElixir[0]
Global $PixelDarkElixir[0]
Global $GoldStoragePos
Global $ElixirStoragePos
Global $darkelixirStoragePos
Global $EagleArtilleryPos[2]
Global $attackcsv_locate_mine = 0
Global $attackcsv_locate_elixir = 0
Global $attackcsv_locate_drill = 0
Global $attackcsv_locate_gold_storage = 0
Global $attackcsv_locate_elixir_storage = 0
Global $attackcsv_locate_dark_storage = 0
Global $attackcsv_locate_townhall = 0
Global $attackcsv_locate_Eagle = 0
Global $lastTroopPositionDropTroopFromINI = -1
Global $ichkUseAttackDBCSV = 0
Global $ichkUseAttackABCSV = 0
Global $MilkFarmOffsetX = 56
Global $MilkFarmOffsetY = 41
Global $MilkFarmOffsetXStep = 35
Global $MilkFarmOffsetYStep = 26
Global $CapacityStructureElixir[9], $DestroyedMineIMG[9], $DestroyedElixirIMG[9], $DestroyedDarkIMG[9]
Global $duringMilkingAttack = 0
Global Const $MilkFarmOffsetMine[9] = ["1-1", "1-1", "0-2", "0-4", "1-2", "1-1", "3-5", "3-6", "3-5"]
Global Const $MilkFarmOffsetElixir[9] = ["1-11", "1-11", "1-9", "1-13", "0-11", "0-11", "0-13", "0-11", "0-14"]
Global Const $MilkFarmOffsetDark[7] = ["0-0", "1-4", "1-3", "0-5", "4-8", "0-4", "0-3"]
Global $MilkFarmObjectivesSTR = ""
Global $milkingAttackOutside = 0
Global Const $League[22][4] = [ ["0", "Bronze III", "0", "B3"], ["1000", "Bronze II", "0", "B2"], ["1300", "Bronze I", "0", "B1"], ["2600", "Silver III", "0", "S3"], ["3700", "Silver II", "0", "S2"], ["4800", "Silver I", "0", "S1"], ["10000", "Gold III", "0", "G3"], ["13500", "Gold II", "0", "G2"], ["17000", "Gold I", "0", "G1"], ["40000", "Crystal III", "120", "c3"], ["55000", "Crystal II", "220", "c2"], ["70000", "Crystal I", "320", "c1"], ["110000", "Master III", "560", "M3"], ["135000", "Master II", "740", "M2"], ["160000", "Master I", "920", "M1"], ["200000", "Champion III", "1220", "C3"], ["225000", "Champion II", "1400", "C2"], ["250000", "Champion I", "1580", "C1"], ["280000", "Titan III", "1880", "T3"], ["300000", "Titan II", "2060", "T2"], ["320000", "Titan I", "2240", "T1"], ["340000", "Legend", "2400", "LE"]]
Global $bTrainEnabled = True
Global $OutOfElixir = 0
Global $aTimeTrain[3] = [0, 0, 0]
Global Enum $ArmyTAB, $TrainTroopsTAB, $BrewSpellsTAB, $QuickTrainTAB
Global $checkSpells = False
Global Const $g_iQuickTrainButtonRetryDelay = 1000
Global $aLabTroops[30][5]
Func TranslateTroopNames()
Dim $aLabTroops[30][5] = [ [-1, -1, -1, GetTranslated(603,0, "None"), $eIcnBlank], [123, 320 + $g_iMidOffsetY, 0, GetTranslated(604,1, "Barbarians"), $eIcnBarbarian], [123, 427 + $g_iMidOffsetY, 0, GetTranslated(604,2, "Archers"), $eIcnArcher], [230, 320 + $g_iMidOffsetY, 0, GetTranslated(604,3, "Giants"), $eIcnGiant], [230, 427 + $g_iMidOffsetY, 0, GetTranslated(604,4, "Goblins"), $eIcnGoblin], [337, 320 + $g_iMidOffsetY, 0, GetTranslated(604,5, "Wall Breakers"), $eIcnWallBreaker], [337, 427 + $g_iMidOffsetY, 0, GetTranslated(604,7, "Balloons"), $eIcnBalloon], [443, 320 + $g_iMidOffsetY, 0, GetTranslated(604,8, "Wizards"), $eIcnWizard], [443, 427 + $g_iMidOffsetY, 0, GetTranslated(604,9, "Healers"), $eIcnHealer], [550, 320 + $g_iMidOffsetY, 0, GetTranslated(604,10, "Dragons"), $eIcnDragon], [550, 427 + $g_iMidOffsetY, 0, GetTranslated(604,11, "Pekkas"), $eIcnPekka], [657, 320 + $g_iMidOffsetY, 0, GetTranslated(604,20, "Baby Dragons"), $eIcnBabyDragon], [657, 427 + $g_iMidOffsetY, 0, GetTranslated(604,21, "Miners"), $eIcnMiner], [433, 320 + $g_iMidOffsetY, 1, GetTranslated(605,1, "Lightning Spell"), $eIcnLightSpell], [433, 427 + $g_iMidOffsetY, 1, GetTranslated(605,2, "Healing Spell"), $eIcnHealSpell], [540, 320 + $g_iMidOffsetY, 1, GetTranslated(605,3, "Rage Spell"), $eIcnRageSpell], [540, 427 + $g_iMidOffsetY, 1, GetTranslated(605,4, "Jump Spell"), $eIcnJumpSpell], [647, 320 + $g_iMidOffsetY, 1, GetTranslated(605,5, "Freeze Spell"), $eIcnFreezeSpell], [647, 427 + $g_iMidOffsetY, 1, GetTranslated(605,12, "Clone Spell"), $eIcnCloneSpell], [109, 320 + $g_iMidOffsetY, 2, GetTranslated(605,6, "Poison Spell"), $eIcnPoisonSpell], [109, 427 + $g_iMidOffsetY, 2, GetTranslated(605,7, "EarthQuake Spell"), $eIcnEarthQuakeSpell], [216, 320 + $g_iMidOffsetY, 2, GetTranslated(605,8, "Haste Spell"), $eIcnHasteSpell], [216, 427 + $g_iMidOffsetY, 2, GetTranslated(605,13, "Skeleton Spell"), $eIcnSkeletonSpell], [322, 320 + $g_iMidOffsetY, 2, GetTranslated(604,13, "Minions"), $eIcnMinion], [322, 427 + $g_iMidOffsetY, 2, GetTranslated(604,14, "Hog Riders"), $eIcnHogRider], [429, 320 + $g_iMidOffsetY, 2, GetTranslated(604,15, "Valkyries"), $eIcnValkyrie], [429, 427 + $g_iMidOffsetY, 2, GetTranslated(604,16, "Golems"), $eIcnGolem], [536, 320 + $g_iMidOffsetY, 2, GetTranslated(604,17, "Witches"), $eIcnWitch], [536, 427 + $g_iMidOffsetY, 2, GetTranslated(604,18, "Lava Hounds"), $eIcnLavaHound], [642, 320 + $g_iMidOffsetY, 2, GetTranslated(604,19, "Bowlers"), $eIcnBowler]]
EndFunc
Global Const $g_aiDonateTroopPriority[$eTroopCount] = [ $eTroopLavaHound, $eTroopGolem, $eTroopPekka, $eTroopDragon, $eTroopWitch, $eTroopHealer, $eTroopBabyDragon, $eTroopValkyrie, $eTroopBowler, $eTroopMiner, $eTroopGiant, $eTroopBalloon, $eTroopHogRider, $eTroopWizard, $eTroopWallBreaker, $eTroopMinion, $eTroopArcher, $eTroopBarbarian, $eTroopGoblin ]
Global Const $g_aiDonateSpellPriority[$eSpellCount] = [ $eSpellLightning, $eSpellHeal, $eSpellRage, $eSpellJump, $eSpellFreeze, $eSpellPoison, $eSpellEarthquake, $eSpellHaste, $eSpellSkeleton ]
Global $aDonIcons[20] = [$eIcnDonBarbarian, $eIcnDonArcher, $eIcnDonGiant, $eIcnDonGoblin, $eIcnDonWallBreaker, $eIcnDonBalloon, $eIcnDonWizard, $eIcnDonHealer, $eIcnDonDragon, $eIcnDonPekka, $eIcnDonBabyDragon, $eIcnDonMiner, $eIcnDonMinion, $eIcnDonHogRider, $eIcnDonValkyrie, $eIcnDonGolem, $eIcnDonWitch, $eIcnDonLavaHound, $eIcnDonBowler, $eIcnDonBlank]
Global $g_aiDonateStatsTroops[$eTroopCount][2] = [[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]]
Global $g_aiDonateStatsSpells[$eSpellCount][2] = [[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]]
Global $g_iTotalDonateStatsTroops = 0 , $g_iTotalDonateStatsTroopsXP = 0
Global $g_iTotalDonateStatsSpells = 0, $g_iTotalDonateStatsSpellsXP = 0
Global $bActiveDonate = -1
Global $g_aiDonateTroops[$eTroopCount] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], $g_aiDonateSpells[$eSpellCount] = [0,0,0,0,0,0,0,0,0,0]
Global $g_aiCurrentTroops[$eTroopCount] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], $g_aiCurrentSpells[$eSpellCount] = [0,0,0,0,0,0,0,0,0,0]
Global $bDonationEnabled = True
Global $TroopsDonated = 0
Global $TroopsReceived = 0
Global $bDisableDropTrophy = False
Global $aDTtroopsToBeUsed[6][2] = [["Barb", 0], ["Arch", 0], ["Giant", 0], ["Wall", 0], ["Gobl", 0], ["Mini", 0]]
Global Const $break = @ScriptDir & "\imgxml\other\break*"
Global Const $device = @ScriptDir & "\imgxml\other\device*"
Global Const $CocStopped = @ScriptDir & "\imgxml\other\CocStopped*"
Global Const $CocReconnecting = @ScriptDir & "\imgxml\other\CocReconnecting*"
Global Const $AppRateNever = @ScriptDir & "\imgxml\other\RateNever*"
Global $MinorObstacle = False
Global $lastmessage = ""
Global $iTaBChkAttack = 0x01
Global $iTaBChkIdle = 0x02
Global $iTaBChkTime = 0x04
Global $bDisableBreakCheck = False
Global $sPBStartTime = ""
Global $aShieldStatus = ["", "", ""]
Global Enum $eSideBuildingDES, $eSideBuildingTH
Global $BuildingLoc, $BuildingLocX = 0, $BuildingLocY = 0
Global $dropQueen, $dropKing, $dropWarden
Global $BuildingEdge, $BuildingToLoc = ""
Global $DarkLow
Global $iChkSnipeWhileTrain = 0
Global Const $itxtminArmyCapacityTHSnipe = 35
Global $iCCRemainTime = 0
Global $canRequestCC = True
Global $__TEST_ERROR_ADB_DEVICE_NOT_FOUND = False
Global $__TEST_ERROR_SLOW_ADB_SHELL_COMMAND_DELAY = 0
Global $__TEST_ERROR_SLOW_ADB_SCREENCAP_DELAY = 0
Global $__TEST_ERROR_SLOW_ADB_CLICK_DELAY = 0
Global $ToleranceImgLoc = 0.95
Global $g_iLSpellLevel = 1
Global $g_iESpellLevel = 1
Global Const $g_fDarkStealFactor = 0.75
Global Const $g_fDarkFillLevel = 0.70
Global Const $g_aDrillLevelHP[6] = [800, 860, 920, 980, 1060, 1160]
Global Const $g_aDrillLevelTotal[6] = [160, 300, 540, 840, 1280, 1800]
Global Const $g_aLSpellDmg[7] = [300, 330, 360, 390, 450, 510, 570]
Global Const $g_aEQSpellDmg[4] = [0.14, 0.17, 0.21, 0.25]
Global $g_sLastModversion = ""
Global $g_sLastModmessage = ""
Global $g_sOldModversmessage = ""
Global $g_ichkGoldTrCollect, $g_ichkElxTrCollect, $g_ichkDarkTrCollect
Global $g_ichkFullGoldTrCollect, $g_ichkFullElxTrCollect, $g_ichkFullDarkTrCollect
Global $g_itxtMinGoldTrCollect, $g_itxtMinElxTrCollect, $g_itxtMinDarkTrCollect
Global $g_ichkEnableTrCollect, $g_ichkForceTrCollect
Global $g_iMinimumPriority, $g_iMaxActionsNumber, $g_iActionToDo
Global $g_aSetActionPriority[13] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_sFrequenceChain = GetTranslated(42, 100, "Never|Sometimes|Frequently|Often|Very Often")
Global $g_sReplayChain = "1|2|4"
Global $g_ichkUseBotHumanization, $g_ichkUseAltRClick, $g_icmbMaxActionsNumber, $g_ichkCollectAchievements, $g_ichkLookAtRedNotifications
Global $g_iacmbPriority[13] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_iacmbMaxSpeed[2] = [0, 0]
Global $g_iacmbPause[2] = [0, 0]
Global $g_iahumanMessage[2] = ["", ""]
Global $g_acmbPriority[13] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_acmbMaxSpeed[2] = [0, 0]
Global $g_acmbPause[2] = [0, 0]
Global $g_ahumanMessage[2] = ["", ""]
Global $g_aReplayDuration[2] = [0, 0]
Global $g_bOnReplayWindow, $g_iReplayToPause
Global $g_iQuickMISX = 0, $g_iQuickMISY = 0
Global $g_iLastLayout = 0
Global $ichkEnableSuperXP = 0, $irbSXTraining = 1, $ichkSXBK = 0, $ichkSXAQ = 0, $ichkSXGW = 0, $iStartXP = 0, $iCurrentXP = 0, $iGainedXP = 0, $iGainedXPHour = 0, $itxtMaxXPtoGain = 500
Global $DebugSX = 0
Global Const $iDelayDropSuperXP1 = 500
Global Const $iDelayDropSuperXP3 = 250
Global $BdGoblinPicnic[3] = [0, "5000-7000", "6000-8000"]
Global $ActivatedHeroes[3] = [False, False, False]
Global Const $minStarsToEnd = 1
Global $canGainXP = False
Global $CurBaseRedLine[2] = ["", ""]
Global $DCD = "440,70|825,344|440,640|55,344"
Global $ECD = "440,22|860,344|440,670|2,344"
Global $ichkExtraPersian = 0
Global $iActivateWardenCondition = 0
Global $delayActivateW = 9
Global $HeroesTimerActivation[$eHeroCount] = [0,0,0]
Global Const $TopLeft[5][2] = [[62, 306], [156, 238], [221, 188], [288, 142], [383, 76]]
Global Const $TopRight[5][2] = [[486, 59], [586, 134], [652, 184], [720, 231], [817, 308]]
Global Const $BottomLeft[5][2] = [[20, 373], [101, 430], [171, 481], [244, 535], [346, 615]]
Global Const $BottomRight[5][2] = [[530, 615], [632, 535], [704, 481], [781, 430], [848, 373]]
Global Const $Edges[4] = [$BottomRight, $TopLeft, $BottomLeft, $TopRight]
Global $aTownHall[4] = [-1, -1, -1, -1]
Global $IMGLOCTHLOCATION
Global $IMGLOCTHNEAR
Global $IMGLOCTHFAR
Global $IMGLOCTHRDISTANCE
Global $debugDropSCommand = 0, $LocateMode = 1
Global $PixelEaglePos[2] = [-2, -2]
Global $PixelInfernoPos[2] = [-2, -2]
Global $PixelADefensePos[2] = [-2, -2]
Global $storedEaglePos = ""
Global $storedInfernoPos = ""
Global $storedADefensePos = ""
Global $DebugSideP = 0
Global $dGoldMines = @ScriptDir & "\imgxml\Storages\SideP\GoldMines", $dDarkDrills = @ScriptDir & "\imgxml\Storages\SideP\Drills", $dElixirCollectors = @ScriptDir & "\imgxml\Storages\SideP\Collectors"
Global $allMinesFound[7][3], $allCollectorsFound[7][3], $allDrillsFound[3][3]
Global $isModeActive[$g_iModeCount]
Global $g_grpVillageSW[9], $g_icnPopOutSW[9]
Global $g_lblGoldNowSW[9], $g_lblElixirNowSW[9], $g_lblDarkNowSW[9]
Global $g_lblHrStatsGoldSW[9], $g_lblHrStatsElixirSW[9], $g_lblHrStatsDarkSW[9]
Global $g_icnGoldSW[9], $g_icnElixirSW[9], $g_icnDarkSW[9]
Global $g_lblUnitMeasureSW1[9], $g_lblUnitMeasureSW2[9], $g_lblUnitMeasureSW3[9]
Global $g_icnGemSW[9], $g_icnBuliderSW[9], $g_icnHourGlassSW[9]
Global $g_lblKingStatus[9], $g_lblQueenStatus[9], $g_lblWardenStatus[9]
Global $g_lblLabStatus[9],$g_lblGemNowSW[9], $g_lblBuilderNowSW[9], $g_lblTimeNowSW[9]
Global $g_grpVillagePO[9], $g_icnPopOutEX[9]
Global $g_lblGoldNowPO[9], $g_lblElixirNowPO[9], $g_lblDarkNowPO[9]
Global $g_lblHrStatsGoldPO[9], $g_lblHrStatsElixirPO[9], $g_lblHrStatsDarkPO[9]
Global $g_icnGoldPO[9], $g_icnElixirPO[9], $g_icnDarkPO[9]
Global $g_lblUnitMeasurePO1[9], $g_lblUnitMeasurePO2[9], $g_lblUnitMeasurePO3[9]
Global $g_icnGemPO[9], $g_icnBuliderPO[9], $g_icnHourGlassPO[9]
Global $g_lblKingStatusPO[9], $g_lblQueenStatusPO[9], $g_lblWardenStatusPO[9]
Global $g_lblLabStatusPO[9],$g_lblGemNowPO[9], $g_lblBuilderNowPO[9], $g_lblTimeNowPO[9]
Global $hGuiPopOut , $hGuiPopOut0, $hGuiPopOut1, $hGuiPopOut2, $hGuiPopOut3
Global $hGuiPopOut4, $hGuiPopOut5, $hGuiPopOut6, $hGuiPopOut7, $hGuiPopOut8
Global $g_iMonitorX, $g_iMonitorY
Global $g_iFreeBuilderCount[9], $g_iTotalBuilderCount[9], $g_iGemAmount[9]
Global $g_iStatsCurrent[9][$eLootCount] = [[0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0]]
Global $g_iStatsStartedWith[9][$eLootCount] = [[0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0]]
Global $g_iStatsLastAttack[9][$eLootCount] = [[0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0]]
Global $g_iStatsBonusLast[9][$eLootCount] = [[0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0]]
Global $g_iStatsTotalGain[9][$eLootCount] = [[0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0]]
Global $g_iSkippedVillageCount[9], $g_iDroppedTrophyCount[9]
Global $g_iSearchCost[9], $g_iTrainCostElixir[9], $g_iTrainCostDElixir[9]
Global $g_iGoldFromMines[9], $g_iElixirFromCollectors[9], $g_iDElixirFromDrills[9]
Global $g_iNbrOfWallsUppedGold[9], $g_iNbrOfWallsUppedElixir[9], $g_iNbrOfBuildingsUppedGold[9], $g_iNbrOfBuildingsUppedElixir[9], $g_iNbrOfHeroesUpped[9]
Global $g_iCostGoldWall[9], $g_iCostElixirWall[9], $g_iCostGoldBuilding[9], $g_iCostElixirBuilding[9], $g_iCostDElixirHero[9]
Global $g_iAttackedVillageCount[9][$g_iModeCount + 3]
Global $g_iTotalGoldGain[9][$g_iModeCount + 3], $g_iTotalElixirGain[9][$g_iModeCount + 3], $g_iTotalDarkGain[9][$g_iModeCount + 3], $g_iTotalTrophyGain[9][$g_iModeCount + 3]
Global $g_iNbrOfDetectedMines[9][$g_iModeCount + 3], $g_iNbrOfDetectedCollectors[9][$g_iModeCount + 3], $g_iNbrOfDetectedDrills[9][$g_iModeCount + 3]
Global $g_iNbrOfTHSnipeFails[9], $g_iNbrOfTHSnipeSuccess[9]
Global $g_iSmartZapGain[9], $g_iNumEQSpellsUsed[9], $g_iNumLSpellsUsed[9]
Global $Init = False, $FirstInit = True, $ichkSwitchAccount
Global $SSAConfig = $g_sProfilePath & "\Profile.ini"
Global $SSAAtkLog = $g_sProfilePath & "\SmartSwitchAccount_Attack_Report.txt"
Global $ichkCanUse[9] = [0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $ichkDonateAccount[9] = [0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $icmbAccount[9] = [0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $isModeActive[$g_iModeCount]
Global $DonationWindowY = 0
Global $g_bSwitchAcctPrereq = False
Global $AllAccountsWaitTimeDiff[9] = [0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $AllAccountsWaitTime[9] = [0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $TimerDiffStart[9] = [0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $TimerDiffEnd[9] = [0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $CurrentAccountWaitTime = 0
Global $TotalAccountsOnEmu = 0, $CurrentDAccount = 1, $FirstLoop = 0
Global $MustGoToDonateAccount = 0
Global $yCoord, $HeroesRemainingWait, $TotalAccountsInUse, $TotalDAccountsInUse, $NextAccount, $NextProfile
Global $AlreadyConnected, $IsLoadButton, $NextStep, $LastDate = ""
Global Const $iDelaySleep = 100
Global Const $iDelayWaitForPopup = 1500
Global Const $iDelayCloudsCleared = 1000
Global Const $iDelayRespond = 5
Global Const $iDelayRunBot1 = 1000
Global Const $iDelayRunBot2 = 800
Global Const $iDelayRunBot3 = 200
Global Const $iDelayRunBot5 = 500
Global Const $iDelayRunBot6 = 100
Global Const $iDelayIdle1 = 200
Global Const $iDelayIdle2 = 1500
Global Const $iDelaySmartWait = 500
Global Const $iDelayAttackMain1 = 1000
Global Const $iDelayAttackMain2 = 1500
Global Const $iDelayAttackTHGrid1 = 500
Global Const $iDelayCastSpell1 = 10
Global Const $iDelayalgorithm_AllTroops1 = 2000
Global Const $iDelayalgorithm_AllTroops2 = 1000
Global Const $iDelayalgorithm_AllTroops3 = $iDelayWaitForPopup
Global Const $iDelayalgorithm_AllTroops4 = 100
Global Const $iDelayalgorithm_AllTroops5 = 500
Global Const $iDelayBarch1 = 100
Global Const $iDelayBarch2 = 500
Global Const $iDelayBarch3 = 1000
Global Const $iDelayAttackReport1 = 500
Global Const $iDelayAttackReport2 = 150
Global Const $iDelaydropCC1 = 500
Global Const $iDelaydropCC2 = 500
Global Const $iDelaydropHeroes1 = 300
Global Const $iDelaydropHeroes2 = 500
Global Const $iDelayGoldElixirChange1 = 500
Global Const $iDelayGoldElixirChange2 = 1000
Global Const $iDelayGoldElixirChangeEBO1 = 500
Global Const $iDelayGoldElixirChangeEBO2 = 1000
Global Const $iDelayPrepareAttack1 = 250
Global Const $iDelayDropOnPixel1 = 50
Global Const $iDelayDropOnPixel2 = 250
Global Const $iDelayDropTroop1 = 100
Global Const $iDelayDropTroop2 = 300
Global Const $iDelayReturnHome1 = 1000
Global Const $iDelayReturnHome2 = 1500
Global Const $iDelayReturnHome3 = 2500
Global Const $iDelayReturnHome4 = 2000
Global Const $iDelayReturnHome5 = 200
Global Const $iDelayDropOnEdge1 = 100
Global Const $iDelayDropOnEdge2 = 300
Global Const $iDelayDropOnEdge3 = 50
Global Const $iDelayLaunchTroop21 = 100
Global Const $iDelayLaunchTroop22 = 1000
Global Const $iDelayLaunchTroop23 = 300
Global Const $iDelayOldDropTroop1 = 100
Global Const $iDelayOldDropTroop2 = 50
Global Const $iDelayUnbreakable1 = 1000
Global Const $iDelayUnbreakable2 = 2000
Global Const $iDelayUnbreakable3 = 3000
Global Const $iDelayUnbreakable4 = 5000
Global Const $iDelayUnbreakable6 = 30000
Global Const $iDelayUnbreakable7 = 100
Global Const $iDelayUnbreakable8 = 50
Global Const $iDelayCheckTombs1 = 500
Global Const $iDelayCheckTombs2 = 2000
Global Const $iDelaycheckMainScreen1 = 1000
Global Const $iDelaycheckObstacles1 = 1000
Global Const $iDelaycheckObstacles2 = 2000
Global Const $iDelaycheckObstacles3 = 5000
Global Const $iDelaycheckObstacles4 = 120000
Global Const $iDelaycheckObstacles6 = 300000
Global Const $iDelaycheckObstacles7 = 600000
Global Const $iDelaycheckObstacles8 = 900000
Global Const $iDelaycheckObstacles9 = 1200000
Global Const $iDelaycheckObstacles10 = 1800000
Global Const $iDelayisGemOpen1 = 350
Global Const $iDelaywaitMainScreen1 = 2000
Global Const $iDelayZoomOut1 = 1500
Global Const $iDelayZoomOut2 = 200
Global Const $iDelayZoomOut3 = 1000
Global Const $iDelayBlockInput1 = 10
Global Const $iDelayCheckVersionHTML1 = 250
Global Const $iDelayDownloadLicense = 250
Global Const $iDelayTogglePause1 = 100
Global Const $iDelayTogglePause2 = 250
Global Const $iDelayWindowsArrange1 = 500
Global Const $iDelayBuildingInfo1 = 1500
Global Const $iDelayGetResources1 = 250
Global Const $iDelayGetResources3 = 150
Global Const $iDelayPrepareSearch1 = 1000
Global Const $iDelayPrepareSearch2 = 2000
Global Const $iDelayPrepareSearch3 = 500
Global Const $iDelayVillageSearch1 = 1000
Global Const $iDelayVillageSearch2 = 100
Global Const $iDelayVillageSearch3 = 500
Global Const $iDelayBoostBarracks2 = 2000
Global Const $iDelayBoostBarracks5 = 200
Global Const $iDelayBoostSpellFactory3 = 500
Global Const $iDelayBoostHeroes1 = 1000
Global Const $iDelayBoostHeroes2 = 2000
Global Const $iDelayBoostHeroes3 = 500
Global Const $iDelayBoostHeroes4 = 600
Global Const $iDelayBotCommand1 = 500
Global Const $iDelayBotDetectFirstTime1 = 1000
Global Const $iDelayBotDetectFirstTime3 = 100
Global Const $iDelaycheckArmyCamp4 = 500
Global Const $iDelaycheckArmyCamp5 = 250
Global Const $iDelaycheckArmyCamp6 = 10
Global Const $iDelayCheckFullArmy1 = 100
Global Const $iDelayCheckFullArmy2 = 200
Global Const $iDelayCheckFullArmy3 = 500
Global Const $iDelayCollect1 = 100
Global Const $iDelayCollect2 = 250
Global Const $iDelayCollect3 = 500
Global Const $iDelayDonateCC1 = 200
Global Const $iDelayDonateCC2 = 250
Global Const $iDelayDonateCC3 = 50
Global Const $iDelayDonateCC4 = 1250
Global Const $iDelayDonateWindow1 = 250
Global Const $iDelayDropTrophy1 = 1000
Global Const $iDelayDropTrophy4 = 250
Global Const $iDelayGetTownHallLevel1 = 1000
Global Const $iDelayGetTownHallLevel2 = 1500
Global Const $iDelayGetTownHallLevel3 = 200
Global Const $iDelayLaboratory1 = 750
Global Const $iDelayLaboratory2 = 200
Global Const $iDelayLaboratory3 = 1000
Global Const $iDelayLaboratory4 = 200
Global Const $iDelayLabUpgrade1 = 1000
Global Const $iDelayLabUpgrade2 = 200
Global Const $iDelayLabUpgrade3 = 200
Global Const $iDelayLocateTownHall1 = 1000
Global Const $iDelayCheckUpgrades1 = 1000
Global Const $iDelayUpgradeValue1 = 200
Global Const $iDelayUpgradeValue2 = 800
Global Const $iDelayUpgradeValue3 = 750
Global Const $iDelayUpgradeValue4 = 1000
Global Const $iDelayDebugImageSave1 = 200
Global Const $iDelayProfileReport1 = 500
Global Const $iDelayProfileReport2 = 1000
Global Const $iDelayProfileReport3 = 200
Global Const $iDelayReportPushBullet1 = 500
Global Const $iDelayPushMsg1 = 500
Global Const $iDelayPushMsg2 = 1000
Global Const $iDelayReArm1 = 500
Global Const $iDelayReArm2 = 1500
Global Const $iDelayReArm3 = 700
Global Const $iDelayReArm4 = 200
Global Const $iDelayReplayShare1 = 250
Global Const $iDelayReplayShare2 = 500
Global Const $iDelayReplayShare3 = 1000
Global Const $iDelayReplayShare4 = 2000
Global Const $iDelayRequestCC1 = 500
Global Const $iDelaymakerequest1 = 500
Global Const $iDelaymakerequest2 = 1500
Global Const $iDelayTrain4 = 200
Global Const $iDelayTrain6 = 20
Global Const $iDelayTrain8 = 5000
Global Const $iDelayLvUP = 150
Global Const $iDelayIsTrainPage1 = 100
Global Const $iDelayUpgradeBuilding1 = 200
Global Const $iDelayUpgradeBuilding2 = 500
Global Const $iDelayUpgradeNormal1 = 700
Global Const $iDelayUpgradeNormal2 = 200
Global Const $iDelayUpgradeNormal3 = 750
Global Const $iDelayUpgradeHero1 = 800
Global Const $iDelayUpgradeHero2 = 500
Global Const $iDelayUpgradeHero3 = 1000
Global Const $iDelayUpgradeWall1 = 500
Global Const $iDelayUpgradeWallGold2 = 1000
Global Const $iDelayUpgradeWallGold3 = 500
Global Const $iDelayUpgradeWallElixir2 = 1000
Global Const $iDelayUpgradeWallElixir3 = 500
Global Const $iDelayVillageReport1 = 500
Global Const $iDelayWaitnOpenCoC10000 = 10000
Global Const $iDelaySWHTSearchLimit1 = 200
Global Const $iDelayImageType1 = 100
Global Const $iSpecialClick1 = 200
Global Const $iSpecialClick2 = 100
Global Const $iPersonalShield1 = 1000
Global Const $iPersonalShield2 = 500
Global Const $iPersonalShield3 = 100
Global Const $iDelayStarBonus100 = 100
Global Const $iDelayStarBonus500 = 500
Global Const $iDelayAttackDisable100 = 100
Global Const $iDelayAttackDisable500 = 500
Global Const $iDelayWaitAttack1 = 60000
Global Const $iDelayWaitAttack2 = 300000
Global Const $iDelayCloseOpen1000 = 1000
Global Const $iDelayCloseOpen2000 = 2000
Global Const $iDelayCloseOpen3000 = 3000
Global $DelaySmartZap1 = 1000
Global $DelaySmartZap4 = 4000
Global $g_hSplash = 0, $g_hSplashProgress, $g_lSplashStatus, $g_lSplashTitle
Global Const $g_iSplashTotalSteps = 10
Global $g_iSplashCurrentStep = 0
Global $g_hSplashTimer = 0
Func SplashStep($status, $bIncreaseStep = True)
If $bIncreaseStep = True Then $g_iSplashCurrentStep += 1
SetDebugLog("SplashStep " & $g_iSplashCurrentStep & " of " & $g_iSplashTotalSteps & ": " & $status & "(" & Round(TimerDiff($g_hSplashTimer)/1000, 2) & " sec)")
If $ichkDisableSplash = 1 Then Return
GUICtrlSetData($g_hSplashProgress,($g_iSplashCurrentStep / $g_iSplashTotalSteps) * 100)
GUICtrlSetData($g_lSplashStatus, $status)
EndFunc
Func UpdateSplashTitle($title)
SetDebugLog("UpdateSplashTitle: " & $title)
If $ichkDisableSplash = 1 Then Return
GUICtrlSetData($g_lSplashTitle, $title)
EndFunc
Func DestroySplashScreen()
If IsHWnd($g_hSplash) Then GUIDelete($g_hSplash)
EndFunc
Func CreateSplashScreen()
Local $sSplashImg = $g_sLogoPath
Local $hImage, $iX, $iY
Local $iT = 20
Local $iB = 10
If $ichkDisableSplash = 0 Then
Local $hSplashImg = _GDIPlus_BitmapCreateFromFile($sSplashImg)
$iX = _GDIPlus_ImageGetWidth($hSplashImg)
$iY = _GDIPlus_ImageGetHeight($hSplashImg)
$g_hSplash = GUICreate("", $iX, $iY + $iT + $iB + 60, -1, -1, BitOR($WS_POPUP, $WS_BORDER), BitOR($WS_EX_TOPMOST, $WS_EX_WINDOWEDGE, $WS_EX_TOOLWINDOW))
GUISetBkColor($COLOR_WHITE, $g_hSplash)
_GUICtrlCreatePic($hSplashImg, 0, $iT)
$g_lSplashTitle = GUICtrlCreateLabel($g_sBotTitle, 15, $iY + $iT + $iB + 3, $iX - 30, 15, $SS_CENTER)
$g_hSplashProgress = GUICtrlCreateProgress(15, $iY + $iT + $iB + 20, $iX - 30, 10, $PBS_SMOOTH, BitOR($WS_EX_TOPMOST, $WS_EX_WINDOWEDGE, $WS_EX_TOOLWINDOW))
$g_lSplashStatus = GUICtrlCreateLabel("", 15, $iY + $iT + $iB + 38, $iX - 30, 15, $SS_CENTER)
_GDIPlus_BitmapDispose($hSplashImg)
GUISetState(@SW_SHOWNOACTIVATE, $g_hSplash)
$g_hSplashTimer = TimerInit()
EndIf
EndFunc
Global $aCenterEnemyVillageClickDrag = [65, 545]
Global $aCenterHomeVillageClickDrag = [160, 665]
Global $aIsReloadError[4] = [457, 301 + $g_iMidOffsetY, 0x33B5E5, 10]
Global $aIsMain[4] = [283, 29, 0x4693BD, 20]
Global $aIsDPI125[4] = [355, 35, 0x399CB8, 15]
Global $aIsDPI150[4] = [426, 42, 0x348FAA, 15]
Global $aIsMainGrayed[4] = [284, 29, 0x120808, 15]
Global $aTopLeftClient[4] = [1, 1, 0x000000, 0]
Global $aTopRightClient[4] = [850, 1, 0x000000, 0]
Global $aIsInactive[4] = [457, 300 + $g_iMidOffsetY, 0x33B5E5, 20]
Global $aIsConnectLost[4] = [255, 271 + $g_iMidOffsetY, 0x33B5E5, 20]
Global $aIsCheckOOS[4] = [223, 272 + $g_iMidOffsetY, 0x33B5E5, 20]
Global $aIsMaintenance[4] = [350, 273 + $g_iMidOffsetY, 0x33B5E5, 20]
Global $aReloadButton[4] = [443, 408 + $g_iMidOffsetY, 0x282828, 10]
Global $aAttackButton[2] = [60, 614 + $g_iBottomOffsetY]
Global $aFindMatchButton[4] = [195, 480 + $g_iBottomOffsetY, 0xF0B028, 10]
Global $aFindMatchButton2[4] = [195, 480 + $g_iBottomOffsetY, 0xD84D00, 10]
Global $aIsAttackShield[4] = [250, 415 + $g_iMidOffsetY, 0xE8E8E0, 10]
Global $aAway[2] = [1, 40]
Global $aRemoveShldButton[4] = [470, 18, 0xA80408, 10]
Global $aNoShield[4] = [448, 20, 0x43484B, 15]
Global $aHaveShield[4] = [455, 19, 0xF0F8FB, 15]
Global $aHavePerGuard[4] = [455, 19, 0x12120E, 15]
Global $aShieldInfoButton[4] = [472, 11, 0x6DB0D3, 10]
Global $aIsShieldInfo[4] = [645, 195, 0xE00408, 20]
Global $aSurrenderButton[4] = [70, 545 + $g_iBottomOffsetY, 0xC00000, 40]
Global $aConfirmSurrender[4] = [500, 415 + $g_iMidOffsetY, 0x60AC10, 20]
Global $aCancelFight[4] = [822, 48, 0xD80408, 20]
Global $aCancelFight2[4] = [830, 59, 0xD80408, 20]
Global $aEndFightSceneBtn[4] = [429, 519 + $g_iMidOffsetY, 0xB8E35F, 20]
Global $aEndFightSceneAvl[4] = [241, 196 + $g_iMidOffsetY, 0xFFF090, 20]
Global $aReturnHomeButton[4] = [376, 567 + $g_iMidOffsetY, 0x60AC10, 20]
Global $aChatTab[4] = [331, 330 + $g_iMidOffsetY, 0xF0951D, 20]
Global $aOpenChat[2] = [19, 349 + $g_iMidOffsetY]
Global $aClanTab[2] = [189, 24]
Global $aArmyCampSize[2] = [110, 136 + $g_iMidOffsetY]
Global $aArmySpellSize[2] = [99, 284 + $g_iMidOffsetY]
Global $aArmyCCRemainTime[2] = [725, 517 + $g_iMidOffsetY]
Global $aIsCampFull[4] = [128, 151 + $g_iMidOffsetY, 0xFFFFFF, 10]
Global $aBarrackFull[4] = [388, 154 + $g_iMidOffsetY, 0xE84D50, 20]
Global $aBuildersDigits[2] = [324, 21]
Global $aTrophies[2] = [72, 85]
Global $aNoCloudsAttack[4] = [25, 606, 0xC00000, 10]
Global $aMessageButton[2] = [38, 143]
Global $aArmyTrainButton[2] = [40, 525 + $g_iBottomOffsetY]
Global $aWonOneStar[4] = [714, 538 + $g_iBottomOffsetY, 0xC0C8C0, 20]
Global $aWonTwoStar[4] = [739, 538 + $g_iBottomOffsetY, 0xC0C8C0, 20]
Global $aArmyOverviewTest[4] = [150, 554 + $g_iMidOffsetY, 0xBC2BD1, 20]
Global $aCancRequestCCBtn[4] = [340, 250, 0xCC4010, 20]
Global $aSendRequestCCBtn[2] = [524, 250]
Global $atxtRequestCCBtn[2] = [430, 140]
Global $aIsAtkDarkElixirFull[4] = [743, 62 + $g_iMidOffsetY, 0x1A0026, 10]
Global $aIsDarkElixirFull[4] = [710, 107 + $g_iMidOffsetY, 0x1A0026, 10]
Global $aIsGoldFull[4] = [661, 6 + $g_iMidOffsetY, 0xDAB300, 10]
Global $aIsElixirFull[4] = [661, 57 + $g_iMidOffsetY, 0xB31AB3, 10]
Global $aPerkBtn[4] = [95, 243 + $g_iMidOffsetY, 0x7cd8e8, 10]
Global $aIsGemWindow1[4] = [573, 256 + $g_iMidOffsetY, 0xDD0408, 20]
Global $aIsGemWindow2[4] = [577, 266 + $g_iMidOffsetY, 0xBF1218, 20]
Global $aIsGemWindow3[4] = [586, 266 + $g_iMidOffsetY, 0xBC1218, 20]
Global $aIsGemWindow4[4] = [595, 266 + $g_iMidOffsetY, 0xBC1218, 20]
Global $aLootCartBtn[2] = [430, 640 + $g_iBottomOffsetY]
Global $aCleanYard[4] = [418, 587 + $g_iBottomOffsetY, 0xE1debe, 20]
Global $aIsTrainPgChk1[4] = [812, 97 + $g_iMidOffsetY, 0xE0070A, 10]
Global $aRtnHomeCloud1[4] = [56, 592 + $g_iBottomOffsetY, 0x0A223F, 15]
Global $aRtnHomeCloud2[4] = [72, 592 + $g_iBottomOffsetY, 0x103F7E, 15]
Global $aDetectLang[2] = [16, 634 + $g_iBottomOffsetY]
Global $aGreenArrowTrainTroops[2] = [389, 126]
Global $aGreenArrowBrewSpells[2] = [586, 126]
Global $g_aShopWindowOpen[4] = [804, 54, 0xC00508, 15]
Global $aKingHealth = [-1, 569 + $g_iBottomOffsetY, 0x543e20, 15]
Global $aQueenHealth = [-1, 569 + $g_iBottomOffsetY, 0x4b35b5, 15]
Global $aWardenHealth = [-1, 569 + $g_iBottomOffsetY, 0xd2696c, 15]
Global $aWonOneStarAtkRprt[4] = [325, 180 + $g_iMidOffsetY, 0xC8CaC4, 30]
Global $aWonTwoStarAtkRprt[4] = [398, 180 + $g_iMidOffsetY, 0xD0D6D0, 30]
Global $aWonThreeStarAtkRprt[4] = [534, 180 + $g_iMidOffsetY, 0xC8CAC7, 30]
Global $NextBtn[4] = [780, 546 + $g_iBottomOffsetY, 0xD34300, 20]
Global $aRequestTroopsAO[6] = [737, 565, 0xa2d44a, 0x808182, 0xb6b6b6, 10]
Global Const $aOpenChatTab[4] = [19, 335 + $g_iMidOffsetY, 0xE88D27, 20]
Global Const $aCloseChat[4] = [331, 330 + $g_iMidOffsetY, 0xF0951D, 20]
Global Const $aChatDonateBtnColors[4][4] = [[0x050505, 0, -4, 30], [0x89CA31, 0, 13, 15], [0x89CA31, 0, 16, 15], [0xFFFFFF, 21, 7, 5]]
Global Const $aAtkRprtDECheck[4] = [459, 372 + $g_iMidOffsetY, 0x433350, 20]
Global Const $aAtkRprtTrophyCheck[4] = [327, 189 + $g_iMidOffsetY, 0x3B321C, 30]
Global Const $aAtkRprtDECheck2[4] = [678, 418 + $g_iMidOffsetY, 0x030000, 30]
Global Const $aRtnHomeCheck1[4] = [363, 548 + $g_iMidOffsetY, 0x78C11C, 20]
Global Const $aRtnHomeCheck2[4] = [497, 548 + $g_iMidOffsetY, 0x79C326, 20]
Global Const $aIsAttackPage[4] = [70, 548 + $g_iBottomOffsetY, 0xC80000, 20]
Global Const $ProfileRep01[4] = [600, 260, 0x71769F, 20]
Global $aArmyTrainButtonRND[4] = [20, 540 + $g_iMidOffsetY, 55, 570 + $g_iMidOffsetY]
Global $aAttackButtonRND[4] = [20, 610 + $g_iMidOffsetY, 100, 670 + $g_iMidOffsetY]
Global $aFindMatchButtonRND[4] = [200, 510 + $g_iMidOffsetY, 300, 530 + $g_iMidOffsetY]
Global $NextBtnRND[4] = [710, 530 + $g_iMidOffsetY, 830, 570 + $g_iMidOffsetY]
Func _StringSize($sText, $iSize = 8.5, $iWeight = 400, $iAttrib = 0, $sName = "", $iMaxWidth = 0, $hWnd = 0)
If $iSize = Default Then $iSize = 8.5
If $iWeight = Default Then $iWeight = 400
If $iAttrib = Default Then $iAttrib = 0
If $sName = "" Or $sName = Default Then $sName = _StringSize_DefaultFontName()
If Not IsString($sText) Then Return SetError(1, 1, 0)
If Not IsNumber($iSize) Then Return SetError(1, 2, 0)
If Not IsInt($iWeight) Then Return SetError(1, 3, 0)
If Not IsInt($iAttrib) Then Return SetError(1, 4, 0)
If Not IsString($sName) Then Return SetError(1, 5, 0)
If Not IsNumber($iMaxWidth) Then Return SetError(1, 6, 0)
If Not IsHwnd($hWnd) And $hWnd <> 0 Then Return SetError(1, 7, 0)
Local $aRet, $hDC, $hFont, $hLabel = 0, $hLabel_Handle
Local $iExpTab = BitAnd($iAttrib, 1)
$iAttrib = BitAnd($iAttrib, BitNot(1))
If IsHWnd($hWnd) Then
$hLabel = GUICtrlCreateLabel("", -10, -10, 10, 10)
$hLabel_Handle = GUICtrlGetHandle(-1)
GUICtrlSetFont(-1, $iSize, $iWeight, $iAttrib, $sName)
$aRet = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hLabel_Handle)
If @error Or $aRet[0] = 0 Then
GUICtrlDelete($hLabel)
Return SetError(2, 1, 0)
EndIf
$hDC = $aRet[0]
$aRet = DllCall("user32.dll", "lparam", "SendMessage", "hwnd", $hLabel_Handle, "int", 0x0031, "wparam", 0, "lparam", 0)
If @error Or $aRet[0] = 0 Then
GUICtrlDelete($hLabel)
Return SetError(2, _StringSize_Error_Close(2, $hDC), 0)
EndIf
$hFont = $aRet[0]
Else
$aRet = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hWnd)
If @error Or $aRet[0] = 0 Then Return SetError(2, 1, 0)
$hDC = $aRet[0]
$aRet = DllCall("gdi32.dll", "int", "GetDeviceCaps", "handle", $hDC, "int", 90)
If @error Or $aRet[0] = 0 Then Return SetError(2, _StringSize_Error_Close(3, $hDC), 0)
Local $iInfo = $aRet[0]
$aRet = DllCall("gdi32.dll", "handle", "CreateFontW", "int", -$iInfo * $iSize / 72, "int", 0, "int", 0, "int", 0, "int", $iWeight, "dword", BitAND($iAttrib, 2), "dword", BitAND($iAttrib, 4), "dword", BitAND($iAttrib, 8), "dword", 0, "dword", 0, "dword", 0, "dword", 5, "dword", 0, "wstr", $sName)
If @error Or $aRet[0] = 0 Then Return SetError(2, _StringSize_Error_Close(4, $hDC), 0)
$hFont = $aRet[0]
EndIf
$aRet = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hDC, "handle", $hFont)
If @error Or $aRet[0] = 0 Then Return SetError(2, _StringSize_Error_Close(5, $hDC, $hFont, $hLabel), 0)
Local $hPrevFont = $aRet[0]
Local $avSize_Info[4], $iLine_Length, $iLine_Height = 0, $iLine_Count = 0, $iLine_Width = 0, $iWrap_Count, $iLast_Word, $sTest_Line
Local $tSize = DllStructCreate("int X;int Y")
DllStructSetData($tSize, "X", 0)
DllStructSetData($tSize, "Y", 0)
$sText = StringRegExpReplace($sText, "((?<!\x0d)\x0a|\x0d(?!\x0a))", @CRLF)
Local $asLines = StringSplit($sText, @CRLF, 1)
For $i = 1 To $asLines[0]
If $iExpTab Then
$asLines[$i] = StringReplace($asLines[$i], @TAB, " XXXXXXXX")
EndIf
$iLine_Length = StringLen($asLines[$i])
DllCall("gdi32.dll", "bool", "GetTextExtentPoint32W", "handle", $hDC, "wstr", $asLines[$i], "int", $iLine_Length, "ptr", DllStructGetPtr($tSize))
If @error Then Return SetError(2, _StringSize_Error_Close(6, $hDC, $hFont, $hLabel), 0)
If DllStructGetData($tSize, "X") > $iLine_Width Then $iLine_Width = DllStructGetData($tSize, "X")
If DllStructGetData($tSize, "Y") > $iLine_Height Then $iLine_Height = DllStructGetData($tSize, "Y")
Next
If $iMaxWidth <> 0 And $iLine_Width > $iMaxWidth Then
For $j = 1 To $asLines[0]
$iLine_Length = StringLen($asLines[$j])
DllCall("gdi32.dll", "bool", "GetTextExtentPoint32W", "handle", $hDC, "wstr", $asLines[$j], "int", $iLine_Length, "ptr", DllStructGetPtr($tSize))
If @error Then Return SetError(2, _StringSize_Error_Close(6, $hDC, $hFont, $hLabel), 0)
If DllStructGetData($tSize, "X") < $iMaxWidth - 4 Then
$iLine_Count += 1
$avSize_Info[0] &= $asLines[$j] & @CRLF
Else
$iWrap_Count = 0
While 1
$iLine_Width = 0
$iLast_Word = 0
For $i = 1 To StringLen($asLines[$j])
If StringMid($asLines[$j], $i, 1) = " " Then $iLast_Word = $i - 1
$sTest_Line = StringMid($asLines[$j], 1, $i)
$iLine_Length = StringLen($sTest_Line)
DllCall("gdi32.dll", "bool", "GetTextExtentPoint32W", "handle", $hDC, "wstr", $sTest_Line, "int", $iLine_Length, "ptr", DllStructGetPtr($tSize))
If @error Then Return SetError(2, _StringSize_Error_Close(6, $hDC, $hFont, $hLabel), 0)
$iLine_Width = DllStructGetData($tSize, "X")
If $iLine_Width >= $iMaxWidth - 4 Then ExitLoop
Next
If $i > StringLen($asLines[$j]) Then
$iWrap_Count += 1
$avSize_Info[0] &= $sTest_Line & @CRLF
ExitLoop
Else
$iWrap_Count += 1
If $iLast_Word = 0 Then Return SetError(3, _StringSize_Error_Close(0, $hDC, $hFont, $hLabel), 0)
$avSize_Info[0] &= StringLeft($sTest_Line, $iLast_Word) & @CRLF
$asLines[$j] = StringTrimLeft($asLines[$j], $iLast_Word)
$asLines[$j] = StringStripWS($asLines[$j], 1)
EndIf
WEnd
$iLine_Count += $iWrap_Count
EndIf
Next
If $iExpTab Then
$avSize_Info[0] = StringRegExpReplace($avSize_Info[0], "\x20?XXXXXXXX", @TAB)
EndIf
$avSize_Info[1] = $iLine_Height
$avSize_Info[2] = $iMaxWidth
$avSize_Info[3] =($iLine_Count * $iLine_Height) + 4
Else
Local $avSize_Info[4] = [$sText, $iLine_Height, $iLine_Width,($asLines[0] * $iLine_Height) + 4]
EndIf
DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hDC, "handle", $hPrevFont)
DllCall("gdi32.dll", "bool", "DeleteObject", "handle", $hFont)
DllCall("user32.dll", "int", "ReleaseDC", "hwnd", 0, "handle", $hDC)
If $hLabel Then GUICtrlDelete($hLabel)
$tSize = 0
Return $avSize_Info
EndFunc
Func _StringSize_Error_Close($iExtCode, $hDC = 0, $hFont = 0, $hLabel = 0)
If $hFont <> 0 Then DllCall("gdi32.dll", "bool", "DeleteObject", "handle", $hFont)
If $hDC <> 0 Then DllCall("user32.dll", "int", "ReleaseDC", "hwnd", 0, "handle", $hDC)
If $hLabel Then GUICtrlDelete($hLabel)
Return $iExtCode
EndFunc
Func _StringSize_DefaultFontName()
Local $tNONCLIENTMETRICS = DllStructCreate("uint;int;int;int;int;int;byte[60];int;int;byte[60];int;int;byte[60];byte[60];byte[60]")
DLLStructSetData($tNONCLIENTMETRICS, 1, DllStructGetSize($tNONCLIENTMETRICS))
DLLCall("user32.dll", "int", "SystemParametersInfo", "int", 41, "int", DllStructGetSize($tNONCLIENTMETRICS), "ptr", DllStructGetPtr($tNONCLIENTMETRICS), "int", 0)
Local $tLOGFONT = DllStructCreate("long;long;long;long;long;byte;byte;byte;byte;byte;byte;byte;byte;char[32]", DLLStructGetPtr($tNONCLIENTMETRICS, 13))
$tNONCLIENTMETRICS = 0
If IsString(DllStructGetData($tLOGFONT, 14)) Then
Local $iVal = DllStructGetData($tLOGFONT, 14)
$tLOGFONT = 0
Return $iVal
Else
$tLOGFONT = 0
Return "Tahoma"
EndIf
EndFunc
Global $g_aEMB_Settings[13]
Global $g_aEMB_TempArray = __EMB_GetDefaultFont()
$g_aEMB_Settings[10] = $g_aEMB_TempArray[0]
$g_aEMB_Settings[11] = $g_aEMB_TempArray[1]
$g_aEMB_TempArray = DllCall("User32.dll", "int", "GetSysColor", "int", 15)
$g_aEMB_Settings[8] = BitAND(BitShift(String(Binary($g_aEMB_TempArray[0])), 8), 0xFFFFFF)
$g_aEMB_TempArray = DllCall("User32.dll", "int", "GetSysColor", "int", 8)
$g_aEMB_Settings[9] = BitAND(BitShift(String(Binary($g_aEMB_TempArray[0])), 8), 0xFFFFFF)
$g_aEMB_TempArray = DllCall("user32.dll", "int", "GetSystemMetrics", "int", 11)
$g_aEMB_Settings[12] = $g_aEMB_TempArray[0]
$g_aEMB_TempArray = DllCall("user32.dll", "int", "GetSystemMetrics", "int", 30)
$g_aEMB_Settings[12] +=(($g_aEMB_TempArray[0] < 30) ?($g_aEMB_TempArray[0] * 3) :($g_aEMB_TempArray[0]) )
$g_aEMB_TempArray = 0
$g_aEMB_TempArray = DllCall("dwmapi.dll", "uint", "DwmIsCompositionEnabled", "int*", $g_aEMB_TempArray)
If Not @error And $g_aEMB_TempArray[1] = True Then
$g_aEMB_TempArray = DllCall("user32.dll", "int", "GetSystemMetrics", "int", 7)
$g_aEMB_Settings[12] +=($g_aEMB_TempArray[0] * 4)
EndIf
$g_aEMB_TempArray = 0
$g_aEMB_Settings[0] = 0
$g_aEMB_Settings[1] = 0
$g_aEMB_Settings[2] = $g_aEMB_Settings[8]
$g_aEMB_Settings[3] = $g_aEMB_Settings[9]
$g_aEMB_Settings[4] = $g_aEMB_Settings[10]
$g_aEMB_Settings[5] = $g_aEMB_Settings[11]
$g_aEMB_Settings[6] = 370
$g_aEMB_Settings[7] = 500
Func _ExtMsgBoxSet($iStyle = -1, $iJust = -1, $iBkCol = -1, $iCol = -1, $iFont_Size = -1, $sFont_Name = -1, $iWidth = -1, $iWidth_Abs = -1)
Switch $iStyle
Case Default
$g_aEMB_Settings[0] = 0
$g_aEMB_Settings[1] = 0
$g_aEMB_Settings[2] = $g_aEMB_Settings[8]
$g_aEMB_Settings[3] = $g_aEMB_Settings[9]
$g_aEMB_Settings[5] = $g_aEMB_Settings[11]
$g_aEMB_Settings[4] = $g_aEMB_Settings[10]
$g_aEMB_Settings[6] = 370
$g_aEMB_Settings[7] = 370
Return
Case -1
Case 0 To 127
$g_aEMB_Settings[0] = Int($iStyle)
Case Else
Return SetError(1, 1, 0)
EndSwitch
Switch $iJust
Case Default
$g_aEMB_Settings[1] = 0
Case -1
Case 0, 1, 2, 4, 5, 6
$g_aEMB_Settings[1] = $iJust
Case Else
Return SetError(1, 2, 0)
EndSwitch
Switch $iBkCol
Case Default
$g_aEMB_Settings[2] = $g_aEMB_Settings[8]
Case -1
Case 0 To 0xFFFFFF
$g_aEMB_Settings[2] = Int($iBkCol)
Case Else
Return SetError(1, 3, 0)
EndSwitch
Switch $iCol
Case Default
$g_aEMB_Settings[3] = $g_aEMB_Settings[9]
Case -1
Case 0 To 0xFFFFFF
$g_aEMB_Settings[3] = Int($iCol)
Case Else
Return SetError(1, 4, 0)
EndSwitch
Switch $iFont_Size
Case Default
$g_aEMB_Settings[4] = $g_aEMB_Settings[10]
Case -1
Case 8 To 72
$g_aEMB_Settings[4] = Int($iFont_Size)
Case Else
Return SetError(1, 5, 0)
EndSwitch
Switch $sFont_Name
Case Default
$g_aEMB_Settings[5] = $g_aEMB_Settings[11]
Case -1
Case Else
If IsString($sFont_Name) Then
$g_aEMB_Settings[5] = $sFont_Name
Else
Return SetError(1, 6, 0)
EndIf
EndSwitch
Switch $iWidth
Case Default
$g_aEMB_Settings[6] = 370
Case -1
Case 370 To @DesktopWidth - 20
$g_aEMB_Settings[6] = Int($iWidth)
Case Else
Return SetError(1, 7, 0)
EndSwitch
Switch $iWidth_Abs
Case Default
$g_aEMB_Settings[7] = 370
Case -1
Case 370 To @DesktopWidth - 20
$g_aEMB_Settings[7] = Int($iWidth_Abs)
Case Else
Return SetError(1, 8, 0)
EndSwitch
If $g_aEMB_Settings[7] < $g_aEMB_Settings[6] Then
$g_aEMB_Settings[7] = $g_aEMB_Settings[6]
EndIf
Return 1
EndFunc
Func _ExtMsgBox($vIcon, $vButton, $sTitle, $sText, $iTimeOut = 0, $hWin = $g_hFrmBot, $iVPos = 0, $bMain = True)
Local $iMsg_Width_Max = $g_aEMB_Settings[6], $iMsg_Width_Min = 150, $iMsg_Width_Abs = $g_aEMB_Settings[7]
Local $iMsg_Height_Min = 100
Local $iButton_Width_Def = 80, $iButton_Width_Min = 50
Local $iParent_Win = 0, $fCountdown = False, $cCheckbox, $aLabel_Size, $aRet, $iRet_Value, $iHpos
Local $sButton_Text, $iButton_Width, $iButton_Xpos
$iTimeOut = Int(Number($iTimeOut))
If $vButton == " " And $iTimeOut = 0 Then
$iTimeOut = 5
EndIf
Local $iIcon_Style = 0
Local $iIcon_Reduction = 50
Local $sDLL = "user32.dll"
If StringIsDigit($vIcon) Then
Switch $vIcon
Case 0
$iIcon_Reduction = 0
Case 8
$sDLL = "imageres.dll"
$iIcon_Style = 78
Case 16
$iIcon_Style = -4
Case 32
$iIcon_Style = -3
Case 48
$iIcon_Style = -2
Case 64
$iIcon_Style = -5
Case 128
If $iTimeOut > 0 Then
$fCountdown = True
Else
ContinueCase
EndIf
Case Else
Return SetError(1, 0, -1)
EndSwitch
Else
$sDLL = $vIcon
$iIcon_Style = 0
EndIf
StringRegExpReplace($vButton, "((?<!&)&)(?!&)", "*")
If @extended > 1 Then
Return SetError(2, 0, -1)
EndIf
If IsNumber($vButton) Then
Switch $vButton
Case 0
$vButton = "OK"
Case 1
$vButton = "&OK|Cancel"
Case 2
$vButton = "&Abort|Retry|Ignore"
Case 3
$vButton = "&Yes|No|Cancel"
Case 4
$vButton = "&Yes|No"
Case 5
$vButton = "&Retry|Cancel"
Case 6
$vButton = "&Cancel|Try Again|Continue"
Case Else
Return SetError(3, 0, -1)
EndSwitch
EndIf
Local $aButton_Text[1] = [0]
Local $iButton_Width_Req = 0
If $vButton <> " " Then
$aButton_Text = StringSplit($vButton, "|")
Local $iButton_Width_Abs = Floor((($iMsg_Width_Max - 10) / $aButton_Text[0]) - 10)
If $iButton_Width_Abs < $iButton_Width_Min Then
Return SetError(4, 0, -1)
EndIf
Local $iButton_Width_Text = 0
For $i = 1 To $aButton_Text[0]
$sButton_Text = StringRegExpReplace($aButton_Text[$i], "^&?(.*)$", "$1")
If BitAND($g_aEMB_Settings[0], 4) Then
$aRet = _StringSize($sButton_Text, $g_aEMB_Settings[10], Default, Default, $g_aEMB_Settings[11])
Else
$aRet = _StringSize($sButton_Text, $g_aEMB_Settings[4], Default, Default, $g_aEMB_Settings[5])
EndIf
If IsArray($aRet) And $aRet[2] + 10 > $iButton_Width_Text Then
$iButton_Width_Text = $aRet[2] + 10
EndIf
Next
If $iButton_Width_Text > $iButton_Width_Abs Then
Return SetError(5, 0, -1)
EndIf
$iButton_Width = $iButton_Width_Def
If $iButton_Width_Text > $iButton_Width_Def Then
$iButton_Width = $iButton_Width_Text
EndIf
If $iButton_Width_Abs < $iButton_Width_Def Then
If $iButton_Width_Text > $iButton_Width_Min Then
$iButton_Width = $iButton_Width_Text
Else
$iButton_Width = $iButton_Width_Min
EndIf
EndIf
$iButton_Width_Req =(($iButton_Width + 10) * $aButton_Text[0]) + 10
EndIf
Local $iExpTab = Default
If BitAND($g_aEMB_Settings[0], 8) Then
$iExpTab = 1
EndIf
While 1
Local $aLabel_Pos = _StringSize($sText, $g_aEMB_Settings[4], Default, $iExpTab, $g_aEMB_Settings[5], $iMsg_Width_Max - 20 - $iIcon_Reduction)
If @error Then
If $iMsg_Width_Max >= $iMsg_Width_Abs Then
Return SetError(6, 0, -1)
Else
$iMsg_Width_Max += 10
EndIf
Else
ExitLoop
EndIf
WEnd
$sText = $aLabel_Pos[0]
Local $iLabel_Width = $aLabel_Pos[2]
Local $iLabel_Height = $aLabel_Pos[3]
Local $iMsg_Width = $iLabel_Width + 20 + $iIcon_Reduction
If $iButton_Width_Req > $iMsg_Width Then $iMsg_Width = $iButton_Width_Req
If $iMsg_Width < $iMsg_Width_Min Then
$iMsg_Width = $iMsg_Width_Min
$iLabel_Width = $iMsg_Width_Min - 20
EndIf
Local $iDialog_Width = $iMsg_Width
Local $aTitleSize = _StringSize($sTitle, $g_aEMB_Settings[10], Default, Default, $g_aEMB_Settings[11])
If $aTitleSize[2] >($iMsg_Width - 70) Then
$iDialog_Width =(($aTitleSize[2] <($g_aEMB_Settings[7] - $g_aEMB_Settings[12])) ?($aTitleSize[2] + $g_aEMB_Settings[12]) :($g_aEMB_Settings[7]) )
EndIf
Local $iMsg_Height = $iLabel_Height + 35
If $vButton <> " " Then
$iMsg_Height += 30
EndIf
If BitAND($g_aEMB_Settings[0], 16) Then
$iMsg_Height += 40
EndIf
If $iMsg_Height < $iMsg_Height_Min Then $iMsg_Height = $iMsg_Height_Min
Local $iLabel_Vert = 20
If StringInStr($sText, @CRLF) = 0 Then $iLabel_Vert = 27
If Mod($g_aEMB_Settings[0], 2) = 1 Then
If IsHWnd($hWin) Then
$iParent_Win = $hWin
Else
$iParent_Win = WinGetHandle(AutoItWinGetTitle())
EndIf
EndIf
If $hWin = "" Then
$iHpos =(@DesktopWidth - $iDialog_Width) / 2
$iVPos =(@DesktopHeight - $iMsg_Height) / 2
Else
If IsHWnd($hWin) Then
If BitAND(WinGetState($hWin), 2) Then
Local $aPos = WinGetPos($hWin)
$iHpos =($aPos[2] - $iDialog_Width) / 2 + $aPos[0] - 3
$iVPos =($aPos[3] - $iMsg_Height) / 2 + $aPos[1] - 20
Else
$iHpos =(@DesktopWidth - $iDialog_Width) / 2
$iVPos =(@DesktopHeight - $iMsg_Height) / 2
EndIf
Else
$iHpos = $hWin
EndIf
EndIf
If $bMain Then
If $iHpos < 10 Then $iHpos = 10
If $iHpos + $iDialog_Width > @DesktopWidth - 20 Then $iHpos = @DesktopWidth - 20 - $iDialog_Width
If $iVPos < 10 Then $iVPos = 10
If $iVPos + $iMsg_Height > @DesktopHeight - 60 Then $iVPos = @DesktopHeight - 60 - $iMsg_Height
EndIf
Local $iExtStyle = 0x00000008
If BitAND($g_aEMB_Settings[0], 2) Then $iExtStyle = -1
Local $hMsgGUI = GUICreate($sTitle, $iDialog_Width, $iMsg_Height, $iHpos, $iVPos, BitOR(0x80880000, 0x00C00000), $iExtStyle, $iParent_Win)
If @error Then
Return SetError(7, 0, -1)
EndIf
If BitAND($g_aEMB_Settings[0], 32) Then
If @Compiled Then
GUISetIcon(@ScriptName, -2, $hMsgGUI)
Else
GUISetIcon(@AutoItExe, -2, $hMsgGUI)
EndIf
EndIf
If $g_aEMB_Settings[2] <> Default Then GUISetBkColor($g_aEMB_Settings[2])
If BitAND($g_aEMB_Settings[0], 64) Then
$aRet = DllCall("User32.dll", "hwnd", "GetSystemMenu", "hwnd", $hMsgGUI, "int", 0)
Local $hSysMenu = $aRet[0]
DllCall("User32.dll", "int", "RemoveMenu", "hwnd", $hSysMenu, "int", 0xF060, "int", 0)
DllCall("User32.dll", "int", "DrawMenuBar", "hwnd", $hMsgGUI)
EndIf
Local $iLabel_Style = 0
If BitAND($g_aEMB_Settings[1], 1) = 1 Then
$iLabel_Style = 1
ElseIf BitAND($g_aEMB_Settings[1], 2) = 2 Then
$iLabel_Style = 2
EndIf
GUICtrlCreateLabel($sText, 10 + $iIcon_Reduction, $iLabel_Vert, $iLabel_Width, $iLabel_Height, $iLabel_Style)
GUICtrlSetFont(-1, $g_aEMB_Settings[4], Default, Default, $g_aEMB_Settings[5])
If $g_aEMB_Settings[3] <> Default Then GUICtrlSetColor(-1, $g_aEMB_Settings[3])
If BitAND($g_aEMB_Settings[0], 16) Then
Local $sAgain = " Do not show again"
Local $iY = $iLabel_Vert + $iLabel_Height + 10
$cCheckbox = GUICtrlCreateCheckbox("", 10 + $iIcon_Reduction, $iY, 20, 20)
Local $cCheckLabel = GUICtrlCreateLabel($sAgain, 20, 20, 20, 20)
GUICtrlSetColor($cCheckLabel, $g_aEMB_Settings[3])
GUICtrlSetBkColor($cCheckLabel, $g_aEMB_Settings[2])
If BitAND($g_aEMB_Settings[0], 4) Then
$aLabel_Size = _StringSize($sAgain)
Else
$aLabel_Size = _StringSize($sAgain, $g_aEMB_Settings[4], 400, 0, $g_aEMB_Settings[5])
GUICtrlSetFont($cCheckLabel, $g_aEMB_Settings[4], 400, 0, $g_aEMB_Settings[5])
EndIf
$iY =($iY + 10) -($aLabel_Size[3] - 4) / 2
ControlMove($hMsgGUI, "", $cCheckLabel, 30 + $iIcon_Reduction, $iY, $iMsg_Width -(30 + $iIcon_Reduction), $aLabel_Size[3])
EndIf
If $fCountdown = True Then
Local $cCountdown_Label = GUICtrlCreateLabel(StringFormat("%2s", $iTimeOut), 10, 20, 32, 32)
GUICtrlSetFont(-1, 18, Default, Default, $g_aEMB_Settings[5])
GUICtrlSetColor(-1, $g_aEMB_Settings[3])
Else
If $iIcon_Reduction Then GUICtrlCreateIcon($sDLL, $iIcon_Style, 10, 20)
EndIf
Local $aButtonCID[$aButton_Text[0] + 1] = [9999]
If $vButton <> " " Then
$aButtonCID[0] = GUICtrlCreateDummy()
Local $aAccel_Key[1][2] = [["{SPACE}", $aButtonCID[0]]]
GUISetAccelerators($aAccel_Key)
If $aButton_Text[0] = 1 Then
If BitAND($g_aEMB_Settings[1], 4) = 4 Then
$iButton_Xpos =($iMsg_Width - $iButton_Width) / 2
Else
$iButton_Xpos = $iMsg_Width - $iButton_Width - 10
EndIf
Else
$iButton_Xpos =($iMsg_Width -($iButton_Width_Req - 20)) / 2
EndIf
Local $iDefButton_Code = 0
Local $iDef_Button_Style = 0
For $i = 0 To $aButton_Text[0] - 1
Local $iButton_Text = $aButton_Text[$i + 1]
If $aButton_Text[0] = 1 Then
$iDef_Button_Style = 0x0001
ElseIf StringLeft($iButton_Text, 1) = "&" Then
$iDef_Button_Style = 0x0001
$aButton_Text[$i + 1] = StringTrimLeft($iButton_Text, 1)
$iDefButton_Code = $i + 1
EndIf
$aButtonCID[$i + 1] = GUICtrlCreateButton($aButton_Text[$i + 1], $iButton_Xpos +($i *($iButton_Width + 10)), $iMsg_Height - 35, $iButton_Width, 25, $iDef_Button_Style)
If Not BitAND($g_aEMB_Settings[0], 4) Then GUICtrlSetFont(-1, $g_aEMB_Settings[4], 400, 0, $g_aEMB_Settings[5])
$iDef_Button_Style = 0
Next
EndIf
GUISetState(@SW_SHOW, $hMsgGUI)
Local $iTimeout_Begin = TimerInit()
Local $iCounter = 0
Local $aMsg
Local $iOrgMode = Opt('GUIOnEventMode', 0)
While 1
$aMsg = GUIGetMsg(1)
If $aMsg[1] = $hMsgGUI Then
Select
Case $aMsg[0] = -3
$iRet_Value = 0
ExitLoop
Case $aMsg[0] = $aButtonCID[0]
If $iDefButton_Code Then
$iRet_Value = $iDefButton_Code
ExitLoop
EndIf
Case Else
For $i = 1 To UBound($aButtonCID) - 1
If $aMsg[0] = $aButtonCID[$i] Then
$iRet_Value = $i
ExitLoop 2
EndIf
Next
EndSelect
EndIf
If TimerDiff($iTimeout_Begin) / 1000 >= $iTimeOut And $iTimeOut > 0 Then
$iRet_Value = 9
ExitLoop
EndIf
If $fCountdown = True Then
Local $iTimeRun = Int(TimerDiff($iTimeout_Begin) / 1000)
If $iTimeRun <> $iCounter Then
$iCounter = $iTimeRun
GUICtrlSetData($cCountdown_Label, StringFormat("%2s", $iTimeOut - $iCounter))
EndIf
EndIf
WEnd
Opt('GUIOnEventMode', $iOrgMode)
If GUICtrlRead($cCheckbox) = 1 Then
$iRet_Value *= -1
EndIf
GUIDelete($hMsgGUI)
Return $iRet_Value
EndFunc
Func __EMB_GetDefaultFont()
Local $aDefFontData[2] = [9, "Tahoma"]
Local $hWnd = WinGetHandle(AutoItWinGetTitle())
Local $hThemeDLL = DllOpen("uxtheme.dll")
Local $hTheme = DllCall($hThemeDLL, 'ptr', 'OpenThemeData', 'hwnd', $hWnd, 'wstr', "Static")
If @error Then Return $aDefFontData
$hTheme = $hTheme[0]
Local $tFont = DllStructCreate("long;long;long;long;long;byte;byte;byte;byte;byte;byte;byte;byte;wchar[32]")
Local $pFont = DllStructGetPtr($tFont)
DllCall($hThemeDLL, 'long', 'GetThemeSysFont', 'HANDLE', $hTheme, 'int', 805, 'ptr', $pFont)
If @error Then
$tFont = 0
Return $aDefFontData
EndIf
Local $hDC = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hWnd)
If @error Then
$tFont = 0
Return $aDefFontData
EndIf
$hDC = $hDC[0]
Local $iPixel_Y = DllCall("gdi32.dll", "int", "GetDeviceCaps", "handle", $hDC, "int", 90)
If Not @error Then
$iPixel_Y = $iPixel_Y[0]
$aDefFontData[0] = Int(2 *(.25 - DllStructGetData($tFont, 1) * 72 / $iPixel_Y)) / 2
EndIf
DllCall("user32.dll", "int", "ReleaseDC", "hwnd", $hWnd, "handle", $hDC)
$aDefFontData[1] = DllStructGetData($tFont, 14)
$tFont = 0
Return $aDefFontData
EndFunc
Func MBRFunc($Start = True)
Switch $Start
Case True
$g_hLibNTDLL = DllOpen("ntdll.dll")
$g_hLibUser32DLL = DllOpen("user32.dll")
$g_hLibFunctions = DllOpen($g_sLibFunctionsPath)
$g_hLibImgLoc = DllOpen($g_sLibImgLocPath)
If $g_hLibFunctions = -1 Then
Setlog("MBRfunctions.dll not found.", $COLOR_ERROR)
Return False
EndIf
SetDebugLog("MBRfunctions.dll opened.")
Case False
DllClose($g_hLibNTDLL)
DllClose($g_hLibUser32DLL)
DllClose($g_hLibFunctions)
DllClose($g_hLibImgLoc)
SetDebugLog("MBRfunctions.dll closed.")
EndSwitch
EndFunc
Func debugMBRFunctions($g_iDebugSearchArea = 0, $g_iDebugRedArea = 0, $g_iDebugOcr = 0)
SetDebugLog("debugMBRFunctions: $g_iDebugSearchArea=" & $g_iDebugSearchArea & ", $g_iDebugRedArea=" & $g_iDebugRedArea & ", $g_iDebugOcr=" & $g_iDebugOcr)
Local $activeHWnD = WinGetHandle("")
Local $result = DllCall($g_hLibFunctions, "str", "setGlobalVar", "int", $g_iDebugSearchArea, "int", $g_iDebugRedArea, "int", $g_iDebugOcr)
If @error Then
_logErrorDLLCall($g_sLibFunctionsPath & ", setGlobalVar:", @error)
Return SetError(@error)
EndIf
If IsArray($result) Then
If $g_iDebugSetlog = 1 And $result[0] = -1 Then SetLog("MBRfunctions.dll error setting Global vars.", $COLOR_DEBUG)
Else
SetDebugLog("MBRfunctions.dll not found.", $COLOR_ERROR)
EndIf
WinActivate($activeHWnD)
EndFunc
Func setAndroidPID($pid)
SetDebugLog("setAndroidPID: $pid=" & $pid)
Local $result = DllCall($g_hLibFunctions, "str", "setAndroidPID", "int", $pid)
If @error Then
_logErrorDLLCall($g_sLibFunctionsPath & ", setAndroidPID:", @error)
Return SetError(@error)
EndIf
If IsArray($result) Then
If $result[0] = "" Then
SetDebugLog("MBRfunctions.dll error setting Android PID.")
Else
SetDebugLog("Android PID=" & $pid & " initialized: " & $result[0])
debugMBRFunctions($g_iDebugSearchArea, $g_iDebugRedArea, $g_iDebugOcr)
EndIf
Else
SetDebugLog("MBRfunctions.dll not found.", $COLOR_ERROR)
EndIf
EndFunc
Func setVillageOffset($x, $y, $z)
DllCall($g_hLibFunctions, "str", "setVillageOffset", "int", $x, "int", $y, "float", $z)
DllCall($g_sLibImgLocPath , "str", "setVillageOffset", "int", $x, "int", $y, "float", $z)
$g_iVILLAGE_OFFSET[0] = $x
$g_iVILLAGE_OFFSET[1] = $y
$g_iVILLAGE_OFFSET[2] = $z
EndFunc
Func setMaxDegreeOfParallelism($iMaxDegreeOfParallelism = -1)
DllCall($g_sLibImgLocPath , "str", "setMaxDegreeOfParallelism", "int", $iMaxDegreeOfParallelism)
EndFunc
Func ConvertVillagePos(ByRef $x, ByRef $y, $zoomfactor = 0)
If $g_iBotLaunchTime = 0 Then Return
Local $result = DllCall($g_hLibFunctions, "str", "ConvertVillagePos", "int", $x, "int", $y, "float", $zoomfactor)
if Isarray($result) = False then
if $g_iDebugSetlog=1 then Setlog("ConvertVillagePos result error", $COLOR_ERROR)
Return
EndIf
Local $a = StringSplit($result[0], "|")
If UBound($a) < 3 Then Return
$x = Int($a[1])
$y = Int($a[2])
EndFunc
Func ConvertToVillagePos(ByRef $x, ByRef $y, $zoomfactor = 0)
If $g_iBotLaunchTime = 0 Then Return
Local $result = DllCall($g_hLibFunctions, "str", "ConvertToVillagePos", "int", $x, "int", $y, "float", $zoomfactor)
if Isarray($result) = False then
if $g_iDebugSetlog=1 then Setlog("ConvertToVillagePos result error", $COLOR_ERROR)
Return
EndIf
Local $a = StringSplit($result[0], "|")
If UBound($a) < 3 Then Return
$x = Int($a[1])
$y = Int($a[2])
EndFunc
Func ConvertFromVillagePos(ByRef $x, ByRef $y)
If $g_iBotLaunchTime = 0 Then Return
Local $result = DllCall($g_hLibFunctions, "str", "ConvertFromVillagePos", "int", $x, "int", $y)
if Isarray($result) = False then
if $g_iDebugSetlog=1 then Setlog("ConvertVillagePos result error", $COLOR_ERROR)
Return
EndIf
Local $a = StringSplit($result[0], "|")
If UBound($a) < 3 Then Return
$x = Int($a[1])
$y = Int($a[2])
EndFunc
Func ReduceBotMemory()
_WinAPI_EmptyWorkingSet(@AutoItPID)
EndFunc
Global Const $g_sAdbScriptsPath = $g_sLibPath & "\adb.scripts"
Global $g_aiAndroidAdbClicks[1] = [-1]
Global $g_aiAndroidAdbStatsTotal[2][2] = [ [0,0], [0,0] ]
Global $g_aiAndroidAdbStatsLast[2][12]
$g_aiAndroidAdbStatsLast[0][0] = 0
$g_aiAndroidAdbStatsLast[0][1] = -1
$g_aiAndroidAdbStatsLast[1][0] = 0
$g_aiAndroidAdbStatsLast[1][1] = -1
Global $g_bWinGetAndroidHandleActive = False
Global $g_bAndroidSuspended = False
Global $g_bAndroidQueueReboot = False
Global $g_iAndroidSuspendedTimer = 0
Func InitAndroidConfig($bRestart = False)
If $bRestart = False Then
$g_sAndroidEmulator = $g_avAndroidAppConfig[$g_iAndroidConfig][0]
$g_sAndroidInstance = $g_avAndroidAppConfig[$g_iAndroidConfig][1]
$Title = $g_avAndroidAppConfig[$g_iAndroidConfig][2]
EndIf
$g_sAppClassInstance = $g_avAndroidAppConfig[$g_iAndroidConfig][3]
$g_sAppPaneName = $g_avAndroidAppConfig[$g_iAndroidConfig][4]
$g_iAndroidClientWidth = $g_avAndroidAppConfig[$g_iAndroidConfig][5]
$g_iAndroidClientHeight = $g_avAndroidAppConfig[$g_iAndroidConfig][6]
$g_iAndroidWindowWidth = $g_avAndroidAppConfig[$g_iAndroidConfig][7]
$g_iAndroidWindowHeight = $g_avAndroidAppConfig[$g_iAndroidConfig][8]
$g_sAndroidAdbPath = ""
$g_sAndroidAdbDevice = $g_avAndroidAppConfig[$g_iAndroidConfig][10]
$g_iAndroidSupportFeature = $g_avAndroidAppConfig[$g_iAndroidConfig][11]
$g_sAndroidShellPrompt = $g_avAndroidAppConfig[$g_iAndroidConfig][12]
$g_sAndroidMouseDevice = $g_avAndroidAppConfig[$g_iAndroidConfig][13]
$g_iAndroidEmbedMode = $g_avAndroidAppConfig[$g_iAndroidConfig][14]
$g_bAndroidAdbScreencap = $g_bAndroidAdbScreencapEnabled = True And BitAND($g_iAndroidSupportFeature, 2) = 2
$g_bAndroidAdbClick = $g_bAndroidAdbClickEnabled = True And AndroidAdbClickSupported()
$g_bAndroidAdbInput = $g_bAndroidAdbInputEnabled = True And BitAND($g_iAndroidSupportFeature, 8) = 8
$g_bAndroidAdbInstance = $g_bAndroidAdbInstanceEnabled = True And BitAND($g_iAndroidSupportFeature, 16) = 16
$g_bAndroidAdbClickDrag = $g_bAndroidAdbClickDragEnabled = True And BitAND($g_iAndroidSupportFeature, 32) = 32
$g_bAndroidEmbed = $g_bAndroidEmbedEnabled = True And $g_iAndroidEmbedMode > -1
$g_bAndroidBackgroundLaunch = $g_bAndroidBackgroundLaunchEnabled = True
$g_bAndroidBackgroundLaunched = False
$g_bUpdateAndroidWindowTitle = False
If $g_bAndroidAdbScreencap And IsDeclared("g_hChkBackground") Then
chkBackground()
EndIf
EndFunc
Func CleanSecureFiles($iAgeInUTCSeconds = 600)
If $g_sAndroidPicturesHostPath = "" Then Return
Local $aFiles = _FileListToArray($g_sAndroidPicturesHostPath, "*", $FLTA_FILES)
If @error Then Return
For $i = 1 To $aFiles[0]
If StringRegExp($aFiles[$i], "[0-9A-F]{40}") = 1 Then
Local $aTime = FileGetTime($g_sAndroidPicturesHostPath & $aFiles[$i], $FT_CREATED)
Local $tTime = _Date_Time_EncodeFileTime($aTime[1], $aTime[2], $aTime[0], $aTime[3], $aTime[4], $aTime[5])
Local $tLocal = _Date_Time_LocalFileTimeToFileTime($tTime)
Local $lo = DllStructGetData($tLocal, "Lo")
Local $hi = DllStructGetData($tLocal, "Hi")
Local $iCreated = $hi * 0x100000000 + $lo
$tTime = _Date_Time_EncodeFileTime(@MON, @MDAY, @YEAR, @HOUR, @MIN, @SEC)
$tLocal = _Date_Time_LocalFileTimeToFileTime($tTime)
$lo = DllStructGetData($tLocal, "Lo")
$hi = DllStructGetData($tLocal, "Hi")
Local $iNow = $hi * 0x100000000 + $lo
If $iCreated + $iAgeInUTCSeconds * 1000 < $iNow Then
FileDelete($g_sAndroidPicturesHostPath & $aFiles[$i])
EndIf
EndIf
Next
EndFunc
Func GetSecureFilename($Filename)
If BitAND($AndroidSecureFlags, 1) = 0 Then
Return $Filename
EndIf
Return StringMid(_Crypt_HashData($Filename, $CALG_SHA1), 3)
EndFunc
Func UpdateAndroidConfig($instance = Default, $emulator = Default)
If $emulator <> Default Then
For $i = 0 To UBound($g_avAndroidAppConfig) - 1
If $g_avAndroidAppConfig[$i][0] = $emulator Then
If $g_iAndroidConfig <> $i Then
$g_iAndroidConfig = $i
$g_sAndroidEmulator = $g_avAndroidAppConfig[$g_iAndroidConfig][0]
SetLog("Android Emulator " & $g_sAndroidEmulator)
EndIf
$emulator = Default
ExitLoop
EndIf
Next
EndIf
If $emulator <> Default Then SetLog("Unknown Android Emulator " & $emulator, $COLOR_RED)
If $instance = "" Then $instance = Default
If $instance = Default Then $instance = $g_avAndroidAppConfig[$g_iAndroidConfig][1]
SetDebugLog("UpdateAndroidConfig(""" & $instance & """)")
InitAndroidConfig()
$g_sAndroidInstance = $instance
If BitAND($AndroidSecureFlags, 1) = 1 Then
$g_sAndroidPicturesHostFolder = ""
Else
$g_sAndroidPicturesHostFolder = "mybot.run\"
EndIf
Local $Result = InitAndroid(False, False)
SetDebugLog("UpdateAndroidConfig(""" & $instance & """) END")
Return $Result
EndFunc
Func UpdateAndroidWindowState()
Local $bChanged = Execute("Update" & $g_sAndroidEmulator & "WindowState()")
If $bChanged = "" And @error <> 0 Then Return False
Return $bChanged
EndFunc
Func UpdateHWnD($hWin)
If $hWin = 0 Then
$HWnD = 0
$HWnDCtrl = 0
Return False
EndIf
$HWnD = $hWin
Local $hCtrl = ControlGetHandle($hWin, $g_sAppPaneName, $g_sAppClassInstance)
If $hCtrl = 0 Then
$HWnDCtrl = 0
Return False
EndIf
Local $hWinParent = _WinAPI_GetParent($hCtrl)
If $hWinParent = 0 Then
$HWnDCtrl = 0
Return False
EndIf
$HWnDCtrl = $hWinParent
Return True
EndFunc
Func WinGetAndroidHandle($bInitAndroid = Default, $bTestPid = False)
If $bInitAndroid = Default Then $bInitAndroid = $g_bInitAndroidActive = False
If $g_bWinGetAndroidHandleActive = True Then
Return $HWnD
EndIf
$g_bWinGetAndroidHandleActive = True
Local $currHWnD = $HWnD
If $HWnD = 0 Or $g_bAndroidBackgroundLaunched = False Then _WinGetAndroidHandle()
If IsHWnd($HWnD) = 1 Then
Local $aPos = WinGetPos($HWnD)
If IsArray($aPos) Then
If _CheckWindowVisibility($HWnD, $aPos) Then
SetDebugLog("Android Window '" & $Title & "' not visible, moving to position: " & $aPos[0] & ", " & $aPos[1])
WinMove2($HWnD, "", $aPos[0], $aPos[1])
$aPos = WinGetPos($HWnD)
EndIf
EndIf
AndroidQueueReboot(False)
If $currHWnD = 0 Or $currHWnD <> $HWnD Then
If $g_bAndroidEmbedded = False And IsArray($aPos) = 1 And($Hide = False Or($aPos[0] > -30000 Or $aPos[1] > -30000)) Then
SetDebugLog("Move Android Window '" & $Title & "' to position: " & $AndroidPosX & ", " & $AndroidPosY)
WinMove2($HWnD, "", $AndroidPosX, $AndroidPosY)
$aPos[0] = $AndroidPosX
$aPos[1] = $AndroidPosY
EndIf
Local $instance =($g_sAndroidInstance = "" ? "" : " (" & $g_sAndroidInstance & ")")
SetLog($g_sAndroidEmulator & $instance & " running in window mode", $COLOR_ACTION)
If $currHWnD <> 0 And $currHWnD <> $HWnD Then
$g_bInitAndroid = True
If $bInitAndroid = True Then InitAndroid(True)
EndIf
EndIf
If $g_bAndroidEmbedded = False And IsArray($aPos) = 1 Then
Local $posX = $AndroidPosX
Local $posY = $AndroidPosY
$AndroidPosX =($aPos[0] > -30000 ? $aPos[0] : $AndroidPosX)
$AndroidPosY =($aPos[1] > -30000 ? $aPos[1] : $AndroidPosY)
If $posX <> $AndroidPosX Or $posY <> $AndroidPosY Then
SetDebugLog("Updating Android Window '" & $Title & "' position: " & $AndroidPosX & ", " & $AndroidPosY)
EndIf
If $Hide = True And($aPos[0] > -30000 Or $aPos[1] > -30000) Then
WinMove2($HWnD, "", -32000, -32000)
EndIf
EndIf
$g_bWinGetAndroidHandleActive = False
Return $HWnD
EndIf
If $g_bAndroidBackgroundLaunch = False And $bTestPid = False Then
$g_bWinGetAndroidHandleActive = False
Return $HWnD
EndIf
If $HWnD <> 0 Then
If $HWnD = ProcessExists2($HWnD) Then
Else
Local $instance =($g_sAndroidInstance = "" ? "" : " (" & $g_sAndroidInstance & ")")
SetDebugLog($g_sAndroidEmulator & $instance & " process with PID = " & $HWnD & " not found")
UpdateHWnD(0)
EndIf
EndIf
If $HWnD = 0 Then
If $g_sAndroidProgramPath <> "" Then
Local $parameter = GetAndroidProgramParameter(False)
Local $parameter2 = GetAndroidProgramParameter(True)
Local $pid = ProcessExists2($g_sAndroidProgramPath, $parameter, 0, 0, "Is" & $g_sAndroidEmulator & "CommandLine")
If $pid = 0 And $parameter <> $parameter2 Then
$parameter = $parameter2
$pid = ProcessExists2($g_sAndroidProgramPath, $parameter, 0, 0, "Is" & $g_sAndroidEmulator & "CommandLine")
EndIf
Local $commandLine = $g_sAndroidProgramPath &($parameter = "" ? "" : " " & $parameter)
Local $instance =($g_sAndroidInstance = "" ? "" : " (" & $g_sAndroidInstance & ")")
If $pid <> 0 Then
SetDebugLog("Found " & $g_sAndroidEmulator & $instance & " process " & $pid & " ('" & $commandLine & "')")
If $bTestPid = True Then
$g_bWinGetAndroidHandleActive = False
Return $pid
EndIf
If $g_bAndroidAdbScreencap = True And $g_bAndroidAdbClick = False And AndroidAdbClickSupported() = True Then
SetLog("Enabled ADB Click to support background mode", $COLOR_ACTION)
$g_bAndroidAdbClick = True
EndIf
If $g_bAndroidAdbClick = False Or $g_bAndroidAdbScreencap = False Then
If $g_bAndroidQueueReboot = False Then
SetLog("Headless Android not supported because", $COLOR_ERROR)
Local $reason = ""
If $g_bAndroidAdbClick = False Then $reason &= "ADB Click " &($g_bAndroidAdbScreencap = False ? "and " : "")
If $g_bAndroidAdbScreencap = False Then $reason &= "ADB Screencap "
$reason &= "not available!"
SetLog($reason, $COLOR_ERROR)
AndroidQueueReboot(True)
EndIf
UpdateHWnD($pid)
If $currHWnD <> 0 And $currHWnD <> $HWnD Then
$g_bInitAndroid = True
If $bInitAndroid = True Then InitAndroid(True)
EndIf
Else
SetLog($g_sAndroidEmulator & $instance & " running in headless mode", $COLOR_ACTION)
UpdateHWnD($pid)
If $currHWnD <> 0 And $currHWnD <> $HWnD Then
$g_bInitAndroid = True
If $bInitAndroid = True Then InitAndroid(True)
EndIf
$g_bAndroidBackgroundLaunched = True
EndIf
setAndroidPID($pid)
Else
SetDebugLog($g_sAndroidEmulator & $instance & " process not found")
EndIf
EndIf
EndIf
If $HWnD = 0 Then
$g_bInitAndroid = True
$g_bAndroidBackgroundLaunched = False
EndIf
$g_bWinGetAndroidHandleActive = False
Return $HWnD
EndFunc
Func GetAndroidPid()
Local $h = WinGetAndroidHandle(Default, True)
If IsHWnd($h) Then Return WinGetProcess($h)
Return $h
EndFunc
Func _WinGetAndroidHandle($bFindByTitle = False)
Local $hWin = WinGetHandle($HWnD)
If $hWin > 0 And $hWin = $HWnD Then Return $HWnD
Local $i
Local $t
Local $ReInitAndroid = $HWnD <> 0
SetDebugLog("Searching " & $g_sAndroidEmulator & " Window: Title = '" & $Title & "', Class = '" & $g_sAppClassInstance & "', Text = '" & $g_sAppPaneName & "'")
Local $aWinList
If $bFindByTitle = True Then
$aWinList = WinList($Title)
If $aWinList[0][0] > 0 Then
For $i = 1 To $aWinList[0][0]
$hWin = $aWinList[$i][1]
$t = $aWinList[$i][0]
If $Title = $t Then
Local $hCtrl = ControlGetHandle($hWin, $g_sAppPaneName, $g_sAppClassInstance)
If $hCtrl <> 0 Then
SetDebugLog("Found " & $g_sAndroidEmulator & " Window '" & $t & "' (" & $hWin & ") by matching title '" & $Title & "' (#1)")
UpdateHWnD($hWin)
$Title = UpdateAndroidWindowTitle($HWnD, $t)
If $ReInitAndroid = True And $g_bInitAndroid = False Then
$g_bInitAndroid = True
InitAndroid()
EndIf
AndroidEmbed(False, False)
setAndroidPID(GetAndroidPid())
Return $hWin
EndIf
EndIf
Next
EndIf
Local $iMode = Opt("WinTitleMatchMode", -1)
$hWin = WinGetHandle($Title)
Local $error = @error
Opt("WinTitleMatchMode", $iMode)
If $error = 0 Then
$t = WinGetTitle($hWin)
If $Title = $t And ControlGetHandle($hWin, $g_sAppPaneName, $g_sAppClassInstance) <> 0 Then
If $HWnD <> $hWin Then SetDebugLog("Found " & $g_sAndroidEmulator & " Window '" & $t & "' (" & $hWin & ") by matching title '" & $Title & "' (#2)")
UpdateHWnD($hWin)
$Title = UpdateAndroidWindowTitle($HWnD, $t)
If $ReInitAndroid = True And $g_bInitAndroid = False Then
$g_bInitAndroid = True
InitAndroid()
EndIf
AndroidEmbed(False, False)
setAndroidPID(GetAndroidPid())
Return $hWin
Else
SetDebugLog($g_sAndroidEmulator & " Window title '" & $t & "' not matching '" & $Title & "' or control")
EndIf
EndIf
$iMode = Opt("WinTitleMatchMode", -1)
$aWinList = WinList($Title)
Opt("WinTitleMatchMode", $iMode)
If $aWinList[0][0] = 0 Then
SetDebugLog($g_sAndroidEmulator & " Window not found")
If $ReInitAndroid = True Then $g_bInitAndroid = True
UpdateHWnD(0)
AndroidEmbed(False, False)
Return 0
EndIf
SetDebugLog("Found " & $aWinList[0][0] & " possible " & $g_sAndroidEmulator & " windows by title '" & $Title & "':")
For $i = 1 To $aWinList[0][0]
SetDebugLog($aWinList[$i][1] & ": " & $aWinList[$i][0])
Next
If $g_sAndroidInstance <> "" Then
For $i = 1 To $aWinList[0][0]
$t = $aWinList[$i][0]
$hWin = $aWinList[$i][1]
If StringRight($t, StringLen($g_sAndroidInstance)) = $g_sAndroidInstance And ControlGetHandle($hWin, $g_sAppPaneName, $g_sAppClassInstance) <> 0 Then
SetDebugLog("Found " & $g_sAndroidEmulator & " Window '" & $t & "' (" & $hWin & ") for instance " & $g_sAndroidInstance)
UpdateHWnD($hWin)
$Title = UpdateAndroidWindowTitle($HWnD, $t)
If $ReInitAndroid = True And $g_bInitAndroid = False Then
$g_bInitAndroid = True
InitAndroid()
EndIf
AndroidEmbed(False, False)
setAndroidPID(GetAndroidPid())
Return $hWin
EndIf
Next
EndIf
EndIf
If $g_sAndroidProgramPath <> "" Then
Local $parameter = GetAndroidProgramParameter(False)
Local $parameter2 = GetAndroidProgramParameter(True)
Local $pid = ProcessExists2($g_sAndroidProgramPath, $parameter, 0, 0, "Is" & $g_sAndroidEmulator & "CommandLine")
If $pid = 0 And $parameter <> $parameter2 Then
$parameter = $parameter2
$pid = ProcessExists2($g_sAndroidProgramPath, $parameter, 0, 0, "Is" & $g_sAndroidEmulator & "CommandLine")
EndIf
Local $commandLine = $g_sAndroidProgramPath &($parameter = "" ? "" : " " & $parameter)
If $pid <> 0 Then
If IsArray($aWinList) = 0 Then
Local $aWinList2 = _WinAPI_EnumProcessWindows($pid, True)
If IsArray($aWinList2) = 1 And $aWinList2[0][0] > 0 Then
Local $aWinList[$aWinList2[0][0] + 1][2]
$aWinList[0][0] = $aWinList2[0][0]
For $i = 1 To $aWinList2[0][0]
$aWinList[$i][0] = WinGetTitle($aWinList2[$i][0])
$aWinList[$i][1] = $aWinList2[$i][0]
Next
EndIf
EndIf
If IsArray($aWinList) = 1 Then
For $i = 1 To $aWinList[0][0]
$t = $aWinList[$i][0]
$hWin = $aWinList[$i][1]
If $pid = WinGetProcess($hWin) And ControlGetHandle($hWin, $g_sAppPaneName, $g_sAppClassInstance) <> 0 Then
SetDebugLog("Found " & $g_sAndroidEmulator & " Window '" & $t & "' (" & $hWin & ") by PID " & $pid & " ('" & $commandLine & "')")
UpdateHWnD($hWin)
$Title = UpdateAndroidWindowTitle($HWnD, $t)
If $ReInitAndroid = True And $g_bInitAndroid = False Then
$g_bInitAndroid = True
InitAndroid()
EndIf
AndroidEmbed(False, False)
setAndroidPID(GetAndroidPid())
Return $hWin
EndIf
Next
EndIf
SetDebugLog($g_sAndroidEmulator &($g_sAndroidInstance = "" ? "" : " (" & $g_sAndroidInstance & ")") & " Window not found for PID " & $pid)
EndIf
EndIf
SetDebugLog($g_sAndroidEmulator &($g_sAndroidInstance = "" ? "" : " (" & $g_sAndroidInstance & ")") & " Window not found in list")
If $ReInitAndroid = True Then $g_bInitAndroid = True
UpdateHWnD(0)
AndroidEmbed(False, False)
Return 0
EndFunc
Func UpdateAndroidWindowTitle($hWin, $t)
If $g_bUpdateAndroidWindowTitle = True And $g_sAndroidInstance <> "" And StringInStr($t, $g_sAndroidInstance) = 0 Then
$t &= " (" & $g_sAndroidInstance & ")"
_WinAPI_SetWindowText($hWin, $t)
EndIf
Return $t
EndFunc
Func AndroidControlAvailable()
If $g_bAndroidBackgroundLaunched = True Then
Return 0
EndIf
Return IsArray(GetAndroidPos(True))
EndFunc
Func GetAndroidSvcPid()
Static $iAndroidSvcPid = 0
If $iAndroidSvcPid <> 0 And $iAndroidSvcPid = ProcessExists2($iAndroidSvcPid) Then
Return $iAndroidSvcPid
EndIf
SetError(0, 0, 0)
Local $pid = Execute("Get" & $g_sAndroidEmulator & "SvcPid()")
If $pid = "" And @error <> 0 Then $pid = GetVBoxAndroidSvcPid()
If $pid <> 0 Then
SetDebugLog("Found " & $g_sAndroidEmulator & " Service PID = " & $pid)
Else
SetDebugLog("Cannot find " & $g_sAndroidEmulator & " Service PID", $COLOR_ERROR)
EndIf
$iAndroidSvcPid = $pid
Return $pid
EndFunc
Func GetVBoxAndroidSvcPid()
Local $aRegExResult = StringRegExp($__VBoxVMinfo, "UUID:\s+(.+)", $STR_REGEXPARRAYMATCH)
Local $uuid = ""
If Not @error Then $uuid = $aRegExResult[0]
If StringLen($uuid) < 32 Then
SetDebugLog("Cannot find VBox UUID", $COLOR_ERROR)
Return 0
EndIf
Local $pid = ProcessExists2("", $uuid, 1, 1)
Return $pid
EndFunc
Func GetAndroidRunningInstance($bStrictCheck = True)
Local $runningInstance = Execute("Get" & $g_sAndroidEmulator & "RunningInstance(" & $bStrictCheck & ")")
Local $i
If $runningInstance = "" And @error <> 0 Then
Local $a[2] = [0, ""]
SetDebugLog("GetAndroidRunningInstance: Try to find """ & $g_sAndroidProgramPath & """")
Local $pids = ProcessesExist($g_sAndroidProgramPath, "", 1)
If UBound($pids) > 0 Then
Local $currentInstance = $g_sAndroidInstance
For $i = 0 To UBound($pids) - 1
Local $pid = $pids[$i]
Local $commandLine = ProcessGetCommandLine($pid)
SetDebugLog("GetAndroidRunningInstance: Found """ & $commandLine & """ by PID=" & $pid)
Local $lastSpace = StringInStr($commandLine, " ", 0, -1)
If $lastSpace > 0 Then
$g_sAndroidInstance = StringStripWS(StringMid($commandLine, $lastSpace + 1), 3)
If $g_sAndroidInstance = "" Then $g_sAndroidInstance = $g_avAndroidAppConfig[$g_iAndroidConfig][1]
EndIf
If WinGetAndroidHandle() <> 0 Then
SetDebugLog("Running " & $g_sAndroidEmulator & " instance found: """ & $g_sAndroidInstance & """")
If $a[0] = 0 Or $g_sAndroidInstance = $currentInstance Then
$a[0] = $HWnD
$a[1] = $g_sAndroidInstance
If $g_sAndroidInstance = $currentInstance Then ExitLoop
EndIf
Else
$g_sAndroidInstance = $currentInstance
EndIf
Next
EndIf
If $a[0] <> 0 Then SetDebugLog("Running " & $g_sAndroidEmulator & " instance is """ & $g_sAndroidInstance & """")
Return $a
EndIf
Return $runningInstance
EndFunc
Func DetectRunningAndroid()
SetDebugLog("DetectRunningAndroid()")
$g_bFoundRunningAndroid = False
Local $i, $iCurrentConfig = $g_iAndroidConfig
$g_bSilentSetLog = True
For $i = 0 To UBound($g_avAndroidAppConfig) - 1
$g_iAndroidConfig = $i
$g_bInitAndroid = True
If UpdateAndroidConfig() = True Then
Local $aRunning = GetAndroidRunningInstance(False)
If $aRunning[0] = 0 Then
Else
$g_bFoundRunningAndroid = True
$g_bSilentSetLog = False
$g_bInitAndroid = True
If InitAndroid() = True Then
SetDebugLog("Found running " & $g_sAndroidEmulator & " " & $g_sAndroidVersion)
EndIf
Return
EndIf
EndIf
Next
$g_bInitAndroid = True
$g_iAndroidConfig = $iCurrentConfig
UpdateAndroidConfig()
$g_bSilentSetLog = False
SetDebugLog("Found no running Android Emulator")
EndFunc
Func DetectInstalledAndroid()
SetDebugLog("DetectInstalledAndroid()")
Local $i, $CurrentConfig = $g_iAndroidConfig
$g_bSilentSetLog = True
For $i = 0 To UBound($g_avAndroidAppConfig) - 1
$g_iAndroidConfig = $i
$g_bInitAndroid = True
If UpdateAndroidConfig() Then
$g_bFoundInstalledAndroid = True
$g_bSilentSetLog = False
SetDebugLog("Found installed " & $g_sAndroidEmulator & " " & $g_sAndroidVersion)
Return
EndIf
Next
$g_iAndroidConfig = $CurrentConfig
$g_bInitAndroid = True
UpdateAndroidConfig()
$g_bSilentSetLog = False
SetDebugLog("Found no installed Android Emulator")
EndFunc
Func FindPreferredAdbPath()
Local $adbPath, $i
For $i = 0 To UBound($g_avAndroidAppConfig) - 1
$adbPath = Execute("Get" & $g_avAndroidAppConfig[$i][0] & "AdbPath()")
If $adbPath <> "" Then Return $adbPath
Next
Return ""
EndFunc
Func CompareAndUpdate(ByRef $UpdateWhenDifferent, Const $New)
Local $bDifferent = $UpdateWhenDifferent <> $New
If $bDifferent Then $UpdateWhenDifferent = $New
Return $bDifferent
EndFunc
Func IncrUpdate(ByRef $i, $ReturnInitial = True)
Local $i2 = $i
$i += 1
If $ReturnInitial Then Return $i2
Return $i
EndFunc
Func InitAndroid($bCheckOnly = False, $bLogChangesOnly = True)
If $bCheckOnly = False And $g_bInitAndroid = False Then
Return True
EndIf
$g_bInitAndroidActive = True
Local $aPriorValues = [ $g_sAndroidEmulator , $g_iAndroidConfig , $g_sAndroidVersion , $g_sAndroidInstance , $Title , $g_sAndroidProgramPath , GetAndroidProgramParameter() ,((IsArray($g_avAndroidProgramFileVersionInfo) ? _ArrayToString($g_avAndroidProgramFileVersionInfo, ",", 1) : "not available")) , $AndroidSecureFlags , $g_sAndroidAdbPath , $g_sAndroidAdbDevice , $g_sAndroidPicturesPath , $g_sAndroidPicturesHostPath , $g_sAndroidPicturesHostFolder , $g_sAndroidMouseDevice , $g_bAndroidAdbScreencap , $g_bAndroidAdbInput , $g_bAndroidAdbClick , $g_bAndroidAdbClickDrag ,($g_bChkBackgroundMode = True ? "enabled" : "disabled") , $g_bNoFocusTampering ]
SetDebugLog("InitAndroid(" & $bCheckOnly & "): " & $g_sAndroidEmulator)
If Not $bCheckOnly Then
If $g_sAndroidInstance = "" Then $g_sAndroidInstance = $g_avAndroidAppConfig[$g_iAndroidConfig][1]
EndIf
Local $Result = Execute("Init" & $g_sAndroidEmulator & "(" & $bCheckOnly & ")")
If $Result = "" And @error <> 0 Then
SetLog("Android support for " & $g_sAndroidEmulator & " is not available", $COLOR_ERROR)
EndIf
Local $successful = @error = 0
If Not $bCheckOnly And $Result Then
Local $pAndroidFileVersionInfo
If _WinAPI_GetFileVersionInfo($g_sAndroidProgramPath, $pAndroidFileVersionInfo) Then
$g_avAndroidProgramFileVersionInfo = _WinAPI_VerQueryValue($pAndroidFileVersionInfo)
Else
$g_avAndroidProgramFileVersionInfo = 0
EndIf
Local $i = 0
Local $sText = ""
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_sAndroidEmulator) Or $bLogChangesOnly = False Then SetDebugLog("Android: " & $g_sAndroidEmulator)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_iAndroidConfig) Or $bLogChangesOnly = False Then SetDebugLog("Android Config: " & $g_iAndroidConfig)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_sAndroidVersion) Or $bLogChangesOnly = False Then SetDebugLog("Android Version: " & $g_sAndroidVersion)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_sAndroidInstance) Or $bLogChangesOnly = False Then SetDebugLog("Android Instance: " & $g_sAndroidInstance)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $Title) Or $bLogChangesOnly = False Then SetDebugLog("Android Window Title: " & $Title)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_sAndroidProgramPath) Or $bLogChangesOnly = False Then SetDebugLog("Android Program Path: " & $g_sAndroidProgramPath)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], GetAndroidProgramParameter()) Or $bLogChangesOnly = False Then SetDebugLog("Android Program Parameter: " & GetAndroidProgramParameter())
$sText =((IsArray($g_avAndroidProgramFileVersionInfo) ? _ArrayToString($g_avAndroidProgramFileVersionInfo, ",", 1) : "not available"))
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $sText) Or $bLogChangesOnly = False Then SetDebugLog("Android Program FileVersionInfo: " & $sText)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $AndroidSecureFlags) Or $bLogChangesOnly = False Then SetDebugLog("Android SecureME setting: " & $AndroidSecureFlags)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_sAndroidAdbPath) Or $bLogChangesOnly = False Then SetDebugLog("Android ADB Path: " & $g_sAndroidAdbPath)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_sAndroidAdbDevice) Or $bLogChangesOnly = False Then SetDebugLog("Android ADB Device: " & $g_sAndroidAdbDevice)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_sAndroidPicturesPath) Or $bLogChangesOnly = False Then SetDebugLog("Android ADB Shared Folder: " & $g_sAndroidPicturesPath)
If FileExists($g_sAndroidPicturesHostPath) Then
If($g_sAndroidPicturesHostFolder <> "" Or BitAND($AndroidSecureFlags, 1) = 1) Then
DirCreate($g_sAndroidPicturesHostPath & $g_sAndroidPicturesHostFolder)
EndIf
ElseIf $g_sAndroidPicturesHostPath <> "" Then
SetLog("Shared Folder doesn't exist, please fix:", $COLOR_ERROR)
SetLog($g_sAndroidPicturesHostPath, $COLOR_ERROR)
EndIf
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_sAndroidPicturesHostPath) Or $bLogChangesOnly = False Then SetDebugLog("Android ADB Shared Folder on Host: " & $g_sAndroidPicturesHostPath)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_sAndroidPicturesHostFolder) Or $bLogChangesOnly = False Then SetDebugLog("Android ADB Shared SubFolder: " & $g_sAndroidPicturesHostFolder)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_sAndroidMouseDevice) Or $bLogChangesOnly = False Then SetDebugLog("Android Mouse Device: " & $g_sAndroidMouseDevice)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_bAndroidAdbScreencap) Or $bLogChangesOnly = False Then SetDebugLog("Android ADB screencap command enabled: " & $g_bAndroidAdbScreencap)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_bAndroidAdbInput) Or $bLogChangesOnly = False Then SetDebugLog("Android ADB input command enabled: " & $g_bAndroidAdbInput)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_bAndroidAdbClick) Or $bLogChangesOnly = False Then SetDebugLog("Android ADB Mouse Click enabled: " & $g_bAndroidAdbClick)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_bAndroidAdbClickDrag) Or $bLogChangesOnly = False Then SetDebugLog("Android ADB Click Drag enabled: " & $g_bAndroidAdbClickDrag)
If CompareAndUpdate($aPriorValues[IncrUpdate($i)],($g_bChkBackgroundMode = True ? "enabled" : "disabled")) Or $bLogChangesOnly = False Then SetDebugLog("Bot Background Mode for screen capture: " &($g_bChkBackgroundMode = True ? "enabled" : "disabled"))
If CompareAndUpdate($aPriorValues[IncrUpdate($i)], $g_bNoFocusTampering) Or $bLogChangesOnly = False Then SetDebugLog("No Focus Tampering: " & $g_bNoFocusTampering)
WinGetAndroidHandle()
InitAndroidTimeLag()
InitAndroidPageError()
$g_bInitAndroid = Not $successful
Else
If $bCheckOnly = False Then $g_bInitAndroid = True
EndIf
SetDebugLog("InitAndroid(" & $bCheckOnly & "): " & $g_sAndroidEmulator & " END, initialization successful = " & $successful & ", result = " & $Result)
$g_bInitAndroidActive = False
Return $Result
EndFunc
Func GetAndroidProgramParameter($bAlternative = False)
Local $parameter = Execute("Get" & $g_sAndroidEmulator & "ProgramParameter(" & $bAlternative & ")")
If $parameter = "" And @error <> 0 Then $parameter = ""
Return $parameter
EndFunc
Func AndroidBotStartEvent()
reHide()
Local $Result = Execute($g_sAndroidEmulator & "BotStartEvent()")
If $Result = "" And @error <> 0 Then $Result = ""
Return $Result
EndFunc
Func AndroidBotStopEvent()
Local $Result = Execute($g_sAndroidEmulator & "BotStopEvent()")
If $Result = "" And @error <> 0 Then $Result = ""
Return $Result
EndFunc
Func OpenAndroid($bRestart = False)
Static $OpenAndroidActive = 0
If $OpenAndroidActive >= $g_iOpenAndroidActiveMaxTry Then
SetLog("Cannot open " & $g_sAndroidEmulator & ", tried " & $OpenAndroidActive & " times...", $COLOR_ERROR)
btnStop()
Return False
EndIf
$OpenAndroidActive += 1
If $OpenAndroidActive > 1 Then
SetDebugLog("Opening " & $g_sAndroidEmulator & " recursively " & $OpenAndroidActive & ". time...")
EndIf
Local $Result = _OpenAndroid($bRestart)
WinGetAndroidHandle()
$OpenAndroidActive -= 1
Return $Result
EndFunc
Func _OpenAndroid($bRestart = False)
ResumeAndroid()
Local $hMutex = AquireAdbDaemonMutex(), $process_killed
LaunchConsole($g_sAndroidAdbPath, "devices", $process_killed)
ReleaseAdbDaemonMutex($hMutex)
If Not InitAndroid() Then
SetLog("Unable to open " & $g_sAndroidEmulator &($g_sAndroidInstance = "" ? "" : " instance '" & $g_sAndroidInstance & "'"), $COLOR_ERROR)
SetLog("Please check emulator/installation", $COLOR_ERROR)
SetLog("Unable to continue........", $COLOR_ERROR)
btnStop()
SetError(1, 1, -1)
Return False
EndIf
AndroidAdbTerminateShellInstance()
If Not $g_bRunState Then Return False
WerFaultClose($g_sAndroidProgramPath)
If $g_bAndroidBackgroundLaunch = False And WinGetAndroidHandle(Default, True) <> 0 Or GetAndroidSvcPid() <> 0 Then
CloseAndroid("_OpenAndroid")
If _Sleep(1000) Then Return False
EndIf
If Not Execute("Open" & $g_sAndroidEmulator & "(" & $bRestart & ")") Then Return False
If Not InitiateLayout() Then Return False
WinGetAndroidHandle(False)
If Not $g_bRunState Then Return False
AndroidBotStartEvent()
If Not $g_bRunState Then Return False
If Not StartAndroidCoC() Then Return False
If $bRestart = False Then
waitMainScreenMini()
If Not $g_bRunState Then Return False
Zoomout()
Else
WaitMainScreenMini()
If Not $g_bRunState Then Return False
If @error = 1 Then
$g_bRestart = True
$Is_ClientSyncError = False
Return False
EndIf
Zoomout()
EndIf
If Not $g_bRunState Then Return False
Return True
EndFunc
Func StartAndroidCoC()
Return RestartAndroidCoC(False, False)
EndFunc
Func RestartAndroidCoC($bInitAndroid = True, $bRestart = True)
$g_bSkipFirstZoomout = False
ResumeAndroid()
If Not $g_bRunState Then Return False
If $bInitAndroid Then
If Not InitAndroid() Then Return False
EndIf
Local $cmdOutput, $process_killed, $connected_to
Local $sRestart = ""
If $bRestart = True Then
SetLog("Please wait for CoC restart......", $COLOR_INFO)
$sRestart = "-S "
Else
SetLog("Launch Clash of Clans now...", $COLOR_SUCCESS)
EndIf
ConnectAndroidAdb()
If Not $g_bRunState Then Return False
If Not $g_bRunState Then Return False
$cmdOutput = LaunchConsole($g_sAndroidAdbPath, "-s " & $g_sAndroidAdbDevice & " shell am start " & $sRestart & "-n " & $g_sAndroidGamePackage & "/" & $g_sAndroidGameClass, $process_killed, 30 * 1000)
If StringInStr($cmdOutput, "Error:") > 0 And StringInStr($cmdOutput, $g_sAndroidGamePackage) > 0 Then
SetLog("Unable to load Clash of Clans, install/reinstall the game.", $COLOR_ERROR)
SetLog("Unable to continue........", $COLOR_WARNING)
btnStop()
SetError(1, 1, -1)
Return False
EndIf
If StringInStr($cmdOutput, "Exception") > 0 Then
If Not RebootAndroid() Then Return False
EndIf
If Not IsAdbConnected($cmdOutput) Then
If Not ConnectAndroidAdb() Then Return False
EndIf
If Not $g_bRunState Then Return False
AndroidAdbLaunchShellInstance()
Return True
EndFunc
Func CloseAndroid($sSource)
ResumeAndroid()
SetLog("Stopping " & $g_sAndroidEmulator & "....", $COLOR_INFO)
SetDebugLog("CloseAndroid, caller: " & $sSource)
AndroidEmbed(False)
AndroidAdbTerminateShellInstance()
If Not $g_bRunState Then Return False
SetLog("Please wait for full " & $g_sAndroidEmulator & " shutdown...", $COLOR_SUCCESS)
Local $pid = GetAndroidPid()
If ProcessExists2($pid) Then
KillProcess($pid, "CloseAndroid")
If _SleepStatus(1000) Then Return False
EndIf
Local $Result = Execute("Close" & $g_sAndroidEmulator & "()")
If Not $g_bRunState Then Return False
If ProcessExists($pid) Then
SetLog("Failed to stop " & $g_sAndroidEmulator, $COLOR_ERROR)
Else
SetLog($g_sAndroidEmulator & " stopped successfully", $COLOR_SUCCESS)
EndIf
If Not $g_bRunState Then Return False
RemoveGhostTrayIcons()
EndFunc
Func CloseVboxAndroidSvc()
Local $process_killed
If Not $g_bRunState Then Return
LaunchConsole($__VBoxManage_Path, "controlvm " & $g_sAndroidInstance & " poweroff", $process_killed, 30000)
If _SleepStatus(3000) Then Return
EndFunc
Func CheckAndroidRunning($bQuickCheck = True, $bStartIfRequired = True)
Local $hWin = $HWnD
If WinGetAndroidHandle() = 0 Or($bQuickCheck = False And $g_bAndroidBackgroundLaunched = False And AndroidControlAvailable() = 0) Then
SetDebugLog($g_sAndroidEmulator & " not running")
If $bStartIfRequired = True Then
If $hWin = 0 Then
OpenAndroid(True)
Else
RebootAndroid()
EndIf
EndIf
Return False
EndIf
Return True
EndFunc
Func SetScreenAndroid()
ResumeAndroid()
If Not $g_bRunState Then Return False
SetLog("Set " & $g_sAndroidEmulator & " screen resolution to " & $g_iAndroidClientWidth & " x " & $g_iAndroidClientHeight, $COLOR_INFO)
Local $Result = Execute("SetScreen" & $g_sAndroidEmulator & "()")
If $Result Then
SetLog("A restart of your computer might be required", $COLOR_ACTION)
SetLog("for the applied changes to take effect.", $COLOR_ACTION)
EndIf
Return $Result
EndFunc
Func CloseUnsupportedAndroid()
ResumeAndroid()
If Not $g_bRunState Then Return False
SetError(0, 0, 0)
Local $Closed = Execute("CloseUnsupported" & $g_sAndroidEmulator & "()")
If $Closed = "" And @error <> 0 Then Return False
Return $Closed
EndFunc
Func RebootAndroidSetScreen()
ResumeAndroid()
If Not $g_bRunState Then Return False
Return Execute("Reboot" & $g_sAndroidEmulator & "SetScreen()")
EndFunc
Func IsAdbTCP()
Return StringInStr($g_sAndroidAdbDevice, ":") > 0
EndFunc
Func WaitForRunningVMS($WaitInSec = 120, $hTimer = 0)
ResumeAndroid()
If Not $g_bRunState Then Return True
Local $cmdOutput, $connected_to, $running, $process_killed, $hMyTimer
$hMyTimer =($hTimer = 0 ? TimerInit() : $hTimer)
While True
If Not $g_bRunState Then Return True
$cmdOutput = LaunchConsole($__VBoxManage_Path, "list runningvms", $process_killed)
If Not $g_bRunState Then Return True
$running = StringInStr($cmdOutput, """" & $g_sAndroidInstance & """") > 0
If $running = True Then ExitLoop
If $hTimer <> 0 Then _StatusUpdateTime($hTimer)
_Sleep(3000)
If TimerDiff($hMyTimer) > $WaitInSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog($g_sAndroidEmulator & " refuses to load, waited " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds for boot completed", $COLOR_ERROR)
SetError(1, @extended, False)
Return True
EndIf
WEnd
Return False
EndFunc
Func WaitForAndroidBootCompleted($WaitInSec = 120, $hTimer = 0)
ResumeAndroid()
If Not $g_bRunState Then Return True
Local $cmdOutput, $connected_to, $booted, $process_killed, $hMyTimer
$hMyTimer =($hTimer = 0 ? TimerInit() : $hTimer)
While True
If Not $g_bRunState Then Return True
$cmdOutput = LaunchConsole($g_sAndroidAdbPath, "-s " & $g_sAndroidAdbDevice & " shell getprop sys.boot_completed", $process_killed)
If Not $g_bRunState Then Return True
$connected_to = IsAdbConnected($cmdOutput)
If Not $g_bRunState Then Return True
If Not $connected_to Then ConnectAndroidAdb(False)
If Not $g_bRunState Then Return True
$booted = StringLeft($cmdOutput, 1) = "1"
If $booted = True Then ExitLoop
If $hTimer <> 0 Then _StatusUpdateTime($hTimer)
If _Sleep(3000) Then Return True
If TimerDiff($hMyTimer) > $WaitInSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog($g_sAndroidEmulator & " refuses to load, waited " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds for boot completed", $COLOR_ERROR)
SetError(1, @extended, False)
Return True
EndIf
WEnd
Return False
EndFunc
Func IsAdbConnected($cmdOutput = Default)
ResumeAndroid()
If $__TEST_ERROR_ADB_DEVICE_NOT_FOUND Then Return False
Local $process_killed, $connected_to
If $cmdOutput = Default Then
If IsAdbTCP() Then
$cmdOutput = LaunchConsole($g_sAndroidAdbPath, "connect " & $g_sAndroidAdbDevice, $process_killed)
$connected_to = StringInStr($cmdOutput, "connected to") > 0
If $connected_to Then
$cmdOutput = LaunchConsole($g_sAndroidAdbPath, "-s " & $g_sAndroidAdbDevice & " shell whoami", $process_killed)
$connected_to = StringInStr($cmdOutput, "device ") = 0 And $process_killed = False
EndIf
Else
$cmdOutput = LaunchConsole($g_sAndroidAdbPath, "-s " & $g_sAndroidAdbDevice & " shell whoami", $process_killed)
$connected_to = StringInStr($cmdOutput, " not ") = 0 And $process_killed = False
EndIf
Else
$connected_to = StringInStr($cmdOutput, " not ") = 0
EndIf
Return $connected_to
EndFunc
Func AquireAdbDaemonMutex($timout = 30000)
Local $timer = TimerInit()
Local $g_hMutex_MyBot = 0
While $g_hMutex_MyBot = 0 And TimerDiff($timer) < $timout
$g_hMutex_MyBot = _Singleton("MyBot.run/AdbDaemonLaunch", 1)
If $g_hMutex_MyBot <> 0 Then ExitLoop
If _Sleep(250) Then ExitLoop
WEnd
Return $g_hMutex_MyBot
EndFunc
Func ReleaseAdbDaemonMutex($hMutex, $ReturnValue = Default)
_WinAPI_CloseHandle($hMutex)
If $ReturnValue = Default Then Return
Return $ReturnValue
EndFunc
Func ConnectAndroidAdb($rebootAndroidIfNeccessary = $g_bRunState, $timeout = 15000)
If $g_sAndroidAdbPath = "" Or FileExists($g_sAndroidAdbPath) = 0 Then
SetLog($g_sAndroidEmulator & " ADB Path not valid: " & $g_sAndroidAdbPath, $COLOR_ERROR)
Return False
EndIf
ResumeAndroid()
If $rebootAndroidIfNeccessary = True Then
WinGetAndroidHandle()
If AndroidInvalidState() Then
SetDebugLog("ConnectAndroidAdb: Reboot Android as it's not running")
RebootAndroid()
EndIf
EndIf
Local $hMutex = AquireAdbDaemonMutex()
Local $process_killed, $cmdOutput
Local $connected_to = False
Local $timer = TimerInit()
Local $timerReInit = $timer
While TimerDiff($timer) < $timeout
$connected_to = IsAdbConnected()
If $connected_to Then Return ReleaseAdbDaemonMutex($hMutex, True)
Local $ms = $timeout - TimerDiff($timer)
If $ms > 3000 Then $ms = 3000
If _Sleep($ms) Then Return ReleaseAdbDaemonMutex($hMutex, False)
If TimerDiff($timerReInit) >= 10000 Then
$timerReInit = TimerInit()
$g_bInitAndroid = True
InitAndroid()
EndIf
WEnd
Switch $g_iAndroidRecoverStrategy
Case 0
SetDebugLog("Stop ADB daemon!", $COLOR_ERROR)
LaunchConsole($g_sAndroidAdbPath, "kill-server", $process_killed)
Local $pids = ProcessesExist($g_sAndroidAdbPath, "", 1)
For $i = 0 To UBound($pids) - 1
KillProcess($pids[$i], $g_sAndroidAdbPath)
Next
$connected_to = IsAdbConnected()
ReleaseAdbDaemonMutex($hMutex)
If Not $connected_to And $g_bRunState = True And $rebootAndroidIfNeccessary = True Then
SetLog("ADB cannot connect to " & $g_sAndroidEmulator & ", restart emulator now...", $COLOR_ERROR)
If Not RebootAndroid() Then Return False
$connected_to = ConnectAndroidAdb(False)
If Not $connected_to Then
If Not $g_bRunState Then Return False
SetLog("ADB really cannot connect to " & $g_sAndroidEmulator & "!", $COLOR_ERROR)
SetLog("Please restart bot, emulator and/or PC...", $COLOR_ERROR)
EndIf
EndIf
Case 1
ReleaseAdbDaemonMutex($hMutex)
If $rebootAndroidIfNeccessary Then
SetDebugLog("ConnectAndroidAdb: Reboot Android due to ADB connection problems...", $COLOR_ERROR)
If Not RebootAndroid() Then Return False
Else
SetDebugLog("ConnectAndroidAdb: Reboot Android nor ADB Daemon not allowed", $COLOR_ERROR)
Return False
EndIf
$connected_to = IsAdbConnected()
If Not $connected_to Then
SetDebugLog("Stop ADB daemon!", $COLOR_ERROR)
LaunchConsole($g_sAndroidAdbPath, "kill-server", $process_killed)
Local $pids = ProcessesExist($g_sAndroidAdbPath, "", 1)
For $i = 0 To UBound($pids) - 1
KillProcess($pids[$i], $g_sAndroidAdbPath)
Next
$connected_to = ConnectAndroidAdb(False)
If Not $connected_to Then
If Not $g_bRunState Then Return False
SetLog("ADB really cannot connect to " & $g_sAndroidEmulator & "!", $COLOR_ERROR)
SetLog("Please restart bot, emulator and/or PC...", $COLOR_ERROR)
EndIf
EndIf
EndSwitch
Return $connected_to
EndFunc
Func RebootAndroid($bRestart = True)
ResumeAndroid()
If Not $g_bRunState Then Return False
If CloseUnsupportedAndroid() Then
Else
CloseAndroid("RebootAndroid")
EndIf
If _Sleep(1000) Then Return False
Return OpenAndroid($bRestart)
EndFunc
Func RebootAndroidSetScreenDefault()
ResumeAndroid()
If Not $g_bRunState Then Return False
AndroidSetFontSizeNormal()
If Not $g_bRunState Then Return False
CloseAndroid("RebootAndroidSetScreenDefault")
If _Sleep(1000) Then Return False
SetScreenAndroid()
If Not $g_bRunState Then Return False
Return OpenAndroid(True)
EndFunc
Func CheckScreenAndroid($ClientWidth, $ClientHeight, $bSetLog = True)
ResumeAndroid()
If Not $g_bRunState Then Return True
AndroidAdbLaunchShellInstance()
If Not $g_bRunState Then Return True
Local $AndroidWinPos = WinGetPos($HWnD)
If IsArray($AndroidWinPos) = 1 Then
Local $WinWidth = $AndroidWinPos[2]
Local $WinHeight = $AndroidWinPos[3]
If $WinWidth <> $g_iAndroidWindowWidth Or $WinHeight <> $g_iAndroidWindowHeight Then
SetDebugLog("CheckScreenAndroid: Window size " & $WinWidth & " x " & $WinHeight & " <> " & $g_iAndroidWindowWidth & " x " & $g_iAndroidWindowHeight, $COLOR_ERROR)
Else
SetDebugLog("CheckScreenAndroid: Window size " & $WinWidth & " x " & $WinHeight)
EndIf
EndIf
Local $ok =($ClientWidth = $g_iAndroidClientWidth) And($ClientHeight = $g_iAndroidClientHeight)
If Not $ok Then
If $bSetLog Then SetLog("MyBot doesn't work with " & $g_sAndroidEmulator & " screen resolution of " & $ClientWidth & " x " & $ClientHeight & "!", $COLOR_ERROR)
SetDebugLog("CheckScreenAndroid: " & $ClientWidth & " x " & $ClientHeight & " <> " & $g_iAndroidClientWidth & " x " & $g_iAndroidClientHeight)
Return False
EndIf
AndroidAdbLaunchShellInstance()
Local $s_font_scale = AndroidAdbSendShellCommand("settings get system font_scale")
Local $font_scale = Number($s_font_scale)
If $font_scale > 0 Then
SetDebugLog($g_sAndroidEmulator & " font_scale = " & $font_scale)
If $font_scale <> 1 Then
SetLog("MyBot doesn't work with Display Font Scale of " & $font_scale, $COLOR_ERROR)
Return False
EndIf
Else
Switch $g_sAndroidEmulator
Case "BlueStacks", "BlueStacks2"
Case Else
SetDebugLog($g_sAndroidEmulator & " Display Font Scale cannot be verified", $COLOR_ERROR)
EndSwitch
EndIf
SetError(0, 0, 0)
$ok = Execute("CheckScreen" & $g_sAndroidEmulator & "(" & $bSetLog & ")")
If $ok = "" And @error <> 0 Then Return True
Return $ok
EndFunc
Func AndroidSetFontSizeNormal()
ResumeAndroid()
AndroidAdbLaunchShellInstance($g_bRunState, False)
SetLog("Set " & $g_sAndroidEmulator & " Display Font Scale to normal", $COLOR_INFO)
AndroidAdbSendShellCommand("settings put system font_scale 1.0")
EndFunc
Func AndroidAdbLaunchShellInstance($wasRunState = $g_bRunState, $rebootAndroidIfNeccessary = $g_bRunState)
If $g_iAndroidAdbPid = 0 Or ProcessExists2($g_iAndroidAdbPid) <> $g_iAndroidAdbPid Then
Local $SuspendMode = ResumeAndroid()
InitAndroid()
Local $s
Local $hostFolder = $g_sAndroidPicturesHostPath & $g_sAndroidPicturesHostFolder
If FileExists($hostFolder) = 1 Then
SetDebugLog($hostFolder & " exists")
Local $aTools[1] = ["sleep"]
Local $tool
For $tool In $aTools
Local $srcFile = $g_sAdbScriptsPath & "\" & $tool
Local $dstFile = $hostFolder & $tool
If FileGetTime($srcFile, $FT_MODIFIED, $FT_STRING) <> FileGetTime($dstFile, $FT_MODIFIED, $FT_STRING) Then
FileCopy($srcFile, $dstFile, $FC_OVERWRITE)
EndIf
Next
EndIf
If $g_bAndroidAdbInstance = True Then
If ConnectAndroidAdb($rebootAndroidIfNeccessary) = False Then
Return SetError(3, 0)
EndIf
$g_iAndroidAdbPid = Run($g_sAndroidAdbPath & " -s " & $g_sAndroidAdbDevice & " shell", "", @SW_HIDE, BitOR($STDIN_CHILD, $STDERR_MERGED))
If $g_iAndroidAdbPid = 0 Or ProcessExists2($g_iAndroidAdbPid) <> $g_iAndroidAdbPid Then
SetLog($g_sAndroidEmulator & " error launching ADB for background mode, zoom-out, mouse click and input", $COLOR_ERROR)
$g_bAndroidAdbScreencap = False
$g_bAndroidAdbClick = False
$g_bAndroidAdbInput = False
If BitAND($g_iAndroidSupportFeature, 1) = 0 Then $g_bChkBackgroundMode = False
SetError(1, 0)
EndIf
$s = AndroidAdbSendShellCommand("PS1=" & $g_sAndroidAdbPrompt, Default, $wasRunState, False)
Local $scriptFile = ""
If $scriptFile = "" And FileExists($g_sAdbScriptsPath & "\shell.init." & $g_sAndroidEmulator & ".script") = 1 Then $scriptFile = "shell.init." & $g_sAndroidEmulator & ".script"
If $scriptFile = "" Then $scriptFile = "shell.init.script"
$s &= AndroidAdbSendShellCommandScript($scriptFile, Default, Default, Default, $wasRunState, False)
Local $error = @error
SetDebugLog("ADB shell launched, PID = " & $g_iAndroidAdbPid & ": " & $s)
If $error <> 0 Then
SuspendAndroid($SuspendMode)
Return
EndIf
EndIf
If True Then
If ConnectAndroidAdb($rebootAndroidIfNeccessary) = False Then
Return SetError(3, 0)
EndIf
Local $pathFound = False
Local $iMount
For $iMount = 0 To 9
$s = AndroidAdbSendShellCommand("mount", Default, $wasRunState, False)
Local $path = $g_sAndroidPicturesPath
If StringRight($path, 1) = "/" Then $path = StringLeft($path, StringLen($path) - 1)
Local $aRegExResult = StringRegExp($s, $path, $STR_REGEXPARRAYMATCH)
If @error = 0 Then
Local $dummyFile = StringMid(_Crypt_HashData($g_sBotTitle & _Now(), $CALG_SHA1), 3)
FileWriteLine($g_sAndroidPicturesHostPath & $dummyFile, _Now())
For $i = 0 To UBound($aRegExResult) - 1
$path = $aRegExResult[$i]
If StringRight($path, 1) <> "/" Then $path &= "/"
$s = AndroidAdbSendShellCommand("ls " & $path & $dummyFile, Default, $wasRunState, False)
If StringInStr($s, "No such file or directory") = 0 Then
$pathFound = True
$g_sAndroidPicturesPath = $path
SetDebugLog("Using " & $g_sAndroidPicturesPath & " for Android shared folder")
ExitLoop
EndIf
Next
FileDelete($g_sAndroidPicturesHostPath & $dummyFile)
EndIf
If $pathFound = True Then ExitLoop
If $iMount = 0 Then
SetLog("Waiting for shared folder to get mounted...", $COLOR_GREEN)
Else
SetDebugLog("Still waiting for shared folder to get mounted...")
EndIf
If _Sleep(3000) Then Return
Next
If $pathFound = False Then
SetLog($g_sAndroidEmulator & " cannot use ADB on shared folder, """ & $g_sAndroidPicturesPath & """ not found", $COLOR_ERROR)
EndIf
EndIf
If StringLen($g_sAndroidMouseDevice) > 0 And $g_sAndroidMouseDevice = $g_avAndroidAppConfig[$g_iAndroidConfig][13] Then
If ConnectAndroidAdb($rebootAndroidIfNeccessary) = False Then
Return SetError(3, 0)
EndIf
If StringInStr($g_sAndroidMouseDevice, "/dev/input/event") = 0 Then
$s = AndroidAdbSendShellCommand("getevent -p", Default, $wasRunState, False)
SetDebugLog($g_sAndroidEmulator & " getevent -p: " & $s)
Local $aRegExResult = StringRegExp($s, "(\/dev\/input\/event\d+)[\r\n]+.+""" & $g_sAndroidMouseDevice & """((?!\/dev\/input\/event)[\s\S])+ABS", $STR_REGEXPARRAYMATCH)
If @error = 0 Then
$g_sAndroidMouseDevice = $aRegExResult[0]
SetDebugLog("Using " & $g_sAndroidMouseDevice & " for mouse events")
Else
$g_bAndroidAdbClick = False
SetLog($g_sAndroidEmulator & " cannot use ADB for mouse events, """ & $g_sAndroidMouseDevice & """ not found", $COLOR_ERROR)
SuspendAndroid($SuspendMode)
Return SetError(2, 1)
EndIf
EndIf
SuspendAndroid($SuspendMode)
Return SetError(0, 1)
Else
SetDebugLog($g_sAndroidEmulator & " ADB use " & $g_sAndroidMouseDevice & " for mouse events")
EndIf
EndIf
SetError(0, 0)
EndFunc
Func AndroidAdbTerminateShellInstance()
Local $SuspendMode = ResumeAndroid()
If $g_iAndroidAdbPid <> 0 Then
StdioClose($g_iAndroidAdbPid)
If ProcessClose($g_iAndroidAdbPid) = 1 Then
SetDebugLog("ADB shell terminated, PID = " & $g_iAndroidAdbPid)
Else
SetDebugLog("ADB shell not terminated, PID = " & $g_iAndroidAdbPid, $COLOR_ERROR)
EndIf
$g_iAndroidAdbPid = 0
EndIf
SuspendAndroid($SuspendMode)
EndFunc
Func AndroidAdbSendShellCommand($cmd = Default, $timeout = Default, $wasRunState = Default, $EnsureShellInstance = True)
Local $wasAllowed = $g_bTogglePauseAllowed
$g_bTogglePauseAllowed = False
Local $Result = _AndroidAdbSendShellCommand($cmd, $timeout, $wasRunState, $EnsureShellInstance)
$g_bTogglePauseAllowed = $wasAllowed
Return SetError(@error, @extended, $Result)
EndFunc
Func _AndroidAdbSendShellCommand($cmd = Default, $timeout = Default, $wasRunState = Default, $EnsureShellInstance = True)
If $timeout = Default Then $timeout = 3000
If $wasRunState = Default Then $wasRunState = $g_bRunState
Local $sentBytes = 0
Local $SuspendMode = ResumeAndroid()
SetError(0, 0, 0)
If $EnsureShellInstance = True Then
AndroidAdbLaunchShellInstance($wasRunState)
EndIf
If @error <> 0 Then Return SetError(@error, 0, "")
Local $hTimer = TimerInit()
Local $s = ""
Local $loopCount = 0
Local $cleanOutput = True
If $g_bAndroidAdbInstance = True Then
StdoutRead($g_iAndroidAdbPid)
If $cmd = Default Then
Else
If $g_iDebugSetlog = 1 Then
SetDebugLog("Send ADB shell command: " & $cmd)
EndIf
$sentBytes = StdinWrite($g_iAndroidAdbPid, $cmd & @LF)
EndIf
While $timeout > 0 And @error = 0 And StringRight($s, StringLen($g_sAndroidAdbPrompt) + 1) <> @LF & $g_sAndroidAdbPrompt And TimerDiff($hTimer) < $timeout
Sleep(10)
$s &= StdoutRead($g_iAndroidAdbPid)
$loopCount += 1
If $wasRunState = True And $g_bRunState = False Then ExitLoop
WEnd
Else
$cleanOutput = False
If $cmd = Default Then
Else
Local $process_killed
If $g_iDebugSetlog = 1 Then
SetDebugLog("Execute ADB shell command: " & $cmd)
EndIf
$s = LaunchConsole($g_sAndroidAdbPath, "-s " & $g_sAndroidAdbDevice & " shell " & $cmd, $process_killed, $timeout)
EndIf
EndIf
If $cleanOutput = True Then
Local $i = StringInStr($s, @LF)
If $i > 0 Then $s = StringMid($s, $i)
If StringRight($s, StringLen($g_sAndroidAdbPrompt) + 1) = @LF & $g_sAndroidAdbPrompt Then $s = StringLeft($s, StringLen($s) - StringLen($g_sAndroidAdbPrompt) - 1)
CleanLaunchOutput($s)
If StringLeft($s, 1) = @LF Then $s = StringMid($s, 2)
EndIf
Local $sRemove = "WARNING: linker: libdvm.so has text relocations. This is wasting memory and is a security risk. Please fix."
If StringLen($s) >= StringLen($sRemove) And StringLeft($s, StringLen($sRemove)) = $sRemove Then
$s = StringMid($s, StringLen($sRemove) + 1)
If StringLeft($s, 1) = @LF Then $s = StringMid($s, 2)
EndIf
If $g_bAndroidAdbInstance = True And $g_iDebugSetlog = 1 And StringLen($s) > 0 Then SetDebugLog("ADB shell command output: " & $s)
SuspendAndroid($SuspendMode)
Local $error =(($g_bRunState = False Or TimerDiff($hTimer) < $timeout Or $timeout < 1) ? 0 : 1)
If $error <> 0 Then SetDebugLog("ADB shell command error " & $error & ": " & $s)
If $__TEST_ERROR_SLOW_ADB_SHELL_COMMAND_DELAY > 0 Then Sleep($__TEST_ERROR_SLOW_ADB_SHELL_COMMAND_DELAY)
$g_iAndroidAdbAutoTerminateCount += 1
If Mod($g_iAndroidAdbAutoTerminateCount, $g_iAndroidAdbAutoTerminate) = 0 And $EnsureShellInstance = True Then
AndroidAdbTerminateShellInstance()
EndIf
Return SetError($error, Int(TimerDiff($hTimer)) & "ms,#" & $loopCount, $s)
EndFunc
Func GetBinaryEvent($type, $code, $value)
Local $h, $hType, $hCode, $hValue
If IsInt($type) Then
$hType = StringLeft(Hex(Binary($type)), 4)
ElseIf IsString($type) Then
$hType = $type
EndIf
If IsInt($code) Then
$hCode = StringLeft(Hex(Binary($code)), 4)
ElseIf IsString($code) Then
$hCode = $code
EndIf
If IsInt($value) Then
$hValue = StringLeft(Hex(Binary($value)), 8)
ElseIf IsString($value) Then
$hValue = $value
EndIf
$h = "0x0000000000000000" & $hType & $hCode & $hValue
Return Binary($h)
EndFunc
Func AndroidAdbSendShellCommandScript($scriptFile, $variablesArray = Default, $combine = Default, $timeout = Default, $wasRunState = $g_bRunState, $EnsureShellInstance = True)
If $combine = Default Then $combine = False
If $timeout = Default Then $timeout = 20000
Local $hostPath = $g_sAndroidPicturesHostPath & $g_sAndroidPicturesHostFolder
Local $androidPath = $g_sAndroidPicturesPath & StringReplace($g_sAndroidPicturesHostFolder, "\", "/")
AndroidAdbLaunchShellInstance()
If @error <> 0 Then Return SetError(3, 0)
Local $hTimer = TimerInit()
Local $hFileOpen = FileOpen($g_sAdbScriptsPath & "\" & $scriptFile)
If $hFileOpen = -1 Then
SetLog("ADB script file not found: " & $scriptFile, $COLOR_ERROR)
Return SetError(5, 0)
EndIf
Local $script = FileRead($hFileOpen)
FileClose($hFileOpen)
Local $scriptModifiedTime = FileGetTime($g_sAdbScriptsPath & "\" & $scriptFile, $FT_MODIFIED, $FT_STRING)
Local $scriptFileSh = $scriptFile
$script = StringReplace($script, "{$AndroidMouseDevice}", $g_sAndroidMouseDevice)
If @extended > 0 Then
$scriptFileSh &= $g_sAndroidMouseDevice
If StringInStr($g_sAndroidMouseDevice, "/dev/input/event") = 0 Then
$g_bAndroidAdbClick = False
SetLog($g_sAndroidEmulator & " mouse device not configured", $COLOR_ERROR)
Return SetError(4, 0, 0)
EndIf
EndIf
Local $i, $j, $k, $iAdditional
Local $additionalFilenames[0]
$i = 1
While FileExists($g_sAdbScriptsPath & "\" & $scriptFile & "." & $i) = 1
Local $srcFile = $g_sAdbScriptsPath & "\" & $scriptFile & "." & $i
Local $secFile = GetSecureFilename($scriptFile & "." & $i)
Local $dstFile = $hostPath & $secFile
If FileGetTime($srcFile, $FT_MODIFIED, $FT_STRING) <> FileGetTime($dstFile, $FT_MODIFIED, $FT_STRING) Then
FileCopy($srcFile, $dstFile, $FC_OVERWRITE)
EndIf
$iAdditional = $i
ReDim $additionalFilenames[$iAdditional]
$additionalFilenames[$iAdditional - 1] = $secFile
$script = StringReplace($script, $scriptFile & "." & $i, $secFile)
$i += 1
WEnd
If UBound($variablesArray, 2) = 2 Then
For $i = 0 To UBound($variablesArray, 1) - 1
$script = StringReplace($script, $variablesArray[$i][0], $variablesArray[$i][1])
If @extended > 0 Then
$scriptFileSh &= "." & $variablesArray[$i][1]
EndIf
Next
EndIf
$scriptFileSh = StringRegExpReplace($scriptFileSh, '[/\:*?"<>|]', '.')
$scriptFileSh &= ".sh"
$scriptFileSh = GetSecureFilename($scriptFileSh)
$script = StringReplace($script, @CRLF, @LF)
Local $aCmds = StringSplit($script, @LF)
Local $hTimer = TimerInit()
Local $s = ""
If FileExists($hostPath) = 0 Then
SetLog($g_sAndroidEmulator & " ADB script file folder doesn't exist:", $COLOR_ERROR)
SetLog($hostPath, $COLOR_ERROR)
Return SetError(6, 0)
EndIf
SetError(0, 0)
Local $sDev
Local $cmds = ""
Local $dd[1]
Local $ddFile, $ddHandle
For $i = 1 To $aCmds[0]
Local $cmd = $aCmds[$i]
If StringInStr($cmd, "/dev/input/") = 1 Then
Local $aElem = StringSplit($cmd, " ")
$sDev = StringReplace($aElem[1], ":", "")
If $aElem[0] < 4 Then
SetDebugLog("ADB script " & $scriptFile & ": ignore line " & $i & ": " & $cmd, $COLOR_ACTION)
Else
If IsString($combine) = 1 And $combine = "dd" Then
$j = UBound($dd)
ReDim $dd[$j + 1]
$dd[0] = $sDev
$dd[$j] = GetBinaryEvent(Dec($aElem[2]), Dec($aElem[3]), Dec($aElem[4]))
$cmd = ""
Else
$cmd = "sendevent " & $sDev & " " & Dec($aElem[2]) & " " & Dec($aElem[3]) & " " & Dec($aElem[4])
EndIf
EndIf
EndIf
$cmd = StringStripWS($cmd, 3)
If $cmd = "#dd send" Then
$j = UBound($dd) - 1
If $j > 0 Then
$iAdditional += 1
$ddFile = GetSecureFilename($scriptFile & "." & $iAdditional)
ReDim $additionalFilenames[$iAdditional]
$additionalFilenames[$iAdditional - 1] = $ddFile
$ddHandle = FileOpen($hostPath & $ddFile, BitOR($FO_OVERWRITE, $FO_BINARY))
$cmd = "dd obs=" & 16 *($j - 1) & " if=" & $androidPath & $ddFile & " of=" & $dd[0]
For $k = 1 To $j
FileWrite($ddHandle, $dd[$k])
Next
FileClose($ddHandle)
EndIf
EndIf
$aCmds[$i] = $cmd
If $combine = True And IsString($combine) = 0 And StringLen($cmd) > 0 Then
$cmds &= $cmd
If $i < $aCmds[0] Then $cmds &= ";"
EndIf
Next
Local $loopCount = 0
If $combine = True And IsString($combine) = 0 And StringLen($cmds) <= 1024 Then
$s = AndroidAdbSendShellCommand($cmds, $timeout, $wasRunState, $EnsureShellInstance)
If @error <> 0 Then Return SetError(1, 0, $s)
Local $a = StringSplit(@extended, "#")
If $a[0] > 1 Then $loopCount += Number($a[2])
Else
If $scriptModifiedTime <> FileGetTime($hostPath & $scriptFileSh, $FT_MODIFIED, $FT_STRING) Then
FileDelete($hostPath & $scriptFileSh)
EndIf
If FileExists($hostPath & $scriptFileSh) = 0 Then
$script = "#!/bin/sh"
For $i = 1 To $aCmds[0]
If($i = 1 And $aCmds[$i] = $script) Or $aCmds[$i] = "" Then
ContinueLoop
EndIf
$script &=(@LF & $aCmds[$i])
Next
If FileWrite($hostPath & $scriptFileSh, $script) = 1 Then
If BitAND($AndroidSecureFlags, 3) = 0 Then SetLog("ADB script file created: " & $hostPath & $scriptFileSh)
Else
SetLog("ADB cannot create script file: " & $hostPath & $scriptFileSh, $COLOR_ERROR)
Return SetError(7, 0)
EndIf
FileSetTime($hostPath & $scriptFileSh, $scriptModifiedTime, $FT_MODIFIED)
EndIf
$s = AndroidAdbSendShellCommand("sh """ & $androidPath & $scriptFileSh & """", $timeout, $wasRunState, $EnsureShellInstance)
If BitAND($AndroidSecureFlags, 2) = 2 Then
FileDelete($hostPath & $scriptFileSh)
For $i = 0 To $iAdditional - 1
FileDelete($hostPath & $additionalFilenames[$i])
Next
EndIf
If @error <> 0 Then
SetDebugLog("Error executing " & $scriptFileSh & ": " & $s)
Return SetError(1, 0, $s)
EndIf
Local $a = StringSplit(@extended, "#")
If $a[0] > 1 Then $loopCount += Number($a[2])
EndIf
Return SetError(0, Int(TimerDiff($hTimer)) & "ms,#" & $loopCount, $s)
EndFunc
Func AndroidScreencap($iLeft, $iTop, $iWidth, $iHeight, $iRetryCount = 0)
Local $wasAllowed = $g_bTogglePauseAllowed
$g_bTogglePauseAllowed = False
Local $Result = _AndroidScreencap($iLeft, $iTop, $iWidth, $iHeight, $iRetryCount)
$g_bTogglePauseAllowed = $wasAllowed
Return SetError(@error, @extended, $Result)
EndFunc
Func _AndroidScreencap($iLeft, $iTop, $iWidth, $iHeight, $iRetryCount = 0)
Local $startTimer = TimerInit()
Local $hostPath = $g_sAndroidPicturesHostPath & $g_sAndroidPicturesHostFolder
Local $androidPath = $g_sAndroidPicturesPath & StringReplace($g_sAndroidPicturesHostFolder, "\", "/")
If $hostPath = "" Or $androidPath = "" Then
If $hostPath = "" Then
SetLog($g_sAndroidEmulator & " shared folder not configured for host", $COLOR_ERROR)
Else
SetLog($g_sAndroidEmulator & " shared folder not configured for Android", $COLOR_ERROR)
EndIf
SetLog($g_sAndroidEmulator & " ADB screen capture disabled", $COLOR_ERROR)
If BitAND($g_iAndroidSupportFeature, 1) = 0 Then $g_bChkBackgroundMode = False
$g_bAndroidAdbScreencap = False
EndIf
Local $wasRunState = $g_bRunState
AndroidAdbLaunchShellInstance($wasRunState)
If @error <> 0 Then Return SetError(2, 0)
Local $sBotTitleEx = StringRegExpReplace($g_sBotTitle, '[/:*?"<>|]', '_')
Local $Filename = $sBotTitleEx & ".rgba"
If $g_bAndroidAdbScreencapPngEnabled = True Then $Filename = $sBotTitleEx & ".png"
$Filename = GetSecureFilename($Filename)
Local $s
Local $tBIV5HDR = 0
If $g_bAndroidAdbScreencapPngEnabled = False Then
$tBIV5HDR = DllStructCreate($tagBITMAPV5HEADER)
DllStructSetData($tBIV5HDR, 'bV5Size', DllStructGetSize($tBIV5HDR))
DllStructSetData($tBIV5HDR, 'bV5Width', $iWidth)
DllStructSetData($tBIV5HDR, 'bV5Height', -$iHeight)
DllStructSetData($tBIV5HDR, 'bV5Planes', 1)
DllStructSetData($tBIV5HDR, 'bV5BitCount', 32)
DllStructSetData($tBIV5HDR, 'biCompression', $BI_RGB)
EndIf
Local $pBits = 0
Local $hHBitmap = 0
If $g_iAndroidAdbScreencapTimer <> 0 And $g_bForceCapture = False And TimerDiff($g_iAndroidAdbScreencapTimer) < $g_iAndroidAdbScreencapTimeout And $g_bRunState = True And $iRetryCount = 0 Then
If $g_bAndroidAdbScreencapPngEnabled = False Then
$hHBitmap = _WinAPI_CreateDIBSection(0, $tBIV5HDR, $DIB_RGB_COLORS, $pBits)
$tBIV5HDR = 0
DllCall($g_sLibPath & "\helper_functions.dll", "none:cdecl", "RGBA2BGRA", "ptr", DllStructGetPtr($g_aiAndroidAdbScreencapBuffer), "ptr", $pBits, "int", $iLeft, "int", $iTop, "int", $iWidth, "int", $iHeight, "int", $g_iAndroidAdbScreencapWidth, "int", $g_iAndroidAdbScreencapHeight)
Return $hHBitmap
ElseIf $g_hAndroidAdbScreencapBufferPngHandle <> 0 Then
If $iWidth > $g_iAndroidAdbScreencapWidth - $iLeft Then $iWidth = $g_iAndroidAdbScreencapWidth - $iLeft
If $iHeight > $g_iAndroidAdbScreencapHeight - $iTop Then $iHeight = $g_iAndroidAdbScreencapHeight - $iTop
Local $hClone = _GDIPlus_BitmapCloneArea($g_hAndroidAdbScreencapBufferPngHandle, $iLeft, $iTop, $iWidth, $iHeight, $GDIP_PXF32ARGB)
Return _GDIPlus_BitmapCreateDIBFromBitmap($hClone)
EndIf
EndIf
FileDelete($hostPath & $Filename)
$s = AndroidAdbSendShellCommand("screencap """ & $androidPath & $Filename & """", $g_iAndroidAdbScreencapWaitAdbTimeout, $wasRunState)
If $__TEST_ERROR_SLOW_ADB_SCREENCAP_DELAY > 0 Then Sleep($__TEST_ERROR_SLOW_ADB_SCREENCAP_DELAY)
Local $shellLogInfo = @extended
Local $hTimer = TimerInit()
Local $hFile = 0
Local $iSize = 0
Local $iLoopCountFile = 0
Local $AdbStatsType = 0
Local $iF = 0
Local $ExpectedFileSize = 1500
Local $iReadData = 0
If $g_bAndroidAdbScreencapPngEnabled = False Then
Local $tHeader = DllStructCreate("int w;int h;int f")
Local $iHeaderSize = DllStructGetSize($tHeader)
Local $iDataSize = DllStructGetSize($g_aiAndroidAdbScreencapBuffer)
$ExpectedFileSize = $g_iAndroidClientWidth * $g_iAndroidClientHeight * 4 + $iHeaderSize
While $iSize < $ExpectedFileSize And TimerDiff($hTimer) < $g_iAndroidAdbScreencapWaitFileTimeout
If $hFile = 0 Then $hFile = _WinAPI_CreateFile($hostPath & $Filename, 2, 2, 7)
If $hFile <> 0 Then $iSize = _WinAPI_GetFileSizeEx($hFile)
If $iSize >= $ExpectedFileSize Then ExitLoop
Sleep(10)
If $wasRunState = True And $g_bRunState = False Then
If $hFile <> 0 Then _WinAPI_CloseHandle($hFile)
Return SetError(1, 0)
EndIf
$iLoopCountFile += 1
WEnd
Local $iReadHeader = 0
$g_iAndroidAdbScreencapWidth = 0
$g_iAndroidAdbScreencapHeight = 0
If $hFile <> 0 Then
If $iSize >= $ExpectedFileSize Then
$hTimer = TimerInit()
While $iReadHeader < $iHeaderSize And TimerDiff($hTimer) < $g_iAndroidAdbScreencapWaitFileTimeout
If _WinAPI_ReadFile($hFile, $tHeader, $iHeaderSize, $iReadHeader) = True And $iReadHeader = $iHeaderSize Then
ExitLoop
Else
SetDebugLog("Error " & _WinAPI_GetLastError() & ", read " & $iReadHeader & " header bytes, file: " & $hostPath & $Filename, $COLOR_ERROR)
If $iReadHeader > 0 Then _WinAPI_SetFilePointer($hFile, 0)
Sleep(10)
EndIf
WEnd
$g_iAndroidAdbScreencapWidth = DllStructGetData($tHeader, "w")
$g_iAndroidAdbScreencapHeight = DllStructGetData($tHeader, "h")
$iF = DllStructGetData($tHeader, "f")
$hTimer = TimerInit()
If $iSize - $iHeaderSize < $iDataSize Then $iDataSize = $iSize - $iHeaderSize
While $iReadData < $iDataSize And TimerDiff($hTimer) < $g_iAndroidAdbScreencapWaitFileTimeout
If _WinAPI_ReadFile($hFile, $g_aiAndroidAdbScreencapBuffer, $iDataSize, $iReadData) = True And $iReadData = $iDataSize Then
ExitLoop
Else
SetDebugLog("Error " & _WinAPI_GetLastError() & ", read " & $iReadData & " data bytes, file: " & $hostPath & $Filename, $COLOR_ERROR)
If $iReadData > 0 Then _WinAPI_SetFilePointer($hFile, $iHeaderSize)
Sleep(10)
EndIf
WEnd
_WinAPI_CloseHandle($hFile)
$hHBitmap = _WinAPI_CreateDIBSection(0, $tBIV5HDR, $DIB_RGB_COLORS, $pBits)
DllCall($g_sLibPath & "\helper_functions.dll", "none:cdecl", "RGBA2BGRA", "ptr", DllStructGetPtr($g_aiAndroidAdbScreencapBuffer), "ptr", $pBits, "int", $iLeft, "int", $iTop, "int", $iWidth, "int", $iHeight, "int", $g_iAndroidAdbScreencapWidth, "int", $g_iAndroidAdbScreencapHeight)
Else
_WinAPI_CloseHandle($hFile)
SetDebugLog("File too small (" & $iSize & " < " & $ExpectedFileSize & "): " & $hostPath & $Filename, $COLOR_ERROR)
EndIf
EndIf
If $hFile = 0 Or $iSize < $ExpectedFileSize Or $iReadHeader < $iHeaderSize Or $iReadData < $iDataSize Then
If $hFile = 0 Then
SetLog("File not found: " & $hostPath & $Filename, $COLOR_ERROR)
Else
If $iSize <> $ExpectedFileSize Then SetDebugLog("File size " & $iSize & " is not " & $ExpectedFileSize & " for " & $hostPath & $Filename, $COLOR_ERROR)
SetDebugLog("Captured screen size " & $g_iAndroidAdbScreencapWidth & " x " & $g_iAndroidAdbScreencapHeight, $COLOR_ERROR)
SetDebugLog("Captured screen bytes read (header/datata): " & $iReadHeader & " / " & $iReadData, $COLOR_ERROR)
EndIf
If $iRetryCount < 10 Then
SetDebugLog("ADB retry screencap in 1000 ms. (restarting ADB session)", $COLOR_ACTION)
_Sleep(1000)
AndroidAdbTerminateShellInstance()
AndroidAdbLaunchShellInstance($wasRunState)
Return AndroidScreencap($iLeft, $iTop, $iWidth, $iHeight, $iRetryCount + 1)
EndIf
SetLog($g_sAndroidEmulator & " screen not captured using ADB", $COLOR_ERROR)
If $g_aiAndroidAdbStatsTotal[$AdbStatsType][0] < 50 And AndroidControlAvailable() Then
SetLog($g_sAndroidEmulator & " ADB screen capture disabled", $COLOR_ERROR)
If BitAND($g_iAndroidSupportFeature, 1) = 0 Then $g_bChkBackgroundMode = False
$g_bAndroidAdbScreencap = False
Else
SetLog("Rebooting " & $g_sAndroidEmulator & " due to problems capturing screen", $COLOR_ERROR)
Local $_NoFocusTampering = $g_bNoFocusTampering
$g_bNoFocusTampering = True
RebootAndroid()
$g_bNoFocusTampering = $_NoFocusTampering
EndIf
Return SetError(3, 0)
EndIf
Else
If $g_hAndroidAdbScreencapBufferPngHandle <> 0 Then
_GDIPlus_ImageDispose($g_hAndroidAdbScreencapBufferPngHandle)
_GDIPlus_BitmapDispose($g_hAndroidAdbScreencapBufferPngHandle)
_WinAPI_DeleteObject($g_hAndroidAdbScreencapBufferPngHandle)
$g_hAndroidAdbScreencapBufferPngHandle = 0
EndIf
Local $hBitmap = 0
While $iSize < $ExpectedFileSize And TimerDiff($hTimer) < $g_iAndroidAdbScreencapWaitFileTimeout
If $hFile = 0 Then $hFile = _WinAPI_CreateFile($hostPath & $Filename, 2, 2, 7)
If $hFile <> 0 Then $iSize = _WinAPI_GetFileSizeEx($hFile)
If $iSize >= $ExpectedFileSize Then ExitLoop
Sleep(10)
If $wasRunState = True And $g_bRunState = False Then Return SetError(1, 0)
$iLoopCountFile += 1
WEnd
Local $hData = _MemGlobalAlloc($iSize, $GMEM_MOVEABLE)
Local $pData = _MemGlobalLock($hData)
Local $tData = DllStructCreate('byte[' & $iSize & ']', $pData)
While $iSize > 0 And $iReadData < $iSize And TimerDiff($hTimer) < $g_iAndroidAdbScreencapWaitFileTimeout
If _WinAPI_ReadFile($hFile, $tData, $iSize, $iReadData) = True And $iReadData = $iSize Then
ExitLoop
Else
SetDebugLog("Error " & _WinAPI_GetLastError() & ", read " & $iReadData & " data bytes, file: " & $hostPath & $Filename, $COLOR_ERROR)
If $iReadData > 0 Then _WinAPI_SetFilePointer($hFile, 0)
Sleep(10)
EndIf
WEnd
_WinAPI_CloseHandle($hFile)
SetDebugLog($iSize, $COLOR_ERROR)
Local $testTimer = TimerInit()
Local $msg = ""
_MemGlobalUnlock($hData)
Local $pStream = _WinAPI_CreateStreamOnHGlobal($hData)
$hBitmap = _GDIPlus_BitmapCreateFromStream($pStream)
_WinAPI_ReleaseStream($pStream)
$msg &= ", " & Round(TimerDiff($testTimer), 2)
If $hBitmap = 0 Then
If $iRetryCount < 10 Then
SetDebugLog("ADB retry screencap in 1000 ms. (restarting ADB session)", $COLOR_ACTION)
_Sleep(1000)
AndroidAdbTerminateShellInstance()
AndroidAdbLaunchShellInstance($wasRunState)
Return AndroidScreencap($iLeft, $iTop, $iWidth, $iHeight, $iRetryCount + 1)
EndIf
SetLog($g_sAndroidEmulator & " screen not captured using ADB", $COLOR_ERROR)
If FileExists($hostPath & $Filename) = 0 Then SetLog("File not found: " & $hostPath & $Filename, $COLOR_ERROR)
SetLog($g_sAndroidEmulator & " ADB screen capture disabled", $COLOR_ERROR)
$g_bAndroidAdbScreencap = False
Return SetError(5, 0)
Else
$g_iAndroidAdbScreencapWidth = _GDIPlus_ImageGetWidth($hBitmap)
$g_iAndroidAdbScreencapHeight = _GDIPlus_ImageGetHeight($hBitmap)
$msg &= ", " & Round(TimerDiff($testTimer), 2)
If $iWidth > $g_iAndroidAdbScreencapWidth - $iLeft Then $iWidth = $g_iAndroidAdbScreencapWidth - $iLeft
If $iHeight > $g_iAndroidAdbScreencapHeight - $iTop Then $iHeight = $g_iAndroidAdbScreencapHeight - $iTop
Local $hClone = _GDIPlus_BitmapCloneArea($hBitmap, $iLeft, $iTop, $iWidth, $iHeight, $GDIP_PXF32ARGB)
$msg &= ", " & Round(TimerDiff($testTimer), 2)
If $hClone = 0 Then
SetDebugLog($g_sAndroidEmulator & " error using " & $g_iAndroidAdbScreencapWidth & "x" & $g_iAndroidAdbScreencapHeight & " on _GDIPlus_BitmapCloneArea(" & $hBitmap & "," & $iLeft & "," & $iTop & "," & $iWidth & "," & $iHeight, $COLOR_ERROR)
SetLog($g_sAndroidEmulator & " screenshot not available", $COLOR_ERROR)
SetLog($g_sAndroidEmulator & " ADB screen capture disabled", $COLOR_ERROR)
$g_bAndroidAdbScreencap = False
Return SetError(6, 0)
EndIf
$g_hAndroidAdbScreencapBufferPngHandle = $hBitmap
$msg &= ", " & Round(TimerDiff($testTimer), 2)
$hHBitmap = _GDIPlus_BitmapCreateDIBFromBitmap($hClone)
EndIf
EndIf
If BitAND($AndroidSecureFlags, 2) = 2 Then
FileDelete($hostPath & $Filename)
EndIf
Local $duration = Int(TimerDiff($startTimer))
$g_iAndroidAdbScreencapTimeout =($g_iAndroidAdbScreencapTimeoutDynamic = 0 ? $g_iAndroidAdbScreencapTimeoutMax : $duration * $g_iAndroidAdbScreencapTimeoutDynamic)
If $g_iAndroidAdbScreencapTimeout < $g_iAndroidAdbScreencapTimeoutMin Then $g_iAndroidAdbScreencapTimeout = $g_iAndroidAdbScreencapTimeoutMin
If $g_iAndroidAdbScreencapTimeout > $g_iAndroidAdbScreencapTimeoutMax Then $g_iAndroidAdbScreencapTimeout = $g_iAndroidAdbScreencapTimeoutMax
$g_iAndroidAdbScreencapTimer = TimerInit()
$g_aiAndroidAdbStatsTotal[$AdbStatsType][0] += 1
$g_aiAndroidAdbStatsTotal[$AdbStatsType][1] += $duration
Local $iLastCount = UBound($g_aiAndroidAdbStatsLast, 2) - 2
If $g_aiAndroidAdbStatsTotal[$AdbStatsType][0] <= $iLastCount Then
$g_aiAndroidAdbStatsLast[$AdbStatsType][0] += $duration
$g_aiAndroidAdbStatsLast[$AdbStatsType][$g_aiAndroidAdbStatsTotal[$AdbStatsType][0] + 1] = $duration
If $g_aiAndroidAdbStatsTotal[$AdbStatsType][0] = $iLastCount Then $g_aiAndroidAdbStatsLast[$AdbStatsType][1] = 0
Else
Local $iLastIdx = $g_aiAndroidAdbStatsLast[$AdbStatsType][1] + 2
$g_aiAndroidAdbStatsLast[$AdbStatsType][0] -= $g_aiAndroidAdbStatsLast[$AdbStatsType][$iLastIdx]
$g_aiAndroidAdbStatsLast[$AdbStatsType][0] += $duration
$g_aiAndroidAdbStatsLast[$AdbStatsType][$iLastIdx] = $duration
$g_aiAndroidAdbStatsLast[$AdbStatsType][1] = Mod($g_aiAndroidAdbStatsLast[$AdbStatsType][1] + 1, $iLastCount)
EndIf
If $g_aiAndroidAdbStatsLast[$AdbStatsType][1] = 0 Then
Local $totalAvg = Round($g_aiAndroidAdbStatsTotal[$AdbStatsType][1] / $g_aiAndroidAdbStatsTotal[$AdbStatsType][0])
Local $lastAvg = Round($g_aiAndroidAdbStatsLast[$AdbStatsType][0] / $iLastCount)
If $g_iDebugSetlog = 1 Or Mod($g_aiAndroidAdbStatsTotal[$AdbStatsType][0], 100) = 0 Then
SetDebugLog("AdbScreencap: " & $totalAvg & "/" & $lastAvg & "/" & $duration & " ms (all/" & $iLastCount & "/1)," & $shellLogInfo & "," & $iLoopCountFile & ",l=" & $iLeft & ",t=" & $iTop & ",w=" & $iWidth & ",h=" & $iHeight & ", " & $Filename & ": w=" & $g_iAndroidAdbScreencapWidth & ",h=" & $g_iAndroidAdbScreencapHeight & ",f=" & $iF)
EndIf
EndIf
$tBIV5HDR = 0
Return $hHBitmap
EndFunc
Func AndroidZoomOut($overWaters = False, $loopCount = 0, $timeout = Default, $wasRunState = $g_bRunState)
If $overWaters = True Then AndroidAdbScript("OverWaters", Default, $timeout, $wasRunState)
Return AndroidAdbScript("ZoomOut", Default, $timeout, $wasRunState)
EndFunc
Func AndroidAdbScript($scriptTag, $variablesArray = Default, $timeout = Default, $wasRunState = $g_bRunState)
ResumeAndroid()
If $g_bAndroidAdbZoomoutEnabled = False Then Return SetError(4, 0)
AndroidAdbLaunchShellInstance($wasRunState)
If @error <> 0 Then Return SetError(2, 0, 0)
If StringInStr($g_sAndroidMouseDevice, "/dev/input/event") = 0 Then Return SetError(2, 0, 0)
Local $scriptFile = ""
If $scriptFile = "" And FileExists($g_sAdbScriptsPath & "\" & $scriptTag & "." & $g_sAndroidEmulator & ".script") = 1 Then $scriptFile = $scriptTag & "." & $g_sAndroidEmulator & ".script"
If $scriptFile = "" And FileExists($g_sAdbScriptsPath & "\" & $scriptTag & "." & $g_sAndroidEmulator & ".getevent") = 1 Then $scriptFile = $scriptTag & "." & $g_sAndroidEmulator & ".getevent"
If $scriptFile = "" And FileExists($g_sAdbScriptsPath & "\" & $scriptTag & ".script") = 1 Then $scriptFile = $scriptTag & ".script"
If $scriptFile = "" Then $scriptFile = $scriptTag & ".getevent"
If FileExists($g_sAdbScriptsPath & "\" & $scriptFile) = 0 Then Return SetError(1, 0, 0)
AndroidAdbSendShellCommandScript($scriptFile, $variablesArray, Default, $timeout, $wasRunState)
Return SetError(@error, @extended,(@error = 0 ? 1 : 0))
EndFunc
Func AndroidClickDrag($x1, $y1, $x2, $y2, $wasRunState = $g_bRunState)
Execute($g_sAndroidEmulator & "AdjustClickCoordinates($x1,$y1)")
Execute($g_sAndroidEmulator & "AdjustClickCoordinates($x2,$y2)")
Local $swipe_coord[4][2] = [["{$x1}", $x1], ["{$y1}", $y1], ["{$x2}", $x2], ["{$y2}", $y2]]
Return AndroidAdbScript("clickdrag", $swipe_coord, Default, $wasRunState)
EndFunc
Func IsKeepClicksActive($Really = True)
If $Really = True Then
Return $g_bAndroidAdbClick = True And $g_bAndroidAdbClicksEnabled = True And $g_aiAndroidAdbClicks[0] > -1
EndIf
Return $g_bAndroidAdbKeepClicksActive
EndFunc
Func KeepClicks()
$g_bAndroidAdbKeepClicksActive = True
If $g_bAndroidAdbClick = False Or $g_bAndroidAdbClicksEnabled = False Then Return False
If $g_aiAndroidAdbClicks[0] = -1 Then $g_aiAndroidAdbClicks[0] = 0
EndFunc
Func ReleaseClicks($minClicksToRelease = 0, $ReleaseClicksEnabled = $g_bAndroidAdbClicksEnabled)
If $g_bAndroidAdbClick = False Or $ReleaseClicksEnabled = False Then
$g_bAndroidAdbKeepClicksActive = False
Return False
EndIf
If $g_aiAndroidAdbClicks[0] > 0 And $g_bRunState = True Then
If $g_aiAndroidAdbClicks[0] >= $minClicksToRelease Then
AndroidClick(-1, -1, $g_aiAndroidAdbClicks[0], 0)
Else
Return False
EndIf
EndIf
$g_bAndroidAdbKeepClicksActive = False
ReDim $g_aiAndroidAdbClicks[1]
$g_aiAndroidAdbClicks[0] = -1
EndFunc
Func AndroidAdbClickSupported()
Return BitAND($g_iAndroidSupportFeature, 4) = 4
EndFunc
Func AndroidClick($x, $y, $times = 1, $speed = 0, $checkProblemAffect = True)
AndroidFastClick($x, $y, $times, $speed, $checkProblemAffect)
EndFunc
Func AndroidMoveMouseAnywhere()
Local $_SilentSetLog = $g_bSilentSetLog
Local $hostPath = $g_sAndroidPicturesHostPath & $g_sAndroidPicturesHostFolder
Local $androidPath = $g_sAndroidPicturesPath & StringReplace($g_sAndroidPicturesHostFolder, "\", "/")
Local $sBotTitleEx = StringRegExpReplace($g_sBotTitle, '[/:*?"<>|]', '_')
Local $Filename = GetSecureFilename($sBotTitleEx & ".moveaway")
Local $recordsNum = 4
Local $iToWrite = $recordsNum * 16
Local $records = ""
If FileExists($hostPath & $Filename) = 0 Then
Local $times = 1
Local $x = 1
Local $y = 40
Execute($g_sAndroidEmulator & "AdjustClickCoordinates($x,$y)")
Local $i = 0
Local $record = "byte[16];"
For $i = 1 To $recordsNum * $times
$records &= $record
Next
Local $data = DllStructCreate($records)
$i = 0
DllStructSetData($data, 1 + $i * $recordsNum, Binary("0x000000000000000003003500" & StringRight(Hex($x, 4), 2) & StringLeft(Hex($x, 4), 2) & "0000"))
DllStructSetData($data, 2 + $i * $recordsNum, Binary("0x000000000000000003003600" & StringRight(Hex($y, 4), 2) & StringLeft(Hex($y, 4), 2) & "0000"))
DllStructSetData($data, 3 + $i * $recordsNum, Binary("0x00000000000000000000020000000000"))
DllStructSetData($data, 4 + $i * $recordsNum, Binary("0x00000000000000000000000000000000"))
Local $data2 = DllStructCreate("byte[" & DllStructGetSize($data) & "]", DllStructGetPtr($data))
Local $iWritten = 0
Local $sleep = ""
Local $hFileOpen = _WinAPI_CreateFile($hostPath & $Filename, 1, 4)
If $hFileOpen = 0 Then
Local $error = _WinAPI_GetLastError()
Return SetError($error, 0)
EndIf
_WinAPI_WriteFile($hFileOpen, DllStructGetPtr($data2), $iToWrite, $iWritten)
_WinAPI_CloseHandle($hFileOpen)
EndIf
$g_bSilentSetLog = True
AndroidAdbSendShellCommand("dd if=""" & $androidPath & $Filename & """ of=" & $g_sAndroidMouseDevice & " obs=" & $iToWrite & ">/dev/null 2>&1" & $sleep, Default)
If BitAND($AndroidSecureFlags, 2) = 2 Then
FileDelete($hostPath & $Filename)
EndIf
$g_bSilentSetLog = $_SilentSetLog
EndFunc
Func AndroidFastClick($x, $y, $times = 1, $speed = 0, $checkProblemAffect = True, $iRetryCount = 0)
Local $wasAllowed = $g_bTogglePauseAllowed
$g_bTogglePauseAllowed = False
Local $Result = _AndroidFastClick($x, $y, $times, $speed, $checkProblemAffect, $iRetryCount)
$g_bTogglePauseAllowed = $wasAllowed
Return SetError(@error, @extended, $Result)
EndFunc
Func _AndroidFastClick($x, $y, $times = 1, $speed = 0, $checkProblemAffect = True, $iRetryCount = 0)
Local $_SilentSetLog = $g_bSilentSetLog
Local $hDuration = TimerInit()
If $times < 1 Then Return SetError(0, 0)
Local $i = 0, $j = 0
Local $Click = [$x, $y, "down-up"]
Local $ReleaseClicks =($x = -1 And $y = -1 And $g_aiAndroidAdbClicks[0] > 0)
If $ReleaseClicks = False And $g_aiAndroidAdbClicks[0] > -1 Then
Local $pos = $g_aiAndroidAdbClicks[0]
$g_aiAndroidAdbClicks[0] = $pos + $times
ReDim $g_aiAndroidAdbClicks[$g_aiAndroidAdbClicks[0] + 1]
For $i = 1 To $times
$g_aiAndroidAdbClicks[$pos + $i] = $Click
Next
If $g_iDebugSetlog = 1 Or $g_iDebugClick = 1 Then
$g_bSilentSetLog = True
SetDebugLog("Hold back click (" & $x & "/" & $y & " * " & $times & "): queue size = " & $g_aiAndroidAdbClicks[0], $COLOR_ERROR)
$g_bSilentSetLog = $_SilentSetLog
EndIf
Return
EndIf
$x = Int($x)
$y = Int($y)
Local $wasRunState = $g_bRunState
Local $hostPath = $g_sAndroidPicturesHostPath & $g_sAndroidPicturesHostFolder
Local $androidPath = $g_sAndroidPicturesPath & StringReplace($g_sAndroidPicturesHostFolder, "\", "/")
If $hostPath = "" Or $androidPath = "" Then
If $hostPath = "" Then
SetLog($g_sAndroidEmulator & " shared folder not configured for host", $COLOR_ERROR)
Else
SetLog($g_sAndroidEmulator & " shared folder not configured for Android", $COLOR_ERROR)
EndIf
SetLog($g_sAndroidEmulator & " shared folder not configured for Android", $COLOR_ERROR)
$g_bAndroidAdbClick = False
SetLog("Disabled " & $g_sAndroidEmulator & " ADB fast mouse click", $COLOR_ERROR)
Return SetError(1, 0)
EndIf
AndroidAdbLaunchShellInstance($wasRunState)
Local $sBotTitleEx = StringRegExpReplace($g_sBotTitle, '[/:*?"<>|]', '_')
Local $Filename = GetSecureFilename($sBotTitleEx & ".click")
Local $record = "byte[16];"
Local $records = ""
Local $loops = 1
Local $remaining = 0
Local $adjustSpeed = 0
Local $timer = TimerInit()
If $times > $g_iAndroidAdbClickGroup Then
$speed = $g_iAndroidAdbClickGroupDelay
$remaining = Mod($times, $g_iAndroidAdbClickGroup)
$loops = Int($times / $g_iAndroidAdbClickGroup) +($remaining > 0 ? 1 : 0)
$times = $g_iAndroidAdbClickGroup
Else
If $ReleaseClicks = False Then $adjustSpeed = $speed
$speed = 0
EndIf
Local $recordsNum = 10
Local $recordsClicks =($times < $g_iAndroidAdbClickGroup ? $times : $g_iAndroidAdbClickGroup)
For $i = 1 To $recordsNum * $recordsClicks
$records &= $record
Next
If $ReleaseClicks = True Then
If $g_iDebugSetlog = 1 Or $g_iDebugClick = 1 Then SetDebugLog("Release clicks: queue size = " & $g_aiAndroidAdbClicks[0])
Else
Execute($g_sAndroidEmulator & "AdjustClickCoordinates($x,$y)")
EndIf
Local $data = DllStructCreate($records)
For $i = 0 To $recordsClicks - 1
DllStructSetData($data, 1 + $i * $recordsNum, Binary("0x000000000000000001004a0101000000"))
DllStructSetData($data, 2 + $i * $recordsNum, Binary("0x000000000000000003003a0001000000"))
DllStructSetData($data, 5 + $i * $recordsNum, Binary("0x00000000000000000000020000000000"))
DllStructSetData($data, 6 + $i * $recordsNum, Binary("0x00000000000000000000000000000000"))
DllStructSetData($data, 7 + $i * $recordsNum, Binary("0x000000000000000001004a0100000000"))
DllStructSetData($data, 8 + $i * $recordsNum, Binary("0x000000000000000003003a0000000000"))
DllStructSetData($data, 9 + $i * $recordsNum, Binary("0x00000000000000000000020000000000"))
DllStructSetData($data, 10 + $i * $recordsNum, Binary("0x00000000000000000000000000000000"))
Next
Local $AdbStatsType = 1
Local $data2 = DllStructCreate("byte[" & DllStructGetSize($data) & "]", DllStructGetPtr($data))
Local $hFileOpen = 0
Local $iToWrite = DllStructGetSize($data2)
Local $iWritten = 0
Local $sleep = ""
Local $timeSlept = 0
If $speed > 0 Then
$sleep = "/system/xbin/sleep " &($speed / 1000)
EndIf
For $i = 1 To $loops
If IsKeepClicksActive(False) = False Then
If $checkProblemAffect = True Then
If isProblemAffect(True) Then
SetDebugLog("VOIDED Click " & $x & "," & $y & "," & $times & "," & $speed, $COLOR_ERROR, "Verdana", "7.5", 0)
checkMainScreen(False)
Return
EndIf
EndIf
EndIf
If $i = $loops And $remaining > 0 Then
$iToWrite =(16 * $recordsNum) * $remaining
$recordsClicks = $remaining
$hFileOpen = 0
ElseIf $ReleaseClicks = True Then
$hFileOpen = 0
EndIf
If $hFileOpen = 0 Then
Local $timer = TimerInit()
While $hFileOpen = 0 And TimerDiff($timer) < 3000
$hFileOpen = _WinAPI_CreateFile($hostPath & $Filename, 1, 4)
If $hFileOpen <> 0 Then ExitLoop
SetDebugLog("Error " & _WinAPI_GetLastError() & " (" & Round(TimerDiff($timer)) & "ms) creating " & $hostPath & $Filename, $COLOR_ERROR)
Sleep(10)
WEnd
If $hFileOpen = 0 Then
Local $error = _WinAPI_GetLastError()
SetLog("Error creating " & $hostPath & $Filename, $COLOR_ERROR)
SetError($error)
ExitLoop
EndIf
For $j = 0 To $recordsClicks - 1
Local $BTN_TOUCH_DOWN = True
Local $BTN_TOUCH_UP = True
If $ReleaseClicks = True Then
$Click = $g_aiAndroidAdbClicks[($i - 1) * $recordsNum + $j + 1]
$x = $Click[0]
$y = $Click[1]
Execute($g_sAndroidEmulator & "AdjustClickCoordinates($x,$y)")
Local $up_down = $Click[2]
$BTN_TOUCH_DOWN = StringInStr($up_down, "down") > 0
$BTN_TOUCH_UP = StringInStr($up_down, "up") > 0
EndIf
If $BTN_TOUCH_DOWN Then
Else
DllStructSetData($data, 1 + $j * $recordsNum, Binary("0x00000000000000000000020000000000"))
DllStructSetData($data, 2 + $j * $recordsNum, Binary("0x00000000000000000000000000000000"))
EndIf
DllStructSetData($data, 3 + $j * $recordsNum, Binary("0x000000000000000003003500" & StringRight(Hex($x, 4), 2) & StringLeft(Hex($x, 4), 2) & "0000"))
DllStructSetData($data, 4 + $j * $recordsNum, Binary("0x000000000000000003003600" & StringRight(Hex($y, 4), 2) & StringLeft(Hex($y, 4), 2) & "0000"))
If $BTN_TOUCH_UP Then
Else
DllStructSetData($data, 7 + $j * $recordsNum, Binary("0x00000000000000000000020000000000"))
DllStructSetData($data, 8 + $j * $recordsNum, Binary("0x00000000000000000000000000000000"))
EndIf
Next
_WinAPI_WriteFile($hFileOpen, DllStructGetPtr($data2), $iToWrite, $iWritten)
If $hFileOpen = 0 Then
Local $error = _WinAPI_GetLastError()
SetLog("Error writing " & $hostPath & $Filename, $COLOR_ERROR)
SetError($error)
ExitLoop
EndIf
_WinAPI_CloseHandle($hFileOpen)
EndIf
If $loops > 1 Then
AndroidMoveMouseAnywhere()
EndIf
$g_bSilentSetLog = True
AndroidAdbSendShellCommand("dd if=""" & $androidPath & $Filename & """ of=" & $g_sAndroidMouseDevice & " obs=" & $iToWrite & ">/dev/null 2>&1", Default)
If BitAND($AndroidSecureFlags, 2) = 2 Then
FileDelete($hostPath & $Filename)
EndIf
$g_bSilentSetLog = $_SilentSetLog
Local $sleepTimer = TimerInit()
If $speed > 0 Then
Local $sleepTime = $speed - TimerDiff($sleepTimer)
If $sleepTime > 0 Then _Sleep($sleepTime, False)
EndIf
If $adjustSpeed > 0 Then
Local $wait = Round($adjustSpeed - TimerDiff($timer))
If $wait > 0 Then
If $g_iDebugSetlog = 1 Or $g_iDebugClick = 1 Then
$g_bSilentSetLog = True
SetDebugLog("AndroidFastClick: Sleep " & $wait & " ms.")
$g_bSilentSetLog = $_SilentSetLog
EndIf
_Sleep($wait, False)
EndIf
EndIf
$timeSlept += TimerDiff($sleepTimer)
If $g_bRunState = False Then ExitLoop
If $__TEST_ERROR_SLOW_ADB_CLICK_DELAY > 0 Then Sleep($__TEST_ERROR_SLOW_ADB_CLICK_DELAY)
Next
If @error <> 0 Then
Local $error = @error
If $iRetryCount < 10 Then
SetError(0, 0, 0)
SetDebugLog("ADB retry sending mouse click in 1000 ms. (restarting ADB session)", $COLOR_ACTION)
_Sleep(1000)
AndroidAdbTerminateShellInstance()
AndroidAdbLaunchShellInstance($wasRunState)
Return AndroidFastClick($x, $y, $times, $speed, $checkProblemAffect, $iRetryCount + 1)
EndIf
If $g_aiAndroidAdbStatsTotal[$AdbStatsType][0] < 10 Then
SetLog("Disabled " & $g_sAndroidEmulator & " ADB fast mouse click due to error " & $error & " (#Err0004)", $COLOR_ERROR)
$g_bAndroidAdbClick = False
Else
SetLog("Rebooting " & $g_sAndroidEmulator & " due to problems sending mouse click", $COLOR_ERROR)
Local $_NoFocusTampering = $g_bNoFocusTampering
$g_bNoFocusTampering = True
RebootAndroid()
$g_bNoFocusTampering = $_NoFocusTampering
EndIf
Return SetError($error, 0)
EndIf
If IsKeepClicksActive(False) = False Then
$g_iAndroidAdbScreencapTimer = 0
EndIf
Local $duration = Round((TimerDiff($hDuration) - $timeSlept) / $loops)
$g_aiAndroidAdbStatsTotal[$AdbStatsType][0] += 1
$g_aiAndroidAdbStatsTotal[$AdbStatsType][1] += $duration
Local $iLastCount = UBound($g_aiAndroidAdbStatsLast, 2) - 2
If $g_aiAndroidAdbStatsTotal[$AdbStatsType][0] <= $iLastCount Then
$g_aiAndroidAdbStatsLast[$AdbStatsType][0] += $duration
$g_aiAndroidAdbStatsLast[$AdbStatsType][$g_aiAndroidAdbStatsTotal[$AdbStatsType][0] + 1] = $duration
If $g_aiAndroidAdbStatsTotal[$AdbStatsType][0] = $iLastCount Then $g_aiAndroidAdbStatsLast[$AdbStatsType][1] = 0
Else
Local $iLastIdx = $g_aiAndroidAdbStatsLast[$AdbStatsType][1] + 2
$g_aiAndroidAdbStatsLast[$AdbStatsType][0] -= $g_aiAndroidAdbStatsLast[$AdbStatsType][$iLastIdx]
$g_aiAndroidAdbStatsLast[$AdbStatsType][0] += $duration
$g_aiAndroidAdbStatsLast[$AdbStatsType][$iLastIdx] = $duration
$g_aiAndroidAdbStatsLast[$AdbStatsType][1] = Mod($g_aiAndroidAdbStatsLast[$AdbStatsType][1] + 1, $iLastCount)
EndIf
If $g_aiAndroidAdbStatsLast[$AdbStatsType][1] = 0 Then
Local $totalAvg = Round($g_aiAndroidAdbStatsTotal[$AdbStatsType][1] / $g_aiAndroidAdbStatsTotal[$AdbStatsType][0])
Local $lastAvg = Round($g_aiAndroidAdbStatsLast[$AdbStatsType][0] / $iLastCount)
If $g_iDebugSetlog = 1 Or $g_iDebugClick = 1 Or Mod($g_aiAndroidAdbStatsTotal[$AdbStatsType][0], 100) = 0 Then
SetDebugLog("AndroidFastClick: " & $totalAvg & "/" & $lastAvg & "/" & $duration & " ms (all/" & $iLastCount & "/1), $x=" & $x & ", $y=" & $y & ", $times=" & $times & ", $speed = " & $speed & ", $checkProblemAffect=" & $checkProblemAffect)
EndIf
EndIf
EndFunc
Func AndroidSendText($sText, $SymbolFix = False, $wasRunState = $g_bRunState)
AndroidAdbLaunchShellInstance($wasRunState)
Local $error = @error
If $error = 0 Then
Local $newText = StringReplace($sText, " ", "%s")
$newText = StringRegExpReplace($newText, "[^A-Za-z0-9\.,\?""!@#\$%\^&\*\(\)-_=\+;:<>\/\\\|\}\{\[\]`~]", ".")
If @extended <> 0 Then
If $SymbolFix = False Then SetDebugLog("Cannot use ADB to send input text, use Windows method", $COLOR_ERROR)
Return SetError(10, 0)
EndIf
If $SymbolFix = False Then
If $g_iAndroidAdbInputWordsCharLimit = 0 Then
AndroidAdbSendShellCommand("input text " & $newText, Default, $wasRunState)
Else
$newText = StringReplace($newText, "%s", " ")
Local $words = StringSplit($newText, " ")
Local $i, $word
For $i = 1 To $words[0]
$word = $words[$i]
While StringLen($word) > 0
AndroidAdbSendShellCommand("input text " & StringLeft($word, $g_iAndroidAdbInputWordsCharLimit), Default, $wasRunState)
$word = StringMid($word, $g_iAndroidAdbInputWordsCharLimit + 1)
WEnd
If $i < $words[0] Then AndroidAdbSendShellCommand("input text %s", Default, $wasRunState)
Next
EndIf
Else
AndroidAdbSendShellCommand("input text %s", Default, $wasRunState)
EndIf
SetError(0, 0)
Else
If $SymbolFix = False Then
SetDebugLog("Disabled " & $g_sAndroidEmulator & " ADB input due to error", $COLOR_ERROR)
$g_bAndroidAdbInput = False
EndIf
Return SetError($error, 0)
EndIf
EndFunc
Func SuspendAndroid($SuspendMode = True, $bDebugLog = True, $bForceSuspendAndroid = False)
If $g_bAndroidSuspendedEnabled = False And $bForceSuspendAndroid = False Then Return False
If $SuspendMode = False Then Return ResumeAndroid($bDebugLog, $bForceSuspendAndroid)
If $g_bAndroidSuspended = True Then Return True
Local $pid = GetAndroidSvcPid()
If $pid = -1 Or $pid = 0 Then $pid = GetAndroidPid()
If $pid = -1 Or $pid = 0 Then Return False
$g_bAndroidSuspended = True
_ProcessSuspendResume($pid, True)
$g_iAndroidSuspendedTimer = TimerInit()
If $bDebugLog = True Then SetDebugLog("Android Suspended")
Return False
EndFunc
Func ResumeAndroid($bDebugLog = True, $bForceSuspendAndroid = False)
If $g_bAndroidSuspendedEnabled = False And $bForceSuspendAndroid = False Then Return False
If $g_bAndroidSuspended = False Then Return False
Local $pid = GetAndroidSvcPid()
If $pid = -1 Or $pid = 0 Then $pid = GetAndroidPid()
If $pid = -1 Or $pid = 0 Then Return False
$g_bAndroidSuspended = False
_ProcessSuspendResume($pid, False)
$g_aiAndroidTimeLag[3] += TimerDiff($g_iAndroidSuspendedTimer)
If $bDebugLog = True Then SetDebugLog("Android Resumed (total time " & Round($g_aiAndroidTimeLag[3]) & " ms)")
Return True
EndFunc
Func AndroidCloseSystemBar()
If AndroidInvalidState() Then Return False
Local $wasRunState = $g_bRunState
AndroidAdbLaunchShellInstance($wasRunState)
If @error <> 0 Then
SetLog("Cannot close " & $g_sAndroidEmulator & " System Bar", $COLOR_ERROR)
Return False
EndIf
Local $cmdOutput = AndroidAdbSendShellCommand("service call activity 42 s16 com.android.systemui", Default, $wasRunState, False)
Local $Result = StringLeft($cmdOutput, 6) = "Result"
SetDebugLog("Closed " & $g_sAndroidEmulator & " System Bar: " & $Result)
Return $Result
EndFunc
Func AndroidOpenSystemBar($bZygote = False)
If AndroidInvalidState() Then Return False
Local $wasRunState = $g_bRunState
AndroidAdbLaunchShellInstance($wasRunState)
If @error <> 0 Then
SetLog("Cannot open " & $g_sAndroidEmulator & " System Bar", $COLOR_ERROR)
Return False
EndIf
Local $cmdOutput
Local $Result
If $bZygote = True Then
$cmdOutput = AndroidAdbSendShellCommand("setprop ctl.restart zygote", Default, $wasRunState, False)
$Result = $cmdOutput = ""
Else
$cmdOutput = AndroidAdbSendShellCommand("am startservice -n com.android.systemui/.SystemUIService", Default, $wasRunState, False)
$Result = StringLeft($cmdOutput, 16) = "Starting service"
SetDebugLog("Opened " & $g_sAndroidEmulator & " System Bar: " & $Result)
EndIf
Return $Result
EndFunc
Func RedrawAndroidWindow()
Local $Result = Execute("Redraw" & $g_sAndroidEmulator & "Window()")
If $Result = "" And @error <> 0 Then Return
Return $Result
EndFunc
Func AndroidQueueReboot($bQueueReboot = True)
$g_bAndroidQueueReboot = $bQueueReboot
EndFunc
Func AndroidInvalidState()
If $HWnD = 0 Then
SetDebugLog("AndroidInvalidState: No Window Handle", $COLOR_ERROR)
Return True
EndIf
If IsHWnd($HWnD) And WinGetHandle($HWnD, "") = 0 Then
SetDebugLog("AndroidInvalidState: Window Handle " & $HWnD & " doesn't exist", $COLOR_ERROR)
Return True
EndIf
If IsHWnd($HWnD) = False And IsNumber($HWnD) And $g_bAndroidBackgroundLaunched = False Then
SetDebugLog("AndroidInvalidState: PID " & $HWnD & " not supported for Headless Mode", $COLOR_ERROR)
Return True
EndIf
If $g_bAndroidBackgroundLaunched = True And ProcessExists2($HWnD) = 0 Then
SetDebugLog("AndroidInvalidState: PID " & $HWnD & " doesn't exist", $COLOR_ERROR)
Return True
EndIf
Return False
EndFunc
Func checkAndroidReboot($bRebootAndroid = True)
If checkAndroidTimeLag($bRebootAndroid) = True Or checkAndroidPageError($bRebootAndroid) = True Then
Local $_NoFocusTampering = $g_bNoFocusTampering
$g_bNoFocusTampering = True
RebootAndroid()
$g_bNoFocusTampering = $_NoFocusTampering
Return True
EndIf
Return False
EndFunc
Func GetAndroidProcessPID($sPackage = $g_sAndroidGamePackage, $bForeground = True)
If AndroidInvalidState() Then Return 0
Local $cmd = "ps -p|grep """ & $g_sAndroidGamePackage & """"
Local $output = AndroidAdbSendShellCommand($cmd)
$output = StringStripWS($output, 7)
Local $aPkgList[0][26]
Local $iCols
_ArrayAdd($aPkgList, $output, 0, " ", @LF)
For $i = 1 To UBound($aPkgList)
$iCols = _ArraySearch($aPkgList, "", 0, 0, 0, 0, 1, $i, True)
If $iCols > 9 And $aPkgList[$i - 1][$iCols - 1] = $g_sAndroidGamePackage Then
If $bForeground = True And $aPkgList[$i - 1][8] <> "0" Then
SetDebugLog("Android process " & $sPackage & " not running in foreground")
Return 0
EndIf
Return Int($aPkgList[$i - 1][1])
EndIf
Next
SetDebugLog("Android process " & $sPackage & " not running")
Return 0
EndFunc
Func HideAndroidWindow($bHide = True)
ResumeAndroid()
WinGetAndroidHandle()
WinGetPos($HWnD)
If @error <> 0 Then Return SetError(0, 0, 0)
Execute("Hide" & $g_sAndroidEmulator & "Window($bHide)")
If $bHide = True Then
WinMove2($HWnD, "", -32000, -32000)
ElseIf $bHide = False Then
WinMove2($HWnD, "", $AndroidPosX, $AndroidPosY)
WinActivate($HWnD)
EndIf
EndFunc
Func AndroidPicturePathAutoConfig($myPictures = Default, $subDir = Default, $bSetLog = Default)
If $subDir = Default Then $subDir = $g_sAndroidEmulator & " Photo"
If $bSetLog = Default Then $bSetLog = True
Local $Result = False
Local $path
If $g_bAndroidPicturesPathAutoConfig = True Then
If $g_sAndroidPicturesHostPath = "" Then
If $myPictures = Default Then $myPictures = RegRead("HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders\", "My Pictures")
If @error = 0 And FileExists($myPictures) = 1 Then
If $subDir <> "" Then $subDir = "\" & $subDir
$path = $myPictures & $subDir
If StringRight($path, 1) <> "\" Then $path &= "\"
If FileExists($path) = 1 Then
$g_sAndroidPicturesHostPath = $path
SetGuiLog("Shared folder: '" & $g_sAndroidPicturesHostPath & "' will be added to " & $g_sAndroidEmulator, $COLOR_SUCCESS, $bSetLog)
$Result = True
ElseIf DirCreate($path) = 1 Then
$g_sAndroidPicturesHostPath = $path
SetGuiLog("Configure " & $g_sAndroidEmulator & " to support shared folder", $COLOR_SUCCESS, $bSetLog)
SetGuiLog("Folder created: " & $path, $COLOR_SUCCESS, $bSetLog)
SetGuiLog("This shared folder will be added to " & $g_sAndroidEmulator, $COLOR_SUCCESS, $bSetLog)
$Result = True
Else
SetGuiLog("Cannot configure " & $g_sAndroidEmulator & " shared folder", $COLOR_SUCCESS, $bSetLog)
SetGuiLog("Cannot create folder: " & $path, $COLOR_ERROR, $bSetLog)
$g_bAndroidPicturesPathAutoConfig = False
EndIf
Else
SetGuiLog("Cannot configure " & $g_sAndroidEmulator & " shared folder", $COLOR_SUCCESS, $bSetLog)
SetGuiLog("Cannot find current user 'My Pictures' folder", $COLOR_ERROR, $bSetLog)
$g_bAndroidPicturesPathAutoConfig = False
EndIf
Else
$path = $g_sAndroidPicturesHostPath
If FileExists($path) = 1 Then
ElseIf DirCreate($path) = 1 Then
SetGuiLog("Shared folder created: " & $path, $COLOR_SUCCESS, $bSetLog)
Else
SetGuiLog("Cannot configure " & $g_sAndroidEmulator & " shared folder", $COLOR_SUCCESS, $bSetLog)
SetGuiLog("Cannot create folder: " & $path, $COLOR_ERROR, $bSetLog)
$g_bAndroidPicturesPathAutoConfig = False
EndIf
EndIf
EndIf
Return $Result
EndFunc
Global $NO_COC, $UNKNOWN_COC
Global $aDistributors[19][4]
Func InitializeCOCDistributors()
$NO_COC = "<" & GetTranslated(642, 1, "No COC") & ">"
$UNKNOWN_COC = "<" & GetTranslated(642, 2, "Unknown COC") & ">"
Dim $aDistributors[19][4] = [ ["Google", "com.supercell.clashofclans", "com.supercell.clashofclans.GameApp", GetTranslated(642, 11, "Google")], ["Kunlun", "com.supercell.clashofclans.kunlun", "com.supercell.clashofclans.GameAppKunlun", GetTranslated(642, 12, "Kunlun")], ["Qihoo", "com.supercell.clashofclans.qihoo", "com.supercell.clashofclans.GameAppKunlun", GetTranslated(642, 13, "Qihoo")], ["Baidu", "com.supercell.clashofclans.baidu", "com.supercell.clashofclans.GameAppKunlun", GetTranslated(642, 14, "Baidu")], ["9game", "com.supercell.clashofclans.uc", "com.supercell.clashofclans.uc.GameApp", GetTranslated(642, 15, "9game")], ["Wandoujia/Downjoy", "com.supercell.clashofclans.wdj", "com.supercell.clashofclans.GameAppKunlun", GetTranslated(642, 16, "Wandoujia/Downjoy")], ["Huawei", "com.supercell.clashofclans.huawei", "com.supercell.clashofclans.GameAppKunlun", GetTranslated(642, 17, "Huawei")], ["OPPO", "com.supercell.clashofclans.nearme.gamecenter", "com.supercell.clashofclans.GameAppKunlun", GetTranslated(642, 18, "OPPO")], ["VIVO", "com.supercell.clashofclans.vivo", "com.supercell.clashofclans.GameAppKunlun", GetTranslated(642, 19, "VIVO")], ["Anzhi", "com.supercell.clashofclans.anzhi", "com.supercell.clashofclans.GameAppKunlun", GetTranslated(642, 20, "Anzhi")], ["Kaopu", "com.supercell.clashofclans.ewan.kaopu", "com.supercell.clashofclans.GameAppKunlun", GetTranslated(642, 21, "Kaopu")], ["Lenovo", "com.supercell.clashofclans.lenovo", "com.supercell.clashofclans.GameAppKunlun", GetTranslated(642, 22, "Lenovo")], ["Guopan", "com.supercell.clashofclans.wdj", "com.flamingo.sdk.view.WDJSplashActivity", GetTranslated(642, 23, "Guopan")], ["Xiaomi", "com.supercell.clashofclans.mi", "com.supercell.clashofclans.mi.GameAppXiaomi", GetTranslated(642, 24, "Xiaomi")], ["Haimawan", "com.supercell.clashofclans.ewan.hm", "cn.ewan.supersdk.activity.SplashActivity", GetTranslated(642, 25, "Haimawan")], ["Leshi", "com.supercell.clashofclans.ewan.leshi", "cn.ewan.supersdk.activity.SplashActivity", GetTranslated(642, 26, "Leshi")], ["Microvirt", "com.supercell.clashofclans.ewan.xyaz", "cn.ewan.supersdk.activity.SplashActivity", GetTranslated(642, 27, "Microvirt")], ["Yeshen", "com.supercell.clashofclans.ewan.yeshen", "cn.ewan.supersdk.activity.SplashActivity", GetTranslated(642, 28, "Yeshen")], ["Aiyouxi", "com.supercell.clashofclans.ewan.egame", "cn.ewan.supersdk.activity.SplashActivity", GetTranslated(642, 29, "Aiyouxi")] ]
EndFunc
Func GetCOCDistributors()
Local $sPkgList = StringReplace(_AndroidAdbSendShellCommand("pm list packages clashofclans"), "package:", "")
If @error <> 0 Or $sPkgList = "" Then Return SetError(1, 0, "")
Local $aPkgList = StringSplit($sPkgList, @LF, $STR_ENTIRESPLIT)
Local $aDList[0]
Local $bFirstTimeWDJ = True
Local $iIndex, $wasSilentSetLog
For $i = 1 To $aPkgList[0]
$iIndex = _ArraySearch($aDistributors, $aPkgList[$i], 0, 0, 0, 0, 1, 1)
If @error = 6 Then
$wasSilentSetLog = $g_bSilentSetLog
$g_bSilentSetLog = True
SetLog("Unrecognized COC Package: " & $aPkgList[$i])
$g_bSilentSetLog = $wasSilentSetLog
If $aPkgList[$i] = $g_sUserGamePackage Then _ArrayAdd($aDList, $g_sUserGameDistributor)
Else
If $iIndex <> 5 Then
_ArrayAdd($aDList, $aDistributors[$iIndex][3])
Else
If $bFirstTimeWDJ Then
_ArrayAdd($aDList, $aDistributors[5][3])
_ArrayAdd($aDList, $aDistributors[12][3])
$bFirstTimeWDJ = False
EndIf
EndIf
EndIf
Next
If UBound($aDList) = 0 Then Return SetError(2, 0, "")
Return SetError(0, 0, $aDList)
EndFunc
Func GetCOCPackage($sDistributor)
Local $iIndex = _ArraySearch($aDistributors, $sDistributor, 0, 0, 0, 0, 1, 3)
If @error = 6 Then
Return SetError(1, 0, "")
Else
Return SetError(0, 0, $aDistributors[$iIndex][1])
EndIf
EndFunc
Func GetCOCClass($sDistributor)
Local $iIndex = _ArraySearch($aDistributors, $sDistributor, 0, 0, 0, 0, 1, 3)
If @error = 6 Then
Return SetError(1, 0, "")
Else
Return SetError(0, 0, $aDistributors[$iIndex][2])
EndIf
EndFunc
Func GetCOCUnTranslated($sDistributor)
Local $iIndex = _ArraySearch($aDistributors, $sDistributor, 0, 0, 0, 0, 1, 3)
If @error = 6 Then
Return SetError(1, 0, $sDistributor)
Else
Return SetError(0, 0, $aDistributors[$iIndex][0])
EndIf
EndFunc
Func GetCOCTranslated($sDistributor)
Local $iIndex = _ArraySearch($aDistributors, $sDistributor, 0, 0, 0, 0, 1, 0)
If @error = 6 Then
Return SetError(1, 0, $sDistributor)
Else
Return SetError(0, 0, $aDistributors[$iIndex][3])
EndIf
EndFunc
Global Const $CLSID_ShellLink = "{00021401-0000-0000-C000-000000000046}"
Global Const $sIID_IShellLinkW = "{000214F9-0000-0000-C000-000000000046}"
Global Const $tag_IShellLinkW = "GetPath hresult(long;long;long;long);" & "GetIDList hresult(long);" & "SetIDList hresult(long);" & "GetDescription hresult(long;long);" & "SetDescription hresult(wstr);" & "GetWorkingDirectory hresult(long;long);" & "SetWorkingDirectory hresult(long;long);" & "GetArguments hresult(long;long);" & "SetArguments hresult(ptr);" & "GetHotkey hresult(long);" & "SetHotkey hresult(word);" & "GetShowCmd hresult(long);" & "SetShowCmd hresult(int);" & "GetIconLocation hresult(long;long;long);" & "SetIconLocation hresult(wstr;int);" & "SetRelativePath hresult(long;long);" & "Resolve hresult(long;long);" & "SetPath hresult(wstr);"
Global Const $tag_IPersist = "GetClassID hresult(long);"
Global Const $sIID_IPersistFile = "{0000010b-0000-0000-C000-000000000046}"
Global Const $tag_IPersistFile = $tag_IPersist & "IsDirty hresult();" & "Load hresult(wstr;dword);" & "Save hresult(wstr;bool);" & "SaveCompleted hresult(long);" & "GetCurFile hresult(long);"
Global Const $STGM_READ = 0x00000000
Global Const $STGM_READWRITE = 0x00000002
Global Const $STGM_SHARE_DENY_NONE = 0x00000040
Global Const $tagPROPERTYKEY = 'struct;ulong Data1;ushort Data2;ushort Data3;byte Data4[8];DWORD pid;endstruct'
Global $tagPROPVARIANT = 'USHORT vt;' & 'WORD wReserved1;' & 'WORD wReserved2;' & 'WORD wReserved3;' & 'LONG;PTR'
Global Const $sIID_IPropertyStore = '{886D8EEB-8CF2-4446-8D02-CDBA1DBDCF99}'
Global Const $VT_EMPTY = 0, $VT_LPWSTR = 31
Func _WindowAppId($hWnd, $appid = Default)
Local $tpIPropertyStore = DllStructCreate('ptr')
_WinAPI_SHGetPropertyStoreForWindow($hWnd, $sIID_IPropertyStore, $tpIPropertyStore)
Local $pPropertyStore = DllStructGetData($tpIPropertyStore, 1)
$tpIPropertyStore = 0
Local $oPropertyStore = ObjCreateInterface($pPropertyStore, $sIID_IPropertyStore, 'GetCount HRESULT(PTR);GetAt HRESULT(DWORD; PTR);GetValue HRESULT(PTR;PTR);' & 'SetValue HRESULT(PTR;PTR);Commit HRESULT()')
If Not IsObj($oPropertyStore) Then Return SetError(1, 0, '')
Local $tPKEY = _PKEY_AppUserModel_ID()
Local $tPROPVARIANT = DllStructCreate($tagPROPVARIANT)
Local $sAppId
If $appid = Default Then
$oPropertyStore.GetValue(DllStructGetPtr($tPKEY), DllStructGetPtr($tPROPVARIANT))
If DllStructGetData($tPROPVARIANT, 'vt') <> $VT_EMPTY Then
Local $buf = DllStructCreate('wchar[128]')
DllCall('Propsys.dll', 'long', 'PropVariantToString', 'ptr', DllStructGetPtr($tPROPVARIANT), 'ptr', DllStructGetPtr($buf), 'uint', DllStructGetSize($buf))
If Not @error Then
$sAppId = DllStructGetData($buf, 1)
EndIf
$buf = 0
EndIf
Else
_WinAPI_InitPropVariantFromString($appId, $tPROPVARIANT)
$oPropertyStore.SetValue(DllStructGetPtr($tPKEY), DllStructGetPtr($tPROPVARIANT))
$oPropertyStore.Commit()
$sAppId = $appid
EndIf
$tPROPVARIANT = 0
$tPKEY = 0
Return SetError(($sAppId == '')*2, 0, $sAppId)
EndFunc
Func _ShortcutAppId($lnkfile, $appid = Default)
Local $oIShellLinkW = ObjCreateInterface($CLSID_ShellLink , $sIID_IShellLinkW, $tag_IShellLinkW )
If Not IsObj( $oIShellLinkW ) Then Return SetError(1, 0, '')
Local $pIPersistFile, $oIPersistFile, $ret, $sAppId
Local $tRIID_IPersistFile = _WinAPI_GUIDFromString( $sIID_IPersistFile )
$oIShellLinkW.QueryInterface( $tRIID_IPersistFile, $pIPersistFile )
$oIPersistFile = ObjCreateInterface( $pIPersistFile, $sIID_IPersistFile, $tag_IPersistFile )
If IsObj( $oIPersistFile ) Then
If $appid == Default Then
$ret = $oIPersistFile.Load($lnkfile, BitOR($STGM_READ, $STGM_SHARE_DENY_NONE))
Else
$ret = $oIPersistFile.Load($lnkfile, $STGM_READWRITE)
EndIf
If $ret = 0 Then
Local $tPKEY = _PKEY_AppUserModel_ID()
Local $tPROPVARIANT = DllStructCreate($tagPROPVARIANT)
Local $tRIID_IPropertyStore = _WinAPI_GUIDFromString($sIID_IPropertyStore)
Local $pPropertyStore
$oIShellLinkW.QueryInterface($tRIID_IPropertyStore, $pPropertyStore)
Local $oPropertyStore = ObjCreateInterface($pPropertyStore, $sIID_IPropertyStore, 'GetCount HRESULT(PTR);GetAt HRESULT(DWORD;PTR);GetValue HRESULT(PTR;PTR);' & 'SetValue HRESULT(PTR;PTR);Commit HRESULT()')
If IsObj($oPropertyStore) Then
If $appid == Default Then
$oPropertyStore.GetValue(DllStructGetPtr($tPKEY), DllStructGetPtr($tPROPVARIANT))
If DllStructGetData($tPROPVARIANT, 'vt') <> $VT_EMPTY Then
Local $buf = DllStructCreate('wchar[128]')
DllCall('Propsys.dll', 'long', 'PropVariantToString', 'ptr', DllStructGetPtr($tPROPVARIANT), 'ptr', DllStructGetPtr($buf), 'uint', DllStructGetSize($buf))
$sAppId = DllStructGetData($buf, 1)
$buf = 0
EndIf
Else
_WinAPI_InitPropVariantFromString($appid, $tPROPVARIANT)
$oPropertyStore.SetValue(DllStructGetPtr($tPKEY), DllStructGetPtr($tPROPVARIANT))
$oPropertyStore.Commit()
$oIPersistFile.Save($lnkfile, True)
$sAppId = $appid
EndIf
EndIf
$tPROPVARIANT = 0
$tPKEY = 0
EndIf
EndIf
If IsObj($oPropertyStore) Then $oPropertyStore.Release()
If IsObj($oIPersistFile) Then $oIPersistFile.Release()
If IsObj($oIShellLinkW) Then $oIShellLinkW.Release()
Return SetError(($sAppId == '')*2, 0, $sAppId)
EndFunc
Func _WinAPI_InitPropVariantFromString($sUnicodeString, ByRef $tPROPVARIANT)
DllStructSetData($tPROPVARIANT, 'vt', $VT_LPWSTR)
Local $aRet = DllCall('Shlwapi.dll', 'LONG', 'SHStrDupW', 'WSTR', $sUnicodeString, 'PTR', DllStructGetPtr($tPROPVARIANT) + 8)
If @error Then Return SetError(@error, @extended, False)
Local $bSuccess = $aRet[0] == 0
If(Not $bSuccess) Then $tPROPVARIANT = DllStructCreate($tagPROPVARIANT)
Return SetExtended($aRet[0], $bSuccess)
EndFunc
Func _PKEY_AppUserModel_ID()
Local $tPKEY = DllStructCreate($tagPROPERTYKEY)
_WinAPI_GUIDFromStringEx('{9F4C2855-9F79-4B39-A8D0-E1D42DE1D5F3}', DllStructGetPtr($tPKEY))
DllStructSetData($tPKEY, 'pid', 5)
Return $tPKEY
EndFunc
Func _WinAPI_SHGetPropertyStoreForWindow($hWnd, $sIID, ByRef $tPointer)
Local $tIID = _WinAPI_GUIDFromString($sIID)
Local $pp = IsPtr($tPointer)? $tPointer : DllStructGetPtr($tPointer)
Local $aRet = DllCall('Shell32.dll', 'LONG', 'SHGetPropertyStoreForWindow', 'HWND', $hWnd, 'STRUCT*', $tIID, 'PTR', $pp)
If @error Then Return SetError(@error, @extended, False)
Return SetExtended($aRet[0],($aRet[0] = 0))
EndFunc
Global $hToolTip = 0
Func _GUICtrlSetTip($controlID, $tiptext, $title = Default, $icon = Default, $options = Default, $useControlID = True)
If $hToolTip = 0 Then
SetDebugLog("_GUICtrlSetTip: Missing $hToolTip!", $COLOR_ERROR)
Return False
EndIf
Local $hCtrl =($useControlID = True ? GUICtrlGetHandle($controlID) : $controlID)
Return _GUIToolTip_AddTool($hToolTip, 0, $tiptext, $hCtrl)
EndFunc
Func _GUICtrlGetControlID($hCtrl = -1)
Local $aRet = DllCall("user32.dll", "int", "GetDlgCtrlID", "hwnd",($hCtrl = -1 ? GUICtrlGetHandle(-1) : $hCtrl))
Return(IsArray($aRet) ? $aRet[0] : -1)
EndFunc
Func _GUICtrlCreatePic($sFilename_or_hBitmap, $iLeft, $iTop, $iWidth = -1, $iHeight = -1, $iStyle = -1, $iExStyle = -1)
Local $idPic = GUICtrlCreatePic("", $iLeft, $iTop, $iWidth, $iHeight, $iStyle, $iExStyle)
Local $hBMP
If IsPtr($sFilename_or_hBitmap) Then
$hBMP = $sFilename_or_hBitmap
Else
$hBMP = _GDIPlus_BitmapCreateFromFile($sFilename_or_hBitmap)
EndIf
Local $iBmpWidth = _GDIPlus_ImageGetWidth($hBMP)
Local $iBmpHeight = _GDIPlus_ImageGetHeight($hBMP)
Local $hBitmap_Resized = 0
Local $hBMP_Ctxt = 0
If $iWidth = -1 Then $iWidth = $iBmpWidth
If $iHeight = -1 Then $iHeight = $iBmpHeight
If $iWidth <> $iBmpWidth Or $iHeight <> $iBmpHeight Then
$hBitmap_Resized = _GDIPlus_BitmapCreateFromScan0($iWidth, $iHeight)
$hBMP_Ctxt = _GDIPlus_ImageGetGraphicsContext($hBitmap_Resized)
_GDIPlus_GraphicsSetInterpolationMode($hBMP_Ctxt, $GDIP_INTERPOLATIONMODE_HIGHQUALITYBICUBIC)
_GDIPlus_GraphicsDrawImageRect($hBMP_Ctxt, $hBMP, 0, 0, $iWidth, $iHeight)
EndIf
Local $hHBMP = _GDIPlus_BitmapCreateDIBFromBitmap(($hBitmap_Resized ? $hBitmap_Resized : $hBMP))
Local $hPrevImage = GUICtrlSendMsg($idPic, $STM_SETIMAGE, 0, $hHBMP)
_WinAPI_DeleteObject($hPrevImage)
If IsPtr($sFilename_or_hBitmap) = 0 Then _GDIPlus_BitmapDispose($hBMP)
If $hBitmap_Resized Then _GDIPlus_BitmapDispose($hBitmap_Resized)
If $hBMP_Ctxt Then _GDIPlus_GraphicsDispose($hBMP_Ctxt)
_WinAPI_DeleteObject($hHBMP)
Return $idPic
EndFunc
Func _GUI_Value_STATE($action_groupe, $group_de_controle)
Local $liste_controle = StringSplit($group_de_controle, "#")
If IsArray($liste_controle) Then
For $i = 1 To $liste_controle[0]
Switch StringUpper($action_groupe)
Case "HIDE"
GUICtrlSetState($liste_controle[$i], $GUI_HIDE)
Case "SHOW"
GUICtrlSetState($liste_controle[$i], $GUI_SHOW)
Case "ENABLE"
GUICtrlSetState($liste_controle[$i], $GUI_ENABLE)
Case "DISABLE"
GUICtrlSetState($liste_controle[$i], $GUI_DISABLE)
Case "UNCHECKED"
GUICtrlSetState($liste_controle[$i], $GUI_UNCHECKED)
Case "CHECKED"
GUICtrlSetState($liste_controle[$i], $GUI_CHECKED)
EndSwitch
Next
EndIf
EndFunc
Global Const $TCM_SETITEM = 0x1306
Global Const $_GUI_MAIN_WIDTH = 470
Global Const $_GUI_MAIN_HEIGHT = 690
Global Const $_GUI_MAIN_TOP = 5
Global Const $_GUI_BOTTOM_HEIGHT = 135
Global Const $_GUI_CHILD_LEFT = 10
Global Const $_GUI_CHILD_TOP = 110 + $_GUI_MAIN_TOP
Global Const $g_bBtnColor = False
Global $hImageList = 0
Global $g_hFrmBotEx = 0, $g_hFrmBotBottom = 0, $g_hFrmBotEmbeddedShield = 0, $g_hFrmBotEmbeddedShieldInput = 0, $g_hFrmBotEmbeddedGraphics = 0
Global $g_hFrmBot_MAIN_PIC = 0, $g_hFrmBot_URL_PIC = 0
Global $g_hTabMain = 0, $g_hTabLog = 0, $g_hTabVillage = 0, $g_hTabAttack = 0, $g_hTabBot = 0, $g_hTabMOD = 0 , $g_hTabAbout = 0
Global $g_hStatusBar = 0
Global $g_hTiShow = 0, $g_hTiHide = 0, $g_hTiDonate = 0, $g_hTiAbout = 0, $g_hTiExit = 0
Global $g_aFrmBotPosInit[7] = [0, 0, 0, 0, 0, 0, 0]
Global $g_hFirstControlToHide = 0, $g_hLastControlToHide = 0, $g_aiControlPrevState[1]
Global $g_bFrmBotMinimized = False
Global $g_hBtnStart = 0, $g_hBtnStop = 0, $g_hBtnPause = 0, $g_hBtnResume = 0, $g_hBtnSearchMode = 0, $g_hBtnMakeScreenshot = 0, $g_hBtnHide = 0, $g_hBtnEmbed = 0, $g_hChkBackgroundMode = 0, $g_hLblDonate = 0, $g_hBtnAttackNowDB = 0, $g_hBtnAttackNowLB = 0, $g_hBtnAttackNowTS = 0
Global $g_hPicTwoArrowShield = 0, $g_hLblVersion = 0, $g_hPicArrowLeft = 0, $g_hPicArrowRight = 0
Global $g_hGrpVillage = 0
Global $g_hLblResultGoldNow = 0, $g_hLblResultGoldHourNow = 0, $g_hPicResultGoldNow = 0, $g_hPicResultGoldTemp = 0
Global $g_hLblResultElixirNow = 0, $g_hLblResultElixirHourNow = 0, $g_hPicResultElixirNow = 0, $g_hPicResultElixirTemp = 0
Global $g_hLblResultDENow = 0, $g_hLblResultDEHourNow = 0, $g_hPicResultDENow = 0, $g_hPicResultDETemp = 0
Global $g_hLblResultTrophyNow = 0, $g_hPicResultTrophyNow = 0, $g_hLblResultRuntimeNow = 0, $g_hPicResultRuntimeNow = 0, $g_hLblResultBuilderNow = 0, $g_hPicResultBuilderNow = 0
Global $g_hLblResultAttackedHourNow = 0, $g_hPicResultAttackedHourNow = 0, $g_hLblResultGemNow = 0, $g_hPicResultGemNow = 0, $g_hLblResultSkippedHourNow = 0, $g_hPicResultSkippedHourNow = 0
Global $g_hLblVillageReportTemp = 0, $g_hBtnTestVillage = 0, $g_hbtnDebug = 0
Func CreateBottomPanel()
Local $sTxtTip = ""
Local $y_bottom = 0
Local $x = 10, $y = $y_bottom + 10
GUICtrlCreateGroup("https://mybot.run " & GetTranslated(602,0, "- freeware bot -"), $x - 5, $y - 10, 190, 108)
$g_hBtnStart = GUICtrlCreateButton(GetTranslated(602,1, "Start Bot"), $x, $y + 2 +5, 90, 40-5)
_GUICtrlSetTip(-1, GetTranslated(602,30, "Use this to START the bot."))
GUICtrlSetOnEvent(-1, "btnStart")
If $g_bBtnColor then GUICtrlSetBkColor(-1, 0x5CAD85)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hBtnStop = GUICtrlCreateButton(GetTranslated(602,2, "Stop Bot"), -1, -1, 90, 40-5)
_GUICtrlSetTip(-1, GetTranslated(602,31, "Use this to STOP the bot (or ESC key)."))
If $g_bBtnColor then GUICtrlSetBkColor(-1, 0xDB4D4D)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hBtnPause = GUICtrlCreateButton(GetTranslated(602,3, "Pause"), $x + 90, -1, 90, 40-5)
_GUICtrlSetTip(-1, GetTranslated(602,4, "Use this to PAUSE all actions of the bot until you Resume (or Pause/Break key)."))
If $g_bBtnColor then GUICtrlSetBkColor(-1, 0xFFA500)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hBtnResume = GUICtrlCreateButton(GetTranslated(602,5, "Resume"), -1, -1, 90, 40-5)
_GUICtrlSetTip(-1, GetTranslated(602,6, "Use this to RESUME a paused Bot (or Pause/Break key)."))
If $g_bBtnColor then GUICtrlSetBkColor(-1, 0xFFA500)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hBtnSearchMode = GUICtrlCreateButton(GetTranslated(602,7, "Search Mode"), -1, -1, 90, 40-5)
_GUICtrlSetTip(-1, GetTranslated(602,8, "Does not attack. Searches for a Village that meets conditions."))
GUICtrlSetOnEvent(-1, "btnSearchMode")
If $g_bBtnColor then GUICtrlSetBkColor(-1, 0xFFA500)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hBtnMakeScreenshot = GUICtrlCreateButton(GetTranslated(602,9, "Photo"), $x , $y + 45, 40, -1)
_GUICtrlSetTip(-1, GetTranslated(602,10, "Click here to take a snaphot of your village and save it to a file."))
If $g_bBtnColor then GUICtrlSetBkColor(-1, 0x5CAD85)
$g_hBtnHide = GUICtrlCreateButton(GetTranslated(602,11, "Hide"), $x + 40, $y + 45, 50, -1)
_GUICtrlSetTip(-1, GetTranslated(602,12, "Use this to move the Android Window out of sight.") & @CRLF & GetTranslated(602,13, "(Not minimized, but hidden)"))
If $g_bBtnColor Then GUICtrlSetBkColor(-1, 0x22C4F5)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hBtnEmbed = GUICtrlCreateButton(GetTranslated(602,27, "Dock"), $x + 90, $y + 45, 90, -1)
_GUICtrlSetTip(-1, GetTranslated(602,29, "Use this to embed the Android Window into Bot."))
If $g_bBtnColor Then GUICtrlSetBkColor(-1, 0x22C4F5)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkBackgroundMode = GUICtrlCreateCheckbox(GetTranslated(602,14, "Background Mode"), $x + 1, $y + 72, 90, 24)
GUICtrlSetFont(-1, 7)
_GUICtrlSetTip(-1, GetTranslated(602,16, "Check this to ENABLE the Background Mode of the Bot.") & @CRLF & GetTranslated(602,17, "With this you can also hide the Android Emulator window out of sight."))
GUICtrlSetOnEvent(-1, "chkBackground")
GUICtrlSetState(-1,(($g_bAndroidAdbScreencap = True) ?($GUI_CHECKED) :($GUI_UNCHECKED)))
$g_hbtnDebug = GUICtrlCreateButton(GetTranslated(602,100, "Debug"), $x + 100, $y + 72, 80, -1)
_GUICtrlSetTip(602,101, "Use this to make a zip with necessary folders to report a issue!.")
GUICtrlSetBkColor(-1, 0xf7754e)
GUICtrlSetOnEvent($g_hbtnDebug, "btnReport")
$g_hLblDonate = GUICtrlCreateLabel(GetTranslated(601,19,"Support the development"), $x + 224, $y + 80, 220, 24, $SS_RIGHT)
GUICtrlSetCursor(-1, 0)
GUICtrlSetFont(-1, 8.5, $FW_BOLD)
_GUICtrlSetTip(-1, GetTranslated(601,18,"Paypal Donate?"))
$g_hBtnAttackNowDB = GUICtrlCreateButton(GetTranslated(602,18, "DB Attack!"), $x + 190, $y - 4, 60, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hBtnAttackNowLB = GUICtrlCreateButton(GetTranslated(602,19, "LB Attack!"), $x + 190, $y + 23, 60, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hBtnAttackNowTS = GUICtrlCreateButton(GetTranslated(602,20, "TH Snipe!"), $x + 190, $y + 50, 60, -1)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
If $g_bAndroidAdbScreencap = True Then chkBackground()
$g_hPicTwoArrowShield = GUICtrlCreateIcon($g_sLibIconPath, $eIcn2Arrow, $x + 190, $y + 10, 48, 48)
$g_hLblVersion = GUICtrlCreateLabel($g_sBotVersion, 200, $y + 60, 60, 17, $SS_CENTER)
GUICtrlSetColor(-1, $COLOR_MEDGRAY)
$g_hPicArrowLeft = GUICtrlCreateIcon($g_sLibIconPath, $eIcnArrowLeft, $x + 249, $y + 30, 16, 16)
$sTxtTip = GetTranslated(602,25, "Switch between village info and stats")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicArrowRight = GUICtrlCreateIcon($g_sLibIconPath, $eIcnArrowRight, $x + 247 + 198, $y + 30, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
Local $x = 295, $y = $y_bottom + 20
$g_hGrpVillage = GUICtrlCreateGroup(GetTranslated(603,32, "Village"), $x - 20, $y - 20, 180, 85)
$g_hLblResultGoldNow = GUICtrlCreateLabel("", $x - 5, $y + 2, 60, 15, $SS_RIGHT)
$g_hLblResultGoldHourNow = GUICtrlCreateLabel("", $x, $y + 2, 60, 15, $SS_RIGHT)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicResultGoldNow = GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 60, $y, 16, 16)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicResultGoldTemp = GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x - 5, $y, 16, 16)
$g_hLblResultElixirNow = GUICtrlCreateLabel("", $x - 5, $y + 22, 60, 15, $SS_RIGHT)
$g_hLblResultElixirHourNow = GUICtrlCreateLabel("", $x, $y + 22, 60, 15, $SS_RIGHT)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicResultElixirNow = GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 60, $y + 20, 16, 16)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicResultElixirTemp = GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x - 5, $y + 20, 16, 16)
$g_hLblResultDENow = GUICtrlCreateLabel("", $x, $y + 42, 55, 15, $SS_RIGHT)
$g_hLblResultDEHourNow = GUICtrlCreateLabel("", $x, $y + 42, 60, 15, $SS_RIGHT)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicResultDENow = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 60, $y + 40, 16, 16)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicResultDETemp = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x - 5, $y + 40, 16, 16)
$x += 75
$g_hLblResultTrophyNow = GUICtrlCreateLabel("", $x, $y + 2, 55, 15, $SS_RIGHT)
$g_icnPopOutSW[0] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnMove, $x + 60, $y - 12, 12, 12)
GUICtrlSetOnEvent($g_icnPopOutSW[0],"PopOut0")
$g_hPicResultTrophyNow = GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 59, $y , 16, 16)
$g_hLblResultRuntimeNow = GUICtrlCreateLabel("00:00:00", $x, $y + 2, 50, 15, $SS_RIGHT)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicResultRuntimeNow = GUICtrlCreateIcon($g_sLibIconPath, $eIcnHourGlass, $x +57, $y, 16, 16)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hLblResultBuilderNow = GUICtrlCreateLabel("", $x, $y + 22, 55, 15, $SS_RIGHT)
$g_hPicResultBuilderNow = GUICtrlCreateIcon($g_sLibIconPath, $eIcnBuilder, $x + 59, $y + 20, 16, 16)
$g_hLblResultAttackedHourNow = GUICtrlCreateLabel("0", $x, $y + 22, 50, 15, $SS_RIGHT)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicResultAttackedHourNow = GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgTarget, $x +59, $y + 20, 16, 16)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hLblResultGemNow = GUICtrlCreateLabel("", $x + 5, $y + 42, 50, 15, $SS_RIGHT)
$g_hPicResultGemNow = GUICtrlCreateIcon($g_sLibIconPath, $eIcnGem, $x + 59, $y + 40, 16, 16)
$g_hLblResultSkippedHourNow = GUICtrlCreateLabel("0", $x, $y + 42, 50, 15, $SS_RIGHT)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicResultSkippedHourNow = GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgX, $x + 59, $y + 40, 16, 16)
GUICtrlSetState(-1, $GUI_HIDE)
$x = 285
$g_hLblVillageReportTemp = GUICtrlCreateLabel(GetTranslated(602,22, "Village Report") & @CRLF & GetTranslated(602,23, "will appear here") & @CRLF & GetTranslated(602,24, "on first run."), $x + 27, $y + 5, 100, 45, BITOR($SS_CENTER, $BS_MULTILINE))
$g_hBtnTestVillage = GUICtrlCreateButton("TEST BUTTON", $x + 25 , $y + 54, 100, 18)
GUICtrlSetOnEvent(-1, "ButtonBoost")
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_LOG = 0
Global $g_hTxtLog = 0, $g_hDivider = 0, $g_hTxtAtkLog = 0
Global $g_hCmbLogDividerOption, $g_hBtnAtkLogClear, $g_hBtnAtkLogCopyClipboard
Func CreateLogTab()
Local $x = 0, $y = 0
Local $activeHWnD = WinGetHandle("")
$g_hGUI_LOG = GUICreate("", $_GUI_MAIN_WIDTH - 20, $_GUI_MAIN_HEIGHT - 255, $_GUI_CHILD_LEFT, $_GUI_CHILD_TOP, BitOR($WS_CHILD, 0), -1, $g_hFrmBotEx)
$g_hTxtLog = _GUICtrlRichEdit_Create($g_hGUI_LOG, _PadStringCenter(" " & GetTranslated(601,2, "BOT LOG") & " ", 71, "="), 0, 0, 20, 20, BitOR($ES_MULTILINE, $ES_READONLY, $WS_VSCROLL, 8908), $WS_EX_STATICEDGE)
_GUICtrlRichEdit_SetFont($g_hTxtLog, 6, "Lucida Console")
_GUICtrlRichEdit_AppendTextColor($g_hTxtLog, "" & @CRLF, _ColorConvert($Color_Black))
$g_hDivider = GUICtrlCreateLabel("", 0, 0, 20, 20, $SS_SUNKEN + $SS_BLACKRECT)
GUICtrlSetCursor(-1, 11)
$g_hTxtAtkLog = _GUICtrlRichEdit_Create($g_hGUI_LOG, "", 0, 0, 20, 20, BitOR($ES_MULTILINE, $ES_READONLY, $WS_VSCROLL, 8908), $WS_EX_STATICEDGE)
WinActivate($activeHWnD)
$y = 410
GUICtrlCreateLabel(GetTranslated(601,3, "Log Style")&":", $x, $y + 5, -1, -1)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKBOTTOM + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$g_hCmbLogDividerOption = GUICtrlCreateCombo("", $x + 50, $y, 180, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKBOTTOM + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
_GUICtrlSetTip(-1, GetTranslated(601,4, "Use these options to set the Log type."))
GUICtrlSetData(-1, GetTranslated(601,5, "Use Divider to Resize Both Logs") &"|" &GetTranslated(601,6, "Bot and Attack Log Same Size") &"|" &GetTranslated(601,7, "Large Bot Log, Small Attack Log") &"|" &GetTranslated(601,8, "Small Bot Log, Large Attack Log") &"|" &GetTranslated(601,9, "Full Bot Log, Hide Attack Log") & "|" & GetTranslated(601,10, "Hide Bot Log, Full Attack Log") , GetTranslated(601,5, "Use Divider to Resize Both Logs"))
GUICtrlSetOnEvent(-1, "cmbLog")
$g_hBtnAtkLogClear = GUICtrlCreateButton(GetTranslated(601,11, "Clear Atk. Log"), $x + 270, $y - 1, 80, 23)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKBOTTOM + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
_GUICtrlSetTip(-1, GetTranslated(601,12, "Use this to clear the Attack Log."))
GUICtrlSetOnEvent(-1, "btnAtkLogClear")
If $g_bBtnColor Then GUICtrlSetBkColor(-1, 0x22C4F5)
$g_hBtnAtkLogCopyClipboard = GUICtrlCreateButton(GetTranslated(601,13, "Copy to Clipboard"), $x + 350, $y - 1, 100, 23)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKBOTTOM + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
_GUICtrlSetTip(-1, GetTranslated(601,14, "Use this to copy the Attack Log to the Clipboard (CTRL+C)"))
GUICtrlSetOnEvent(-1, "btnAtkLogCopyClipboard")
If $g_bBtnColor Then GUICtrlSetBkColor(-1, 0x22C4F5)
EndFunc
Global $g_hGUI_VILLAGE = 0
Global $g_hChkBotStop = 0, $g_hCmbBotCommand = 0, $g_hCmbBotCond = 0, $g_hCmbHoursStop = 0
Global $g_hTxtRestartGold = 0, $g_hTxtRestartElixir = 0, $g_hTxtRestartDark = 0
Global $g_hChkTrap = 1, $g_hChkCollect = 1, $g_hChkTombstones = 1, $g_hChkCleanYard = 0, $g_hChkGemsBox = 0
Global $g_hBtnLocateKingAltar = 0, $g_hBtnLocateQueenAltar = 0, $g_hBtnLocateWardenAltar = 0, $g_hBtnLocateLaboratory = 0, $g_hBtnResetBuilding = 0
Func CreateVillageMisc()
Local $sTxtTip = ""
Local $x = 15, $y = 45
GUICtrlCreateGroup(GetTranslated(610,1, "Halt Attack"), $x - 10, $y - 20, 440, 100)
$g_hChkBotStop = GUICtrlCreateCheckbox("", $x - 5, $y, 16, 16)
$sTxtTip = GetTranslated(610,2, "Use these options to set when the bot will stop attacking.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkBotStop")
$g_hCmbBotCommand = GUICtrlCreateCombo("", $x + 20, $y - 3, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, GetTranslated(610,3, "Halt Attack") & "|" & GetTranslated(610,4, "Stop Bot") & "|" & GetTranslated(610,5, "Close Bot") & "|" & GetTranslated(610,6, "Close CoC+Bot") & "|" & GetTranslated(610,7, "Shutdown PC") & "|" & GetTranslated(610,8, "Sleep PC") & "|" & GetTranslated(610,9, "Reboot PC"), GetTranslated(610,3, -1))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel(GetTranslated(610,10, "When..."), $x + 128, $y, 45, 17)
$g_hCmbBotCond = GUICtrlCreateCombo("", $x + 175, $y - 3, 160, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, GetTranslated(610,11, "G and E Full and Max.Trophy") & "|" & GetTranslated(610,12, "(G and E) Full or Max.Trophy") & "|" & GetTranslated(610,13, "(G or E) Full and Max.Trophy") & "|" & GetTranslated(610,14, "G or E Full or Max.Trophy") & "|" & GetTranslated(610,15, "Gold and Elixir Full") & "|" & GetTranslated(610,16, "Gold or Elixir Full") & "|" & GetTranslated(610,17, "Gold Full and Max.Trophy") & "|" & GetTranslated(610,18, "Elixir Full and Max.Trophy") & "|" & GetTranslated(610,19, "Gold Full or Max.Trophy") & "|" & GetTranslated(610,20, "Elixir Full or Max.Trophy") & "|" & GetTranslated(610,21, "Gold Full") & "|" & GetTranslated(610,22, "Elixir Full") & "|" & GetTranslated(610,23, "Reach Max. Trophy") & "|" & GetTranslated(610,24, "Dark Elixir Full") & "|" & GetTranslated(610,25, "All Storage (G+E+DE) Full") & "|" & GetTranslated(610,26, "Bot running for...") & "|" & GetTranslated(610,27, "Now (Train/Donate Only)") & "|" & GetTranslated(610,28, "Now (Donate Only)") & "|" & GetTranslated(610,29, "Now (Only stay online)") & "|" & GetTranslated(610,30, "W/Shield (Train/Donate Only)") & "|" & GetTranslated(610,31, "W/Shield (Donate Only)") & "|" & GetTranslated(610,32, "W/Shield (Only stay online)"), GetTranslated(610,27, -1))
GUICtrlSetOnEvent(-1, "cmbBotCond")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hCmbHoursStop = GUICtrlCreateCombo("", $x + 340, $y - 3, 80, 35, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $sTxtTip)
Local $sTxtHours = GetTranslated(603,14, "Hours")
GUICtrlSetData(-1, "-|1 " & GetTranslated(603,15, "Hour") & "|2 " & $sTxtHours & "|3 " & $sTxtHours & "|4 " & $sTxtHours & "|5 " & $sTxtHours & "|6 " & $sTxtHours & "|7 " & $sTxtHours & "|8 " & $sTxtHours & "|9 " & $sTxtHours & "|10 " & $sTxtHours & "|11 " & $sTxtHours & "|12 " & $sTxtHours& "|13 " & $sTxtHours & "|14 " & $sTxtHours & "|15 " & $sTxtHours & "|16 " & $sTxtHours & "|17 " & $sTxtHours & "|18 " & $sTxtHours & "|19 " & $sTxtHours & "|20 " & $sTxtHours & "|21 " & $sTxtHours & "|22 " & $sTxtHours & "|23 " & $sTxtHours & "|24 " & $sTxtHours, "-")
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 25
GUICtrlCreateLabel(GetTranslated(610,35, "The bot will Halt automatically when you run out of Resources. It will resume when reaching these minimal values."), $x + 20, $y, 400, 25, $BS_MULTILINE)
$y += 30
GUICtrlCreateLabel(GetTranslated(610,36, "Resume Attack") & ":", $x + 20, $y + 2, 80, -1)
$x += 90
GUICtrlCreateLabel(ChrW(8805), $x + 22, $y + 2, -1, -1)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 84, $y, 16, 16)
$g_hTxtRestartGold = GUICtrlCreateInput("10000", $x + 32, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(610,37, "Minimum Gold value for the bot to resume attacking after halting because of low gold."))
GUICtrlSetLimit(-1, 7)
$x += 90
GUICtrlCreateLabel(ChrW(8805), $x + 22, $y + 2, -1, -1)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 84, $y, 16, 16)
$g_hTxtRestartElixir = GUICtrlCreateInput("25000", $x + 32, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(610,38, "Minimum Elixir value for the bot to resume attacking after halting because of low elixir."))
GUICtrlSetLimit(-1, 7)
$x += 90
GUICtrlCreateLabel(ChrW(8805), $x + 22, $y + 2, -1, -1)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 84, $y, 16, 16)
$g_hTxtRestartDark = GUICtrlCreateInput("500", $x + 32, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(610,39, "Minimum Dark Elixir value for the bot to resume attacking after halting because of low dark elixir."))
GUICtrlSetLimit(-1, 6)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 15, $y = 150
GUICtrlCreateGroup(GetTranslated(610,40, "Rearm, Collect, Clear"), $x -10, $y - 20 , 440, 190)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrap, $x + 7, $y, 24, 24)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnXbow, $x + 32, $y, 24, 24)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnInferno, $x + 57, $y, 24, 24)
$g_hChkTrap = GUICtrlCreateCheckbox(GetTranslated(610,41, "Rearm Traps && Reload Xbows and Infernos"), $x + 100, $y + 4, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(610,42, "Check this to automatically Rearm Traps, Reload Xbows and Infernos (if any) in your Village."))
$y += 35
GUICtrlCreateIcon($g_sLibIconPath, $eIcnMine, $x - 5, $y, 24, 24)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 20, $y, 24, 24)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDrill, $x + 45, $y, 24, 24)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnLootCart, $x + 70, $y, 24, 24)
$g_hChkCollect = GUICtrlCreateCheckbox(GetTranslated(610,43, "Collect Resources && Loot Cart"), $x + 100, $y + 4, -1, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(610,44, "Check this to automatically collect the Village's Resources") & @CRLF & GetTranslated(610,45, "from Gold Mines, Elixir Collectors and Dark Elixir Drills.") & @CRLF & GetTranslated(610,46, "This will also search for a Loot Cart in your village and collect it."))
GUICtrlSetState(-1, $GUI_CHECKED)
$y += 35
GUICtrlCreateIcon($g_sLibIconPath, $eIcnTombstone, $x + 32 , $y, 24, 24)
$g_hChkTombstones = GUICtrlCreateCheckbox(GetTranslated(610,47, "Clear Tombstones"), $x + 100, $y + 4, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(610,48, "Check this to automatically clear tombstones after enemy attack."))
GUICtrlSetState(-1, $GUI_UNCHECKED)
$y += 35
GUICtrlCreateIcon($g_sLibIconPath, $eIcnTree, $x + 20, $y, 24, 24)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnBark, $x + 45, $y, 24, 24)
$g_hChkCleanYard = GUICtrlCreateCheckbox(GetTranslated(610,49, "Remove Obstacles"), $x + 100, $y + 4, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(610,50, "Check this to automatically clear Yard from Trees, Trunks, etc."))
GUICtrlSetState(-1, $GUI_UNCHECKED)
$y += 35
GUICtrlCreateIcon($g_sLibIconPath, $eIcnGembox, $x + 32, $y, 24, 24)
$g_hChkGemsBox = GUICtrlCreateCheckbox(GetTranslated(610,51, "Remove GemBox"), $x + 100, $y + 4, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(610,52, "Check this to automatically clear GemBox."))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 20, $y = 345
GUICtrlCreateGroup(GetTranslated(610,53, "Locate Manually"), $x - 15, $y - 20, 440, 65)
Local $sTxtRelocate = GetTranslated(610,55, "Relocate your") & " "
$X -= 11
$y += 0
GUICtrlCreateButton(GetTranslated(610,54, "Townhall"), $x, $y, 36, 36, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnTH11, 1)
_GUICtrlSetTip(-1, $sTxtRelocate & GetTranslated(610,54, -1))
GUICtrlSetOnEvent(-1, "btnLocateTownHall")
$x += 38
GUICtrlCreateButton(GetTranslated(610,56, "Clan Castle"), $x, $y, 36, 36, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnCC, 1)
_GUICtrlSetTip(-1, $sTxtRelocate & GetTranslated(610,56, -1))
GUICtrlSetOnEvent(-1, "btnLocateClanCastle")
$x += 38
$g_hBtnLocateKingAltar = GUICtrlCreateButton(GetTranslated(610,65, "King"), $x, $y, 36, 36, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnKingBoostLocate)
_GUICtrlSetTip(-1, $sTxtRelocate & GetTranslated(610,66, "Barbarian King Altar"))
GUICtrlSetOnEvent(-1, "btnLocateKingAltar")
$x += 38
$g_hBtnLocateQueenAltar = GUICtrlCreateButton(GetTranslated(610,67, "Queen"), $x, $y, 36, 36, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnQueenBoostLocate)
_GUICtrlSetTip(-1, $sTxtRelocate & GetTranslated(610,68, "Archer Queen Altar"))
GUICtrlSetOnEvent(-1, "btnLocateQueenAltar")
$x += 38
$g_hBtnLocateWardenAltar = GUICtrlCreateButton(GetTranslated(610,69, "Grand Warden"), $x, $y, 36, 36, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnWardenBoostLocate)
_GUICtrlSetTip(-1, $sTxtRelocate & GetTranslated(610,70, "Grand Warden Altar"))
GUICtrlSetOnEvent(-1, "btnLocateWardenAltar")
$x += 38
$g_hBtnLocateLaboratory = GUICtrlCreateButton(GetTranslated(610,71, "Lab."), $x, $y, 36, 36, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnLaboratory)
_GUICtrlSetTip(-1, $sTxtRelocate & GetTranslated(610,72, "Laboratory"))
GUICtrlSetOnEvent(-1, "btnLab")
$x += 205
GUICtrlCreateButton(GetTranslated(610,73, "Reset."), $x, $y, 36, 36, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnBldgX)
_GUICtrlSetTip(-1, GetTranslated(610,74, "Click here to reset all building locations,") & @CRLF & GetTranslated(610,75, "when you have changed your village layout."))
GUICtrlSetOnEvent(-1, "btnResetBuilding")
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_DONATE = 0, $g_hGUI_DONATE_TAB = 0, $g_hGUI_DONATE_TAB_ITEM1 = 0, $g_hGUI_DONATE_TAB_ITEM2 = 0, $g_hGUI_DONATE_TAB_ITEM3 = 0
Global $g_hChkRequestTroopsEnable = 0, $g_hTxtRequestCC = 0, $g_ahChkRequestCCHours[24] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Global $g_hChkRequestCCHoursE1 = 0, $g_hChkRequestCCHoursE2 = 0
Global $g_hGrpRequestCC = 0, $g_ahLblRequestCCHours0 = 0, $g_hLblRequestCCHoursAM = 0, $g_hLblRequestCCHoursPM = 0
Global $g_hChkExtraAlphabets = 0, $g_hChkExtraChinese = 0, $g_hChkExtraKorean = 0
Global $g_ahChkDonateTroop[$eTroopCount+$g_iCustomDonateConfigs] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Global $g_ahChkDonateAllTroop[$eTroopCount+$g_iCustomDonateConfigs] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Global $g_ahTxtDonateTroop[$eTroopCount+$g_iCustomDonateConfigs] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Global $g_ahTxtBlacklistTroop[$eTroopCount+$g_iCustomDonateConfigs] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Global $g_ahGrpDonateTroop[$eTroopCount+$g_iCustomDonateConfigs] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Global $g_ahLblDonateTroop[$eTroopCount+$g_iCustomDonateConfigs] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Global $g_ahBtnDonateTroop[$eTroopCount+$g_iCustomDonateConfigs] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Global $g_ahChkDonateSpell[$eSpellCount] = [0,0,0,0,0,-1,0,0,0,0]
Global $g_ahChkDonateAllSpell[$eSpellCount] = [0,0,0,0,0,-1,0,0,0,0]
Global $g_ahTxtDonateSpell[$eSpellCount] = [0,0,0,0,0,-1,0,0,0,0]
Global $g_ahTxtBlacklistSpell[$eSpellCount] = [0,0,0,0,0,-1,0,0,0,0]
Global $g_ahGrpDonateSpell[$eSpellCount] = [0,0,0,0,0,-1,0,0,0,0]
Global $g_ahLblDonateSpell[$eSpellCount] = [0,0,0,0,0,-1,0,0,0,0]
Global $g_ahBtnDonateSpell[$eSpellCount] = [0,0,0,0,0,-1,0,0,0,0]
Global $g_ahCmbDonateCustomA[3] = [0,0,0], $g_ahTxtDonateCustomA[3] = [0,0,0], $g_ahPicDonateCustomA[3] = [0,0,0]
Global $g_ahCmbDonateCustomB[3] = [0,0,0], $g_ahTxtDonateCustomB[3] = [0,0,0], $g_ahPicDonateCustomB[3] = [0,0,0]
Global $g_hLblDonateTroopTBD1 = 0, $g_hLblDonateTroopTBD2 = 0, $g_hLblDonateTroopTBD3 = 0, $g_hLblDonateTroopCustomC = 0, $g_hLblDonateTroopCustomD = 0, $g_hLblDonateTroopCustomF = 0, $g_hLblDonateTroopCustomG = 0, $g_hLblDonateTroopCustomH = 0, $g_hLblDonateTroopCustomI = 0, $g_hLblDonateTroopCustomJ = 0, $g_hLblDonateSpellTBD1 = 0
Global $g_hGrpDonateGeneralBlacklist = 0, $g_hTxtGeneralBlacklist = 0
Global $lblBtnCustomE = 0
Global $g_hChkDonateHoursEnable = 0, $g_ahChkDonateHours[24] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Global $g_hCmbFilterDonationsCC = 0, $g_hChkSkipDonateNearFullTroopsEnable = 0
Global $g_hLblDonateHours1 = 0, $g_hLblDonateHoursPM = 0
Global $g_hLblSkipDonateNearFullTroopsText = 0, $g_hTxtSkipDonateNearFullTroopsPercentage = 0, $g_hLblSkipDonateNearFullTroopsText1 = 0
Global $g_hGrpDonateCC = 0, $g_ahChkDonateHoursE1 = 0, $g_ahChkDonateHoursE2 = 0
Global $g_hGUI_RequestCC = 0, $g_hGUI_DONATECC = 0, $g_hGUI_ScheduleCC = 0
Global $g_hGrpDonate = 0, $g_hChkDonate = 1, $g_hLblDonateDisabled = 0, $g_hLblScheduleDisabled = 0
Global $g_hChkUseCCBalanced = 0, $g_hCmbCCDonated = 0, $g_hCmbCCReceived = 0
Func CreateVillageDonate()
$g_hGUI_DONATE = GUICreate("", $_GUI_MAIN_WIDTH - 28, $_GUI_MAIN_HEIGHT - 255 - 28, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_VILLAGE)
Local $x = 82
$g_hChkDonate = GUICtrlCreateCheckbox("", $x + 131, 6, 13, 13)
GUICtrlSetState(-1,$GUI_CHECKED)
GUICtrlSetOnEvent(-1, "Doncheck")
CreateRequestSubTab()
CreateDonateSubTab()
CreateScheduleSubTab()
GUISwitch($g_hGUI_DONATE)
$g_hGUI_DONATE_TAB = GUICtrlCreateTab(0, 0, $_GUI_MAIN_WIDTH - 30, $_GUI_MAIN_HEIGHT - 255 - 30, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_DONATE_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslated(600,11,"Request Troops"))
$g_hGUI_DONATE_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslated(600,12,"Donate Troops") & "    ")
$g_hLblDonateDisabled = GUICtrlCreateLabel(GetTranslated(612, 1, "Note: Donate is disabled, tick the checkmark on the") & " " & GetTranslated(600, 12, -1) & " " & GetTranslated(600, 50, -1), 5, 30, 430, 374)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hGUI_DONATE_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslated(600,13,"Schedule Donations"))
$g_hLblScheduleDisabled = GUICtrlCreateLabel(GetTranslated(612, 1, -1) & " " & GetTranslated(600, 12, -1) & " " & GetTranslated(600, 50, -1), 5, 30, 430, 374)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateTabItem("")
EndFunc
Func CreateRequestSubTab()
Local $xStart = 25, $yStart = 45
$g_hGUI_RequestCC = GUICreate("", $_GUI_MAIN_WIDTH - 30 - 10, $_GUI_MAIN_HEIGHT - 255 - 30 - 30, $xStart - 20, $yStart - 20, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_DONATE)
GUISetBkColor($COLOR_WHITE)
Local $xStart = 20, $yStart = 20
Local $x = $xStart
Local $y = $yStart
$g_hGrpRequestCC = GUICtrlCreateGroup(GetTranslated(611,1, "Clan Castle Troops"), $x - 20, $y - 20, 430, 375)
$y += 10
$x += 10
GUICtrlCreateIcon($g_sLibIconPath, $eIcnCCRequest, $x - 5, $y, 64, 64, $BS_ICON)
$g_hChkRequestTroopsEnable = GUICtrlCreateCheckbox(GetTranslated(611,2, "Request Troops / Spells"), $x+40+30, $y-6)
GUICtrlSetOnEvent(-1, "chkRequestCCHours")
$g_hTxtRequestCC = GUICtrlCreateInput(GetTranslated(611,3, "Anything please"), $x +40+30 , $y + 15, 214, 20, BitOR($SS_CENTER, $ES_AUTOHSCROLL))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(611,4, "This text is used on your request for troops in the Clan chat."))
$x += 29 + 30
$y += 60
GUICtrlCreateLabel(GetTranslated(603,30,"Only during these hours of day"), $x + 30, $y, 300, 20, $BS_MULTILINE)
$x += 30
$y += 25
$g_ahLblRequestCCHours0 = GUICtrlCreateLabel(" 0", $x + 30, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel(" 1", $x + 45, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel(" 2", $x + 60, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel(" 3", $x + 75, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel(" 4", $x + 90, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel(" 5", $x + 105, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel(" 6", $x + 120, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel(" 7", $x + 135, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel(" 8", $x + 150, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel(" 9", $x + 165, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel("10", $x + 180, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel("11", $x + 195, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel("X", $x + 213, $y+2, 11, 11)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 15
$g_ahChkRequestCCHours[0] = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[1] = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[2] = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[3] = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[4] = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[5] = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[6] = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[7] = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[8] = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[9] = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[10] = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[11] = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkRequestCCHoursE1 = GUICtrlCreateCheckbox("", $x + 211, $y+1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED + $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(603,2, "This button will clear or set the entire row of boxes"))
GUICtrlSetOnEvent(-1, "chkRequestCCHoursE1")
$g_hLblRequestCCHoursAM = GUICtrlCreateLabel(GetTranslated(603,3, "AM"), $x + 5, $y)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 15
$g_ahChkRequestCCHours[12] = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[13] = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[14] = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[15] = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[16] = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[17] = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[18] = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[19] = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[20] = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[21] = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[22] = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkRequestCCHours[23] = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkRequestCCHoursE2 = GUICtrlCreateCheckbox("", $x + 211, $y+1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED + $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(603,2, -1))
GUICtrlSetOnEvent(-1, "chkRequestCCHoursE2")
$g_hLblRequestCCHoursPM = GUICtrlCreateLabel(GetTranslated(603,4, "PM"), $x + 5, $y)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateDonateSubTab()
Local $xStart = 25, $yStart = 45
$g_hGUI_DONATECC = GUICreate("", $_GUI_MAIN_WIDTH - 30 - 10, $_GUI_MAIN_HEIGHT - 255 - 30 - 30, $xStart - 20, $yStart - 20, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_DONATE)
GUISetBkColor($COLOR_WHITE)
Local $xStart = 20, $yStart = 20
Local $sTxtBlacklist1 = GetTranslated(612,23, "Blacklist")
Local $sDonateTxtCustomA = GetTranslated(612,24, "Custom Troops")
Local $sDonateTxtCustomB = GetTranslated(612,24, -1)
Local $sTxtNothing = GetTranslated(603,1, "Nothing")
Local $sTxtDonate = GetTranslated(612,27, "Donate")
Local $sTxtDonateTip = GetTranslated(612,28, "Check this to donate")
Local $sTxtDonateAll = GetTranslated(612,29, "Donate to All")
Local $sTxtIgnoreAll = GetTranslated(612,31, "This will also ignore ALL keywords.")
Local $sTxtKeywords = GetTranslated(612,32, "Keywords for donating")
Local $sTxtKeywordsNo = GetTranslated(612,33, "Do NOT donate to these keywords")
Local $sTxtKeywordsNoTip = GetTranslated(612,34, "Blacklist for donating")
Local $sTxtDonateTipTroop = GetTranslated(612,81, "if keywords match the Chat Request.")
Local $sTxtDonateTipAll = GetTranslated(612,82, "to ALL Chat Requests.")
Local $sTxtBarbarians = GetTranslated(604,1, "Barbarians")
Local $sTxtArchers = GetTranslated(604,2, "Archers")
Local $sTxtGiants = GetTranslated(604,3, "Giants")
Local $sTxtGoblins = GetTranslated(604,4, "Goblins")
Local $sTxtWallBreakers = GetTranslated(604,5, "Wall Breakers")
Local $sTxtBalloons = GetTranslated(604,7, "Balloons")
Local $sTxtWizards = GetTranslated(604,8, "Wizards")
Local $sTxtHealers = GetTranslated(604,9, "Healers")
Local $sTxtDragons = GetTranslated(604,10, "Dragons")
Local $sTxtPekkas = GetTranslated(604,11, "Pekkas")
Local $sTxtMinions = GetTranslated(604,13, "Minions")
Local $sTxtHogRiders = GetTranslated(604,14, "Hog Riders")
Local $sTxtValkyries = GetTranslated(604,15, "Valkyries")
Local $sTxtGolems = GetTranslated(604,16, "Golems")
Local $sTxtWitches = GetTranslated(604,17, "Witches")
Local $sTxtLavaHounds = GetTranslated(604,18, "Lava Hounds")
Local $sTxtBowlers = GetTranslated(604, 19, "Bowlers")
Local $sTxtBabyDragons = GetTranslated(604,20, "Baby Dragons")
Local $sTxtMiners = GetTranslated(604,21, "Miners")
Local $sTxtLightningSpells = GetTranslated(605,15,"Lightning")
Local $sTxtHealSpells = GetTranslated(605,16,"Heal")
Local $sTxtRageSpells = GetTranslated(605,17,"Rage")
Local $sTxtJumpSpells = GetTranslated(605,18,"Jump")
Local $sTxtFreezeSpells = GetTranslated(605,19,"Freeze")
Local $sTxtPoisonSpells = GetTranslated(605,9, "Poison")
Local $sTxtEarthquakeSpells = GetTranslated(605,10, "EarthQuake")
Local $sTxtHasteSpells = GetTranslated(605,11, "Haste")
Local $sTxtSkeletonSpells = GetTranslated(605,14, "Skeleton")
Local $x = $xStart
Local $y = $yStart
Local $Offx = 38
GUICtrlCreateGroup(GetTranslated(612,22, "Donate Troops Selection Menu"), $x - 20, $y - 20, 430, 185)
$x = $xStart - 18
$g_ahLblDonateTroop[$eTroopBarbarian] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopBarbarian] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnBarbarian, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopArcher] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopArcher] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnArcher, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopGiant] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopGiant] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGiant, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopGoblin] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopGoblin] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoblin, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopWallBreaker] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopWallBreaker] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnWallBreaker, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopBalloon] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopBalloon] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnBalloon, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$x += 4
$g_ahLblDonateTroop[$eTroopMinion] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopMinion] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnMinion, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopHogRider] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopHogRider] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnHogRider, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopValkyrie] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopValkyrie] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnValkyrie, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopGolem] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopGolem] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGolem, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopWitch] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopWitch] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnWitch, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x = $xStart - 18
$y += 40
$g_ahLblDonateTroop[$eTroopWizard] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopWizard] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnWizard, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopHealer] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopHealer] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnHealer, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopDragon] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopDragon] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnDragon, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopPekka] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopPekka] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnPekka, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopBabyDragon] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopBabyDragon] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnBabyDragon, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopMiner] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopMiner] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnMiner, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$x += 4
$g_ahLblDonateTroop[$eTroopLavaHound] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopLavaHound] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnLavaHound, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eTroopBowler] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eTroopBowler] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnBowler, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_hLblDonateTroopTBD1 = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetState(-1, $GUI_DISABLE)
$x += $Offx
$g_hLblDonateTroopTBD2 = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetState(-1, $GUI_DISABLE)
$x += $Offx
$g_hLblDonateTroopTBD3 = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetState(-1, $GUI_DISABLE)
$x = $xStart - 18
$y += 40
$g_ahLblDonateSpell[$eSpellLightning] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateSpell[$eSpellLightning] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnLightSpell, 1)
GUICtrlSetOnEvent(-1, "btnDonateSpell")
$x += $Offx
$g_ahLblDonateSpell[$eSpellHeal] = GUICtrlCreateLabel("", $x , $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateSpell[$eSpellHeal] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnHealSpell, 1)
GUICtrlSetOnEvent(-1, "btnDonateSpell")
$x += $Offx
$g_ahLblDonateSpell[$eSpellRage] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateSpell[$eSpellRage] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnRageSpell, 1)
GUICtrlSetOnEvent(-1, "btnDonateSpell")
$x += $Offx
$g_ahLblDonateSpell[$eSpellJump] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateSpell[$eSpellJump] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnJumpSpell, 1)
GUICtrlSetOnEvent(-1, "btnDonateSpell")
$x += $Offx
$g_ahLblDonateSpell[$eSpellFreeze] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateSpell[$eSpellFreeze] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnFreezeSpell, 1)
GUICtrlSetOnEvent(-1, "btnDonateSpell")
$x += $Offx
$lblBtnCustomE = GUICtrlCreateLabel("", $x + 2, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetState(-1, $GUI_DISABLE)
$x += 4
$x += $Offx
$g_ahLblDonateSpell[$eSpellPoison] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateSpell[$eSpellPoison] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnPoisonSpell, 1)
GUICtrlSetOnEvent(-1, "btnDonateSpell")
$x += $Offx
$g_ahLblDonateSpell[$eSpellEarthquake] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateSpell[$eSpellEarthquake] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnEarthQuakeSpell, 1)
GUICtrlSetOnEvent(-1, "btnDonateSpell")
$x += $Offx
$g_ahLblDonateSpell[$eSpellHaste] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateSpell[$eSpellHaste] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnHasteSpell, 1)
GUICtrlSetOnEvent(-1, "btnDonateSpell")
$x += $Offx
$g_ahLblDonateSpell[$eSpellSkeleton] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateSpell[$eSpellSkeleton] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnSkeletonSpell, 1)
GUICtrlSetOnEvent(-1, "btnDonateSpell")
$x += $Offx
$g_hLblDonateSpellTBD1 = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetState(-1, $GUI_DISABLE)
$x = $xStart - 18
$y += 40
GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetState(-1, $GUI_DISABLE)
$x += $Offx
$g_hLblDonateTroopCustomF = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetState(-1, $GUI_DISABLE)
$x += $Offx
$g_hLblDonateTroopCustomG = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetState(-1, $GUI_DISABLE)
$x += $Offx
$g_hLblDonateTroopCustomH = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetState(-1, $GUI_DISABLE)
$x += $Offx
$g_hLblDonateTroopCustomI = GUICtrlCreateLabel("", $x , $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetState(-1, $GUI_DISABLE)
$x += $Offx
$g_hLblDonateTroopCustomJ = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetState(-1, $GUI_DISABLE)
$x += 4
$x += $Offx
$g_ahLblDonateTroop[$eCustomA] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eCustomA] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnDonCustom, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_ahLblDonateTroop[$eCustomB] = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahBtnDonateTroop[$eCustomB] = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnDonCustomB, 1)
GUICtrlSetOnEvent(-1, "btnDonateTroop")
$x += $Offx
$g_hLblDonateTroopCustomC = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetState(-1, $GUI_DISABLE)
$x += $Offx
$g_hLblDonateTroopCustomD = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetState(-1, $GUI_DISABLE)
$x += $Offx
GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnDonBlacklist, 1)
GUICtrlSetOnEvent(-1, "btnDonateBlacklist")
Local $Offy = $yStart + 185
$x = $xStart
$y = $yStart + 185
GUICtrlCreateLabel(GetTranslated(612,115, "Extra Alphabet Recognitions:"), $x - 15, $y + 153, -1, -1)
$g_hChkExtraAlphabets = GUICtrlCreateCheckbox(GetTranslated(612,25, "Cyrillic"), $x + 127 , $y + 149, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(612,26, "Check this to enable the Cyrillic Alphabet."))
$g_hChkExtraChinese = GUICtrlCreateCheckbox(GetTranslated(612,103, "Chinese"), $x + 221, $y + 149, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(612,104, "Check this to enable the Chinese Alphabet."))
$g_hChkExtraKorean = GUICtrlCreateCheckbox(GetTranslated(612,116, "Korean"), $x + 315, $y + 149, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(612,117, "Check this to enable the Korean Alphabet."))
GUICtrlCreateGroup("", -99, -99, 1, 1)
$g_ahGrpDonateTroop[$eTroopBarbarian] = GUICtrlCreateGroup($sTxtBarbarians, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonBarbarian, $x + 215, $y, 64, 64, $BS_ICON)
$g_ahChkDonateTroop[$eTroopBarbarian] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtBarbarians, $x + 285, $y + 10, -1, -1)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtBarbarians & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopBarbarian] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtBarbarians & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtBarbarians & ":", $x - 5, $y + 5, -1, -1)
$g_ahTxtDonateTroop[$eTroopBarbarian] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetData(-1, StringFormat(GetTranslated(612,35, "barbarians\r\nbarb")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtBarbarians)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
$g_ahTxtBlacklistTroop[$eTroopBarbarian] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,36, "no barbarians\r\nno barb\r\nbarbarians no\r\nbarb no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtBarbarians)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopArcher] = GUICtrlCreateGroup($sTxtArchers, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonArcher, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopArcher] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtArchers, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtArchers & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopArcher] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtArchers & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtArchers & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopArcher] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,37, "archers\r\narch")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtArchers)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopArcher] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,38, "no archers\r\nno arch\r\narchers no\r\narch no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtArchers)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopGiant] = GUICtrlCreateGroup($sTxtGiants, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonGiant, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopGiant] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtGiants, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtGiants & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopGiant] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtGiants & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtGiants & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopGiant] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,39, "giants\r\ngiant\r\nany\r\nreinforcement")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtGiants)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopGiant] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,40, "no giants\r\ngiants no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtGiants)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopGoblin] = GUICtrlCreateGroup($sTxtGoblins, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonGoblin, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopGoblin] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtGoblins, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtGoblins & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopGoblin] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtGoblins & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtGoblins & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopGoblin] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,41, "goblins\r\ngoblin")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtGoblins)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopGoblin] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,42, "no goblins\r\ngoblins no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtGoblins)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopWallBreaker] = GUICtrlCreateGroup($sTxtWallBreakers, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonWallBreaker, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopWallBreaker] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtWallBreakers, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtWallBreakers & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopWallBreaker] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtWallBreakers & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtWallBreakers & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopWallBreaker] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,43, "wall breakers\r\nbreaker")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtWallBreakers)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopWallBreaker] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,44, "no wall breakers\r\nwall breakers no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtWallBreakers)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopBalloon] = GUICtrlCreateGroup($sTxtBalloons, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonBalloon, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopBalloon] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtBalloons, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtBalloons & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopBalloon] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtBalloons & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtBalloons & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopBalloon] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,45, "balloons\r\nballoon")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtBalloons)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopBalloon] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,46, "no balloon\r\nballoons no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtBalloons)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopWizard] = GUICtrlCreateGroup($sTxtWizards, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonWizard, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopWizard] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtWizards, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtWizards & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopWizard] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtWizards & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtWizards & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopWizard] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,47, "wizards\r\nwizard\r\nwiz")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtWizards)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopWizard] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,48, "no wizards\r\nwizards no\r\nno wizard\r\nwizard no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtWizards)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopHealer] = GUICtrlCreateGroup($sTxtHealers, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonHealer, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopHealer] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtHealers, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtHealers & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopHealer] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtHealers & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtHealers & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopHealer] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,49, "healer")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtHealers)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopHealer] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,50, "no healer\r\nhealer no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtHealers)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopDragon] = GUICtrlCreateGroup($sTxtDragons, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonDragon, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopDragon] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtDragons, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtDragons & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopDragon] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtDragons & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtDragons & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopDragon] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,51, "dragon")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtDragons)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopDragon] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,52, "no dragon\r\ndragon no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtDragons)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopPekka] = GUICtrlCreateGroup($sTxtPekkas, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonPekka, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopPekka] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtPekkas, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtPekkas & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopPekka] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtPekkas & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtPekkas & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopPekka] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,53, "PEKKA\r\npekka")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtPekkas)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopPekka] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,54, "no PEKKA\r\npekka no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtPekkas)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopBabyDragon] = GUICtrlCreateGroup($sTxtBabyDragons, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonBabyDragon, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopBabyDragon] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtBabyDragons, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtBabyDragons & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopBabyDragon] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtBabyDragons & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtBabyDragons & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopBabyDragon] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,95, "baby dragon\r\nbaby")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtBabyDragons)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopBabyDragon] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,96, "no baby dragon\r\nbaby dragon no\r\nno baby\r\nbaby no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtBabyDragons)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopMiner] = GUICtrlCreateGroup($sTxtMiners, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonMiner, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopMiner] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtMiners, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtMiners & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopMiner] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtMiners & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtMiners & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopMiner] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,97, "miner|mine")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtMiners)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopMiner] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,98, "no miner\r\nminer no\r\nno mine\r\nmine no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtMiners)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateSpell[$eSpellLightning] = GUICtrlCreateGroup($sTxtLightningSpells, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnLightSpell, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateSpell[$eSpellLightning] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtLightningSpells, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtLightningSpells & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateSpell")
$g_ahChkDonateAllSpell[$eSpellLightning] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtLightningSpells & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllSpell")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtLightningSpells & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateSpell[$eSpellLightning] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,105, "lightning")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtLightningSpells)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistSpell[$eSpellLightning] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,106, "no lightning\r\nlightning no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtLightningSpells)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateSpell[$eSpellHeal] = GUICtrlCreateGroup($sTxtHealSpells, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnHealSpell, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateSpell[$eSpellHeal] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtHealSpells, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtHealSpells & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateSpell")
$g_ahChkDonateAllSpell[$eSpellHeal] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtHealSpells & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllSpell")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtHealSpells & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateSpell[$eSpellHeal] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,107, "heal")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtHealSpells)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistSpell[$eSpellHeal] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,108, "no heal\r\nheal no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtHealSpells)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateSpell[$eSpellRage] = GUICtrlCreateGroup($sTxtRageSpells, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnRageSpell, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateSpell[$eSpellRage] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtRageSpells, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtRageSpells & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateSpell")
$g_ahChkDonateAllSpell[$eSpellRage] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtRageSpells & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllSpell")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtRageSpells & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateSpell[$eSpellRage] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,109, "rage")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtRageSpells)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistSpell[$eSpellRage] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,110, "no rage\r\nrage no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtRageSpells)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateSpell[$eSpellJump] = GUICtrlCreateGroup($sTxtJumpSpells, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnJumpSpell, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateSpell[$eSpellJump] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtJumpSpells, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtJumpSpells & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateSpell")
$g_ahChkDonateAllSpell[$eSpellJump] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtJumpSpells & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllSpell")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtJumpSpells & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateSpell[$eSpellJump] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,111, "jump")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtJumpSpells)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistSpell[$eSpellJump] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,112, "no jump\r\njump no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtJumpSpells)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateSpell[$eSpellFreeze] = GUICtrlCreateGroup($sTxtFreezeSpells, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnFreezeSpell, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateSpell[$eSpellFreeze] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtFreezeSpells, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtFreezeSpells & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateSpell")
$g_ahChkDonateAllSpell[$eSpellFreeze] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtFreezeSpells & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllSpell")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtFreezeSpells & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateSpell[$eSpellFreeze] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,113, "freeze")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtFreezeSpells)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistSpell[$eSpellFreeze] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,114, "no freeze\r\nfreeze no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtFreezeSpells)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopMinion] = GUICtrlCreateGroup($sTxtMinions, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonMinion, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopMinion] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtMinions, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtMinions & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopMinion] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtMinions & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtMinions & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopMinion] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,55, "minions\r\nminion")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtMinions)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopMinion] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,56, "no minions\r\nminions no\r\nno minion\r\nminion no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtMinions)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopHogRider] = GUICtrlCreateGroup($sTxtHogRiders, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonHogRider, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopHogRider] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtHogRiders, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtHogRiders & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopHogRider] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtHogRiders & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtHogRiders & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopHogRider] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,57, "hogriders\r\nhogs\r\nhog")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtHogRiders)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopHogRider] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,58, "no hogs\r\nhog no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtHogRiders)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopValkyrie] = GUICtrlCreateGroup($sTxtValkyries, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonValkyrie, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopValkyrie] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtValkyries, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtValkyries & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopValkyrie] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtValkyries & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtValkyries & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopValkyrie] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,59, "valkyries\r\nvalkyrie\r\nvalk")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtValkyries)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopValkyrie] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,60, "no valkyries\r\nvalkyries no\r\nno valk\r\nvalk no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtValkyries)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopGolem] = GUICtrlCreateGroup($sTxtGolems, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonGolem, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopGolem] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtGolems, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtGolems & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopGolem] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtGolems & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtGolems & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopGolem] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,61, "golem")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtGolems)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopGolem] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,62, "no golem\r\ngolem no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtGolems)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopWitch] = GUICtrlCreateGroup($sTxtWitches, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonWitch, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopWitch] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtWitches, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtWitches & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopWitch] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtWitches & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtWitches & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopWitch] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,63, "witches\r\nwitch")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtWitches)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopWitch] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,64, "no witches\r\nwitch no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtWitches)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopLavaHound] = GUICtrlCreateGroup($sTxtLavaHounds, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonLavaHound, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopLavaHound] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtLavaHounds, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtLavaHounds & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopLavaHound] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtLavaHounds & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtLavaHounds & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopLavaHound] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,65, "lavahound\r\nlava\r\nhound")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtLavaHounds)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopLavaHound] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,66, "no lavahound\r\nlava no\r\nhound no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtLavaHounds)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eTroopBowler] = GUICtrlCreateGroup($sTxtBowlers, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonBowler, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eTroopBowler] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtBowlers, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtBowlers & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eTroopBowler] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtBowlers & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtBowlers & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eTroopBowler] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,93, "bowler\r\nbowlers\r\nbowl")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtBowlers)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eTroopBowler] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,94, "no bowler\r\nbowl no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtBowlers)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateSpell[$eSpellPoison] = GUICtrlCreateGroup($sTxtPoisonSpells, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonPoisonSpell, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateSpell[$eSpellPoison] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtPoisonSpells, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtPoisonSpells & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateSpell")
$g_ahChkDonateAllSpell[$eSpellPoison] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtPoisonSpells & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllSpell")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtPoisonSpells & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateSpell[$eSpellPoison] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,87, "poison")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtPoisonSpells)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistSpell[$eSpellPoison] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,88, "no poison\r\npoison no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtPoisonSpells)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateSpell[$eSpellEarthquake] = GUICtrlCreateGroup($sTxtEarthQuakeSpells, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonEarthQuakeSpell, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateSpell[$eSpellEarthquake] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtEarthQuakeSpells, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtEarthQuakeSpells & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateSpell")
$g_ahChkDonateAllSpell[$eSpellEarthquake] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtEarthQuakeSpells & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllSpell")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtEarthQuakeSpells & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateSpell[$eSpellEarthquake] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,89, "earthquake\r\nquake")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtEarthQuakeSpells)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistSpell[$eSpellEarthquake] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,90, "no earthquake\r\nquake no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtEarthQuakeSpells)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateSpell[$eSpellHaste] = GUICtrlCreateGroup($sTxtHasteSpells, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonHasteSpell, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateSpell[$eSpellHaste] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtHasteSpells, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtHasteSpells & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateSpell")
$g_ahChkDonateAllSpell[$eSpellHaste] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtHasteSpells & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllSpell")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtHasteSpells & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateSpell[$eSpellHaste] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,91, "haste")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtHasteSpells)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistSpell[$eSpellHaste] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,92, "no haste\r\nhaste no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtHasteSpells)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateSpell[$eSpellSkeleton] = GUICtrlCreateGroup($sTxtSkeletonSpells, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonSkeletonSpell, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateSpell[$eSpellSkeleton] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtSkeletonSpells, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtSkeletonSpells & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateSpell")
$g_ahChkDonateAllSpell[$eSpellSkeleton] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtSkeletonSpells & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllSpell")
GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtSkeletonSpells & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateSpell[$eSpellSkeleton] = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,99, "skeleton|skel")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtSkeletonSpells)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistSpell[$eSpellSkeleton] = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,100, "no skeleton\r\nskeleton no\r\nno skel")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtSkeletonSpells)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eCustomA] = GUICtrlCreateGroup($sDonateTxtCustomA, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 2
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonCustom, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eCustomA] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sDonateTxtCustomA, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sDonateTxtCustomA & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eCustomA] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sDonateTxtCustomA & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sDonateTxtCustomA & ":", $x - 5, $y + 80, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eCustomA] = GUICtrlCreateEdit("", $x - 5, $y + 95, 205, 50, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,71, "ground support\r\nground")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sDonateTxtCustomA)
GUICtrlCreateLabel(GetTranslated(612,72, "1st") & ":", $x, $y + 4, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDonateCustomA[0] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonWizard, $x + 25, $y, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahCmbDonateCustomA[0] = GUICtrlCreateCombo("", $x + 60, $y, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $sTxtLavaHounds & "|" & $sTxtBowlers & "|" & $sTxtNothing, $sTxtWizards)
GUICtrlSetOnEvent(-1, "cmbDonateCustomA")
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateCustomA[0] = GUICtrlCreateInput("2", $x + 165, $y, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel(GetTranslated(612,73, "2nd") & ":", $x, $y + 29, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDonateCustomA[1] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonArcher, $x + 25, $y + 25, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahCmbDonateCustomA[1] = GUICtrlCreateCombo("", $x + 60, $y + 25, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $sTxtLavaHounds & "|" & $sTxtBowlers & "|" & $sTxtNothing, $sTxtArchers)
GUICtrlSetOnEvent(-1, "cmbDonateCustomA")
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateCustomA[1] = GUICtrlCreateInput("3", $x + 165, $y + 25, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel(GetTranslated(612,74, "3rd") & ":", $x, $y + 54, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDonateCustomA[2] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonBarbarian, $x + 25, $y + 50, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahCmbDonateCustomA[2] = GUICtrlCreateCombo("", $x + 60, $y + 50, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $sTxtLavaHounds & "|" & $sTxtBowlers & "|" & $sTxtNothing, $sTxtBarbarians)
GUICtrlSetOnEvent(-1, "cmbDonateCustomA")
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateCustomA[2] = GUICtrlCreateInput("1", $x + 165, $y + 50, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 80, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eCustomA] = GUICtrlCreateEdit("", $x + 215, $y + 95, 200, 50, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,76, "no ground\r\nground no\r\nonly")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sDonateTxtCustomA)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_ahGrpDonateTroop[$eCustomB] = GUICtrlCreateGroup($sDonateTxtCustomB, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 2
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonCustomB, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahChkDonateTroop[$eCustomB] = GUICtrlCreateCheckbox($sTxtDonate & " " & $sDonateTxtCustomB, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sDonateTxtCustomB & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateTroop")
$g_ahChkDonateAllTroop[$eCustomB] = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sDonateTxtCustomB & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllTroop")
GUICtrlCreateLabel($sTxtKeywords & " " & $sDonateTxtCustomB & ":", $x - 5, $y + 80, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateTroop[$eCustomB] = GUICtrlCreateEdit("", $x - 5, $y + 95, 205, 50, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,101, "air support\r\nany air")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sDonateTxtCustomB)
GUICtrlCreateLabel(GetTranslated(612,72, "1st") & ":", $x, $y + 4, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDonateCustomB[0] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonBabyDragon, $x + 25, $y, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahCmbDonateCustomB[0] = GUICtrlCreateCombo("", $x + 60, $y, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $sTxtLavaHounds & "|" & $sTxtBowlers & "|" & $sTxtNothing, $sTxtBabyDragons)
GUICtrlSetOnEvent(-1, "cmbDonateCustomB")
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateCustomB[0] = GUICtrlCreateInput("1", $x + 165, $y, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel(GetTranslated(612,73, "2nd") & ":", $x, $y + 29, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDonateCustomB[1] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonBalloon, $x + 25, $y + 25, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahCmbDonateCustomB[1] = GUICtrlCreateCombo("", $x + 60, $y + 25, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $sTxtLavaHounds & "|" & $sTxtBowlers & "|" & $sTxtNothing, $sTxtBalloons)
GUICtrlSetOnEvent(-1, "cmbDonateCustomB")
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateCustomB[1] = GUICtrlCreateInput("3", $x + 165, $y + 25, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel(GetTranslated(612,74, "3rd") & ":", $x, $y + 54, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahPicDonateCustomB[2] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonMinion, $x + 25, $y + 50, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahCmbDonateCustomB[2] = GUICtrlCreateCombo("", $x + 60, $y + 50, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $sTxtLavaHounds & "|" & $sTxtBowlers & "|" & $sTxtNothing, $sTxtMinions)
GUICtrlSetOnEvent(-1, "cmbDonateCustomB")
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtDonateCustomB[2] = GUICtrlCreateInput("5", $x + 165, $y + 50, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 80, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_ahTxtBlacklistTroop[$eCustomB] = GUICtrlCreateEdit("", $x + 215, $y + 95, 200, 50, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,102, "no air\r\nair no\r\nonly\r\njust")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sDonateTxtCustomB)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $Offy
$g_hGrpDonateGeneralBlacklist = GUICtrlCreateGroup(GetTranslated(612,78, "General Blacklist"), $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDonBlacklist, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateLabel(GetTranslated(612,77, "Do NOT donate to any of these keywords") & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hTxtGeneralBlacklist = GUICtrlCreateEdit("", $x -5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor(-1, 0x505050)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,79, "clan war\r\nwar\r\ncw")))
_GUICtrlSetTip(-1, GetTranslated(612,80, "General Blacklist for donation requests"))
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateScheduleSubTab()
Local $xStart = 25, $yStart = 45
$g_hGUI_ScheduleCC = GUICreate("", $_GUI_MAIN_WIDTH - 30 - 10, $_GUI_MAIN_HEIGHT - 255 - 30 - 30, $xStart - 20, $yStart - 20, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_DONATE)
GUISetBkColor($COLOR_WHITE)
Local $xStart = 20, $yStart = 20
Local $x = $xStart
Local $y = $yStart
$g_hGrpDonateCC = GUICtrlCreateGroup(GetTranslated(613,1,"Donate Schedule"), $x - 20, $y - 20, 430, 120)
$y += 10
$x += 10
GUICtrlCreateIcon($g_sLibIconPath, $eIcnCCDonate, $x - 5, $y, 64, 60, $BS_ICON)
$g_hChkDonateHoursEnable = GUICtrlCreateCheckbox(GetTranslated(603,30, -1), $x +40+ 30, $y-6)
GUICtrlSetOnEvent(-1, "chkDonateHours")
$y += 20
$x += 90
$g_hLblDonateHours1 = GUICtrlCreateLabel(" 0", $x + 30, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel(" 1", $x + 45, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel(" 2", $x + 60, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel(" 3", $x + 75, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel(" 4", $x + 90, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel(" 5", $x + 105, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel(" 6", $x + 120, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel(" 7", $x + 135, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel(" 8", $x + 150, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel(" 9", $x + 165, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel("10", $x + 180, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel("11", $x + 195, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel("X", $x + 213, $y+2, 11, 11)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 15
$g_ahChkDonateHours[0] = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[1] = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[2] = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[3] = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[4] = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[5] = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[6] = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[7] = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[8] = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[9] = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[10] = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[11] = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHoursE1 = GUICtrlCreateCheckbox("", $x + 211, $y+1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED + $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(603,2, -1))
GUICtrlSetOnEvent(-1, "chkDonateHoursE1")
GUICtrlCreateLabel(GetTranslated(603,3, -1), $x + 5, $y)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 15
$g_ahChkDonateHours[12] = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[13] = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[14] = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[15] = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[16] = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[17] = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[18] = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[19] = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[20] = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[21] = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[22] = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHours[23] = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkDonateHoursE2 = GUICtrlCreateCheckbox("", $x + 211, $y+1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED + $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(603,2, -1))
GUICtrlSetOnEvent(-1, "chkDonateHoursE2")
$g_hLblDonateHoursPM = GUICtrlCreateLabel(GetTranslated(603,4, -1), $x + 5, $y)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 16
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $yStart + 130
GUICtrlCreateGroup(GetTranslated(613,2,"Donation Clan Mates Filter"), $x - 20, $y - 20, 430, 155)
$y += 10
GUICtrlCreateLabel(GetTranslated(613, 8,"Using this option you can choose to donate to all members of your team (No Filter), donate only to certain friends (White List) or give everyone except a few members of your team (Black List)"), $x , $y - 10, 380, 40, $BS_MULTILINE)
$y += 35
$g_hCmbFilterDonationsCC = GUICtrlCreateCombo("", $x, $y, 300, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslated(613,4, "No Filter, donate at all Clan Mates") & "|" & GetTranslated(613,5, "No Filter but collect Clan Mates Images") & "|" & GetTranslated(613,6, "Donate only at Clan Mates in White List" ) & "|" & GetTranslated(613,7, "Donate at all Except at Clan Mates in Black List") , GetTranslated(613,4,-1))
GUICtrlSetOnEvent(-1, "cmbABAlgorithm")
$y += 35
GUICtrlCreateLabel(GetTranslated(613, 10,"Images of Clan Mates are captured and stored in main folder, move to appropriate folder (White or Black List)"), $x , $y - 10, 380, 30, $BS_MULTILINE)
$y += 20
GUICtrlCreateButton(GetTranslated(613, 9,"Open Clan Mates Image Folder"), $x + 2, $y, 300, 20,-1)
GUICtrlSetOnEvent(-1, "btnFilterDonationsCC")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 60
GUICtrlCreateGroup(GetTranslated(613,15,"Skip donation near full troops"), $x - 20, $y - 20, 430, 45)
$g_hChkSkipDonateNearFullTroopsEnable = GUICtrlCreateCheckbox(GetTranslated(613,13,"Skip donation near full troops"), $x, $y-4)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetOnEvent(-1, "chkskipDonateNearFulLTroopsEnable")
$x += 180
$g_hLblSkipDonateNearFullTroopsText = GUICtrlCreateLabel(GetTranslated(613,14,"if troops army camps are greater than"), $x, $y)
$x += 110
$g_hTxtSkipDonateNearFullTroopsPercentage = GUICtrlCreateInput("90", $x +40+30 , $y -2 , 20, 20, BitOR($SS_CENTER, $ES_AUTOHSCROLL))
GUICtrlSetLimit(-1,2)
$x += 95
$g_hLblSkipDonateNearFullTroopsText1 = GUICtrlCreateLabel("%", $x, $y)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_UPGRADE = 0, $g_hGUI_UPGRADE_TAB = 0, $g_hGUI_UPGRADE_TAB_ITEM1 = 0, $g_hGUI_UPGRADE_TAB_ITEM2 = 0, $g_hGUI_UPGRADE_TAB_ITEM3 = 0, $g_hGUI_UPGRADE_TAB_ITEM4 = 0
Global $g_hChkAutoLabUpgrades = 0, $g_hCmbLaboratory = 0, $g_hLblNextUpgrade = 0, $g_hBtnResetLabUpgradeTime = 0, $g_hPicLabUpgrade = 0
Global $g_hChkUpgradeKing = 0, $g_hChkUpgradeQueen = 0, $g_hChkUpgradeWarden = 0, $g_hPicChkKingSleepWait = 0, $g_hPicChkQueenSleepWait = 0, $g_hPicChkWardenSleepWait = 0
Global $g_hChkUpgrade[$g_iUpgradeSlots] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Global $g_hPicUpgradeStatus[$g_iUpgradeSlots] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Global $g_hTxtUpgradeName[$g_iUpgradeSlots] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Global $g_hTxtUpgradeLevel[$g_iUpgradeSlots] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Global $g_hPicUpgradeType[$g_iUpgradeSlots] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Global $g_hTxtUpgradeValue[$g_iUpgradeSlots] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Global $g_hTxtUpgradeTime[$g_iUpgradeSlots] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Global $g_hTxtUpgradeEndTime[$g_iUpgradeSlots] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Global $g_hChkUpgradeRepeat[$g_iUpgradeSlots] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Global $g_hTxtUpgrMinGold = 0, $g_hTxtUpgrMinElixir = 0, $g_hTxtUpgrMinDark = 0
Global $g_hChkWalls = 0, $g_hTxtWallMinGold = 0, $g_hTxtWallMinElixir = 0, $g_hRdoUseGold = 0, $g_hRdoUseElixir = 0, $g_hRdoUseElixirGold = 0, $g_hChkSaveWallBldr = 0, $g_hCmbWalls = 4
Global $g_hLblWallCost = 0, $g_hBtnFindWalls = 0
Global $g_ahWallsCurrentCount[13] = [-1,-1,-1,-1,0,0,0,0,0,0,0,0,0]
Global $g_ahPicWallsLevel[13] = [-1,-1,-1,-1,0,0,0,0,0,0,0,0,0]
Func CreateVillageUpgrade()
$g_hGUI_UPGRADE = GUICreate("", $_GUI_MAIN_WIDTH - 28, $_GUI_MAIN_HEIGHT - 255 - 28, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_VILLAGE)
GUISwitch($g_hGUI_UPGRADE)
$g_hGUI_UPGRADE_TAB = GUICtrlCreateTab(0, 0, $_GUI_MAIN_WIDTH - 30, $_GUI_MAIN_HEIGHT - 255 - 30, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_UPGRADE_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslated(600,14,"Laboratory"))
CreateLaboratorySubTab()
$g_hGUI_UPGRADE_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslated(600,15,"Heroes"))
CreateHeroesSubTab()
$g_hGUI_UPGRADE_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslated(600,16,"Buildings"))
CreateBuildingsSubTab()
$g_hGUI_UPGRADE_TAB_ITEM4 = GUICtrlCreateTabItem(GetTranslated(600,17,"Walls"))
CreateWallsSubTab()
GUICtrlCreateTabItem("")
EndFunc
Func CreateLaboratorySubTab()
Local $sTxtNames = GetTranslated(603,0, "None") & "|" & GetTranslated(604,1, "Barbarians") & "|" & GetTranslated(604,2, "Archers") & "|" & GetTranslated(604,3, "Giants") & "|" & GetTranslated(604,4, "Goblins") & "|" & GetTranslated(604,5, "Wall Breakers") & "|" & GetTranslated(604,7, "Balloons") & "|" & GetTranslated(604,8, "Wizards") & "|" & GetTranslated(604,9, "Healers") & "|" & GetTranslated(604,10, "Dragons") & "|" & GetTranslated(604,11, "Pekkas") & "|" & GetTranslated(604,20, "Baby Dragons") & "|" & GetTranslated(604,21, "Miners") & "|" & GetTranslated(605,1, "Lightning Spell") & "|" & GetTranslated(605,2, "Healing Spell") & "|" & GetTranslated(605,3, "Rage Spell") & "|" & GetTranslated(605,4, "Jump Spell") & "|" & GetTranslated(605,5, "Freeze Spell") & "|" & GetTranslated(605,12, "Clone Spell")& "|" & GetTranslated(605,6, "Poison Spell") & "|" & GetTranslated(605,7, "EarthQuake Spell") & "|" & GetTranslated(605,8, "Haste Spell") & "|" & GetTranslated(605,13, "Skeleton Spell") & "|" & GetTranslated(604,13, "Minions") & "|" & GetTranslated(604,14, "Hog Riders") & "|" & GetTranslated(604,15, "Valkyries") & "|" & GetTranslated(604,16, "Golems") & "|" & GetTranslated(604,17, "Witches") & "|" & GetTranslated(604,18, "Lava Hounds") & "|" & GetTranslated(604, 19, "Bowlers")
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslated(614,1, "Laboratory"), $x - 20, $y - 20, 430, 334)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnLaboratory, $x, $y, 64, 64)
$g_hChkAutoLabUpgrades = GUICtrlCreateCheckbox(GetTranslated(614,2, "Auto Laboratory Upgrades"), $x + 80, $y + 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(614,3, "Check box to enable automatically starting Upgrades in laboratory"))
GUICtrlSetOnEvent(-1, "chkLab")
$g_hLblNextUpgrade = GUICtrlCreateLabel(GetTranslated(614,4, "Next one") & ":", $x + 80, $y + 38, 50, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hCmbLaboratory = GUICtrlCreateCombo("", $x + 135, $y + 35, 140, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtNames, GetTranslated(603,0, "None"))
_GUICtrlSetTip(-1, GetTranslated(614,5, "Select the troop type to upgrade with this pull down menu") & @CRLF & GetTranslated(614,6, "The troop icon will appear on the right.") & @CRLF & GetTranslated(614,7, "Any Dark Spell/Troop have priority over Upg Heroes!"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "cmbLab")
$g_hBtnResetLabUpgradeTime = GUICtrlCreateButton("", $x + 120 + 172, $y + 36, 18, 18, BitOR($BS_PUSHLIKE,$BS_DEFPUSHBUTTON))
GUICtrlSetBkColor(-1, $COLOR_ERROR)
_GUICtrlSetTip(-1, GetTranslated(614,8, "Visible Red button means that laboratory upgrade in process") & @CRLF & GetTranslated(614,9, "This will automatically disappear when near time for upgrade to be completed.") & @CRLF & GetTranslated(614,10, "If upgrade has been manually finished with gems before normal end time,") & @CRLF & GetTranslated(614,11, "Click red button to reset internal upgrade timer BEFORE STARTING NEW UPGRADE") & @CRLF & GetTranslated(614,12, "Caution - Unnecessary timer reset will force constant checks for lab status"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetOnEvent(-1, "ResetLabUpgradeTime")
$g_hPicLabUpgrade = GUICtrlCreateIcon($g_sLibIconPath, $eIcnBlank, $x + 330, $y, 64, 64)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateHeroesSubTab()
Local $sTxtTip = ""
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslated(615,1, "Upgrade Heroes Continuously"), $x - 20, $y - 20, 430, 334)
GUICtrlCreateLabel(GetTranslated(615,2, "Auto upgrading of your Heroes"), $x - 10, $y, -1, -1)
$y += 20
$g_hChkUpgradeKing = GUICtrlCreateCheckbox("", $x, $y + 25, 17, 17)
$sTxtTip = GetTranslated(615,3, "Enable upgrading of your King when you have enough Dark Elixir (Saving Min. Dark Elixir)") & @CRLF & GetTranslated(615,4, "You can manually locate your Kings Altar on Misc Tab") & @CRLF & GetTranslated(615,5, "Verify your Resume Bot Dark Elixir value at Misc Tab vs Saving Min. Dark Elixir here!") & @CRLF & GetTranslated(615,11, "Enabled with TownHall 7 and higher")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkUpgradeKing")
GUICtrlCreateIcon($g_sLibIconPath, $eIcnKingUpgr, $x + 18, $y, 64, 64)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicChkKingSleepWait = GUICtrlCreateIcon($g_sLibIconPath, $eIcnSleepingKing, $x + 18, $y, 64, 64)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1,$GUI_HIDE)
$x += 95
$g_hChkUpgradeQueen = GUICtrlCreateCheckbox("", $x, $y + 25, 17, 17)
$sTxtTip = GetTranslated(615,6, "Enable upgrading of your Queen when you have enough Dark Elixir (Saving Min. Dark Elixir)") & @CRLF & GetTranslated(615,7, "You can manually locate your Queens Altar on Misc Tab") & @CRLF & GetTranslated(615,5, -1) & @CRLF & GetTranslated(615,12, "Enabled with TownHall 9 and higher")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkUpgradeQueen")
GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueenUpgr, $x + 18, $y, 64, 64)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicChkQueenSleepWait = GUICtrlCreateIcon($g_sLibIconPath, $eIcnSleepingQueen, $x + 18, $y, 64, 64)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1,$GUI_HIDE)
$x += 95
$g_hChkUpgradeWarden = GUICtrlCreateCheckbox("", $x, $y + 25, 17, 17)
$sTxtTip = GetTranslated(615,8, "Enable upgrading of your Warden when you have enough Elixir (Saving Min. Elixir)") & @CRLF & GetTranslated(615,9, "You can manually locate your Wardens Altar on Misc Tab") & @CRLF & GetTranslated(615,5, -1) & @CRLF & GetTranslated(615,13, "Enabled with TownHall 11")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkUpgradeWarden")
GUICtrlSetColor(-1, $COLOR_ERROR )
GUICtrlCreateIcon($g_sLibIconPath, $eIcnWardenUpgr, $x + 18, $y, 64, 64)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicChkWardenSleepWait = GUICtrlCreateIcon($g_sLibIconPath, $eIcnSleepingWarden, $x + 18, $y, 64, 64)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1,$GUI_HIDE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateBuildingsSubTab()
Local $sTxtShowType = GetTranslated(616,29, "This shows type of upgrade, click to show location")
Local $sTxtStatus = GetTranslated(616,30, "Status: Red=not programmed, Yellow=programmed, not completed, Green=Completed")
Local $sTxtShowName = GetTranslated(616, 31, "This box is updated with unit name after upgrades are checked")
Local $sTxtShowLevel = GetTranslated(616, 32, "This unit box is updated with unit level after upgrades are checked")
Local $sTxtShowCost = GetTranslated(616, 33, "This upgrade cost box is updated after upgrades are checked")
Local $sTxtShowTime = GetTranslated(616, 34, "This box is updated with time length of upgrade after upgrades are checked")
Local $sTxtChkRepeat = GetTranslated(616, 35, "Check box to Enable Upgrade to repeat continuously")
Local $sTxtShowEndTime = GetTranslated(616, 36, "This box is updated with estimate end time of upgrade after upgrades are checked")
Local $sTxtCheckBox = GetTranslated(616,27, "Check box to Enable Upgrade")
Local $sTxtAfterUsing = GetTranslated(616,28, "after using Locate Upgrades button")
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslated(616,1, "Buildings or Heroes"), $x - 20, $y - 20, 430, 30 +($g_iUpgradeSlots * 22))
$x -= 7
$y -= 7
GUICtrlCreateLabel(GetTranslated(616,2,"Unit Name"), $x+71, $y, 70, 18)
GUICtrlCreateLabel(GetTranslated(616,3,"Lvl"), $x+153, $y, 40, 18)
GUICtrlCreateLabel(GetTranslated(616,4,"Type"), $x+173, $y, 50, 18)
GUICtrlCreateLabel(GetTranslated(616,5,"Cost"), $x+219, $y, 50, 18)
GUICtrlCreateLabel(GetTranslated(616,6,"Time"), $x+270, $y, 50, 18)
GUICtrlCreateLabel(GetTranslated(616,7,"Rep."), $x+392, $y, 50, 18)
GUICtrlCreateLabel(GetTranslated(616,37,"Estimate End"), $x+314, $y, 70, 18)
$y+=13
For $i = 0 To $g_iUpgradeSlots - 1
$g_hPicUpgradeStatus[$i]= GUICtrlCreateIcon($g_sLibIconPath, $eIcnTroops, $x - 10, $y+1, 14, 14)
_GUICtrlSetTip(-1, $sTxtStatus)
$g_hChkUpgrade[$i] = GUICtrlCreateCheckbox($i+1 &":", $x + 5, $y+1, 34, 15)
_GUICtrlSetTip(-1, $sTxtCheckBox & " #" & $i+1 & " " & $sTxtAfterUsing)
GUICtrlSetOnEvent(-1, "btnchkbxUpgrade")
$g_hTxtUpgradeName[$i] = GUICtrlCreateInput("", $x+40, $y, 107, 17,BitOR($ES_CENTER, $GUI_SS_DEFAULT_INPUT, $ES_READONLY, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtShowName)
$g_hTxtUpgradeLevel[$i] = GUICtrlCreateInput("", $x+150, $y, 23, 17, BitOR($ES_CENTER, $GUI_SS_DEFAULT_INPUT, $ES_READONLY, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtShowLevel)
$g_hPicUpgradeType[$i]= GUICtrlCreateIcon($g_sLibIconPath, $eIcnBlank,$x+178, $y+1, 15, 15)
_GUICtrlSetTip(-1, $sTxtShowType)
GUICtrlSetOnEvent(-1, "picUpgradeTypeLocation")
$g_hTxtUpgradeValue[$i] = GUICtrlCreateInput("", $x+197, $y, 65, 17, BitOR($ES_CENTER, $GUI_SS_DEFAULT_INPUT, $ES_READONLY, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtShowCost)
$g_hTxtUpgradeTime[$i] = GUICtrlCreateInput("", $x+266, $y, 35, 17, BitOR($ES_CENTER, $GUI_SS_DEFAULT_INPUT, $ES_READONLY, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtShowTime)
$g_hTxtUpgradeEndTime[$i] = GUICtrlCreateInput("", $x+305, $y, 85, 17, BitOR($ES_LEFT, $GUI_SS_DEFAULT_INPUT, $ES_READONLY, $ES_NUMBER))
GUICtrlSetFont(-1, 7)
_GUICtrlSetTip(-1, $sTxtShowEndTime)
$g_hChkUpgradeRepeat[$i] = GUICtrlCreateCheckbox("", $x + 395, $y+1, 15, 15)
_GUICtrlSetTip(-1, $sTxtChkRepeat)
GUICtrlSetOnEvent(-1, "btnchkbxRepeat")
$y += 22
Next
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x += 5
$y += 8
GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x - 15, $y, 15, 15)
GUICtrlCreateLabel(GetTranslated(616,14, "Min. Gold")&":", $x + 5, $y + 3, -1, -1)
$g_hTxtUpgrMinGold = GUICtrlCreateInput("250000", $x + 55, $y, 61, 17, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(616,15, "Save this much Gold after the upgrade completes.") & @CRLF & GetTranslated(616,16, "Set this value as needed to save for searching, or wall upgrades."))
GUICtrlSetLimit(-1, 7)
$y += 18
GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x - 15, $y, 15, 15)
GUICtrlCreateLabel(GetTranslated(616,17, "Min. Elixir") & ":", $x + 5, $y + 3, -1, -1)
$g_hTxtUpgrMinElixir = GUICtrlCreateInput("250000", $x + 55, $y, 61, 17, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(616,18, "Save this much Elixir after the upgrade completes") & @CRLF & GetTranslated(616,19, "Set this value as needed to save for making troops or wall upgrades."))
GUICtrlSetLimit(-1, 7)
$x -= 15
$y -= 8
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 140, $y, 15, 15)
GUICtrlCreateLabel(GetTranslated(616,20, "Min. Dark") & ":", $x + 160, $y + 3, -1, -1)
$g_hTxtUpgrMinDark = GUICtrlCreateInput("3000", $x + 210, $y, 61, 17, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(616,21, "Save this amount of Dark Elixir after the upgrade completes.") & @CRLF & GetTranslated(616,22, "Set this value higher if you want make war troops."))
GUICtrlSetLimit(-1, 6)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y -= 8
GUICtrlCreateButton(GetTranslated(616,8, "Locate Upgrades"), $x + 290, $y - 4, 120, 18, BitOR($BS_MULTILINE, $BS_VCENTER))
_GUICtrlSetTip(-1, GetTranslated(616,9, "Push button to locate and record information on building/Hero upgrades") & @CRLF & GetTranslated(616,10, "Any upgrades with repeat enabled are skipped and can not be located again"))
GUICtrlSetOnEvent(-1, "btnLocateUpgrades")
GUICtrlCreateButton(GetTranslated(616,11, "Reset Upgrades"), $x + 290, $y + 16, 120, 18, BitOR($BS_MULTILINE, $BS_VCENTER))
_GUICtrlSetTip(-1, GetTranslated(616,12, "Push button to reset & remove upgrade information") & @CRLF & GetTranslated(616,13, "If repeat box is checked, data will not be reset"))
GUICtrlSetOnEvent(-1, "btnResetUpgrade")
EndFunc
Func CreateWallsSubTab()
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslated(617,1, "Walls"), $x - 20, $y - 20, 430, 120)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnWall, $x - 12, $y - 6, 24, 24)
$g_hChkWalls = GUICtrlCreateCheckbox(GetTranslated(617,2, "Auto Wall Upgrade"), $x + 18, $y-2, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(617,3, "Check this to upgrade Walls if there are enough resources."))
GUICtrlSetState(-1, $GUI_ENABLE)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "chkWalls")
$g_hBtnFindWalls = GUICtrlCreateButton(GetTranslated(617,5, "TEST"), $x + 150, $y +26 , 45, -1)
_GUICtrlSetTip(-1, GetTranslated(617,6, "Click here to test the Wall Detection."))
GUICtrlSetOnEvent(-1, "btnWalls")
If $g_bBtnColor then GUICtrlSetBkColor(-1, 0x5CAD85)
$g_hRdoUseGold = GUICtrlCreateRadio(GetTranslated(617,7, "Use Gold"), $x + 25, $y + 16, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(617,8, "Use only Gold for Walls.") & @CRLF & GetTranslated(617,9, "Available at all Wall levels."))
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hRdoUseElixir = GUICtrlCreateRadio(GetTranslated(617,10, "Use Elixir"), $x + 25, $y + 34, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(617,11, "Use only Elixir for Walls.") & @CRLF & GetTranslated(617,12, "Available only at Wall levels upgradeable with Elixir."))
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hRdoUseElixirGold = GUICtrlCreateRadio(GetTranslated(617,13, "Try Elixir first, Gold second"), $x + 25, $y + 52, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(617,14, "Try to use Elixir first. If not enough Elixir try to use Gold second for Walls.") & @CRLF & GetTranslated(617,12, -1))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnBuilder, $x - 12, $y + 72, 20, 20)
$g_hChkSaveWallBldr = GUICtrlCreateCheckbox(GetTranslated(617,15, "Save ONE builder for Walls"), $x+18, $y + 72, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(617,16, "Check this to reserve 1 builder exclusively for walls and") & @CRLF & GetTranslated(617,17, "reduce the available builder by 1 for other upgrades"))
GUICtrlSetState(-1, $GUI_ENABLE)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "chkSaveWallBldr")
$x += 225
GUICtrlCreateLabel(GetTranslated(617,18, "Search for Walls level") & ":", $x, $y+2, -1, -1)
$g_hCmbWalls = GUICtrlCreateCombo("", $x + 110, $y, 61, 21, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL), $WS_EX_RIGHT)
_GUICtrlSetTip(-1, GetTranslated(617,19, "Search for Walls of this level and try to upgrade them one by one."))
GUICtrlSetData(-1, "4   |5   |6   |7   |8   |9   |10   |11   ", "4   ")
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "cmbWalls")
GUICtrlCreateLabel(GetTranslated(617,20, "Next Wall level costs") &":", $x, $y + 25, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(617,21, "Use this value as an indicator.") & @CRLF & GetTranslated(617,22, "The value will update if you select an other wall level."))
$g_hLblWallCost = GUICtrlCreateLabel("30 000", $x + 110, $y + 25, 50, -1, $SS_RIGHT)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x, $y + 47, 16, 16)
GUICtrlCreateLabel(GetTranslated(617,23, "Min. Gold to save"), $x + 20, $y + 47, -1, -1)
$g_hTxtWallMinGold = GUICtrlCreateInput("250000", $x + 110, $y + 45, 61, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(617,24, "Save this much Gold after the wall upgrade completes,") & @CRLF & GetTranslated(617,25, "Set this value to save Gold for other upgrades, or searching."))
GUICtrlSetLimit(-1, 7)
GUICtrlSetState(-1, $GUI_DISABLE)
$y +=2
GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x, $y + 67, 16, 16)
GUICtrlCreateLabel(GetTranslated(617,32, "Min. Elixir to save"), $x + 20, $y + 70, -1, -1)
$g_hTxtWallMinElixir = GUICtrlCreateInput("250000", $x + 110, $y + 65, 61, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(617,27, "Save this much Elixir after the wall upgrade completes,") & @CRLF & GetTranslated(617,28, "Set this value to save Elixir for other upgrades or troop making."))
GUICtrlSetLimit(-1, 7)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 25, $y = 170
GUICtrlCreateGroup(Gettranslated(617,29, "Walls counter"), $x - 20, $y - 20, 430, 100)
$x -= 3
$g_ahWallsCurrentCount[4] = GUICtrlCreateInput("0", $x - 10, $y , 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(617,30, "Input number of Walls level")&" 4 "&GetTranslated(617,31, "you have."))
$g_ahPicWallsLevel[4] = GUICtrlCreateIcon($g_sLibIconPath, $eWall04, $x + 17, $y-2, 24, 24)
$x += 80
$g_ahWallsCurrentCount[5] = GUICtrlCreateInput("0", $x, $y , 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(617,30, "Input number of Walls level")&" 5 "&GetTranslated(617,31, "you have."))
$g_ahPicWallsLevel[5] = GUICtrlCreateIcon($g_sLibIconPath, $eWall05, $x+27, $y-2, 24, 24)
$x += 80
$g_ahWallsCurrentCount[6] = GUICtrlCreateInput("0", $x, $y , 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(617,30, "Input number of Walls level")&" 6 "&GetTranslated(617,31, "you have."))
$g_ahPicWallsLevel[6] = GUICtrlCreateIcon($g_sLibIconPath, $eWall06, $x+27, $y-2, 24, 24)
$x += 80
$g_ahWallsCurrentCount[7] = GUICtrlCreateInput("0", $x, $y , 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(617,30, "Input number of Walls level")&" 7 "&GetTranslated(617,31, "you have."))
$g_ahPicWallsLevel[7] = GUICtrlCreateIcon($g_sLibIconPath, $eWall07, $x+27, $y-2, 24, 24)
$x += 80
$g_ahWallsCurrentCount[8] = GUICtrlCreateInput("0", $x, $y , 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(617,30, "Input number of Walls level")&" 8 "&GetTranslated(617,31, "you have."))
$g_ahPicWallsLevel[8] = GUICtrlCreateIcon($g_sLibIconPath, $eWall08, $x+27, $y-2, 24, 24)
Local $x = 25
$x -= 3
$x += 10
$y += 40
$g_ahWallsCurrentCount[9] = GUICtrlCreateInput("0", $x, $y , 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(617,30, "Input number of Walls level")&" 9 "&GetTranslated(617,31, "you have."))
$g_ahPicWallsLevel[9] = GUICtrlCreateIcon($g_sLibIconPath, $eWall09, $x+27, $y-2, 24, 24)
$x += 80
$g_ahWallsCurrentCount[10] = GUICtrlCreateInput("0", $x, $y , 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(617,30, "Input number of Walls level")&" 10 "&GetTranslated(617,31, "you have."))
$g_ahPicWallsLevel[10] = GUICtrlCreateIcon($g_sLibIconPath, $eWall10, $x+27, $y-2, 24, 24)
$x += 80
$g_ahWallsCurrentCount[11] = GUICtrlCreateInput("0", $x, $y , 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(617,30, "Input number of Walls level")&" 11 "&GetTranslated(617,31, "you have."))
$g_ahPicWallsLevel[11] = GUICtrlCreateIcon($g_sLibIconPath, $eWall11, $x+27, $y-2, 24, 24)
$x += 80
$g_ahWallsCurrentCount[12] = GUICtrlCreateInput("0", $x, $y , 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(617,30, "Input number of Walls level")&" 12 "&GetTranslated(617,31, "you have."))
$g_ahPicWallsLevel[12] = GUICtrlCreateIcon($g_sLibIconPath, $eWall12, $x+27, $y-2, 24, 24)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hChkUnbreakable = 0, $g_hTxtUnbreakable = 0, $g_hTxtUnBrkMinGold = 0, $g_hTxtUnBrkMaxGold = 0, $g_hTxtUnBrkMinElixir = 0, $g_hTxtUnBrkMaxElixir = 0, $g_hTxtUnBrkMinDark = 0, $g_hTxtUnBrkMaxDark = 0
Global $g_hLblUnbreakableHelp = 0, $g_hLblUnbreakableLink = 0
Func CreateVillageAchievements()
Local $x = 25
Local $y = 45
GUICtrlCreateGroup(GetTranslated(618,1, "Defense Farming"), $x - 20, $y - 20, 440, 150)
$y +=10
$g_hChkUnbreakable = GUICtrlCreateCheckbox(GetTranslated(618,2, "Enable Unbreakable"), $x - 10, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(618,3, "Enable farming Defense Wins for Unbreakable achievement."))
GUICtrlSetOnEvent(-1, "chkUnbreakable")
GUICtrlCreateIcon($g_sLibIconPath, $eIcnGoldStar, $x + 10, $y + 51, 32, 32)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnGoldStar, $x + 42, $y + 36, 48, 48)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnGoldStar, $x + 90, $y + 51, 32, 32)
$x = 150
GUICtrlCreateLabel(GetTranslated(618,4, "Wait Time") & ":", $x - 10, $y + 3, 86, -1, $SS_RIGHT)
$g_hTxtUnbreakable = GUICtrlCreateInput("5", $x + 80, $y, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(618,5, "Set the amount of time to stop CoC and wait for enemy attacks to gain defense wins. (1-99 minutes)"))
GUICtrlSetLimit(-1, 2)
GUICtrlCreateLabel(GetTranslated(618,6, "Minutes"), $x + 113, $y+3, -1, -1)
$y += 28
GUICtrlCreateLabel(GetTranslated(618,7, "Farm Min."), $x + 25 , $y, -1, -1)
GUICtrlCreateLabel(GetTranslated(618,8, "Save Min."), $x + 115 , $y, -1, -1)
$y += 16
$g_hTxtUnBrkMinGold = GUICtrlCreateInput("50000", $x + 20, $y, 58, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(618,9, "Amount of Gold that stops Defense farming, switches to normal farming if below.") & @CRLF & GetTranslated(618,10, "Set this value to amount of Gold you need for searching or upgrades."))
GUICtrlSetLimit(-1, 7)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 80, $y + 2, 16, 16)
$g_hTxtUnBrkMaxGold = GUICtrlCreateInput("600000", $x + 110, $y, 58, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(618,11, "Amount of Gold in Storage Required to Enable Defense Farming.") & @CRLF & GetTranslated(618,12, "Input amount of Gold you need to attract enemy or for upgrades."))
GUICtrlSetLimit(-1, 7)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 170, $y + 2, 16, 16)
$y += 26
$g_hTxtUnBrkMinElixir = GUICtrlCreateInput("50000", $x + 20, $y, 58, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(618,13, "Amount of Elixir that stops Defense farming, switches to normal farming if below.") & @CRLF & GetTranslated(618,14, "Set this value to amount of Elixir you need for making troops or upgrades."))
GUICtrlSetLimit(-1, 7)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 80, $y, 16, 16)
$g_hTxtUnBrkMaxElixir = GUICtrlCreateInput("600000", $x + 110, $y, 58, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(618,15, "Amount of Elixir in Storage Required to Enable Defense Farming.") & @CRLF & GetTranslated(618,16, "Input amount of Elixir you need to attract enemy or for upgrades."))
GUICtrlSetLimit(-1, 7)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 170, $y, 16, 16)
$y += 24
$g_hTxtUnBrkMinDark = GUICtrlCreateInput("5000", $x + 20, $y, 58, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(618,17, "Amount of Dark Elixir that stops Defense farming, switches to normal farming if below.") & @CRLF & GetTranslated(618,18, "Set this value to amount of Dark Elixir you need for making troops or upgrades."))
GUICtrlSetLimit(-1, 6)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 80, $y, 16, 16)
$g_hTxtUnBrkMaxDark = GUICtrlCreateInput("6000", $x + 110, $y, 58, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(618,19, "Amount of Dark Elixir in Storage Required to Enable Defense Farming.") & @CRLF & GetTranslated(618,20, "Input amount of Dark Elixir you need to attract enemy or for upgrades."))
GUICtrlSetLimit(-1, 6)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 170, $y, 16, 16)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25
$y = 200
GUICtrlCreateGroup(GetTranslated(618,21,"How to use Unbreakable Mode"), $x - 20, $y - 20, 440, 200)
Local $txtHelp = GetTranslated(618,22,"Unbreakable mode will help you gain defense wins and the ""Unbreakable"" achievement.") & @CRLF & GetTranslated(618,23,"Set ""Wait Time"" to how long you want the bot to wait for defenses." ) & @CRLF & GetTranslated(618,24,"Farm Min is how many resources the bot must have before attacking." ) & @CRLF & GetTranslated(618,25,"Save Min is how many resources the bot must have before starting unbreakable mode." ) & @CRLF & GetTranslated(618,26,"Click the below link for more information:" )
$g_hLblUnbreakableHelp = GUICtrlCreateLabel($txtHelp, $x - 10, $y, 430, 125)
$g_hLblUnbreakableLink = GUICtrlCreateLabel(GetTranslated(618,27,"More Info"), $x - 10, $y + 100, 100,20)
_GUIToolTip_AddTool($hToolTip, 0, "https://mybot.run/forums/index.php?/topic/2964-guide-how-to-use-mybot-unbreakable-mode-updated/", GUICtrlGetHandle($g_hLblUnbreakableLink))
GUICtrlSetFont(-1, 8.5, $FW_BOLD, $GUI_FONTUNDER)
GUICtrlSetColor(-1, $COLOR_INFO)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_NOTIFY = 0, $g_hGUI_NOTIFY_TAB = 0, $g_hGUI_NOTIFY_TAB_ITEM2 = 0, $g_hGUI_NOTIFY_TAB_ITEM6 = 0
Global $g_hGrpNotify = 0
Global $g_hChkNotifyPBEnable = 0, $g_hTxtNotifyPBToken = 0, $g_hChkNotifyTGEnable = 0, $g_hTxtNotifyTGToken = 0
Global $g_hChkNotifyRemote = 0, $g_hTxtNotifyOrigin = 0
Global $g_hChkNotifyDeleteAllPBPushes = 0, $g_hBtnNotifyDeleteMessages = 0, $g_hChkNotifyDeleteOldPBPushes = 0, $g_hCmbNotifyPushHours = 0, $g_hChkNotifyAlertMatchFound = 0, $g_hChkNotifyAlertLastRaidIMG = 0, $g_hChkNotifyAlertLastRaidTXT = 0, $g_hChkNotifyAlertCampFull = 0, $g_hChkNotifyAlertUpgradeWall = 0, $g_hChkNotifyAlertOutOfSync = 0, $g_hChkNotifyAlertTakeBreak = 0, $g_hChkNotifyAlertBuilderIdle = 0, $g_hChkNotifyAlertVillageStats = 0, $g_hChkNotifyAlertLastAttack = 0, $g_hChkNotifyAlertAnotherDevice = 0, $g_hChkNotifyAlertMaintenance = 0, $g_hChkNotifyAlertBAN = 0, $g_hChkNotifyBOTUpdate = 0
Global $g_hChkNotifyOnlyHours = 0, $g_hChkNotifyOnlyWeekDays = 0, $g_hChkNotifyhours[24] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], $g_hChkNotifyWeekdays[7] = [0,0,0,0,0,0,0]
GLobal $g_hLblNotifyhour = 0, $g_ahLblNotifyhoursE = 0, $g_hChkNotifyhoursE1 = 0, $g_hChkNotifyhoursE2 = 0, $g_hLblNotifyhoursAM = 0, $g_hLblNotifyhoursPM = 0
GLobal $g_hLblNotifyhours[12] = [0,0,0,0,0,0,0,0,0,0,0,0]
Global $g_hLblNotifyWeekdays[7] = [0,0,0,0,0,0,0], $g_ahLblNotifyWeekdaysE = 0, $g_ahChkNotifyWeekdaysE = 0
Func CreateVillageNotify()
$g_hGUI_NOTIFY = GUICreate("", $_GUI_MAIN_WIDTH - 28, $_GUI_MAIN_HEIGHT - 255 - 28, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_VILLAGE)
GUISwitch($g_hGUI_NOTIFY)
$g_hGUI_NOTIFY_TAB = GUICtrlCreateTab(0, 0, $_GUI_MAIN_WIDTH - 30, $_GUI_MAIN_HEIGHT - 255 - 30, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_NOTIFY_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslated(600,18,"PushBullet/Telegram"))
CreatePushBulletTelegramSubTab()
$g_hGUI_NOTIFY_TAB_ITEM6 = GUICtrlCreateTabItem(GetTranslated(619,51,"Notify Schedule"))
CreateNotifyScheduleSubTab()
GUICtrlCreateTabItem("")
EndFunc
Func CreatePushBulletTelegramSubTab()
Local $sTxtTip = ""
Local $x = 25, $y = 45
$g_hGrpNotify = GUICtrlCreateGroup(GetTranslated(619,1, "PushBullet/Telegram Notify") & " " & $g_sNotifyVersion, $x - 20, $y - 20, 430, 320)
$x -= 10
GUICtrlCreateIcon($g_sLibIconPath, $eIcnNotify, $x + 3, $y, 32, 32)
$g_hChkNotifyPBEnable = GUICtrlCreateCheckbox(GetTranslated(619,2, "Enable PushBullet"), $x + 40, $y + 5)
GUICtrlSetOnEvent(-1, "chkPBTGenabled")
_GUICtrlSetTip(-1, GetTranslated(619,3, "Enable PushBullet notifications"))
$g_hChkNotifyDeleteAllPBPushes = GUICtrlCreateCheckbox(GetTranslated(619,8, "Delete Msg on Start"), $x + 160, $y)
_GUICtrlSetTip(-1, GetTranslated(619,9, "It will delete all previous push notification when you start bot"))
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hBtnNotifyDeleteMessages = GUICtrlCreateButton(GetTranslated(619,10, "Delete all Msg now"), $x + 300, $y, 100, 20)
_GUICtrlSetTip(-1, GetTranslated(619,11, "Click here to delete all PushBullet messages."))
GUICtrlSetOnEvent(-1, "btnDeletePBMessages")
If $g_bBtnColor then GUICtrlSetBkColor(-1, 0x5CAD85)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 22
$g_hChkNotifyDeleteOldPBPushes = GUICtrlCreateCheckbox(GetTranslated(619,12, "Delete Msg older than"), $x + 160, $y)
_GUICtrlSetTip(-1, GetTranslated(619,13, "Delete all previous push notification older than specified hour"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "chkDeleteOldPBPushes")
$g_hCmbNotifyPushHours = GUICtrlCreateCombo("", $x + 300, $y, 100, 35, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslated(619,14, "Set the interval for messages to be deleted."))
Local $sTxtHours = GetTranslated(603, 14, -1)
GUICtrlSetData(-1, "1 " & GetTranslated(603, 15, -1) &"|2 " & $sTxtHours & "|3 " & $sTxtHours & "|4 " & $sTxtHours & "|5 " & $sTxtHours & "|6 " & $sTxtHours & "|7 " & $sTxtHours & "|8 " &$sTxtHours & "|9 " & $sTxtHours & "|10 " & $sTxtHours & "|11 " & $sTxtHours & "|12 " & $sTxtHours & "|13 " & $sTxtHours & "|14 " & $sTxtHours & "|15 " & $sTxtHours & "|16 " & $sTxtHours & "|17 " & $sTxtHours & "|18 " & $sTxtHours & "|19 " & $sTxtHours & "|20 " & $sTxtHours & "|21 " & $sTxtHours & "|22 " & $sTxtHours & "|23 " & $sTxtHours & "|24 " & $sTxtHours )
_GUICtrlComboBox_SetCurSel(-1,0)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 30
GUICtrlCreateLabel(GetTranslated(619,16, "Token (PushBullet)") & ":", $x, $y, -1, -1, $SS_RIGHT)
$g_hTxtNotifyPBToken = GUICtrlCreateInput("", $x + 120, $y - 3, 280, 19)
_GUICtrlSetTip(-1, GetTranslated(619,17, "You need a Token to use PushBullet notifications. Get a token from PushBullet.com"))
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 20
GUICtrlCreateIcon($g_sLibIconPath, $eIcnTelegram, $x + 3, $y, 32, 32)
$g_hChkNotifyTGEnable = GUICtrlCreateCheckbox(GetTranslated(619,4, "Enable Telegram"), $x + 40, $y + 5)
GUICtrlSetOnEvent(-1, "chkPBTGenabled")
_GUICtrlSetTip(-1, GetTranslated(619,5, "Enable Telegram notifications"))
$y += 40
GUICtrlCreateLabel(GetTranslated(619,18, "Token (Telegram)") & ":", $x, $y, -1, -1, $SS_RIGHT)
$g_hTxtNotifyTGToken = GUICtrlCreateInput("", $x + 120, $y - 3, 280, 19)
_GUICtrlSetTip(-1, GetTranslated(619,19, "You need a Token to use Telegram notifications. Get a token from Telegram.com"))
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 30
$g_hChkNotifyRemote = GUICtrlCreateCheckbox(GetTranslated(619,6, "Remote Control"), $x + 10, $y)
_GUICtrlSetTip(-1, GetTranslated(619,7, "Enables PushBullet Remote function"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel(GetTranslated(619,20, "Origin") & ":", $x + 120, $y + 3, -1, -1, $SS_RIGHT)
$sTxtTip = GetTranslated(619,21, "Origin - Village name.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtNotifyOrigin = GUICtrlCreateInput("", $x + 170, $y, 230, 19)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 25
GUICtrlCreateLabel(GetTranslated(619,22, "Send a PushBullet/Telegram message for these options") & ":", $x, $y, -1, -1, $SS_RIGHT)
$y += 15
$g_hChkNotifyAlertMatchFound = GUICtrlCreateCheckbox(GetTranslated(619,23, "Match Found"), $x + 10, $y)
_GUICtrlSetTip(-1, GetTranslated(619,24, "Send the amount of available loot when bot finds a village to attack."))
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkNotifyAlertLastRaidIMG = GUICtrlCreateCheckbox(GetTranslated(619,25, "Last raid as image"), $x + 100, $y)
_GUICtrlSetTip(-1, GetTranslated(619,26, "Send the last raid screenshot."))
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkNotifyAlertLastRaidTXT = GUICtrlCreateCheckbox(GetTranslated(619,27, "Last raid as Text"), $x + 210, $y, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(619,28, "Send the last raid results as text."))
$g_hChkNotifyAlertCampFull = GUICtrlCreateCheckbox(GetTranslated(619,29, "Army Camp Full"), $x + 315, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(619,30, "Sent an Alert when your Army Camp is full."))
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 20
$g_hChkNotifyAlertUpgradeWall = GUICtrlCreateCheckbox(GetTranslated(619,31, "Wall upgrade"), $x + 10, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(619,32, "Send info about wall upgrades."))
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkNotifyAlertOutOfSync = GUICtrlCreateCheckbox(GetTranslated(619,33, "Error: Out Of Sync"), $x + 100, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(619,34, "Send an Alert when you get the Error: Client and Server out of sync"))
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkNotifyAlertTakeBreak = GUICtrlCreateCheckbox(GetTranslated(619,35, "Take a break"), $x + 210, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(619,36, "Send an Alert when you have been playing for too long and your villagers need to rest."))
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkNotifyAlertBuilderIdle = GUICtrlCreateCheckbox(GetTranslated(619,37, "Builder Idle"), $x + 315, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(619,38, "Send an Alert when at least one builder is idle."))
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 20
$g_hChkNotifyAlertVillageStats = GUICtrlCreateCheckbox(GetTranslated(619,39, "Village Report"), $x + 10, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(619,40, "Send a Village Report."))
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkNotifyAlertLastAttack = GUICtrlCreateCheckbox(GetTranslated(619,41, "Alert Last Attack"), $x + 100, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(619,42, "Send info about the Last Attack."))
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkNotifyAlertAnotherDevice = GUICtrlCreateCheckbox(GetTranslated(619,43, "Another device"), $x + 210, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(619,44, "Send an Alert when your village is connected to from another device."))
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 20
$g_hChkNotifyAlertMaintenance = GUICtrlCreateCheckbox(GetTranslated(619,45, "Maintenance"), $x + 10, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(619,46, "Send an Alert when CoC is under maintenance by SuperCell"))
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkNotifyAlertBAN = GUICtrlCreateCheckbox(GetTranslated(619,47, "BAN"), $x + 100, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(619,48, "Send an Alert if your village was BANNED by SuperCell"))
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkNotifyBOTUpdate = GUICtrlCreateCheckbox(GetTranslated(619,49, "BOT Update"), $x + 210, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(619,50, "Send an Alert when there is a new version of the bot."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel(GetTranslated(619,69,"Help ?"), $x + 200, $y + 60, 220, 24, $SS_RIGHT)
GUICtrlSetOnEvent(-1, "NotifyHelp")
GUICtrlSetCursor(-1, 0)
GUICtrlSetFont(-1, 8.5, $FW_BOLD)
_GUICtrlSetTip(-1, GetTranslated(619,70,"Click here to get Help about Notify Remote commands to PushBullet and Telegram"))
GUICtrlSetColor(-1, $COLOR_NAVY)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateNotifyScheduleSubTab()
Local $x = 25
Local $y = 150 - 105
Local $sTxtTip = ""
GUICtrlCreateGroup(GetTranslated(619,51, "Notify Schedule"), $x - 20, $y - 20, 430, 334)
$x += 10
$y += 10
GUICtrlCreateIcon($g_sLibIconPath, $eIcnPBNotify, $x - 5, $y, 64, 64, $BS_ICON)
$g_hChkNotifyOnlyHours = GUICtrlCreateCheckbox(GetTranslated(603,30, -1), $x+70, $y-6)
GUICtrlSetOnEvent(-1, "chkNotifyHours")
$x += 59
$y += 85
$g_hLblNotifyhour = GUICtrlCreateLabel(GetTranslated(603, 15, -1) & ":", $x , $y, -1, 15)
$sTxtTip = GetTranslated(603, 30, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblNotifyhours[0] = GUICtrlCreateLabel(" 0", $x + 30, $y)
$g_hLblNotifyhours[1] = GUICtrlCreateLabel(" 1", $x + 45, $y)
$g_hLblNotifyhours[2] = GUICtrlCreateLabel(" 2", $x + 60, $y)
$g_hLblNotifyhours[3] = GUICtrlCreateLabel(" 3", $x + 75, $y)
$g_hLblNotifyhours[4] = GUICtrlCreateLabel(" 4", $x + 90, $y)
$g_hLblNotifyhours[5] = GUICtrlCreateLabel(" 5", $x + 105, $y)
$g_hLblNotifyhours[6] = GUICtrlCreateLabel(" 6", $x + 120, $y)
$g_hLblNotifyhours[7] = GUICtrlCreateLabel(" 7", $x + 135, $y)
$g_hLblNotifyhours[8] = GUICtrlCreateLabel(" 8", $x + 150, $y)
$g_hLblNotifyhours[9] = GUICtrlCreateLabel(" 9", $x + 165, $y)
$g_hLblNotifyhours[10] = GUICtrlCreateLabel("10", $x + 180, $y)
$g_hLblNotifyhours[11] = GUICtrlCreateLabel("11", $x + 195, $y)
$g_ahLblNotifyhoursE = GUICtrlCreateLabel("X", $x + 214, $y+1, 11, 11)
$y += 15
$g_hChkNotifyhours[0] = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[1] = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[2] = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[3] = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[4] = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[5] = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[6] = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[7] = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[8] = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[9] = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[10] = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[11] = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhoursE1 = GUICtrlCreateCheckbox("", $x + 211, $y+1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED + $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(603, 2, -1))
GUICtrlSetOnEvent(-1, "chkNotifyhoursE1")
$g_hLblNotifyhoursAM = GUICtrlCreateLabel(GetTranslated(603, 3, -1), $x + 10, $y)
$y += 15
$g_hChkNotifyhours[12] = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[13] = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[14] = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[15] = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[16] = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[17] = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[18] = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[19] = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[20] = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[21] = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[22] = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhours[23] = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyhoursE2 = GUICtrlCreateCheckbox("", $x + 211, $y+1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED + $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(603, 2, -1))
GUICtrlSetOnEvent(-1, "chkNotifyhoursE2")
$g_hLblNotifyhoursPM = GUICtrlCreateLabel(GetTranslated(603, 4, -1), $x + 10, $y)
$x = 35
$y = 220
$g_hChkNotifyOnlyWeekDays = GUICtrlCreateCheckbox(GetTranslated(603, 31, -1), $x + 70, $y - 6)
GUICtrlSetOnEvent(-1, "chkNotifyWeekDays")
GUICtrlSetState(-1, $GUI_DISABLE)
$x += 59
$y += 19
GUICtrlCreateLabel(GetTranslated(603, 36, -1) & ":", $x, $y, -1, 15)
_GUICtrlSetTip(-1, GetTranslated(603, 31, -1))
$g_hLblNotifyWeekdays[0] = GUICtrlCreateLabel(GetTranslated(603, 16, -1), $x + 30, $y)
_GUICtrlSetTip(-1, GetTranslated(603, 17, -1))
$g_hLblNotifyWeekdays[1] = GUICtrlCreateLabel(GetTranslated(603, 18, -1), $x + 46, $y)
_GUICtrlSetTip(-1, GetTranslated(603, 19, -1))
$g_hLblNotifyWeekdays[2] = GUICtrlCreateLabel(GetTranslated(603, 20, -1), $x + 62, $y)
_GUICtrlSetTip(-1, GetTranslated(603, 21, -1))
$g_hLblNotifyWeekdays[3] = GUICtrlCreateLabel(GetTranslated(603, 22, -1), $x + 80, $y)
_GUICtrlSetTip(-1, GetTranslated(603, 23, -1))
$g_hLblNotifyWeekdays[4] = GUICtrlCreateLabel(GetTranslated(603, 24, -1), $x + 99, $y)
_GUICtrlSetTip(-1, GetTranslated(603, 25, -1))
$g_hLblNotifyWeekdays[5] = GUICtrlCreateLabel(GetTranslated(603, 26, -1), $x + 116, $y)
_GUICtrlSetTip(-1, GetTranslated(603, 27, -1))
$g_hLblNotifyWeekdays[6] = GUICtrlCreateLabel(GetTranslated(603, 28, -1), $x + 133, $y)
_GUICtrlSetTip(-1, GetTranslated(603, 29, -1))
$g_ahLblNotifyWeekdaysE = GUICtrlCreateLabel("X", $x + 155, $y+1, -1, 15)
_GUICtrlSetTip(-1, GetTranslated(603, 2, -1))
$y += 13
$g_hChkNotifyWeekdays[0] = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyWeekdays[1] = GUICtrlCreateCheckbox("", $x + 47, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyWeekdays[2] = GUICtrlCreateCheckbox("", $x + 64, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyWeekdays[3] = GUICtrlCreateCheckbox("", $x + 81, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyWeekdays[4] = GUICtrlCreateCheckbox("", $x + 99, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyWeekdays[5] = GUICtrlCreateCheckbox("", $x + 117, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_hChkNotifyWeekdays[6] = GUICtrlCreateCheckbox("", $x + 133, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$g_ahChkNotifyWeekdaysE = GUICtrlCreateCheckbox("", $x + 151, $y + 1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(603, 2, -1))
GUICtrlSetOnEvent(-1, "ChkNotifyWeekdaysE")
EndFunc
Global $g_hGUI_VILLAGE_TAB = 0, $g_hGUI_VILLAGE_TAB_ITEM1 = 0, $g_hGUI_VILLAGE_TAB_ITEM2 = 0, $g_hGUI_VILLAGE_TAB_ITEM3 = 0, $g_hGUI_VILLAGE_TAB_ITEM4 = 0, $g_hGUI_VILLAGE_TAB_ITEM5 = 0
Func CreateVillageTab()
$g_hGUI_VILLAGE = GUICreate("", $_GUI_MAIN_WIDTH - 20, $_GUI_MAIN_HEIGHT - 255, $_GUI_CHILD_LEFT, $_GUI_CHILD_TOP, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hFrmBotEx)
CreateVillageDonate()
CreateVillageUpgrade()
CreateVillageNotify()
GUISwitch($g_hGUI_VILLAGE)
$g_hGUI_VILLAGE_TAB = GUICtrlCreateTab(0, 0, $_GUI_MAIN_WIDTH - 20, $_GUI_MAIN_HEIGHT - 255, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_VILLAGE_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslated(600,6,"Misc"))
CreateVillageMisc()
$g_hGUI_VILLAGE_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslated(600,7,"Req. && Donate"))
$g_hGUI_VILLAGE_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslated(600,8,"Upgrade"))
$g_hGUI_VILLAGE_TAB_ITEM4 = GUICtrlCreateTabItem(GetTranslated(600,9,"Achievements"))
CreateVillageAchievements()
$g_hGUI_VILLAGE_TAB_ITEM5 = GUICtrlCreateTabItem(GetTranslated(600,10,"Notify"))
GUICtrlCreateTabItem("")
EndFunc
Global $g_hGUI_ATTACK = 0
Global $g_hGUI_TRAINARMY = 0
Global $g_hGUI_TRAINARMY_TAB = 0, $g_hGUI_TRAINARMY_TAB_ITEM1 = 0, $g_hGUI_TRAINARMY_TAB_ITEM2 = 0, $g_hGUI_TRAINARMY_TAB_ITEM3 = 0, $g_hGUI_TRAINARMY_TAB_ITEM4 = 0
Global $g_hChkUseQuickTrain = 0, $g_hRdoArmy1 = 0, $g_hRdoArmy2 = 0, $g_hRdoArmy3 = 0
Global $g_ahTxtTrainArmyTroopCount[$eTroopCount] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Global $g_ahLblTrainArmyTroopLevel[$eTroopCount] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Global $g_ahTxtTrainArmySpellCount[$eSpellCount] = [0,0,0,0,0,0,0,0,0,0]
Global $g_ahLblTrainArmySpellLevel[$eSpellCount] = [0,0,0,0,0,0,0,0,0,0]
Global $g_hTxtFullTroop = 0, $g_hChkTotalCampForced = 0, $g_hTxtTotalCampForced = 0, $g_hChkForceBrewBeforeAttack = 0
Global $g_hGrpTrainTroops = 0, $g_hGrpCookSpell = 0
Global $g_ahPicTrainArmyTroop[$eTroopCount] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Global $g_ahPicTrainArmySpell[$eSpellCount] = [0,0,0,0,0,0,0,0,0,0]
Global $g_hLblTotalTimeCamp = 0, $g_hLblElixirCostCamp = 0, $g_hLblDarkCostCamp = 0, $g_hCalTotalTroops = 0, $g_hLblTotalProgress = 0, $g_hLblCountTotal = 0, $g_hTxtTotalCountSpell = 0, $g_hLblTotalTimeSpell = 0, $g_hLblElixirCostSpell = 0, $g_hLblDarkCostSpell = 0
Global $g_hCmbBoostBarracks = 0, $g_hCmbBoostSpellFactory = 0, $g_hCmbBoostBarbarianKing = 0, $g_hCmbBoostArcherQueen = 0, $g_hCmbBoostWarden = 0
Global $g_hChkBoostBarracksHours[24] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], $g_hChkBoostBarracksHoursE1 = 0, $g_hChkBoostBarracksHoursE2 = 0
Global Const $g_asTroopOrderList[] = [ "", GetTranslated(604,1, "Barbarians"), GetTranslated(604,2, "Archers"), GetTranslated(604,3, "Giants"), GetTranslated(604,4, "Goblins"), GetTranslated(604,5, "Wall Breakers"), GetTranslated(604,7, "Balloons"), GetTranslated(604,8, "Wizards"), GetTranslated(604,9, "Healers"), GetTranslated(604,10, "Dragons"), GetTranslated(604,11, "Pekkas"), GetTranslated(604,20, "Baby Dragons"), GetTranslated(604,21, "Miners"), GetTranslated(604,13, "Minions"), GetTranslated(604,14, "Hog Riders"), GetTranslated(604,15, "Valkyries"), GetTranslated(604,16, "Golems"), GetTranslated(604,17, "Witches"), GetTranslated(604,18, "Lava Hounds"), GetTranslated(604, 19, "Bowlers") ]
Global $g_hChkCustomTrainOrderEnable = 0
Global $g_ahCmbTroopOrder[$eTroopCount] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Global $g_ahImgTroopOrder[$eTroopCount] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Global $g_hBtnTroopOrderSet = 0, $g_ahImgTroopOrderSet = 0
Global $g_hChkCloseWhileTraining = 0, $g_hChkCloseWithoutShield = 0, $g_hChkCloseEmulator = 0, $g_hChkRandomClose = 0, $g_hRdoCloseWaitExact = 0, $g_hRdoCloseWaitRandom = 0
Global $g_hCmbCloseWaitRdmPercent = 0, $g_hCmbMinimumTimeClose = 0, $g_hSldTrainITDelay = 0, $g_hChkTrainAddRandomDelayEnable = 0, $g_hTxtAddRandomDelayMin = 0, $g_hTxtAddRandomDelayMax = 0
Global $g_hLblCloseWaitRdmPercent = 0, $g_hLblCloseWaitingTroops = 0, $g_hLblSymbolWaiting = 0, $g_hLblWaitingInMinutes = 0, $g_hLblTrainITDelay = 0, $g_hLblTrainITDelayTime = 0, $g_hLblAddDelayIdlePhaseBetween = 0, $g_hLblAddDelayIdlePhaseSec = 0, $g_hPicCloseWaitTrain = 0, $g_hPicCloseWaitStop = 0, $g_hPicCloseWaitExact = 0
Func CreateAttackTroops()
$g_hGUI_TRAINARMY = GUICreate("", $_GUI_MAIN_WIDTH - 28, $_GUI_MAIN_HEIGHT - 255 - 28, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_ATTACK)
$g_hGUI_TRAINARMY_TAB = GUICtrlCreateTab(0, 0, $_GUI_MAIN_WIDTH - 30, $_GUI_MAIN_HEIGHT - 255 - 30, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
CreateTroopsSpellsSubTab()
CreateBoostSubTab()
CreateTrainOrderSubTab()
CreateOptionsSubTab()
EndFunc
Func CreateTroopsSpellsSubTab()
$g_hGUI_TRAINARMY_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslated(600, 52, "Troops/Spells"))
Local $sTxtSetPerc = GetTranslated(621, 26, "Enter the No. of")
Local $sTxtSetPerc2 = GetTranslated(621, 27, " to make.")
Local $sTxtSetPerc3 = GetTranslated(621, 28, "Enter the No. of")
Local $sTxtSetSpell = GetTranslated(621, 29, "Spells to make.")
Local $x = 0
Local $y = 8
$g_hChkUseQuickTrain = GUICtrlCreateCheckbox(GetTranslated(621, 34, "Use Quick Train"), $x + 15, $y + 19, -1, 15)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "chkUseQTrain")
$g_hRdoArmy1 = GUICtrlCreateRadio(GetTranslated(621, 37, "Army 1"), $x + 120, $y + 20, 50, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hRdoArmy2 = GUICtrlCreateRadio(GetTranslated(621, 38, "Army 2"), $x + 180, $y + 20, 50, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hRdoArmy3 = GUICtrlCreateRadio(GetTranslated(621, 39, "Army 3"), $x + 240, $y + 20, 50, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel(GetTranslated(621, 41, "Remove Army"), $x + 335, $y + 20, -1, 15, $SS_LEFT)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnResetButton, $x + 405, $y + 17, 24, 24)
GUICtrlSetOnEvent(-1, "Removecamp")
$x = 10
$y = 45
$g_hGrpTrainTroops = GUICtrlCreateGroup(GetTranslated(1000, 1, "Train Troops"), $x, $y, 418, 195)
$x = 30
$y += 20
Local $sTroopName = GetTranslated(604,1, "Barbarians")
$g_ahPicTrainArmyTroop[$eTroopBarbarian] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnBarbarian, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslated(603,39, "Level") & " " & $sTroopName & ":" & @CRLF & GetTranslated(621,40, "Mouse Left Click to Up level" & @CRLF & "Shift + Mouse Left Click to Down level"))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopBarbarian] = GUICtrlCreateLabel("1", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopBarbarian] = GUICtrlCreateInput("58", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 38
Local $sTroopName = GetTranslated(604,3, "Giants")
$g_ahPicTrainArmyTroop[$eTroopGiant] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnGiant, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslated(603,39, -1) & " " & $sTroopName & ":" & @CRLF & GetTranslated(621,40, -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopGiant] = GUICtrlCreateLabel("1", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopGiant] = GUICtrlCreateInput("4", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 38
Local $sTroopName = GetTranslated(604,5, "Wall Breakers")
$g_ahPicTrainArmyTroop[$eTroopWallBreaker] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnWallBreaker, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslated(603,39, -1) & " " & $sTroopName & ":" & @CRLF & GetTranslated(621,40, -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopWallBreaker] = GUICtrlCreateLabel("1", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopWallBreaker] = GUICtrlCreateInput("4", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 38
Local $sTroopName = GetTranslated(604,8, "Wizards")
$g_ahPicTrainArmyTroop[$eTroopWizard] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnWizard, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslated(603,39, -1) & " " & $sTroopName & ":" & @CRLF & GetTranslated(621,40, -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopWizard] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopWizard] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 38
Local $sTroopName = GetTranslated(604,10, "Dragons")
$g_ahPicTrainArmyTroop[$eTroopDragon] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDragon, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslated(603,39, -1) & " " & $sTroopName & ":" & @CRLF & GetTranslated(621,40, -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopDragon] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopDragon] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 38
Local $sTroopName = GetTranslated(604,20, "Baby Dragons")
$g_ahPicTrainArmyTroop[$eTroopBabyDragon] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnBabyDragon, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslated(603,39, -1) & " " & $sTroopName & ":" & @CRLF & GetTranslated(621,40, -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopBabyDragon] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopBabyDragon] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 45
Local $sTroopName = GetTranslated(604,13, "Minions")
$g_ahPicTrainArmyTroop[$eTroopMinion] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnMinion, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslated(603,39, -1) & " " & $sTroopName & ":" & @CRLF & GetTranslated(621,40, -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopMinion] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopMinion] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 38
Local $sTroopName = GetTranslated(604,15, "Valkyries")
$g_ahPicTrainArmyTroop[$eTroopValkyrie] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnValkyrie, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslated(603,39, -1) & " " & $sTroopName & ":" & @CRLF & GetTranslated(621,40, -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopValkyrie] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopValkyrie] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 38
Local $sTroopName = GetTranslated(604,17, "Witches")
$g_ahPicTrainArmyTroop[$eTroopWitch] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnWitch, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslated(603,39, -1) & " " & $sTroopName & ":" & @CRLF & GetTranslated(621,40, -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopWitch] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopWitch] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 38
Local $sTroopName = GetTranslated(604, 19, "Bowlers")
$g_ahPicTrainArmyTroop[$eTroopBowler] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnBowler, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslated(603,39, -1) & " " & $sTroopName & ":" & @CRLF & GetTranslated(621,40, -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopBowler] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopBowler] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x = 30
$y += 60
Local $sTroopName = GetTranslated(604,2, "Archers")
$g_ahPicTrainArmyTroop[$eTroopArcher] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnArcher, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslated(603,39, -1) & " " & $sTroopName & ":" & @CRLF & GetTranslated(621,40, -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopArcher] = GUICtrlCreateLabel("1", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopArcher] = GUICtrlCreateInput("115", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 38
Local $sTroopName = GetTranslated(604,4, "Goblins")
$g_ahPicTrainArmyTroop[$eTroopGoblin] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnGoblin, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslated(603,39, -1) & " " & $sTroopName & ":" & @CRLF & GetTranslated(621,40, -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopGoblin] = GUICtrlCreateLabel("1", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopGoblin] = GUICtrlCreateInput("19", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 38
Local $sTroopName = GetTranslated(604,7, "Balloons")
$g_ahPicTrainArmyTroop[$eTroopBalloon] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnBalloon, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslated(603,39, -1) & " " & $sTroopName & ":" & @CRLF & GetTranslated(621,40, -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopBalloon] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopBalloon] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 38
Local $sTroopName = GetTranslated(604,9, "Healers")
$g_ahPicTrainArmyTroop[$eTroopHealer] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnHealer, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslated(603,39, -1) & " " & $sTroopName & ":" & @CRLF & GetTranslated(621,40, -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopHealer] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopHealer] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 38
Local $sTroopName = GetTranslated(604,11, "Pekkas")
$g_ahPicTrainArmyTroop[$eTroopPekka] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnPekka, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslated(603,39, -1) & " " & $sTroopName & ":" & @CRLF & GetTranslated(621,40, -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopPekka] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopPekka] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 38
Local $sTroopName = GetTranslated(604,21, "Miners")
$g_ahPicTrainArmyTroop[$eTroopMiner] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnMiner, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslated(603,39, -1) & " " & $sTroopName & ":" & @CRLF & GetTranslated(621,40, -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopMiner] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopMiner] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 45
Local $sTroopName = GetTranslated(604,14, "Hog Riders")
$g_ahPicTrainArmyTroop[$eTroopHogRider] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnHogRider, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslated(603,39, -1) & " " & $sTroopName & ":" & @CRLF & GetTranslated(621,40, -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopHogRider] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopHogRider] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 38
Local $sTroopName = GetTranslated(604,16, "Golems")
$g_ahPicTrainArmyTroop[$eTroopGolem] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnGolem, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslated(603,39, -1) & " " & $sTroopName & ":" & @CRLF & GetTranslated(621,40, -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopGolem] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopGolem] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x += 38
Local $sTroopName = GetTranslated(604,18, "Lava Hounds")
$g_ahPicTrainArmyTroop[$eTroopLavaHound] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnLavaHound, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, GetTranslated(603,39, -1) & " " & $sTroopName & ":" & @CRLF & GetTranslated(621,40, -1))
GUICtrlSetOnEvent(-1, "TrainTroopLevelClick")
$g_ahLblTrainArmyTroopLevel[$eTroopLavaHound] = GUICtrlCreateLabel("0", $x + 2, $y + 14, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmyTroopCount[$eTroopLavaHound] = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTroopName & " " & $sTxtSetPerc2)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainTroopCountEdit")
$x = 30
$y += 66
GUICtrlCreateIcon($g_sLibIconPath, $eIcnCamp, $x - 10, $y - 15, 24, 24)
GUICtrlCreateLabel(GetTranslated(621, 20, "'Full' Camps"), $x + 16, $y - 7, 55, 17)
GUICtrlCreateLabel(ChrW(8805), $x + 75, $y - 7, -1, 17)
$g_hTxtFullTroop = GUICtrlCreateInput("100", $x + 84, $y - 10, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetOnEvent(-1, "SetComboTroopComp")
_GUICtrlSetTip(-1, GetTranslated(621, 21, "Army camps are 'Full' when reaching this %, then start attack."))
GUICtrlSetLimit(-1, 3)
GUICtrlCreateLabel("%", $x + 115, $y - 7, -1, 17)
$x += 180
$Y -= 23
GUICtrlCreateIcon($g_sLibIconPath, $eIcnTroopsCost, $x - 33, $y + 10, 24, 24)
$g_hLblTotalTimeCamp = GUICtrlCreateLabel(" 0s", $x - 11, $y + 15, 70, 15, $SS_RIGHT)
GUICtrlSetBkColor(-1, $COLOR_GRAY)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_WHITE)
$g_hLblElixirCostCamp = GUICtrlCreateLabel(" 0", $x + 65, $y + 15, 77, 15, $SS_RIGHT)
GUICtrlSetBkColor(-1, $COLOR_GRAY)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 63, $y + 14, 16, 16)
$g_hLblDarkCostCamp = GUICtrlCreateLabel(" 0", $x + 148, $y + 15, 62, 15, $SS_RIGHT)
GUICtrlSetBkColor(-1, $COLOR_GRAY)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 146, $y + 14, 16, 16)
$x -= 195
$Y += 35
$g_hChkTotalCampForced = GUICtrlCreateCheckbox(GetTranslated(636, 46, "Force Total Army Camp") & ":", $x + 3, $y, -1, -1)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkTotalCampForced")
_GUICtrlSetTip(-1, GetTranslated(636, 47, "If not detected set army camp values (instead ask)"))
$g_hTxtTotalCampForced = GUICtrlCreateInput("220", $x + 137, $y + 3, 30, 17, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetOnEvent(-1, "SetComboTroopComp")
GUICtrlSetLimit(-1, 3)
$g_hCalTotalTroops = GUICtrlCreateProgress($x, $y + 22, 407, 10)
$g_hLblTotalProgress = GUICtrlCreateLabel("", $x, $y + 22, 407, 10)
GUICtrlSetBkColor(-1, $COLOR_RED)
GUICtrlSetState(-1, BitOR($GUI_DISABLE, $GUI_HIDE))
$x += 38
GUICtrlCreateLabel(GetTranslated(621, 15, "Total"), $x + 295, $y + 7, -1, -1, $SS_RIGHT)
$g_hLblCountTotal = GUICtrlCreateLabel(0, $x + 330, $y + 5, 30, 15, $SS_CENTER)
_GUICtrlSetTip(-1, GetTranslated(621, 16, "The total Units of Troops should equal Total Army Camps."))
GUICtrlSetBkColor(-1, $COLOR_MONEYGREEN)
GUICtrlCreateLabel("x", $x + 364, $y + 7, -1, -1)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 10
$y = 240
$g_hGrpCookSpell = GUICtrlCreateGroup(GetTranslated(1000, 2, "Brew Spells"), $x, $y, 418, 123)
$x += 20
$y += 17
GUICtrlCreateLabel(GetTranslated(622, 2, "Spell Capacity") & " :", $x - 15, $y, -1, -1, $SS_RIGHT)
$g_hTxtTotalCountSpell = GUICtrlCreateCombo("", $x + 80, $y - 3, 35, 21, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslated(622, 3, "Enter the No. of Spells Capacity. Set to ZERO if you don't want any Spells"))
GUICtrlSetData(-1, "0|2|4|6|7|8|9|10|11", "0")
GUICtrlSetOnEvent(-1, "TotalSpellCountClick")
$y += 13
Local $sSpellName = GetTranslated(605,1, "Lightning Spell")
$g_ahPicTrainArmySpell[$eSpellLightning] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnLightSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, GetTranslated(603,39, -1) & " " & $sSpellName & ":" & @CRLF & GetTranslated(621,40, -1))
GUICtrlSetOnEvent(-1, "TrainSpellLevelClick")
$g_ahLblTrainArmySpellLevel[$eSpellLightning] = GUICtrlCreateLabel("0", $x + 2, $y + 29, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmySpellCount[$eSpellLightning] = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sSpellName & " " & $sTxtSetSpell)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainSpellCountEdit")
$x += 38
Local $sSpellName = GetTranslated(605,2, "Healing Spell")
$g_ahPicTrainArmySpell[$eSpellHeal] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnHealSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, GetTranslated(603,39, -1) & " " & $sSpellName & ":" & @CRLF & GetTranslated(621,40, -1))
GUICtrlSetOnEvent(-1, "TrainSpellLevelClick")
$g_ahLblTrainArmySpellLevel[$eSpellHeal] = GUICtrlCreateLabel("0", $x + 2, $y + 29, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmySpellCount[$eSpellHeal] = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sSpellName & " " & $sTxtSetSpell)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainSpellCountEdit")
$x += 38
Local $sSpellName = GetTranslated(605,3, "Rage Spell")
$g_ahPicTrainArmySpell[$eSpellRage] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnRageSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, GetTranslated(603,39, -1) & " " & $sSpellName & ":" & @CRLF & GetTranslated(621,40, -1))
GUICtrlSetOnEvent(-1, "TrainSpellLevelClick")
$g_ahLblTrainArmySpellLevel[$eSpellRage] = GUICtrlCreateLabel("0", $x + 2, $y + 29, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmySpellCount[$eSpellRage] = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sSpellName & " " & $sTxtSetSpell)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainSpellCountEdit")
$x += 38
Local $sSpellName = GetTranslated(605,4, "Jump Spell")
$g_ahPicTrainArmySpell[$eSpellJump] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnJumpSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, GetTranslated(603,39, -1) & " " & $sSpellName & ":" & @CRLF & GetTranslated(621,40, -1))
GUICtrlSetOnEvent(-1, "TrainSpellLevelClick")
$g_ahLblTrainArmySpellLevel[$eSpellJump] = GUICtrlCreateLabel("0", $x + 2, $y + 29, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmySpellCount[$eSpellJump] = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sSpellName & " " & $sTxtSetSpell)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainSpellCountEdit")
$x += 38
Local $sSpellName = GetTranslated(605,5, "Freeze Spell")
$g_ahPicTrainArmySpell[$eSpellFreeze] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnFreezeSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, GetTranslated(603,39, -1) & " " & $sSpellName & ":" & @CRLF & GetTranslated(621,40, -1))
GUICtrlSetOnEvent(-1, "TrainSpellLevelClick")
$g_ahLblTrainArmySpellLevel[$eSpellFreeze] = GUICtrlCreateLabel("0", $x + 2, $y + 29, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmySpellCount[$eSpellFreeze] = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sSpellName & " " & $sTxtSetSpell)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainSpellCountEdit")
$x += 38
Local $sSpellName = GetTranslated(605,12, "Clone Spell")
$g_ahPicTrainArmySpell[$eSpellClone] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnCloneSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, GetTranslated(603,39, -1) & " " & $sSpellName & ":" & @CRLF & GetTranslated(621,40, -1))
GUICtrlSetOnEvent(-1, "TrainSpellLevelClick")
$g_ahLblTrainArmySpellLevel[$eSpellClone] = GUICtrlCreateLabel("0", $x + 2, $y + 29, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmySpellCount[$eSpellClone] = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sSpellName & " " & $sTxtSetSpell)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainSpellCountEdit")
$x += 45
Local $sSpellName = GetTranslated(605,6, "Poison Spell")
$g_ahPicTrainArmySpell[$eSpellPoison] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnPoisonSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, GetTranslated(603,39, -1) & " " & $sSpellName & ":" & @CRLF & GetTranslated(621,40, -1))
GUICtrlSetOnEvent(-1, "TrainSpellLevelClick")
$g_ahLblTrainArmySpellLevel[$eSpellPoison] = GUICtrlCreateLabel("0", $x + 2, $y + 29, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmySpellCount[$eSpellPoison] = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sSpellName & " " & $sTxtSetSpell)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainSpellCountEdit")
$x += 38
Local $sSpellName = GetTranslated(605,7, "EarthQuake Spell")
$g_ahPicTrainArmySpell[$eSpellEarthquake] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnEarthquakeSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, GetTranslated(603,39, -1) & " " & $sSpellName & ":" & @CRLF & GetTranslated(621,40, -1))
GUICtrlSetOnEvent(-1, "TrainSpellLevelClick")
$g_ahLblTrainArmySpellLevel[$eSpellEarthquake] = GUICtrlCreateLabel("0", $x + 2, $y + 29, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmySpellCount[$eSpellEarthquake] = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sSpellName & " " & $sTxtSetSpell)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainSpellCountEdit")
$x += 38
Local $sSpellName = GetTranslated(605,8, "Haste Spell")
$g_ahPicTrainArmySpell[$eSpellHaste] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnHasteSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, GetTranslated(603,39, -1) & " " & $sSpellName & ":" & @CRLF & GetTranslated(621,40, -1))
GUICtrlSetOnEvent(-1, "TrainSpellLevelClick")
$g_ahLblTrainArmySpellLevel[$eSpellHaste] = GUICtrlCreateLabel("0", $x + 2, $y + 29, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmySpellCount[$eSpellHaste] = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sSpellName & " " & $sTxtSetSpell)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainSpellCountEdit")
$x += 38
Local $sSpellName = GetTranslated(605,13, "Skeleton Spell")
$g_ahPicTrainArmySpell[$eSpellSkeleton] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnSkeletonSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, GetTranslated(603,39, -1) & " " & $sSpellName & ":" & @CRLF & GetTranslated(621,40, -1))
GUICtrlSetOnEvent(-1, "TrainSpellLevelClick")
$g_ahLblTrainArmySpellLevel[$eSpellSkeleton] = GUICtrlCreateLabel("0", $x + 2, $y + 29, 6, 11)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetFont(-1, 7, 400)
$g_ahTxtTrainArmySpellCount[$eSpellSkeleton] = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sSpellName & " " & $sTxtSetSpell)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "TrainSpellCountEdit")
$y += 56
$x = 17
$g_hChkForceBrewBeforeAttack = GUICtrlCreateCheckbox(GetTranslated(621, 42, "Force Brew Spells"), $x, $y + 12, -1, -1)
GUICtrlSetState(-1, $GUI_UNCHECKED)
$x = 210
GUICtrlCreateIcon($g_sLibIconPath, $eIcnSpellsCost, $x - 33, $y + 10, 24, 24)
$g_hLblTotalTimeSpell = GUICtrlCreateLabel(" 0s", $x - 11, $y + 15, 70, 15, $SS_RIGHT)
GUICtrlSetBkColor(-1, $COLOR_GRAY)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_WHITE)
$g_hLblElixirCostSpell = GUICtrlCreateLabel(" 0", $x + 65, $y + 15, 77, 15, $SS_RIGHT)
GUICtrlSetBkColor(-1, $COLOR_GRAY)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 63, $y + 14, 16, 16)
$g_hLblDarkCostSpell = GUICtrlCreateLabel(" 0", $x + 148, $y + 15, 62, 15, $SS_RIGHT)
GUICtrlSetBkColor(-1, $COLOR_GRAY)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_WHITE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 146, $y + 14, 16, 16)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateBoostSubTab()
Local $sTextBoostLeft = GetTranslated(623, 1, "Boosts left")
Local $sTxtTip = ""
$g_hGUI_TRAINARMY_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslated(600, 22, "Boost"))
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslated(623, 2, "Boost Barracks"), $x - 20, $y - 20, 430, 60)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnBarrackBoost, $x - 10, $y + 5, 24, 24)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDarkBarrackBoost, $x + 19, $y + 5, 24, 24)
GUICtrlCreateLabel(GetTranslated(623, 5, "Barracks") & " " & $sTextBoostLeft, $x + 20 + 29, $y + 4 + 7, -1, -1)
$sTxtTip = GetTranslated(623, 6, "Use this to boost your Barracks with GEMS! Use with caution!")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbBoostBarracks = GUICtrlCreateCombo("", $x + 140 + 45, $y + 7, 40, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "0|1|2|3|4|5|6|7|8|9|10|11|12", "0")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 65
GUICtrlCreateGroup(GetTranslated(623, 7, "Boost Spell Factories"), $x - 20, $y - 20, 430, 50)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnSpellFactoryBoost, $x - 10, $y - 2, 24, 24)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDarkSpellBoost, $x + 19, $y - 2, 24, 24)
GUICtrlCreateLabel(GetTranslated(623, 8, "Spell Factory") & " " & $sTextBoostLeft, $x + 20 + 29, $y + 4, -1, -1)
$sTxtTip = GetTranslated(623, 9, "Use this to boost your Spell Factory with GEMS! Use with caution!")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbBoostSpellFactory = GUICtrlCreateCombo("", $x + 185, $y, 40, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "0|1|2|3|4|5|6|7|8|9|10|11|12", "0")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 55
GUICtrlCreateGroup(GetTranslated(623, 12, "Boost Heroes"), $x - 20, $y - 20, 430, 95)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnKingBoost, $x - 10, $y - 2, 24, 24)
GUICtrlCreateLabel(GetTranslated(623, 13, "Barbarian King") & " " & $sTextBoostLeft, $x + 20, $y + 4, -1, -1)
$sTxtTip = GetTranslated(623, 14, "Use this to boost your Barbarian King with GEMS! Use with caution!")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbBoostBarbarianKing = GUICtrlCreateCombo("", $x + 185, $y, 40, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "0|1|2|3|4|5|6|7|8|9|10|11|12", "0")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkUpgradeKing")
$y += 25
GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueenBoost, $x - 10, $y - 2, 24, 24)
GUICtrlCreateLabel(GetTranslated(623, 15, "Archer Queen") & " " & $sTextBoostLeft, $x + 20, $y + 4, -1, -1)
$sTxtTip = GetTranslated(623, 16, "Use this to boost your Archer Queen with GEMS! Use with caution!")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbBoostArcherQueen = GUICtrlCreateCombo("", $x + 185, $y, 40, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "0|1|2|3|4|5|6|7|8|9|10|11|12", "0")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkUpgradeQueen")
$y += 25
GUICtrlCreateIcon($g_sLibIconPath, $eIcnWardenBoost, $x - 10, $y - 2, 24, 24)
GUICtrlCreateLabel(GetTranslated(623, 17, "Grand Warden") & " " & $sTextBoostLeft, $x + 20, $y + 4, -1, -1)
$sTxtTip = GetTranslated(623, 18, "Use this to boost your Grand Warden with GEMS! Use with caution!")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbBoostWarden = GUICtrlCreateCombo("", $x + 185, $y, 40, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "0|1|2|3|4|5|6|7|8|9|10|11|12", "0")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkUpgradeWarden")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 50
GUICtrlCreateGroup(GetTranslated(623, 19, "Boost Schedule"), $x - 20, $y - 20, 430, 70)
GUICtrlCreateLabel(" 0", $x + 30, $y)
GUICtrlCreateLabel(" 1", $x + 45, $y)
GUICtrlCreateLabel(" 2", $x + 60, $y)
GUICtrlCreateLabel(" 3", $x + 75, $y)
GUICtrlCreateLabel(" 4", $x + 90, $y)
GUICtrlCreateLabel(" 5", $x + 105, $y)
GUICtrlCreateLabel(" 6", $x + 120, $y)
GUICtrlCreateLabel(" 7", $x + 135, $y)
GUICtrlCreateLabel(" 8", $x + 150, $y)
GUICtrlCreateLabel(" 9", $x + 165, $y)
GUICtrlCreateLabel("10", $x + 180, $y)
GUICtrlCreateLabel("11", $x + 195, $y)
GUICtrlCreateLabel("X", $x + 213, $y + 2, 11, 11)
$y += 15
$g_hChkBoostBarracksHours[0] = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[1] = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[2] = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[3] = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[4] = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[5] = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[6] = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[7] = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[8] = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[9] = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[10] = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[11] = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHoursE1 = GUICtrlCreateCheckbox("", $x + 211, $y + 1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, GetTranslated(603, 2, "This button will clear or set the entire row of boxes"))
GUICtrlSetOnEvent(-1, "chkBoostBarracksHoursE1")
GUICtrlCreateLabel(GetTranslated(603, 3, "AM"), $x + 5, $y)
$y += 15
$g_hChkBoostBarracksHours[12] = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[13] = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[14] = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[15] = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[16] = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[17] = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[18] = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[19] = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[20] = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[21] = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[22] = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHours[23] = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hChkBoostBarracksHoursE2 = GUICtrlCreateCheckbox("", $x + 211, $y + 1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, GetTranslated(603, 2, -1))
GUICtrlSetOnEvent(-1, "chkBoostBarracksHoursE2")
GUICtrlCreateLabel(GetTranslated(603, 4, "PM"), $x + 5, $y)
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlCreateTabItem("")
EndFunc
Func CreateTrainOrderSubTab()
$g_hGUI_TRAINARMY_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslated(600, 54, "Train Order"))
SetDefaultTroopGroup(False)
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslated(641, 25, "Training Order"), $x - 20, $y - 20, 271, 335)
$g_hChkCustomTrainOrderEnable = GUICtrlCreateCheckbox(GetTranslated(641, 26, "Custom Order"), $x - 5, $y, -1, -1)
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, GetTranslated(641, 27, "Enable to select a custom troop training order") & @CRLF & GetTranslated(641, 28, "Changing train order can be useful with CSV scripted attack armies!"))
GUICtrlSetOnEvent(-1, "chkTroopOrder2")
If UBound($g_asTroopOrderList) - 1 <> $eTroopCount Then
If $g_iDebugSetlogTrain = 1 Then Setlog("UBound($g_asTroopOrderList) - 1: " & UBound($g_asTroopOrderList) - 1 & " = " & "$eTroopCount: " & $eTroopCount, $COLOR_DEBUG)
Setlog("Monkey ate bad banana, fix $g_asTroopOrderList & $eTroopCount arrays!", $COLOR_RED)
EndIf
Local $sComboData = ""
For $j = 0 To UBound($g_asTroopOrderList) - 1
$sComboData &= $g_asTroopOrderList[$j] & "|"
Next
Local $txtTroopOrder = GetTranslated(641, 29, "Enter sequence order for training of troop #")
$y += 23
For $z = 0 To $eTroopCount - 1
If $z < 12 Then
GUICtrlCreateLabel($z + 1 & ":", $x - 16, $y + 2, -1, 18)
$g_ahCmbTroopOrder[$z] = GUICtrlCreateCombo("", $x, $y, 94, 18, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetOnEvent(-1, "GUITrainOrder")
GUICtrlSetData(-1, $sComboData, "")
_GUICtrlSetTip(-1, $txtTroopOrder & $z + 1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahImgTroopOrder[$z] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnOptions, $x + 96, $y + 1, 18, 18)
$y += 22
Else
If $z = 12 Then
$x += 128
$y = 45 + 23
EndIf
GUICtrlCreateLabel($z + 1 & ":", $x - 13, $y + 2, -1, 18)
$g_ahCmbTroopOrder[$z] = GUICtrlCreateCombo("", $x + 4, $y, 94, 18, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetOnEvent(-1, "GUITrainOrder")
GUICtrlSetData(-1, $sComboData, "")
_GUICtrlSetTip(-1, $txtTroopOrder & $z + 1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahImgTroopOrder[$z] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnOptions, $x + 100, $y + 1, 18, 18)
$y += 22
EndIf
Next
$x = 25
$y = 45 + 291
$g_hBtnTroopOrderSet = GUICtrlCreateButton(GetTranslated(641, 30, "Apply New Order"), $x, $y, 222, 20)
GUICtrlSetState(-1, BitOR($GUI_UNCHECKED, $GUI_DISABLE))
_GUICtrlSetTip(-1, GetTranslated(641, 31, "Push button when finished selecting custom troop training order") & @CRLF & GetTranslated(641, 32, "Icon changes color based on status: Red= Not Set, Green = Order Set"))
GUICtrlSetOnEvent(-1, "btnTroopOrderSet")
$g_ahImgTroopOrderSet = GUICtrlCreateIcon($g_sLibIconPath, $eIcnSilverStar, $x + 226, $y + 2, 18, 18)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateOptionsSubTab()
$g_hGUI_TRAINARMY_TAB_ITEM4 = GUICtrlCreateTabItem(GetTranslated(641, 1, "Options"))
Local $sTxtTip = ""
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslated(641, 2, "Training Idle Time"), $x - 20, $y - 20, 151, 266)
$g_hChkCloseWhileTraining = GUICtrlCreateCheckbox(GetTranslated(641, 3, "Close While Training"), $x - 12, $y, 140, -1)
GUICtrlSetState(-1, $GUI_CHECKED)
_GUICtrlSetTip(-1, GetTranslated(641, 4, "Option will exit CoC game for time required to complete TROOP training when SHIELD IS ACTIVE") & @CRLF & GetTranslated(641, 5, "Close for Spell creation will be enabled when 'Wait for Spells' is selected on Search tabs") & @CRLF & GetTranslated(641, 6, "Close for Hero healing will be enabled when 'Wait for Heroes' is enabled on Search tabs"))
GUICtrlSetOnEvent(-1, "chkCloseWaitEnable")
$y += 28
$g_hChkCloseWithoutShield = GUICtrlCreateCheckbox(GetTranslated(641, 7, "Without Shield"), $x + 18, $y + 1, 110, -1)
$sTxtTip = GetTranslated(641, 8, "Option will ALWAYS close CoC for idle training time and when NO SHIELD IS ACTIVE!") & @CRLF & GetTranslated(641, 9, "Note - You can be attacked and lose trophies when this option is enabled!")
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkCloseWaitTrain")
$g_hPicCloseWaitTrain = GUICtrlCreateIcon($g_sLibIconPath, $eIcnNoShield, $x - 13, $y, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
$g_hChkCloseEmulator = GUICtrlCreateCheckbox(GetTranslated(641, 13, "Close Emulator"), $x + 18, $y + 1, 110, -1)
$sTxtTip = GetTranslated(641, 14, "Option will close Android Emulator completely when selected") & @CRLF & GetTranslated(641, 15, "Adding this option may increase offline time slightly due to variable times required for startup")
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "btnCloseWaitStop")
$g_hPicCloseWaitStop = GUICtrlCreateIcon($g_sLibIconPath, $eIcnRecycle, $x - 13, $y + 13, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
$g_hChkRandomClose = GUICtrlCreateCheckbox(GetTranslated(641, 10, "Random Close"), $x + 18, $y + 1, 110, -1)
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, GetTranslated(641, 11, "Option will Randomly choose between time out, close CoC, or Close emulator when selected") & @CRLF & GetTranslated(641, 15, "Adding this option may increase offline time slightly due to variable times required for startup"))
GUICtrlSetOnEvent(-1, "btnCloseWaitStopRandom")
$y += 28
$g_hRdoCloseWaitExact = GUICtrlCreateRadio(GetTranslated(641, 16, "Exact Time"), $x + 18, $y + 1, 110, -1)
_GUICtrlSetTip(-1, GetTranslated(641, 17, "Select to wait exact time required for troops to complete training"))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "btnCloseWaitRandom")
$g_hPicCloseWaitExact = GUICtrlCreateIcon($g_sLibIconPath, $eIcnHourGlass, $x - 13, $y + 13, 24, 24)
_GUICtrlSetTip(-1, GetTranslated(641, 18, "Select how much time to wait when feature enables"))
$y += 24
$g_hRdoCloseWaitRandom = GUICtrlCreateRadio(GetTranslated(641, 19, "Random Time"), $x + 18, $y + 1, 110, -1)
_GUICtrlSetTip(-1, GetTranslated(641, 20, "Select to ADD a random extra wait time like human who forgets to clash"))
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "btnCloseWaitRandom")
$y += 28
$g_hCmbCloseWaitRdmPercent = GUICtrlCreateCombo("", $x + 36, $y, 40, 18, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslated(641, 21, "Enter maximum percentage of additional time to be used creating random wait times,") & @CRLF & GetTranslated(641, 22, "Bot will compute a random wait time between exact time needed, and") & @CRLF & GetTranslated(641, 23, "maximum random percent entered to appear more human like")
GUICtrlSetData(-1, "1|2|3|4|5|6|7|8|9|10|11|12|13|14|15", "10")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblCloseWaitRdmPercent = GUICtrlCreateLabel("%", $x + 84, $y + 3, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
$g_hLblCloseWaitingTroops = GUICtrlCreateLabel(GetTranslated(641, 41, "Minimum Time To Close") & ": ", $x - 12, $y, -1, -1)
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, GetTranslated(641, 42, "Will be close CoC If train time troops >= (Minimum time required to close)" & @CRLF & "Just stay in the main screen if train time troops < (Minimum time required to close)"))
GUICtrlSetOnEvent(-1, "chkCloseWaitEnable")
$y += 22
$g_hLblSymbolWaiting = GUICtrlCreateLabel(">", $x + 26, $y + 3, -1, -1)
$sTxtTip = GetTranslated(641, 43, "Enter number Minimum time to close in minutes for close CoC which you want, Default Is (2)")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbMinimumTimeClose = GUICtrlCreateCombo("", $x + 36, $y, 40, 18, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "2|3|4|5|6|7|8|9|10", "2")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblWaitingInMinutes = GUICtrlCreateLabel(GetTranslated(603, 10, -1), $x + 84, $y + 3, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 53
GUICtrlCreateGroup(GetTranslated(636, 30, "Train Click Timing"), $x - 20, $y - 20, 151, 60)
$g_hLblTrainITDelay = GUICtrlCreateLabel(GetTranslated(636, 32, "delay"), $x - 10, $y, 37, 30)
$sTxtTip = GetTranslated(636, 33, "Increase the delay if your PC is slow or to create human like training click speed")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTrainITDelayTime = GUICtrlCreateLabel("40 ms", $x - 10, $y + 15, 37, 30)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hSldTrainITDelay = GUICtrlCreateSlider($x + 30, $y, 90, 25, BitOR($TBS_TOOLTIPS, $TBS_AUTOTICKS))
_GUICtrlSetTip(-1, GetTranslated(636, 33, -1))
_GUICtrlSlider_SetTipSide(-1, $TBTS_BOTTOM)
_GUICtrlSlider_SetTicFreq(-100, 100)
GUICtrlSetLimit(-1, 500, 1)
GUICtrlSetData(-1, 40)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetOnEvent(-1, "sldTrainITDelay")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25 + 151 + 5
$y = 45
GUICtrlCreateGroup(GetTranslated(641,35, "Training Add Random Delay"), $x - 20, $y - 20, 173, 81)
$y += 15
$g_hChkTrainAddRandomDelayEnable = GUICtrlCreateCheckbox(GetTranslated(641, 36, "Add Random Delay"),$x + 18, $y - 11, 130, -1)
$sTxtTip = GetTranslated(641, 37, "Add random delay between two calls of train army.")& @CRLF & GetTranslated(641, 38, "This option reduces the calls to the training window  humanizing the bot spacing calls each time with a causal interval chosen between the minimum and maximum values indicated below.")
GUICtrlSetState(-1, $GUI_CHECKED)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkAddDelayIdlePhaseEnable")
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDelay, $x - 13, $y - 13, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 18
$y += 18
$g_hLblAddDelayIdlePhaseBetween = GUICtrlCreateLabel(GetTranslated(641, 39, "Between"), $x-12, $y, 50, 30)
$g_hTxtAddRandomDelayMin = GUICtrlCreateInput($g_iTrainAddRandomDelayMin, $x + 32, $y-2, 25, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 999)
GUICtrlCreateLabel(GetTranslated(641, 40, "And"), $x+61, $y, 20, 30)
$g_hTxtAddRandomDelayMax = GUICtrlCreateInput($g_iTrainAddRandomDelayMax, $x + 82, $y-2, 25, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 999)
$g_hLblAddDelayIdlePhaseSec = GUICtrlCreateLabel(GetTranslated(603, 6, "sec."), $x+110, $y, 20, 30)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_SEARCH = 0
Global $g_ahChkMaxMortar[$g_iModeCount] = [0,0,0], $g_ahChkMaxWizTower[$g_iModeCount] = [0,0,0], $g_ahChkMaxAirDefense[$g_iModeCount] = [0,0,0], $g_ahChkMaxXBow[$g_iModeCount] = [0,0,0], $g_ahChkMaxInferno[$g_iModeCount] = [0,0,0], $g_ahChkMaxEagle[$g_iModeCount] = [0,0,0]
Global $g_ahCmbWeakMortar[$g_iModeCount] = [0,0,0], $g_ahCmbWeakWizTower[$g_iModeCount] = [0,0,0], $g_ahCmbWeakAirDefense[$g_iModeCount] = [0,0,0], $g_ahCmbWeakXBow[$g_iModeCount] = [0,0,0], $g_ahCmbWeakInferno[$g_iModeCount] = [0,0,0], $g_ahCmbWeakEagle[$g_iModeCount] = [0,0,0]
Global $g_ahPicWeakMortar[$g_iModeCount] = [0,0,0], $g_ahPicWeakWizTower[$g_iModeCount] = [0,0,0], $g_ahPicWeakAirDefense[$g_iModeCount] = [0,0,0], $g_ahPicWeakXBow[$g_iModeCount] = [0,0,0], $g_ahPicWeakInferno[$g_iModeCount] = [0,0,0], $g_ahPicWeakEagle[$g_iModeCount] = [0,0,0]
Global $g_ahChkMeetOne[$g_iModeCount] = [0,0,0]
Global $g_hGUI_DEADBASE = 0
Global $g_hGUI_DEADBASE_ATTACK_STANDARD = 0
Global $g_hCmbStandardDropOrderDB = 0, $g_hCmbStandardDropSidesDB = 0, $g_hCmbStandardUnitDelayDB = 0, $g_hCmbStandardWaveDelayDB = 0, $g_hChkRandomSpeedAtkDB = 0, $g_hChkSmartAttackRedAreaDB = 0, $g_hCmbSmartDeployDB = 0, $g_hChkAttackNearGoldMineDB = 0, $g_hChkAttackNearElixirCollectorDB = 0, $g_hChkAttackNearDarkElixirDrillDB = 0
Global $g_hLblSmartDeployDB = 0, $g_hPicAttackNearDarkElixirDrillDB = 0
Func CreateAttackSearchDeadBaseStandard()
$g_hGUI_DEADBASE_ATTACK_STANDARD = GUICreate("", $_GUI_MAIN_WIDTH - 195, $_GUI_MAIN_HEIGHT - 344, 150, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_DEADBASE)
Local $sTxtTip
Local $x = 25, $y = 20
GUICtrlCreateGroup(GetTranslated(608,1,"Deploy"), $x - 20, $y - 20, 270, 306)
GUICtrlCreateLabel(GetTranslated(608,2,"Troop Drop Order"),$x, $y, 143,18,$SS_LEFT)
$y += 15
$g_hCmbStandardDropOrderDB = GUICtrlCreateCombo("", $x, $y, 150, Default, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslated(608,25,"Default(All Troops)")&"|Barch/BAM/BAG|GiBarch", GetTranslated(608,25, -1))
_GUICtrlSetTip(-1, GetTranslated(608,33,"Select a preset troop drop order.") & @CRLF & GetTranslated(608,34,"Each option deploys troops in a different order and in different waves") & @CRLF & GetTranslated(608,35,"Only the troops selected in the ""Only drop these troops"" option will be dropped"))
$y += 25
GUICtrlCreateLabel(GetTranslated(608,3, "Attack on")&":", $x, $y + 5, -1, -1)
$g_hCmbStandardDropSidesDB = GUICtrlCreateCombo("", $x + 55, $y, 120, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslated(608,4, "Attack on a single side, penetrates through base") & @CRLF & GetTranslated(608,5, "Attack on two sides, penetrates through base") & @CRLF & GetTranslated(608,6, "Attack on three sides, gets outer and some inside of base") & @CRLF & "Attack on Classic Four Fingers", GetTranslated(608,7,"Select the No. of sides to attack on."))
GUICtrlSetData(-1, GetTranslated(608,8, "one side") & "|" & GetTranslated(608,9, "two sides") & "|" & GetTranslated(608,10, "three sides") &"|" & GetTranslated(608,11,"all sides equally" ) &"|" & "Classic Four Fingers", GetTranslated(608,11, -1))
GUICtrlSetOnEvent(-1,"cmbDeployDB")
$y += 25
GUICtrlCreateLabel(GetTranslated(608,12, "Delay Unit") & ":", $x, $y + 5, -1, -1)
$sTxtTip = GetTranslated(608,13, "This delays the deployment of troops, 1 (fast) = like a Bot, 10 (slow) = Like a Human.") & @CRLF & GetTranslated(608,14, "Random will make bot more varied and closer to a person.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbStandardUnitDelayDB = GUICtrlCreateCombo("", $x + 55, $y, 36, 21, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "1|2|3|4|5|6|7|8|9|10", "4")
GUICtrlCreateLabel(GetTranslated(608,15, "Wave") & ":", $x + 100, $y + 5, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbStandardWaveDelayDB = GUICtrlCreateCombo("", $x + 140, $y, 36, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "1|2|3|4|5|6|7|8|9|10", "4")
$y += 22
$g_hChkRandomSpeedAtkDB = GUICtrlCreateCheckbox(GetTranslated(608,16, "Randomize delay for Units && Waves"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkRandomSpeedAtkDB")
$y +=22
$g_hChkSmartAttackRedAreaDB = GUICtrlCreateCheckbox(GetTranslated(608,17, "Use Smart Attack: Near Red Line."), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(608,18, "Use Smart Attack to detect the outer 'Red Line' of the village to attack. And drop your troops close to it."))
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkSmartAttackRedAreaDB")
$y += 22
$g_hLblSmartDeployDB = GUICtrlCreateLabel(GetTranslated(608,19, "Drop Type") & ":", $x, $y + 5, -1, -1)
$sTxtTip = GetTranslated(608,20, "Select the Deploy Mode for the waves of Troops.") & @CRLF & GetTranslated(608,21, "Type 1: Drop a single wave of troops on each side then switch troops, OR") & @CRLF & GetTranslated(608,22, "Type 2: Drop a full wave of all troops (e.g. giants, barbs and archers) on each side then switch sides.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbSmartDeployDB = GUICtrlCreateCombo("", $x + 55, $y, 120, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslated(608,23, "Sides, then Troops") & "|" & GetTranslated(608,24, "Troops, then Sides") , GetTranslated(608,23, -1))
_GUICtrlSetTip(-1, $sTxtTip)
$y += 26
$g_hChkAttackNearGoldMineDB = GUICtrlCreateCheckbox("", $x + 20, $y, 17, 17)
$sTxtTip = GetTranslated(608,26, "Drop troops near Gold Mines")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnMine, $x + 40 , $y - 3 , 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 75
$g_hChkAttackNearElixirCollectorDB = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
$sTxtTip = GetTranslated(608,27, "Drop troops near Elixir Collectors")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 20 , $y - 3 , 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 55
$g_hChkAttackNearDarkElixirDrillDB = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
$sTxtTip = GetTranslated(608,28, "Drop troops near Dark Elixir Drills")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicAttackNearDarkElixirDrillDB = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDrill, $x + 20 , $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_DEADBASE_ATTACK_SCRIPTED = 0
Global $g_hCmbScriptNameDB = 0, $g_hCmbScriptRedlineImplDB = 0, $g_hCmbScriptDroplineDB = 0
Global $g_hLblNotesScriptDB = 0
Func CreateAttackSearchDeadBaseScripted()
$g_hGUI_DEADBASE_ATTACK_SCRIPTED = GUICreate("", $_GUI_MAIN_WIDTH - 195, $_GUI_MAIN_HEIGHT - 344, 150, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_DEADBASE)
Local $x = 25, $y = 20
GUICtrlCreateGroup(GetTranslated(607,1,"Deploy"), $x - 20, $y - 20, 270, 306)
$y +=15
$g_hCmbScriptNameDB = GUICtrlCreateCombo("", $x, $y, 200, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL, $WS_VSCROLL))
_GUICtrlSetTip(-1, GetTranslated(607,4, "Choose the script; You can edit/add new scripts located in folder: 'CSV/Attack'"))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "cmbScriptNameDB")
GUICtrlCreateIcon($g_sLibIconPath, $eIcnReload, $x + 210, $y + 2, 16, 16)
_GUICtrlSetTip(-1, GetTranslated(607,5, "Reload Script Files"))
GUICtrlSetOnEvent(-1, 'UpdateComboScriptNameDB')
$y +=25
$g_hLblNotesScriptDB = GUICtrlCreateLabel("", $x, $y + 5, 200, 180)
$g_hCmbScriptRedlineImplDB = GUICtrlCreateCombo("", $x, $y + 195, 230, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslated(607,9, "ImgLoc Raw Redline (default)|ImgLoc Redline Drop Points|Original Redline|External Edges"))
_GUICtrlComboBox_SetCurSel(-1, $g_aiAttackScrRedlineRoutine[$DB])
_GUICtrlSetTip(-1, GetTranslated(607,10, "Choose the Redline implementation. ImgLoc Redline is default and best."))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "cmbScriptRedlineImplDB")
$g_hCmbScriptDroplineDB = GUICtrlCreateCombo("", $x, $y + 220, 230, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslated(607,11, "Drop line fix outer corner|Drop line fist Redline point|Full Drop line fix outer corner|Full Drop line fist Redline point|No Drop line"))
_GUICtrlComboBox_SetCurSel(-1, $g_aiAttackScrDroplineEdge[$DB])
_GUICtrlSetTip(-1, GetTranslated(607,12, "Choose the drop line edges. Default is outer corner and safer. First Redline point can improve attack."))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "cmbScriptDroplineDB")
GUICtrlCreateIcon($g_sLibIconPath, $eIcnEdit, $x + 210, $y + 2, 16, 16)
_GUICtrlSetTip(-1, GetTranslated(607,6, "Show/Edit current Attack Script"))
GUICtrlSetOnEvent(-1, "EditScriptDB")
$y +=25
GUICtrlCreateIcon($g_sLibIconPath, $eIcnAddcvs, $x + 210, $y + 2, 16, 16)
_GUICtrlSetTip(-1, GetTranslated(607,7, "Create a new Attack Script"))
GUICtrlSetOnEvent(-1, "NewScriptDB")
$y +=25
GUICtrlCreateIcon($g_sLibIconPath, $eIcnCopy, $x + 210, $y + 2, 16, 16)
_GUICtrlSetTip(-1, GetTranslated(607,8, "Copy current Attack Script to a new name"))
GUICtrlSetOnEvent(-1, "DuplicateScriptDB")
GUICtrlCreateGroup("", -99, -99, 1, 1)
UpdateComboScriptNameDB()
Local $tempindex = _GUICtrlComboBox_FindStringExact($g_hCmbScriptNameDB, $g_sAttackScrScriptName[$DB])
If $tempindex = -1 Then $tempindex = 0
_GUICtrlComboBox_SetCurSel($g_hCmbScriptNameDB, $tempindex)
EndFunc
Global $g_hGUI_DEADBASE_ATTACK_MILKING = 0
Global $g_hCmbMilkAttackType = 0, $g_hCmbMilkLvl[13] = [-1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0]
Global $g_hChkAtkElixirExtractors = 0, $g_hChkAtkGoldMines = 0, $g_hCmbAtkGoldMinesLevel = 0, $g_hChkAtkDarkDrills = 0, $g_hCmbAtkDarkDrillsLevel = 0
Global $g_hCmbRedlineResDistance = 0, $g_hChkAttackMinesIfGold = 0, $g_hTxtAttackMinesIfGold = 0, $g_hChkAttackMinesIfElixir = 0, $g_hTxtAttackMinesIfElixir = 0, $g_hChkAttackMinesIfDarkElixir = 0, $g_hTxtAttackMinesIfDarkElixir = 0
Global $g_hTxtLowerXWave = 0, $g_hTxtUpperXWave = 0, $g_hTxtMaxWaves = 0, $g_hTxtLowerDelayWaves = 0, $g_hTxtUpperDelayWaves = 0
Global $g_hCmbMilkingAttackDropGoblinAlgorithm = 0, $g_hCmbStructureOrder = 0
Global $g_hChkStructureDestroyedBeforeAttack = 0, $g_hChkStructureDestroyedAfterAttack = 0
Global $g_hChkMilkAfterAttackTHSnipe = 0, $g_hTxtMaxTilesMilk = 0, $g_hCmbMilkSnipeAlgorithm = 0, $g_hChkSnipeIfNoElixir = 0, $g_hChkMilkAfterAttackScripted = 0, $g_hCmbMilkingCSVScriptName = 0
Global $g_hGrpSnipeOutsideTHAtEnd = 0, $g_hGrpDeploy = 0, $g_hLblMilkingCSVNotesScript = 0
Global $g_hChkMilkFarmForceTolerance = 0, $g_hTxtMilkFarmForceToleranceNormal = 0, $g_hTxtMilkFarmForceToleranceBoosted = 0, $g_hTxtMilkFarmForceToleranceDestroyed = 0
Global $g_hGrpMilkingDebug = 0, $g_hChkMilkingDebugIMG = 0, $g_hChkMilkingDebugVillage = 0, $g_hChkMilkingDebugFullSearch = 0
Func CreateAttackSearchDeadBaseMilking()
$g_hGUI_DEADBASE_ATTACK_MILKING = GUICreate("", $_GUI_MAIN_WIDTH - 195, $_GUI_MAIN_HEIGHT - 344, 150, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_DEADBASE)
Local $sTxtDisable = GetTranslated(631,79,"DIS.")
Local $x = 5, $y = 0
GUICtrlCreateTab($x, $y, 268, 306, $TCS_MULTILINE)
GUICtrlCreateTabItem(GetTranslated(600,44,"A - Structures"))
Local $x = 15, $y = 45
GUICtrlCreateGroup(GetTranslated(631,80,"Choose Milking Search Type"), $x - 5, $y - 5, 260, 45)
$y += 15
$g_hCmbMilkAttackType = GUICtrlCreateCombo("", $x, $y, 250, 20,BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslated(631,59,"Slower: Check the Resources in each collector.") & "|" & GetTranslated(631,60,"Faster: Only check the Level of each collector."), GetTranslated(631,60,-1))
$y += 30
GUICtrlCreateGroup(GetTranslated(631,2, "Elixir Collectors Min. Level to Attack"), $x - 5, $y, 210, 145)
$y += 20
GUICtrlCreateLabel(GetTranslated(631,3, "Levels 1-4"), $x,$y)
$g_hCmbMilkLvl[4] = GUICtrlCreateCombo("", $x, $y +16, 65,20,BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtDisable & "|0-4%|5-19%|20-74%|75-89%|90-100%",$sTxtDisable)
$x+=67
GUICtrlCreateLabel(GetTranslated(631,4, "Level 5"), $x,$y)
$g_hCmbMilkLvl[5] = GUICtrlCreateCombo("", $x, $y +16, 65,20,BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtDisable & "|0-4%|5-19%|20-74%|75-89%|90-100%",$sTxtDisable)
$x+=67
GUICtrlCreateLabel(GetTranslated(631,5, "Level 6"), $x,$y)
$g_hCmbMilkLvl[6] = GUICtrlCreateCombo("", $x, $y +16, 65,20,BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtDisable & "|0-4%|5-19%|20-74%|75-89%|90-100%",$sTxtDisable)
$x = 15
$y += 40
GUICtrlCreateLabel(GetTranslated(631,6, "Level 7"), $x,$y)
$g_hCmbMilkLvl[7] = GUICtrlCreateCombo("", $x, $y +16, 65,20,BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtDisable & "|0-4%|5-19%|20-74%|75-89%|90-100%",$sTxtDisable)
$x+=67
GUICtrlCreateLabel(GetTranslated(631,7, "Level 8"), $x,$y)
$g_hCmbMilkLvl[8] = GUICtrlCreateCombo("", $x, $y +16, 65,20,BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtDisable & "|0-4%|5-19%|20-74%|75-89%|90-100%",$sTxtDisable)
$x+=67
GUICtrlCreateLabel(GetTranslated(631,8, "Level 9"), $x,$y)
$g_hCmbMilkLvl[9] = GUICtrlCreateCombo("", $x, $y +16, 65,20,BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtDisable & "|0-4%|5-19%|20-74%|75-89%|90-100%",$sTxtDisable)
$x = 15
$y += 40
GUICtrlCreateLabel(GetTranslated(631,9, "Level 10"), $x,$y)
$g_hCmbMilkLvl[10] = GUICtrlCreateCombo("", $x, $y +16, 65,20,BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtDisable & "|0-4%|5-19%|20-74%|75-89%|90-100%","5-19%")
$x+=67
GUICtrlCreateLabel(GetTranslated(631,10, "Level 11"), $x,$y)
$g_hCmbMilkLvl[11] = GUICtrlCreateCombo("", $x, $y +16, 65,20,BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtDisable & "|0-4%|5-19%|20-74%|75-89%|90-100%","5-19%")
$x+=67
GUICtrlCreateLabel(GetTranslated(631,11, "Level 12"), $x,$y)
$g_hCmbMilkLvl[12] = GUICtrlCreateCombo("", $x, $y +16, 65,20,BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtDisable & "|0-4%|5-19%|20-74%|75-89%|90-100%","5-19%")
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 10, $y = 240
GUICtrlCreateGroup(GetTranslated(631,31, "Legend"), $x, $y, 260, 65)
$x = 23
$y = 255
GUICtrlCreateLabel(GetTranslated(631,32, "0-4%"),$x, $y)
$x = 21
$y = 273
GUICtrlCreatePic(@ScriptDir & "\Images\CapacityStructure\elixir_8_0_70_A.bmp", $x , $y, 25, 25 )
$x = 65
$y = 255
GUICtrlCreateLabel(GetTranslated(631,33, "5-19%"),$x, $y)
$x = 66
$y = 273
GUICtrlCreatePic(@ScriptDir & "\Images\CapacityStructure\elixir_8_1_70_A.bmp", $x , $y, 25, 25 )
$x = 117
$y = 255
GUICtrlCreateLabel(GetTranslated(631,34, "20-74%"),$x, $y)
$x = 121
$y = 273
GUICtrlCreatePic(@ScriptDir & "\Images\CapacityStructure\elixir_8_2_70_A.bmp", $x , $y, 25, 25 )
$x = 173
$y = 255
GUICtrlCreateLabel(GetTranslated(631,35, "75-89%"),$x, $y)
$x = 176
$y = 273
GUICtrlCreatePic(@ScriptDir & "\Images\CapacityStructure\elixir_8_3_70_A.bmp", $x , $y, 25, 25 )
$x = 224
$y = 255
GUICtrlCreateLabel(GetTranslated(631,36, "90-100%"),$x, $y)
$x = 232
$y = 273
GUICtrlCreatePic(@ScriptDir & "\Images\CapacityStructure\elixir_8_4_70_A.bmp", $x , $y, 25, 25 )
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlCreateTabItem(GetTranslated(600,45,"B - Conditions"))
Local $x = 14, $y = 45
GUICtrlCreateGroup(GetTranslated(631,56, "Structures to Attack"), $x - 5, $y, 260, 100)
$y += 22
$g_hChkAtkElixirExtractors = GUICtrlCreateCheckbox(GetTranslated(631,13, "Attack"), $x, $y, -1, 18)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 60, $y - 6, 24, 24)
$y += 26
$g_hChkAtkGoldMines = GUICtrlCreateCheckbox(GetTranslated(631,13, -1), $x, $y, -1, 18)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkAtkGoldMines")
GUICtrlCreateIcon($g_sLibIconPath, $eIcnMine, $x + 60, $y - 6, 24, 24)
GUICtrlCreateLabel(GetTranslated(631,14, "Which have a Level") & " " & ChrW(8805), $x + 70, $y + 2, 115, 18, $SS_RIGHT)
$g_hCmbAtkGoldMinesLevel = GUICtrlCreateCombo("", $x + 200, $y - 2, 50, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1,"1-4|5|6|7|8|9|10|11","5")
$y += 26
$g_hChkAtkDarkDrills = GUICtrlCreateCheckbox(GetTranslated(631,13, -1), $x, $y, -1, 18)
GUICtrlSetOnEvent(-1, "chkAtkDarkDrills")
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDrill, $x + 60, $y - 6, 24, 24)
GUICtrlCreateLabel(GetTranslated(631,14, -1) & " " & ChrW(8805), $x + 70, $y + 2, 115, 18, $SS_RIGHT)
$g_hCmbAtkDarkDrillsLevel = GUICtrlCreateCombo("", $x + 200, $y - 2, 50, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1,"1|2|3|4|5|6","1")
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 14, $y = 155
GUICtrlCreateGroup(GetTranslated(631,16, "Only Attack If"), $x - 5, $y - 5, 260, 110)
$y += 15
GUICtrlCreateLabel(GetTranslated(631,17, "Distance between red line and collectors"), $x, $y)
$g_hCmbRedlineResDistance = GUICtrlCreateCombo("", $x + 200, $y - 4, 50, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "0 tile|1 tile|2 tiles","0 tile")
$y += 21
$g_hChkAttackMinesIfGold = GUICtrlCreateCheckbox(GetTranslated(631,18, "Attack Gold Mines If Gold Under"), $x, $y)
GUICtrlSetOnEvent(-1, "chkAttackMinesifGold")
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hTxtAttackMinesIfGold = GUICtrlCreateInput("9950000", $x + 200, $y, 50, 18, $SS_CENTER)
GUICtrlSetState(-1,$GUI_DISABLE)
$y += 21
$g_hChkAttackMinesIfElixir = GUICtrlCreateCheckbox(GetTranslated(631,19, "Attack Elixir Collectors If Elixir Under"), $x, $y)
GUICtrlSetOnEvent(-1, "chkAttackMinesifElixir")
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hTxtAttackMinesIfElixir = GUICtrlCreateInput("9950000", $x + 200, $y, 50, 18, $SS_CENTER)
GUICtrlSetState(-1,$GUI_DISABLE)
$y += 21
$g_hChkAttackMinesIfDarkElixir = GUICtrlCreateCheckbox(GetTranslated(631,20, "Attack Dark Elixir Drills If Dark Under"), $x, $y)
GUICtrlSetOnEvent(-1, "chkAttackMinesifDarkElixir")
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hTxtAttackMinesIfDarkElixir = GUICtrlCreateInput("200000", $x + 200, $y, 50, 18, $SS_CENTER)
GUICtrlSetState(-1,$GUI_DISABLE)
GUICtrlCreateTabItem("")
GUICtrlCreateTabItem(GetTranslated(600,46,"C - Attack"))
Local $x = 9
Local $y = 45
GUICtrlCreateGroup(GetTranslated(631,21, "4. Troops To Use For Each Building"), $x, $y,260,90)
$x = 15
$y +=20
GUICtrlCreateLabel(GetTranslated(631,22, "- Troops Per Wave:"),$x, $y)
$g_hTxtLowerXWave = GUICtrlCreateInput("4", 180-10, $y-7, 37,21)
GUICtrlCreateLabel("-", 208, $y)
$g_hTxtUpperXWave = GUICtrlCreateInput("6", 245-20, $y-7, 37,21)
$y +=20
GUICtrlCreateLabel(GetTranslated(631,23, "- Max Waves:"),$x, $y)
$g_hTxtMaxWaves = GUICtrlCreateInput("3", 180-10, $y-7, 37,21)
_GUICtrlSetTip(-1, GetTranslated(631,85,"Choose the maximum number of waves of troops to drop at each collector.") & @CRLF & GetTranslated(631,86,"If the collector gets destroyed, then no more waves will be dropped at it."))
$y +=20
GUICtrlCreateLabel(GetTranslated(631,24, "- Delay Between Waves (ms):"),$x, $y)
$g_hTxtLowerDelayWaves = GUICtrlCreateInput("3000", 180-10, $y-7, 37,21)
GUICtrlCreateLabel("-", 208, $y)
$g_hTxtUpperDelayWaves = GUICtrlCreateInput("5000", 245-20, $y-7, 37,21)
$x = 9
$y +=40
GUICtrlCreateGroup(GetTranslated(631,71, "5. Dropping options"), $x,$y, 260,80)
$y +=21
$g_hCmbMilkingAttackDropGoblinAlgorithm = GUICtrlCreateCombo("", $x+5, $y , 240,20,BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslated(631,72,"Drop each Goblin in the same place") & "|" & GetTranslated(631,73,"Drop each Goblin in a different place"), GetTranslated(631,72,-1))
$y +=25
$g_hCmbStructureOrder = GUICtrlCreateCombo("", $x+5, $y , 250,20,BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslated(631,74,"Attack Order: as found") & "|" & GetTranslated(631,75,"Attack Order: Random") & "|" & GetTranslated(631,76,"Attack Order: by side"), GetTranslated(631,76,-1))
$x = 9
$y +=40
GUICtrlCreateGroup(GetTranslated(631,61, "Check Destroyed Structures"), $x,$y, 260,70)
$y += 20
$x += 5
$g_hChkStructureDestroyedBeforeAttack = GUICtrlCreateCheckbox(GetTranslated(631,62, "Check Structure Destruction Before Wave"), $x, $y)
_GUICtrlSetTip(-1, GetTranslated(631,63, "Before attacking a structure, check to see if it has been destroyed by another wave.") & @CRLF & GetTranslated(631,64,"You must have a high delay between waves to use this option"))
$y += 20
$g_hChkStructureDestroyedAfterAttack = GUICtrlCreateCheckbox(GetTranslated(631,65, "Check Structure Destruction After Wave"), $x, $y)
_GUICtrlSetTip(-1, GetTranslated(631,66, "After attacking a structure, check to see if it has been destroyed by another wave.") & @CRLF & GetTranslated(631,67,"You must have a high delay between waves to use this option"))
GUICtrlCreateTabItem("")
GUICtrlCreateTabItem(GetTranslated(600,47,"D - After Milking"))
Local $x = 9
Local $y = 45
$g_hGrpSnipeOutsideTHAtEnd = GUICtrlCreateGroup(GetTranslated(631,25, "5a. Snipe Outside TH After Milking"), $x, $y-4,260,120)
$x =15
$y+=15
$g_hChkMilkAfterAttackTHSnipe = GUICtrlCreateCheckbox(GetTranslated(631,82,"Enable TH Snipe"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(631,82,"Enable TH Snipe"))
GUICtrlSetOnEvent(-1, "chkMilkAfterAttackTHSnipe")
$y+=21
GUICtrlCreateLabel(GetTranslated(631,27, "Max Tiles From Border") & ":", $x, $y)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hTxtMaxTilesMilk = GUICtrlCreateInput("1", $x + 175,$y-7, 37,21)
GUICtrlSetState(-1, $GUI_DISABLE)
$y+=20
GUICtrlCreateLabel(GetTranslated(631,28, "Use Algorithm")&":", $x, $y)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hCmbMilkSnipeAlgorithm = GUICtrlCreateCombo("", 120,$y-2, 120,20,BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetState(-1, $GUI_DISABLE)
PopulateCmbMilkSnipeAlgorithm()
_GUICtrlComboBox_SetCurSel($g_hCmbMilkSnipeAlgorithm,_GUICtrlComboBox_FindStringExact($g_hCmbMilkSnipeAlgorithm, "Queen&GobTakeTH"))
$y+=20
$g_hChkSnipeIfNoElixir = GUICtrlCreateCheckbox(GetTranslated(631,29, "Snipe Even If No Collectors can be Milked"), $x,$y)
GUICtrlSetState(-1, $GUI_DISABLE)
$x =9
$y += 85
$g_hGrpDeploy = GUICtrlCreateGroup(GetTranslated(631,84,"5b. Continue With An Scripted Attack"), $x , $y - 20, 260, 70)
$x+=15
$g_hChkMilkAfterAttackScripted = GUICtrlCreateCheckbox(GetTranslated(631,83,"Enable Scripted Attack"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(631,83,"Enable Scripted Attack"))
$y+=21
$g_hCmbMilkingCSVScriptName = GUICtrlCreateCombo("", $x-10 , $y, 185, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslated(631,30, "Use scripted attack for dead bases, this disables standard attack"))
PopulateComboMilkingCSVScriptsFiles()
_GUICtrlComboBox_SetCurSel($g_hCmbMilkingCSVScriptName,_GUICtrlComboBox_FindStringExact($g_hCmbMilkingCSVScriptName, "Barch four fingers"))
$y +=25
$g_hLblMilkingCSVNotesScript = GUICtrlCreateLabel("", $x, $y + 5, 180, 118)
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlCreateTabItem("")
GUICtrlCreateTabItem(GetTranslated(600,48,"Advanced"))
Local $x = 9
Local $y = 45
$y +=21
GUICtrlCreateGroup(GetTranslated(631,68, "Tolerance Settings"), $x,$y, 260,120)
$x+=5
$y +=21
$g_hChkMilkFarmForceTolerance = GUICtrlCreateCheckbox(GetTranslated(631,50, "Force Tolerance"), $x, $y)
GUICtrlSetOnEvent(-1,"chkMilkFarmForcetolerance")
$y +=21
GUICtrlCreateLabel(GetTranslated(631,51, "Tolerance Normal"), $x,$y)
$g_hTxtMilkFarmForceToleranceNormal = GUICtrlCreateInput("60", 235-31, $y, 60-8,21)
GUICtrlSetState(-1, $GUI_DISABLE)
$y +=21
GUICtrlCreateLabel(GetTranslated(631,52, "Tolerance Boosted"), $x,$y)
$g_hTxtMilkFarmForceToleranceBoosted = GUICtrlCreateInput("60", 235-31, $y, 60-8,21)
GUICtrlSetState(-1, $GUI_DISABLE)
$y +=21
GUICtrlCreateLabel(GetTranslated(631,53, "Tolerance Destroyed"), $x,$y)
$g_hTxtMilkFarmForceToleranceDestroyed = GUICtrlCreateInput("60", 235-31, $y, 60-8,21)
GUICtrlSetState(-1, $GUI_DISABLE)
$x = 9
$y += 50
$g_hGrpMilkingDebug = GUICtrlCreateGroup(GetTranslated(631,37, "Debug"), $x,$y, 260,100)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$x += 5
$g_hChkMilkingDebugIMG = GUICtrlCreateCheckbox(GetTranslated(631,38, "Make Images of each extractor with offset"), $x, $y)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkMilkingDebugVillage = GUICtrlCreateCheckbox(GetTranslated(631,41, "Make Images of villages"), $x, $y)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkMilkingDebugFullSearch = GUICtrlCreateCheckbox(GetTranslated(631,39, "fullsearch, only for debug purpose (very slow)"), $x, $y)
_GUICtrlSetTip(-1, GetTranslated(631,81,"with this options you can detect images of undetected Elixir Extractors"))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateTabItem("")
EndFunc
Global $g_hChkDBActivateSearches = 0, $g_hTxtDBSearchesMin = 0, $g_hTxtDBSearchesMax = 0
Global $g_hChkDBActivateTropies = 0, $g_hTxtDBTropiesMin = 0, $g_hTxtDBTropiesMax = 0
Global $g_hChkDBActivateCamps = 0, $g_hTxtDBArmyCamps = 0
Global $g_hChkDBKingWait = 0, $g_hChkDBQueenWait = 0, $g_hChkDBWardenWait = 0
Global $g_hChkDBSpellsWait = 0, $g_hChkDBWaitForCastleSpell = 0, $g_hCmbDBWaitForCastleSpell = 0, $g_hCmbDBWaitForCastleSpell = 0,$g_hCmbDBWaitForCastleSpell2 = 0, $g_hTxtDBWaitForCastleSpell = 0, $g_hChkDBWaitForCastleTroops = 0
Global $g_hLblDBSearches = 0, $g_hLblDBTropies = 0, $g_hLblDBArmyCamps = 0
Global $g_hPicDBHeroesWait = 0, $g_hTxtDBHeroesWait = 0, $g_hPicDBKingWait = 0, $g_hPicDBKingSleepWait = 0, $g_hPicDBQueenWait = 0, $g_hPicDBQueenSleepWait = 0, $g_hPicDBWardenWait = 0, $g_hPicDBWardenSleepWait = 0
Global $g_hPicDBLightSpellWait = 0, $g_hPicDBHealSpellWait = 0, $g_hPicDBRageSpellWait = 0, $g_hPicDBJumpSpellWait = 0, $g_hPicDBFreezeSpellWait = 0, $g_hPicDBPoisonSpellWait = 0, $g_hPicDBEarthquakeSpellWait = 0, $g_hPicDBHasteSpellWait = 0
Global $g_hCmbDBMeetGE = 0, $g_hTxtDBMinGold = 0, $g_hTxtDBMinElixir = 0, $g_hTxtDBMinGoldPlusElixir = 0
Global $g_hChkDBMeetDE = 0, $g_hTxtDBMinDarkElixir = 0
Global $g_hChkDBMeetTrophy = 0, $g_hTxtDBMinTrophy = 0
Global $g_hChkDBMeetTH = 0, $g_hCmbDBTH = 0, $g_hChkDBMeetTHO = 0
Global $g_hGrpDBFilter = 0, $g_hPicDBMinGold = 0, $g_hPicDBMinElixir = 0, $g_hPicDBMinGPEGold = 0, $g_hPicDBMinDarkElixir = 0, $g_hPicDBMinTrophies = 0, $g_hPicDBMaxTH10 = 0
Func CreateAttackSearchDeadBaseSearch()
Local $sTxtLightningSpells = GetTranslated(605,15,"Lightning")
Local $sTxtHealSpells = GetTranslated(605,16,"Heal")
Local $sTxtRageSpells = GetTranslated(605,17,"Rage")
Local $sTxtJumpSpells = GetTranslated(605,18,"Jump")
Local $sTxtFreezeSpells = GetTranslated(605,19,"Freeze")
Local $sTxtPoisonSpells = GetTranslated(605,9, "Poison")
Local $sTxtEarthquakeSpells = GetTranslated(605,10, "EarthQuake")
Local $sTxtHasteSpells = GetTranslated(605,11, "Haste")
Local $sTxtSkeletonSpells = GetTranslated(605,14, "Skeleton")
Local $sTxtTip = ""
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslated(625,0, "Start Search IF"), $x - 20, $y - 20, 190, 305)
$x -= 15
$g_hChkDBActivateSearches = GUICtrlCreateCheckbox(GetTranslated(625,1,"Search"), $x, $y, 68, 18)
_GUICtrlSetTip(-1, GetTranslated(625,68, "Note - enables SEARCH range for this attack type ONLY.") & @CRLF & GetTranslated(625,69, "Setting will not set search limit to restart search process!"))
GUICtrlSetState(-1,$GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkDBActivateSearches")
$g_hTxtDBSearchesMin = GUICtrlCreateInput("1", $x + 70, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(625,2, "Set the Min. number of searches to activate this attack option") & @CRLF & @CRLF & GetTranslated(625,68, -1) & @CRLF & GetTranslated(625,69, -1))
GUICtrlSetLimit(-1, 6)
$g_hLblDBSearches = GUICtrlCreateLabel("-", $x + 113, $y + 2, -1, -1)
$g_hTxtDBSearchesMax = GUICtrlCreateInput("9999", $x + 120, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(625,3, "Set the Max number of searches to activate this attack option") & @CRLF & @CRLF & GetTranslated(625,68, -1) & @CRLF & GetTranslated(625,69,-1))
GUICtrlSetLimit(-1, 6)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnMagnifier, $x + 163, $y + 1, 16, 16)
$y += 21
$g_hChkDBActivateTropies = GUICtrlCreateCheckbox(GetTranslated(625,4,"Trophies"), $x, $y, 68, 18)
_GUICtrlSetTip(-1, GetTranslated(625,68, -1) & @CRLF & GetTranslated(625,70,"This option will NOT adjust tropies to stay in range entered!"))
GUICtrlSetOnEvent(-1, "chkDBActivateTropies")
$g_hTxtDBTropiesMin = GUICtrlCreateInput("0", $x + 70, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1,$GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(625,5, "Set the Min. number of tropies where this attack will be used") & @CRLF & @CRLF & GetTranslated(625,68, -1) & @CRLF & GetTranslated(625,70,-1))
GUICtrlSetLimit(-1, 6)
$g_hLblDBTropies = GUICtrlCreateLabel("-", $x + 113, $y + 2, -1, -1)
GUICtrlSetState(-1,$GUI_DISABLE)
$g_hTxtDBTropiesMax = GUICtrlCreateInput("6000", $x + 120, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1,$GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(625,6, "Set the Max number of tropies where this attack will be used") & @CRLF & @CRLF & GetTranslated(625,68, -1) & @CRLF & GetTranslated(625,70, -1))
GUICtrlSetLimit(-1, 6)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 163, $y + 1, 16, 16)
$y +=21
$g_hChkDBActivateCamps = GUICtrlCreateCheckbox(GetTranslated(625,7, "Army Camps"), $x, $y, 110, 18)
$sTxtTip = GetTranslated(625,8, "Set the % Army camps required to enable this attack option while searching")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkDBActivateCamps")
$g_hLblDBArmyCamps = GUICtrlCreateLabel(ChrW(8805), $x + 113 - 1, $y + 2, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1,$GUI_DISABLE)
$g_hTxtDBArmyCamps = GUICtrlCreateInput("80", $x + 120, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1,$GUI_DISABLE)
GUICtrlSetLimit(-1, 6)
GUICtrlCreateLabel("%", $x + 163 + 3, $y + 4, -1, -1)
GUICtrlSetState(-1,$GUI_DISABLE)
$y +=23
$g_hPicDBHeroesWait = GUICtrlCreateIcon($g_sLibIconPath, $eIcnHourGlass, $x - 1, $y + 3, 16, 16)
$g_hTxtDBHeroesWait = GUICtrlCreateLabel(GetTranslated(625,9,"Wait for Heroes to be Ready") & ":", $x + 20, $y + 4, 180, 18)
$y += 20
$x += 20
$g_hChkDBKingWait = GUICtrlCreateCheckbox("", $x, $y + 55, 16, 16)
Local $sTxtKingWait = GetTranslated(625,50, "Wait for Hero option disabled when continuous Upgrade Hero selected!")
$sTxtTip = GetTranslated(625,10, "Wait for King to be ready before attacking...") & @CRLF & $sTxtKingWait & @CRLF & GetTranslated(625,65, "Enabled with TownHall 7 and higher")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkDBKingWait")
$g_hPicDBKingWait=GUICtrlCreateIcon($g_sLibIconPath, $eIcnKing, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicDBKingSleepWait=GUICtrlCreateIcon($g_sLibIconPath, $eIcnSleepingKing, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1,$GUI_HIDE)
$x += 55
$g_hChkDBQueenWait = GUICtrlCreateCheckbox("", $x, $y + 55, 16, 16)
$sTxtTip = GetTranslated(625,12, "Wait for Queen to be ready before attacking...") & @CRLF & $sTxtKingWait & @CRLF & GetTranslated(625,66, "Enabled with TownHall 9 and higher")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkDBQueenWait")
$g_hPicDBQueenWait=GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueen, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicDBQueenSleepWait=GUICtrlCreateIcon($g_sLibIconPath, $eIcnSleepingQueen, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1,$GUI_HIDE)
$x += 55
$g_hChkDBWardenWait = GUICtrlCreateCheckbox("", $x, $y + 55, 16, 16)
$sTxtTip = GetTranslated(625,13, "Wait for Warden to be ready before attacking...") & @CRLF & $sTxtKingWait & @CRLF & GetTranslated(625,67, "Enabled with TownHall 11")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkDBWardenWait")
$g_hPicDBWardenWait=GUICtrlCreateIcon($g_sLibIconPath, $eIcnWarden, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicDBWardenSleepWait=GUICtrlCreateIcon($g_sLibIconPath, $eIcnSleepingWarden, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1,$GUI_HIDE)
$y += 80
$x = 8
$g_hPicDBLightSpellWait = GUICtrlCreateIcon($g_sLibIconPath, $eIcnLightSpell, $x, $y, 22, 22)
$g_hPicDBHealSpellWait = GUICtrlCreateIcon($g_sLibIconPath, $eIcnHealSpell, $x+23, $y, 22, 22)
$g_hPicDBRageSpellWait = GUICtrlCreateIcon($g_sLibIconPath, $eIcnRageSpell, $x+46, $y, 22, 22)
$g_hPicDBJumpSpellWait = GUICtrlCreateIcon($g_sLibIconPath, $eIcnJumpSpell , $x+69, $y, 22, 22)
$g_hPicDBFreezeSpellWait = GUICtrlCreateIcon($g_sLibIconPath, $eIcnFreezeSpell , $x+92, $y, 22, 22)
$g_hPicDBPoisonSpellWait = GUICtrlCreateIcon($g_sLibIconPath, $eIcnPoisonSpell , $x+115, $y, 22, 22)
$g_hPicDBEarthquakeSpellWait = GUICtrlCreateIcon($g_sLibIconPath, $eIcnEarthquakeSpell , $x+138, $y, 22, 22)
$g_hPicDBHasteSpellWait = GUICtrlCreateIcon($g_sLibIconPath, $eIcnHasteSpell, $x+161, $y, 22, 22)
$y += 22
$x = 10
$g_hChkDBSpellsWait = GUICtrlCreateCheckbox(GetTranslated(625,71, "Wait for Spells to be Ready"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(625,72, "Stop searching for this attack type when Spells are not ready") & @CRLF & GetTranslated(625,73, "Warning: Do not enable unless you have spell factory or bot will not attack!"))
GUICtrlSetOnEvent(-1, "chkDBSpellsWait")
$g_hChkDBWaitForCastleSpell = GUICtrlCreateCheckbox(GetTranslated(625,74, "Wait to get Castle Spell"), $x, $y + 25, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(625,75, "Wait until Someone Donate you an Spell"))
GUICtrlSetOnEvent(-1, "chkDBWaitForCCSpell")
$g_hCmbDBWaitForCastleSpell = GUICtrlCreateCombo(GetTranslated(625,76, "Any"), $x, $y + 50, 70, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtLightningSpells & "|" & $sTxtHealSpells & "|" & $sTxtRageSpells & "|" & $sTxtJumpSpells & "|" & $sTxtFreezeSpells & "|" & $sTxtPoisonSpells & "|" & $sTxtEarthquakeSpells & "|" & $sTxtHasteSpells & "|" & $sTxtSkeletonSpells)
_GUICtrlSetTip(-1, GetTranslated(625,77, -1))
GUICtrlSetOnEvent(-1, "cmbDBWaitForCCSpell")
$g_hTxtDBWaitForCastleSpell = GUICtrlCreateLabel(GetTranslated(641, 40, "And"), $x + 80, $y + 53, -1, -1)
$g_hCmbDBWaitForCastleSpell2 = GUICtrlCreateCombo(GetTranslated(625,76, "Any"),$x + 110, $y + 50, 70, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtPoisonSpells & "|" & $sTxtEarthquakeSpells & "|" & $sTxtHasteSpells & "|" & $sTxtSkeletonSpells)
_GUICtrlSetTip(-1, GetTranslated(625,75, -1))
$g_hChkDBWaitForCastleTroops = GUICtrlCreateCheckbox(GetTranslated(625,78, "Wait for Castle troops to be full"), $x, $y + 75, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(625,79, "Wait until your Clan Castle be Full"))
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 220, $y = 45
$g_hGrpDBFilter = GUICtrlCreateGroup(GetTranslated(625,14, "Filters"), $x - 20, $y - 20, 225, 305)
$x -= 15
$g_hCmbDBMeetGE = GUICtrlCreateCombo("", $x , $y + 10, 65, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslated(625,19, "G And E") &"|" & GetTranslated(625,20, "G Or E") & "|" & GetTranslated(625,21, "G + E"), GetTranslated(625,19, -1))
_GUICtrlSetTip(-1, GetTranslated(625,15, "Search for a base that meets the values set for Gold And/Or/Plus Elixir.") & @CRLF & GetTranslated(625,16, "AND: Both conditions must meet, Gold and Elixir.") & @CRLF & GetTranslated(625,17, "OR: One condition must meet, Gold or Elixir.") & @CRLF & GetTranslated(625,18, "+ (PLUS): Total amount of Gold + Elixir must meet."))
GUICtrlSetOnEvent(-1, "cmbDBGoldElixir")
$g_hTxtDBMinGold = GUICtrlCreateInput("80000", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslated(625,23, "Set the Min. amount of Gold to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
$g_hPicDBMinGold = GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 140, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
$g_hTxtDBMinElixir = GUICtrlCreateInput("80000", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslated(625,24, "Set the Min. amount of Elixir to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
$g_hPicDBMinElixir = GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 140, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y -= 11
$g_hTxtDBMinGoldPlusElixir = GUICtrlCreateInput("160000", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslated(625,25, "Set the Min. amount of Gold + Elixir to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicDBMinGPEGold = GUICtrlCreateIcon($g_sLibIconPath, $eIcnGoldElixir, $x + 140, $y + 1, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 34
$g_hChkDBMeetDE = GUICtrlCreateCheckbox(GetTranslated(625,26, "Dark Elixir"), $x , $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkDBMeetDE")
_GUICtrlSetTip(-1, GetTranslated(625,27, "Search for a base that meets the value set for Min. Dark Elixir."))
$g_hTxtDBMinDarkElixir = GUICtrlCreateInput("0", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslated(625,28, "Set the Min. amount of Dark Elixir to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 5)
_GUICtrlEdit_SetReadOnly(-1, True)
$g_hPicDBMinDarkElixir = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 140, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$g_hChkDBMeetTrophy = GUICtrlCreateCheckbox(GetTranslated(625,4, -1), $x, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkDBMeetTrophy")
_GUICtrlSetTip(-1, GetTranslated(625,29, "Search for a base that meets the value set for Min. Trophies."))
$g_hTxtDBMinTrophy = GUICtrlCreateInput("0", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslated(625,30, "Set the Min. amount of Trophies to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlEdit_SetReadOnly(-1, True)
GUICtrlSetLimit(-1, 2)
$g_hPicDBMinTrophies = GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 140, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$g_hChkDBMeetTH = GUICtrlCreateCheckbox(GetTranslated(625,31, "Townhall"), $x, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkDBMeetTH")
_GUICtrlSetTip(-1, GetTranslated(625,32, "Search for a base that meets the value set for Max. Townhall Level."))
$g_hCmbDBTH = GUICtrlCreateCombo("", $x + 85, $y - 1, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslated(625,33, "Set the Max. level of the Townhall to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetData(-1, "4-6|7|8|9|10|11", "4-6")
$g_hPicDBMaxTH10 = GUICtrlCreateIcon($g_sLibIconPath, $eIcnTH10, $x + 140, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$g_hChkDBMeetTHO = GUICtrlCreateCheckbox(GetTranslated(625,34, "Townhall Outside"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(625,35, "Search for a base that has an exposed Townhall. (Outside of Walls)"))
$y += 24
GUICtrlCreateGroup(GetTranslated(625,80, "Weak base | max defenses"), $x, $y, 215, 100)
$x += 5
$y += 20
Local $xStartColumn = $x, $yStartColumn = $y
$g_ahChkMaxMortar[$DB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
_GUICtrlSetTip(-1, GetTranslated(625,59, "Search for a base that has Mortar below this level."))
GUICtrlSetOnEvent(-1, "chkDBWeakBase")
$g_ahCmbWeakMortar[$DB] = GUICtrlCreateCombo("", $x + 19, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslated(625,38, "Set the Max. level of the Mortar to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3|Lvl 4|Lvl 5|Lvl 6|Lvl 7|Lvl 8", "Lvl 5")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahPicWeakMortar[$DB] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnMortar, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y +=24
$g_ahChkMaxWizTower[$DB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
_GUICtrlSetTip(-1, GetTranslated(625,60, "Search for a base that has Wizard Tower below this level"))
GUICtrlSetOnEvent(-1, "chkDBWeakBase")
$g_ahCmbWeakWizTower[$DB] = GUICtrlCreateCombo("", $x + 19, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslated(625,39, "Set the Max. level of the Wizard Tower to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3|Lvl 4|Lvl 5|Lvl 6|Lvl 7|Lvl 8|Lvl 9", "Lvl 4")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahPicWeakWizTower[$DB] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnWizTower, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y +=24
$g_ahChkMaxAirDefense[$DB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
_GUICtrlSetTip(-1, GetTranslated(625,64, "Search for a base that has Air Defense below this level"))
GUICtrlSetOnEvent(-1, "chkDBWeakBase")
$g_ahCmbWeakAirDefense[$DB] = GUICtrlCreateCombo("", $x + 19, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslated(625,81, "Set the Max. level of the Air Defense to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3|Lvl 4|Lvl 5|Lvl 6|Lvl 7|Lvl 8", "Lvl 7")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahPicWeakAirDefense[$DB] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnAirdefense, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$x = $xStartColumn + 104
$y = $yStartColumn
$g_ahChkMaxXBow[$DB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
_GUICtrlSetTip(-1, GetTranslated(625,61, "Search for a base that has X-Bow below this level"))
GUICtrlSetOnEvent(-1, "chkDBWeakBase")
$g_ahCmbWeakXBow[$DB] = GUICtrlCreateCombo("", $x + 19, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslated(625,51, "Set the Max. level of the X-Bow to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3|Lvl 4", "Lvl 2")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahPicWeakXBow[$DB] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnXBow3, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y +=24
$g_ahChkMaxInferno[$DB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
_GUICtrlSetTip(-1, GetTranslated(625,62, "Search for a base that has Inferno below this level"))
GUICtrlSetOnEvent(-1, "chkDBWeakBase")
$g_ahCmbWeakInferno[$DB] = GUICtrlCreateCombo("", $x + 19, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslated(625,52, "Set the Max. level of the Inferno Tower to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3", "Lvl 2")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahPicWeakInferno[$DB] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnInferno4, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y +=24
$g_ahChkMaxEagle[$DB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
_GUICtrlSetTip(-1, GetTranslated(625,63, "Search for a base that has Eagle Artillery below this level"))
GUICtrlSetOnEvent(-1, "chkDBWeakBase")
$g_ahCmbWeakEagle[$DB] = GUICtrlCreateCombo("", $x + 19, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslated(625,53, "Set the Max. level of the Eagle Artillery to search for on a village to attack.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2", "Lvl 1")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahPicWeakEagle[$DB] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnEagleArt, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 44
$x = $xStartColumn
$g_ahChkMeetOne[$DB] = GUICtrlCreateCheckbox(GetTranslated(625,40, "Meet One Then Attack"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(625,41, "Just meet only ONE of the above conditions, then Attack."))
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hCmbDBAlgorithm = 0, $g_hCmbDBSelectTroop = 0, $g_hChkDBKingAttack = 0, $g_hChkDBQueenAttack = 0, $g_hChkDBWardenAttack = 0, $g_hChkDBDropCC = 0
Global $g_hChkDBLightSpell = 0, $g_hChkDBHealSpell = 0, $g_hChkDBRageSpell = 0, $g_hChkDBJumpSpell = 0, $g_hChkDBFreezeSpell = 0, $g_hChkDBCloneSpell = 0, $g_hChkDBPoisonSpell = 0, $g_hChkDBEarthquakeSpell = 0, $g_hChkDBHasteSpell = 0, $g_hChkDBSkeletonSpell = 0
Global $g_hPicDBKingAttack = 0, $g_hPicDBQueenAttack = 0, $g_hPicDBWardenAttack = 0, $g_hPicDBDropCC = 0
Global $g_hPicDBLightSpell = 0, $g_hPicDBHealSpell = 0, $g_hPicDBRageSpell = 0, $g_hPicDBJumpSpell = 0, $g_hPicDBFreezeSpell = 0, $g_hPicDBCloneSpell = 0, $g_hPicDBPoisonSpell = 0, $g_hPicDBEarthquakeSpell = 0, $g_hPicDBHasteSpell = 0, $g_hPicDBSkeletonSpell = 0
Global $g_hChkTHSnipeBeforeDBEnable = 0, $g_hTxtTHSnipeBeforeDBTiles = 0, $g_hCmbTHSnipeBeforeDBScript = 0
Global $g_hLblTHSnipeBeforeDBTiles = 0
Func CreateAttackSearchDeadBaseAttack()
Local $sTxtTip = ""
Local $x = 25, $y = 40
GUICtrlCreateGroup(GetTranslated(624,1,"Attack with"), $x - 20, $y - 15, 145, 223)
$x -= 15
$y += 5
$g_hCmbDBAlgorithm = GUICtrlCreateCombo("", $x, $y, 135, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, "")
GUICtrlSetData(-1, GetTranslated(624,3,"Standard Attack") & "|" & GetTranslated(624,4,"Scripted Attack") & "|" & GetTranslated(624,5,"Milking Attack"), GetTranslated(624,3,-1))
GUICtrlSetOnEvent(-1, "cmbDBAlgorithm")
$y += 30
$g_hCmbDBSelectTroop = GUICtrlCreateCombo("", $x, $y, 135, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslated(624,7, "Use All Troops") &"|"&GetTranslated(624,8, "Use Troops in Barracks")&"|"&GetTranslated(624,9, "Barb Only")&"|" & GetTranslated(624,10, "Arch Only") &"|"&GetTranslated(624,11, "B+A")&"|"&GetTranslated(624,12, "B+Gob")&"|"&GetTranslated(624,13, "A+Gob")&"|"&GetTranslated(624,14, "B+A+Gi")&"|"&GetTranslated(624,15, "B+A+Gob+Gi")&"|"&GetTranslated(624,16, "B+A+Hog Rider")&"|"&GetTranslated(624,17, "B+A+Minion") , GetTranslated(624,7, -1))
_GUICtrlSetTip(-1, GetTranslated(624,18,"Select the troops to use in attacks"))
$y += 30
$g_hPicDBKingAttack = GUICtrlCreateIcon($g_sLibIconPath, $eIcnKing, $x , $y, 24, 24)
$sTxtTip = GetTranslated(624,20, "Use your King when Attacking...") & @CRLF & GetTranslated(624,41, "Enabled with TownHall 7 and higher")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBKingAttack = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicDBQueenAttack = GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueen, $x, $y, 24, 24)
$sTxtTip = GetTranslated(624,21, "Use your Queen when Attacking...")& @CRLF & GetTranslated(624,42, "Enabled with TownHall 9 and higher")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBQueenAttack = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x +=46
$g_hPicDBWardenAttack = GUICtrlCreateIcon($g_sLibIconPath, $eIcnWarden, $x, $y, 24, 24)
$sTxtTip = GetTranslated(624,22, "Use your Warden when Attacking...") & @CRLF & GetTranslated(624,43, "Enabled with Townhall 11")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBWardenAttack = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$y +=27
$x -=92
$g_hPicDBDropCC = GUICtrlCreateIcon($g_sLibIconPath, $eIcnCC, $x, $y, 24, 24)
$sTxtTip =GetTranslated(624,23, "Drop your Clan Castle in battle if it contains troops.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBDropCC = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicDBLightSpell = GUICtrlCreateIcon($g_sLibIconPath, $eIcnLightSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslated(624,24, "Use your Light Spells when Attacking...")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBLightSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x +=46
$g_hPicDBHealSpell = GUICtrlCreateIcon($g_sLibIconPath, $eIcnHealSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslated(624,25, "Use your Healing Spells when Attacking...")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBHealSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$y +=27
$x -=92
$g_hPicDBRageSpell = GUICtrlCreateIcon($g_sLibIconPath, $eIcnRageSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslated(624,26, "Use your Rage Spells when Attacking...")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBRageSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x +=46
$g_hPicDBJumpSpell = GUICtrlCreateIcon($g_sLibIconPath, $eIcnJumpSpell , $x, $y, 24, 24)
$sTxtTip =GetTranslated(624,27, "Use your Jump Spells when Attacking...")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBJumpSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicDBFreezeSpell=GUICtrlCreateIcon($g_sLibIconPath, $eIcnFreezeSpell , $x, $y, 24, 24)
$sTxtTip = GetTranslated(624,28, "Use your Freeze Spells when Attacking...")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBFreezeSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$y +=27
$x -=92
$g_hPicDBCloneSpell=GUICtrlCreateIcon($g_sLibIconPath, $eIcnCloneSpell , $x, $y, 24, 24)
$sTxtTip = GetTranslated(624,44, "Use your Clone Spells when Attacking...")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBCloneSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x +=46
$g_hPicDBPoisonSpell=GUICtrlCreateIcon($g_sLibIconPath, $eIcnPoisonSpell , $x, $y, 24, 24)
$sTxtTip = GetTranslated(624,29, "Use your Poison Spells when Attacking...")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBPoisonSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x +=46
$g_hPicDBEarthquakeSpell = GUICtrlCreateIcon($g_sLibIconPath, $eIcnEarthquakeSpell , $x, $y, 24, 24)
$sTxtTip = GetTranslated(624,30, "Use your Earthquake Spells when Attacking...")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBEarthquakeSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$y +=27
$x -=92
$g_hPicDBHasteSpell = GUICtrlCreateIcon($g_sLibIconPath, $eIcnHasteSpell, $x, $y, 24, 24)
$sTxtTip =GetTranslated(624,31, "Use your Haste Spells when Attacking...")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBHasteSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x +=46
$g_hPicDBSkeletonSpell=GUICtrlCreateIcon($g_sLibIconPath, $eIcnSkeletonSpell , $x, $y, 24, 24)
$sTxtTip = GetTranslated(624,45, "Use your Skeletons Spells when Attacking...")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkDBSkeletonSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 10, $y = 268
GUICtrlCreateGroup(GetTranslated(624,32, "TH Snipe"), $x - 5, $y - 20, 145, 84,$SS_CENTER)
$g_hChkTHSnipeBeforeDBEnable = GUICtrlCreateCheckbox(GetTranslated(624,33, "Snipe TH External first") ,$x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(624,34, "If TH is external start with a TH Snipe"))
GUICtrlSetOnEvent(-1, "chkTHSnipeBeforeDBEnable")
$y +=16
$g_hLblTHSnipeBeforeDBTiles = GUICtrlCreateLabel(GetTranslated(624,35, "Add Tiles")& ":", $x, $y + 3, 70, -1, $SS_RIGHT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hTxtTHSnipeBeforeDBTiles = GUICtrlCreateInput("2", $x + 75, $y + 1, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslated(624,36, "Max numbers of tiles from border to consider TH as external")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnTiles, $x + 107, $y + 1, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
$g_hCmbTHSnipeBeforeDBScript = GUICtrlCreateCombo("", $x, $y, 130, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "")
_GUICtrlSetTip(-1, GetTranslated(624,37, "You can add/edit CSV settings in the CSV\THSnipe folder"))
GUICtrlSetState(-1, $GUI_DISABLE)
LoadDBSnipeAttacks()
_GUICtrlComboBox_SetCurSel($g_hCmbTHSnipeBeforeDBScript,_GUICtrlComboBox_FindStringExact($g_hCmbTHSnipeBeforeDBScript, "Bam"))
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hChkStopAtkDBNoLoot1 = 0, $g_hTxtStopAtkDBNoLoot1 = 0, $g_hChkStopAtkDBNoLoot2 = 0, $g_hTxtStopAtkDBNoLoot2 = 0, $g_hTxtDBMinGoldStopAtk2 = 0, $g_hTxtDBMinElixirStopAtk2 = 0, $g_hTxtDBMinDarkElixirStopAtk2 = 0, $g_hChkDBEndNoResources = 0, $g_hChkDBEndOneStar = 0, $g_hChkDBEndTwoStars = 0, $g_hChkDBEndPercentHigher = 0, $g_hTxtDBPercentHigher = 0, $g_hChkDBEndPercentChange = 0, $g_hTxtDBPercentChange = 0
Global $g_hGrpDBEndBattle = 0, $g_hLblStopAtkDBNoLoot1a = 0, $g_hLblStopAtkDBNoLoot1b = 0, $g_hLblStopAtkDBNoLoot2a = 0, $g_hLblStopAtkDBNoLoot2b = 0, $g_hLblDBMinRerourcesAtk2 = 0, $g_hPicDBMinGoldStopAtk2 = 0, $g_hPicDBMinElixirStopAtk2 = 0, $g_hPicDBMinDarkElixirStopAtk2 = 0, $g_hLblDBPercentHigher = 0, $g_hLblDBPercentHigherSec = 0, $g_hLblDBPercentChange = 0, $g_hLblDBPercentChangeSec = 0
Func CreateAttackSearchDeadBaseEndBattle()
Local $sTxtTip = ""
Local $x = 10, $y = 45
$g_hGrpDBEndBattle = GUICtrlCreateGroup(GetTranslated(606,1, "Exit Battle"), $x - 5, $y - 20, 420, 345)
$y -=5
$g_hChkStopAtkDBNoLoot1 = GUICtrlCreateCheckbox(GetTranslated(606,2, "When no New loot") ,$x, $y, -1, -1)
$sTxtTip = GetTranslated(606,3, "End Battle if there is no extra loot raided within this No. of seconds.") & @CRLF & GetTranslated(606,4, "Countdown is started after all Troops and Royals are deployed in battle.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkStopAtkDBNoLoot1")
GUICtrlSetState(-1, $GUI_CHECKED)
$y +=20
$g_hLblStopAtkDBNoLoot1a = GUICtrlCreateLabel(GetTranslated(606,5, "raided within")& ":", $x + 16, $y + 3, -1, -1)
$g_hTxtStopAtkDBNoLoot1 = GUICtrlCreateInput("15", $x + 85, $y + 1, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
$g_hLblStopAtkDBNoLoot1b = GUICtrlCreateLabel(GetTranslated(603,6, "sec."), $x + 120, $y + 3, -1, -1)
$y += 20
$g_hChkStopAtkDBNoLoot2 = GUICtrlCreateCheckbox(GetTranslated(606,2, -1) ,$x, $y, -1, -1)
$sTxtTip = GetTranslated(606,3, -1) & @CRLF & GetTranslated(606,4, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkStopAtkDBNoLoot2")
GUICtrlSetState(-1, $GUI_UNCHECKED)
$y += 20
$g_hLblStopAtkDBNoLoot2a = GUICtrlCreateLabel(GetTranslated(606,5, -1)& ":", $x + 16, $y + 3, -1, -1)
$g_hTxtStopAtkDBNoLoot2 = GUICtrlCreateInput("5", $x + 85, $y + 1, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblStopAtkDBNoLoot2b = GUICtrlCreateLabel(GetTranslated(603,6, -1), $x + 120, $y + 3, -1, -1)
$y += 21
$g_hLblDBMinRerourcesAtk2 = GUICtrlCreateLabel(GetTranslated(606,7, "And Resources are below") & ":", $x + 16 , $y + 2, -1, -1)
$sTxtTip = GetTranslated(606,8, "End Battle if below this amount of Gold.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 21
$g_hTxtDBMinGoldStopAtk2 = GUICtrlCreateInput("2000", $x + 65, $y , 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hPicDBMinGoldStopAtk2 = GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 117, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
$g_hTxtDBMinElixirStopAtk2 = GUICtrlCreateInput("2000", $x + 65, $y , 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hPicDBMinElixirStopAtk2 = GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 117, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
$g_hTxtDBMinDarkElixirStopAtk2 = GUICtrlCreateInput("50", $x + 65, $y , 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 4)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hPicDBMinDarkElixirStopAtk2 = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 117, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
$g_hChkDBEndNoResources = GUICtrlCreateCheckbox(GetTranslated(606,9, "When no Resources left"), $x , $y , -1, -1)
_GUICtrlSetTip(-1, GetTranslated(606,10, "End Battle when all Gold, Elixir and Dark Elixir = 0"))
GUICtrlSetState(-1, $GUI_ENABLE)
$y += 21
$g_hChkDBEndOneStar = GUICtrlCreateCheckbox(GetTranslated(606,11, "When One Star is won") , $x, $y , -1, -1)
_GUICtrlSetTip(-1, GetTranslated(606,12, "Will End the Battle if 1 star is won in battle"))
GUICtrlSetState(-1, $GUI_ENABLE)
$y += 21
$g_hChkDBEndTwoStars = GUICtrlCreateCheckbox(GetTranslated(606,13, "When Two Stars are won") , $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(606,14, "Will End the Battle if 2 stars are won in battle"))
GUICtrlSetState(-1, $GUI_ENABLE)
$y += 21
$g_hChkDBEndPercentHigher = GUICtrlCreateCheckbox(GetTranslated(606,30, "When Percentage is"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(606,31, "End Battle if Overall Damage Percentage is above"))
GUICtrlSetState(-1, $GUI_ENABLE)
$y +=20
$g_hLblDBPercentHigher = GUICtrlCreateLabel(GetTranslated(606,32,"above") & ":", $x + 16 , $y + 2, -1, -1)
$g_hTxtDBPercentHigher = GUICtrlCreateInput("60", $x + 85, $y + 1, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(606,31, -1))
GUICtrlSetLimit(-1, 3)
$g_hLblDBPercentHigherSec = GUICtrlCreateLabel("%", $x + 120, $y + 3, -1, -1)
$y += 21
$g_hChkDBEndPercentChange = GUICtrlCreateCheckbox(GetTranslated(606,33,"When Percentage doesn't") , $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(606, 34,"End Battle when Percentage doesn't change in"))
GUICtrlSetState(-1, $GUI_ENABLE)
$y +=20
$g_hLblDBPercentChange = GUICtrlCreateLabel(GetTranslated(606, 35,"change in")& ":", $x + 16, $y + 3, -1, -1)
$g_hTxtDBPercentChange = GUICtrlCreateInput("15", $x + 85, $y + 1, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(606,34, -1))
GUICtrlSetLimit(-1, 2)
$g_hLblDBPercentChangeSec = GUICtrlCreateLabel(GetTranslated(603,6, -1), $x + 120, $y + 3, -1, -1)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hChkDBDisableCollectorsFilter = 0
Global $g_ahChkDBCollectorLevel[13] = [-1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0]
Global $g_ahCmbDBCollectorLevel[13] = [-1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0]
Global $g_hCmbMinCollectorMatches = 0, $g_hSldCollectorTolerance = 0, $g_hLblCollectorWarning = 0
Func CreateAttackSearchDeadBaseCollectors()
Local $x = 10, $y = 45
Local $s_TxtTip1 = GetTranslated(626,15, "If this box is checked, then the bot will look")
Local $g_hTxtFull = GetTranslated(626,30, "Full")
Local $sTxtTip = ""
GUICtrlCreateGroup(GetTranslated(626,1,"Collectors"), $x - 5, $y - 20, 420, 305)
GUICtrlCreateLabel(GetTranslated(626,2, "Choose which collectors to search for while looking for a dead base. Also, choose how full they must be."), $x, $y, 250, 28)
$g_hChkDBDisableCollectorsFilter = GUICtrlCreateCheckbox(GetTranslated(626,32,"Disable Collector Filter"), $x+250, $y+60, 150, 18)
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, GetTranslated(626,33, "Excluding Collector Filter the bot consider DeadBase as ActiveBase"))
$y+=40
$g_ahChkDBCollectorLevel[6] = GUICtrlCreateCheckbox("", $x, $y, 18, 18)
$sTxtTip = $s_TxtTip1 & @CRLF & GetTranslated(626,16, "for level 6 elixir collectors during dead base detection.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, BitOR($GUI_UNCHECKED, $GUI_DISABLE))
GUICtrlSetOnEvent(-1, "chkDBCollector")
GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 20, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(626,3, "Lvl 6. Must be >"), $x + 40, $y + 3, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahCmbDBCollectorLevel[6] = GUICtrlCreateCombo("", $x + 125, $y, 75, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslated(626,23,'Select how full a level 6 collector needs to be for it to be marked "dead"'))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetData(-1, "50%|100%", "50%")
GUICtrlSetOnEvent(-1, "cmbDBCollector")
GUICtrlCreateLabel($g_hTxtFull, $x + 205, $y + 3)
$y+= 25
$g_ahChkDBCollectorLevel[7] = GUICtrlCreateCheckbox("", $x, $y, 18, 18)
$sTxtTip = $s_TxtTip1 & @CRLF & GetTranslated(626,17, "for level 7 elixir collectors during dead base detection.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkDBCollector")
GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 20, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(626,4, "Lvl 7. Must be >"), $x + 40, $y + 3, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahCmbDBCollectorLevel[7] = GUICtrlCreateCombo("", $x + 125, $y, 75, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslated(626,24,'Select how full a level 7 collector needs to be for it to be marked "dead"'))
GUICtrlSetData(-1, "50%|100%", "50%")
GUICtrlSetOnEvent(-1, "cmbDBCollector")
GUICtrlCreateLabel($g_hTxtFull, $x + 205, $y + 3)
$y+= 25
$g_ahChkDBCollectorLevel[8] = GUICtrlCreateCheckbox("", $x, $y, 18, 18)
$sTxtTip = $s_TxtTip1 & @CRLF & GetTranslated(626,18,"for level 8 elixir collectors during dead base detection.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkDBCollector")
GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 20, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(626,5, "Lvl 8. Must be >"), $x + 40, $y + 3, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahCmbDBCollectorLevel[8] = GUICtrlCreateCombo("", $x + 125, $y, 75, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslated(626,25,'Select how full a level 8 collector needs to be for it to be marked "dead"'))
GUICtrlSetData(-1, "50%|100%", "50%")
GUICtrlSetOnEvent(-1, "cmbDBCollector")
GUICtrlCreateLabel($g_hTxtFull, $x + 205, $y + 3)
$y+= 25
$g_ahChkDBCollectorLevel[9] = GUICtrlCreateCheckbox("", $x, $y, 18, 18)
$sTxtTip = $s_TxtTip1 & @CRLF & GetTranslated(626,19,"for level 9 elixir collectors during dead base detection.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkDBCollector")
GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 20, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(626,6, "Lvl 9. Must be >"), $x + 40, $y + 3, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahCmbDBCollectorLevel[9] = GUICtrlCreateCombo("", $x + 125, $y, 75, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslated(626,26,'Select how full a level 9 collector needs to be for it to be marked "dead"'))
GUICtrlSetData(-1, "50%|100%", "50%")
GUICtrlSetOnEvent(-1, "cmbDBCollector")
GUICtrlCreateLabel($g_hTxtFull, $x + 205, $y + 3)
$y+= 25
$g_ahChkDBCollectorLevel[10] = GUICtrlCreateCheckbox("", $x, $y, 18, 18)
$sTxtTip = $s_TxtTip1 & @CRLF & GetTranslated(626,20,"for level 10 elixir collectors during dead base detection.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkDBCollector")
GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 20, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(626,7, "Lvl 10. Must be >"), $x + 40, $y + 3, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahCmbDBCollectorLevel[10] = GUICtrlCreateCombo("", $x + 125, $y, 75, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslated(626,27,'Select how full a level 10 collector needs to be for it to be marked "dead"'))
GUICtrlSetData(-1, "50%|100%", "50%")
GUICtrlSetOnEvent(-1, "cmbDBCollector")
GUICtrlCreateLabel($g_hTxtFull, $x + 205, $y + 3)
$y+= 25
$g_ahChkDBCollectorLevel[11] = GUICtrlCreateCheckbox("", $x, $y, 18, 18)
$sTxtTip = $s_TxtTip1 & @CRLF & GetTranslated(626,21,"for level 11 elixir collectors during dead base detection.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkDBCollector")
GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 20, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(626,8, "Lvl 11. Must be >"), $x + 40, $y + 3, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahCmbDBCollectorLevel[11] = GUICtrlCreateCombo("", $x + 125, $y, 75, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslated(626,28,'Select how full a level 11 collector needs to be for it to be marked "dead"'))
GUICtrlSetData(-1, "50%|100%", "50%")
GUICtrlSetOnEvent(-1, "cmbDBCollector")
GUICtrlCreateLabel($g_hTxtFull, $x + 205, $y + 3)
$y+= 25
$g_ahChkDBCollectorLevel[12] = GUICtrlCreateCheckbox("", $x, $y, 18, 18)
$sTxtTip = $s_TxtTip1 & @CRLF & GetTranslated(626,22,"for level 12 elixir collectors during dead base detection.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkDBCollector")
GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 20, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(626,9, "Lvl 12. Must be >"), $x + 40, $y + 3, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahCmbDBCollectorLevel[12] = GUICtrlCreateCombo("", $x + 125, $y, 75, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslated(626,29,'Select how full a level 12 collector needs to be for it to be marked "dead"'))
GUICtrlSetData(-1, "50%|100%", "50%")
GUICtrlSetOnEvent(-1, "cmbDBCollector")
GUICtrlCreateLabel($g_hTxtFull, $x + 205, $y + 3)
$y+= 25
GUICtrlCreateLabel(GetTranslated(626,34, "Collectors required"), $x, $y + 3, -1, -1)
$sTxtTip = GetTranslated(626,35,'Select how many collectors are needed to consider village "dead"')
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbMinCollectorMatches = GUICtrlCreateCombo("", $x + 125, $y, 75, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "1|2|3|4|5|6", "3")
GUICtrlSetOnEvent(-1, "cmbMinCollectorMatches")
$y += 25
GUICtrlCreateLabel("-15" & _PadStringCenter(GetTranslated(626,11, "Tolerance"), 66, " ") & "15", $x, $y)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 15
$g_hSldCollectorTolerance = GUICtrlCreateSlider($x, $y, 250, 20, BITOR($TBS_TOOLTIPS, $TBS_AUTOTICKS))
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
_GUICtrlSetTip(-1, GetTranslated(626,12, "Use this slider to adjust the tolerance of ALL images.") & @CRLF & GetTranslated(626,13, "If you want to adjust individual images, you must edit the files.") & @CRLF & GetTranslated(626,31,"WARNING: Do not change this setting unless you know what you are doing. Set it to 0 if you're not sure."))
_GUICtrlSlider_SetTipSide(-1, $TBTS_BOTTOM)
_GUICtrlSlider_SetTicFreq(-1,1)
GUICtrlSetLimit(-1, 15,-15)
GUICtrlSetData(-1, 0)
GUICtrlSetOnEvent(-1, "sldCollectorTolerance")
GUICtrlSetState(-1, $GUI_HIDE)
$y += 25
$g_hLblCollectorWarning = GUICtrlCreateLabel("Warning: no collecters are selected. The bot will never find a dead base.", $x, $y, 255, 30)
GUICtrlSetFont(-1, 10, $FW_BOLD)
GUICtrlSetColor(-1, $COLOR_ERROR)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_DEADBASE_TAB = 0, $g_hGUI_DEADBASE_TAB_ITEM1 = 0, $g_hGUI_DEADBASE_TAB_ITEM2 = 0, $g_hGUI_DEADBASE_TAB_ITEM3 = 0, $g_hGUI_DEADBASE_TAB_ITEM4 = 0
Func CreateAttackSearchDeadBase()
$g_hGUI_DEADBASE = GUICreate("", $_GUI_MAIN_WIDTH - 40, $_GUI_MAIN_HEIGHT - 315, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_SEARCH)
CreateAttackSearchDeadBaseStandard()
CreateAttackSearchDeadBaseScripted()
CreateAttackSearchDeadBaseMilking()
GUISwitch($g_hGUI_DEADBASE)
$g_hGUI_DEADBASE_TAB = GUICtrlCreateTab(0, 0, $_GUI_MAIN_WIDTH - 40, $_GUI_MAIN_HEIGHT - 315, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_DEADBASE_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslated(600,28,"Search"))
CreateAttackSearchDeadBaseSearch()
$g_hGUI_DEADBASE_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslated(600,29,"Attack"))
CreateAttackSearchDeadBaseAttack()
$g_hGUI_DEADBASE_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslated(600,30,"End Battle"))
CreateAttackSearchDeadBaseEndBattle()
$g_hGUI_DEADBASE_TAB_ITEM4 = GUICtrlCreateTabItem(GetTranslated(600,31,"Collectors"))
CreateAttackSearchDeadBaseCollectors()
EndFunc
Global $g_hGUI_ACTIVEBASE = 0
Global $g_hGUI_ACTIVEBASE_ATTACK_STANDARD = 0
Global $g_hCmbStandardDropOrderAB = 0, $g_hCmbStandardDropSidesAB = 0, $g_hCmbStandardUnitDelayAB = 0, $g_hCmbStandardWaveDelayAB = 0, $g_hChkRandomSpeedAtkAB = 0, $g_hChkSmartAttackRedAreaAB = 0, $g_hCmbSmartDeployAB = 0, $g_hChkAttackNearGoldMineAB = 0, $g_hChkAttackNearElixirCollectorAB = 0, $g_hChkAttackNearDarkElixirDrillAB = 0
Global $g_hLblSmartDeployAB = 0, $g_hPicAttackNearDarkElixirDrillAB = 0
Func CreateAttackSearchActiveBaseStandard()
$g_hGUI_ACTIVEBASE_ATTACK_STANDARD = GUICreate("", $_GUI_MAIN_WIDTH - 195, $_GUI_MAIN_HEIGHT - 344, 150, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_ACTIVEBASE)
Local $sTxtTip = ""
Local $x = 25, $y = 20
GUICtrlCreateGroup(GetTranslated(608,1, -1), $x - 20, $y - 20, 270, 306)
GUICtrlCreateLabel(GetTranslated(608,2, -1),$x, $y, 143,18,$SS_LEFT)
$y += 15
$g_hCmbStandardDropOrderAB = GUICtrlCreateCombo("", $x, $y, 150, Default, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslated(608,25, -1)&"|Barch/BAM/BAG|GiBarch", GetTranslated(608,25, -1))
_GUICtrlSetTip(-1, GetTranslated(608,33, -1)&@CRLF&GetTranslated(608,34, -1))
$y += 25
GUICtrlCreateLabel(GetTranslated(608,3, "Attack on")&":", $x, $y + 5, -1, -1)
$g_hCmbStandardDropSidesAB = GUICtrlCreateCombo("", $x + 55, $y, 120, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslated(608,4, -1) & @CRLF & GetTranslated(608,5, -1) & @CRLF & GetTranslated(608,6, -1) & @CRLF & "Attack on Classic Four Fingers" & @CRLF & GetTranslated(608,29, "Attack on the single side closest to the Dark Elixir Storage") & @CRLF & GetTranslated(608,30, "Attack on the single side closest to the Townhall"), GetTranslated(608,7, -1))
GUICtrlSetData(-1, GetTranslated(608,8, -1) & "|" & GetTranslated(608,9, -1) & "|" & GetTranslated(608,10, -1) & "|" & GetTranslated(608,11, -1) & "|" & "Classic Four Fingers" & "|" & GetTranslated(608,31, "DE Side Attack") & "|" & GetTranslated(608,32, "TH Side Attack"), GetTranslated(608,11, -1))
GUICtrlSetOnEvent(-1,"cmbDeployAB")
$y += 25
GUICtrlCreateLabel(GetTranslated(608,12, -1) & ":", $x, $y + 5, -1, -1)
$sTxtTip = GetTranslated(608,13, -1) & @CRLF & GetTranslated(608,14, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbStandardUnitDelayAB = GUICtrlCreateCombo("", $x + 55, $y, 36, 21, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "1|2|3|4|5|6|7|8|9|10", "4")
GUICtrlCreateLabel(GetTranslated(608,15, -1) & ":", $x + 100, $y + 5, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbStandardWaveDelayAB = GUICtrlCreateCombo("", $x + 140, $y, 36, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "1|2|3|4|5|6|7|8|9|10", "4")
$y += 22
$g_hChkRandomSpeedAtkAB = GUICtrlCreateCheckbox(GetTranslated(608,16, -1), $x, $y, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkRandomSpeedAtkAB")
$y +=22
$g_hChkSmartAttackRedAreaAB = GUICtrlCreateCheckbox(GetTranslated(608,17, -1), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(608,18, -1))
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkSmartAttackRedAreaAB")
$y += 22
$g_hLblSmartDeployAB = GUICtrlCreateLabel(GetTranslated(608,19, -1) & ":", $x, $y + 5, -1, -1)
$sTxtTip = GetTranslated(608,20, -1) & @CRLF & GetTranslated(608,21, -1) & @CRLF & GetTranslated(608,22, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hCmbSmartDeployAB = GUICtrlCreateCombo("", $x + 55, $y, 120, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslated(608,23, -1) & "|" & GetTranslated(608,24, -1) , GetTranslated(608,23, -1))
_GUICtrlSetTip(-1, $sTxtTip)
$y += 26
$g_hChkAttackNearGoldMineAB = GUICtrlCreateCheckbox("", $x + 20, $y, 17, 17)
$sTxtTip = GetTranslated(608,26, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnMine, $x + 40 , $y - 3 , 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 75
$g_hChkAttackNearElixirCollectorAB = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
$sTxtTip = GetTranslated(608,27, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 20 , $y - 3 , 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 55
$g_hChkAttackNearDarkElixirDrillAB = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
$sTxtTip = GetTranslated(608,28, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicAttackNearDarkElixirDrillAB = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDrill, $x + 20 , $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
EndFunc
Global $g_hGUI_ACTIVEBASE_ATTACK_SCRIPTED = 0
Global $g_hCmbScriptNameAB = 0, $g_hCmbScriptRedlineImplAB = 0, $g_hCmbScriptDroplineAB = 0
Global $g_hLblNotesScriptAB = 0
Func CreateAttackSearchActiveBaseScripted()
$g_hGUI_ACTIVEBASE_ATTACK_SCRIPTED = GUICreate("", $_GUI_MAIN_WIDTH - 195, $_GUI_MAIN_HEIGHT - 344, 150, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_ACTIVEBASE)
Local $x = 25, $y = 20
GUICtrlCreateGroup(GetTranslated(607,1, -1), $x - 20, $y - 20, 270, 306)
$y +=15
$g_hCmbScriptNameAB = GUICtrlCreateCombo("", $x , $y, 200, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL, $WS_VSCROLL))
_GUICtrlSetTip(-1, GetTranslated(607,4, -1))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "cmbScriptNameAB")
GUICtrlCreateIcon($g_sLibIconPath, $eIcnReload, $x + 210, $y + 2, 16, 16)
_GUICtrlSetTip(-1, GetTranslated(607,5, -1))
GUICtrlSetOnEvent(-1, 'UpdateComboScriptNameAB')
$y +=25
$g_hLblNotesScriptAB = GUICtrlCreateLabel("", $x, $y + 5, 200, 180)
$g_hCmbScriptRedlineImplAB = GUICtrlCreateCombo("", $x, $y + 195, 230, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslated(607,9, "ImgLoc Raw Redline (default)|ImgLoc Redline Drop Points|Original Redline|External Edges"))
_GUICtrlComboBox_SetCurSel(-1, $g_aiAttackScrRedlineRoutine[$LB])
_GUICtrlSetTip(-1, GetTranslated(607,10, "Choose the Redline implementation. ImgLoc Redline is default and best."))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "cmbScriptRedlineImplAB")
$g_hCmbScriptDroplineAB = GUICtrlCreateCombo("", $x, $y + 220, 230, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslated(607,11, "Drop line fix outer corner|Drop line fist Redline point|Full Drop line fix outer corner|Full Drop line fist Redline point|No Drop line"))
_GUICtrlComboBox_SetCurSel(-1, $g_aiAttackScrDroplineEdge[$LB])
_GUICtrlSetTip(-1, GetTranslated(607,12, "Choose the drop line edges. Default is outer corner and safer. First Redline point can improve attack."))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "cmbScriptDroplineAB")
GUICtrlCreateIcon($g_sLibIconPath, $eIcnEdit, $x + 210, $y + 2, 16, 16)
_GUICtrlSetTip(-1, GetTranslated(607,6, -1))
GUICtrlSetOnEvent(-1, "EditScriptAB")
$y +=25
GUICtrlCreateIcon($g_sLibIconPath, $eIcnAddcvs, $x + 210, $y + 2, 16, 16)
_GUICtrlSetTip(-1, GetTranslated(607,7, -1))
GUICtrlSetOnEvent(-1, "NewScriptAB")
$y +=25
GUICtrlCreateIcon($g_sLibIconPath, $eIcnCopy, $x + 210, $y + 2, 16, 16)
_GUICtrlSetTip(-1, GetTranslated(607,8, -1))
GUICtrlSetOnEvent(-1, "DuplicateScriptAB")
GUICtrlCreateGroup("", -99, -99, 1, 1)
UpdateComboScriptNameAB()
Local $tempindex = _GUICtrlComboBox_FindStringExact($g_hCmbScriptNameAB, $g_sAttackScrScriptName[$LB])
If $tempindex = -1 Then $tempindex = 0
_GUICtrlComboBox_SetCurSel($g_hCmbScriptNameAB, $tempindex)
EndFunc
Global $g_hChkABActivateSearches = 0, $g_hTxtABSearchesMin = 0, $g_hTxtABSearchesMax = 0
Global $g_hChkABActivateTropies = 0, $g_hTxtABTropiesMin = 0, $g_hTxtABTropiesMax = 0
Global $g_hChkABActivateCamps = 0, $g_hTxtABArmyCamps = 0
Global $g_hChkABKingWait = 0, $g_hChkABQueenWait = 0, $g_hChkABWardenWait = 0
Global $g_hChkABSpellsWait = 0, $g_hChkABWaitForCastleSpell = 0, $g_hCmbABWaitForCastleSpell = 0,$g_hCmbABWaitForCastleSpell2 = 0, $g_hTxtABWaitForCastleSpell = 0, $g_hChkABWaitForCastleTroops = 0
Global $g_hLblABSearches = 0, $g_hLblABTropies = 0, $g_hLblABArmyCamps = 0
Global $g_hPicABHeroesWait = 0, $g_hTxtABHeroesWait = 0, $g_hPicABKingWait = 0, $g_hPicABKingSleepWait = 0, $g_hPicABQueenWait = 0, $g_hPicABQueenSleepWait = 0, $g_hPicABWardenWait = 0, $g_hPicABWardenSleepWait = 0
Global $g_hPicABLightSpellWait = 0, $g_hPicABHealSpellWait = 0, $g_hPicABRageSpellWait = 0, $g_hPicABJumpSpellWait = 0, $g_hPicABFreezeSpellWait = 0, $g_hPicABPoisonSpellWait = 0, $g_hPicABEarthquakeSpellWait = 0, $g_hPicABHasteSpellWait = 0
Global $g_hCmbABMeetGE = 0, $g_hTxtABMinGold = 0, $g_hTxtABMinElixir = 0, $g_hTxtABMinGoldPlusElixir = 0
Global $g_hChkABMeetDE = 0, $g_hTxtABMinDarkElixir = 0
Global $g_hChkABMeetTrophy = 0, $g_hTxtABMinTrophy = 0
Global $g_hChkABMeetTH = 0, $g_hCmbABTH = 0, $g_hChkABMeetTHO = 0
Global $g_hGrpABFilter = 0, $g_hPicABMinGold = 0, $g_hPicABMinElixir = 0, $g_hPicABMinGPEGold = 0, $g_hPicABMinDarkElixir = 0, $g_hPicABMinTrophies = 0, $g_hPicABMaxTH10 = 0
Func CreateAttackSearchActiveBaseSearch()
Local $sTxtLightningSpells = GetTranslated(605,15,"Lightning")
Local $sTxtHealSpells = GetTranslated(605,16,"Heal")
Local $sTxtRageSpells = GetTranslated(605,17,"Rage")
Local $sTxtJumpSpells = GetTranslated(605,18,"Jump")
Local $sTxtFreezeSpells = GetTranslated(605,19,"Freeze")
Local $sTxtPoisonSpells = GetTranslated(605,9, "Poison")
Local $sTxtEarthquakeSpells = GetTranslated(605,10, "EarthQuake")
Local $sTxtHasteSpells = GetTranslated(605,11, "Haste")
Local $sTxtSkeletonSpells = GetTranslated(605,14, "Skeleton")
Local $sTxtTip = ""
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslated(625,0, -1), $x - 20, $y - 20, 190, 305)
$x -= 15
$g_hChkABActivateSearches = GUICtrlCreateCheckbox(GetTranslated(625,1, -1), $x, $y, 68, 18)
_GUICtrlSetTip(-1, GetTranslated(625,68, -1) & @CRLF & GetTranslated(625,69, -1))
GUICtrlSetState(-1,$GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "chkABActivateSearches")
$g_hTxtABSearchesMin = GUICtrlCreateInput("1", $x + 70, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(625,2, -1) & @CRLF & @CRLF & GetTranslated(625,68, -1) & @CRLF & GetTranslated(625,69, -1))
GUICtrlSetLimit(-1, 6)
$g_hLblABSearches = GUICtrlCreateLabel("-", $x + 113, $y + 2, -1, -1)
$g_hTxtABSearchesMax = GUICtrlCreateInput("9999", $x + 120, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(625,3, -1) & @CRLF & @CRLF & GetTranslated(625,68, -1) & @CRLF & GetTranslated(625,69,-1))
GUICtrlSetLimit(-1, 6)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnMagnifier, $x + 163, $y + 1, 16, 16)
$y +=21
$g_hChkABActivateTropies = GUICtrlCreateCheckbox(GetTranslated(625,4, -1), $x, $y, 68, 18)
_GUICtrlSetTip(-1, GetTranslated(625,68, -1) & @CRLF & GetTranslated(625,70,-1))
GUICtrlSetOnEvent(-1, "chkABActivateTropies")
$g_hTxtABTropiesMin = GUICtrlCreateInput("0", $x + 70, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1,$GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(625,5, -1) & @CRLF & @CRLF & GetTranslated(625,68, -1) & @CRLF & GetTranslated(625,70,-1))
GUICtrlSetLimit(-1, 6)
$g_hLblABTropies = GUICtrlCreateLabel("-", $x + 113, $y + 2, -1, -1)
GUICtrlSetState(-1,$GUI_DISABLE)
$g_hTxtABTropiesMax = GUICtrlCreateInput("6000", $x + 120, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1,$GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(625,6, -1) & @CRLF & @CRLF & GetTranslated(625,68, -1) & @CRLF & GetTranslated(625,70,-1))
GUICtrlSetLimit(-1, 6)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 163, $y + 1, 16, 16)
$y +=21
$g_hChkABActivateCamps = GUICtrlCreateCheckbox(GetTranslated(625,7, -1), $x, $y, 110, 18)
$sTxtTip = GetTranslated(625,8, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkABActivateCamps")
$g_hLblABArmyCamps = GUICtrlCreateLabel(ChrW(8805), $x + 113 - 1, $y + 2, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1,$GUI_DISABLE)
$g_hTxtABArmyCamps = GUICtrlCreateInput("100", $x + 120, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1,$GUI_DISABLE)
GUICtrlSetLimit(-1, 6)
GUICtrlCreateLabel("%", $x + 163 + 3, $y + 4, -1, -1)
GUICtrlSetState(-1,$GUI_DISABLE)
$y +=23
$g_hPicABHeroesWait = GUICtrlCreateIcon($g_sLibIconPath, $eIcnHourGlass, $x - 1, $y + 3, 16, 16)
$g_hTxtABHeroesWait = GUICtrlCreateLabel(GetTranslated(625,9, -1) & ":", $x + 20, $y + 4, 180, 18)
$y += 20
$x += 20
$g_hChkABKingWait = GUICtrlCreateCheckbox("", $x , $y + 55, 16, 16)
$sTxtTip = GetTranslated(625,10, -1) & @CRLF & GetTranslated(625, 50, -1) & @CRLF & GetTranslated(625, 65, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkABKingWait")
$g_hPicABKingWait = GUICtrlCreateIcon($g_sLibIconPath, $eIcnKing, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicABKingSleepWait = GUICtrlCreateIcon($g_sLibIconPath, $eIcnSleepingKing, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1,$GUI_HIDE)
$x += 55
$g_hChkABQueenWait = GUICtrlCreateCheckbox("", $x , $y + 55, 16, 16)
$sTxtTip = GetTranslated(625,12, -1) & @CRLF & GetTranslated(625, 50, -1) & @CRLF & GetTranslated(625, 66, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkABQueenWait")
$g_hPicABQueenWait = GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueen, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicABQueenSleepWait = GUICtrlCreateIcon($g_sLibIconPath, $eIcnSleepingQueen, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1,$GUI_HIDE)
$x += 55
$g_hChkABWardenWait = GUICtrlCreateCheckbox("", $x , $y + 55, 16, 16)
$sTxtTip = GetTranslated(625,13, -1) & @CRLF & GetTranslated(625, 50, -1) & @CRLF & GetTranslated(625, 67, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkABWardenWait")
$g_hPicABWardenWait = GUICtrlCreateIcon($g_sLibIconPath, $eIcnWarden, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hPicABWardenSleepWait = GUICtrlCreateIcon($g_sLibIconPath, $eIcnSleepingWarden, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1,$GUI_HIDE)
$y += 80
$x = 8
$g_hPicABLightSpellWait = GUICtrlCreateIcon($g_sLibIconPath, $eIcnLightSpell, $x, $y, 22, 22)
$g_hPicABHealSpellWait = GUICtrlCreateIcon($g_sLibIconPath, $eIcnHealSpell, $x+23, $y, 22, 22)
$g_hPicABRageSpellWait = GUICtrlCreateIcon($g_sLibIconPath, $eIcnRageSpell, $x+46, $y, 22, 22)
$g_hPicABJumpSpellWait = GUICtrlCreateIcon($g_sLibIconPath, $eIcnJumpSpell , $x+69, $y, 22, 22)
$g_hPicABFreezeSpellWait = GUICtrlCreateIcon($g_sLibIconPath, $eIcnFreezeSpell , $x+92, $y, 22, 22)
$g_hPicABPoisonSpellWait = GUICtrlCreateIcon($g_sLibIconPath, $eIcnPoisonSpell , $x+115, $y, 22, 22)
$g_hPicABEarthquakeSpellWait = GUICtrlCreateIcon($g_sLibIconPath, $eIcnEarthquakeSpell , $x+138, $y, 22, 22)
$g_hPicABHasteSpellWait = GUICtrlCreateIcon($g_sLibIconPath, $eIcnHasteSpell, $x+161, $y, 22, 22)
$y += 22
$x = 10
$x = 10
$g_hChkABSpellsWait = GUICtrlCreateCheckbox(GetTranslated(625,71, -1), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(625,72, -1) & @CRLF & GetTranslated(625,73, -1))
GUICtrlSetOnEvent(-1, "chkABSpellsWait")
$g_hChkABWaitForCastleSpell = GUICtrlCreateCheckbox(GetTranslated(625,74, -1), $x, $y + 25, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(625,75, -1))
GUICtrlSetOnEvent(-1, "chkABWaitForCCSpell")
$g_hCmbABWaitForCastleSpell = GUICtrlCreateCombo(GetTranslated(625,76, "Any"), $x, $y + 50, 70, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtLightningSpells & "|" & $sTxtHealSpells & "|" & $sTxtRageSpells & "|" & $sTxtJumpSpells & "|" & $sTxtFreezeSpells & "|" & $sTxtPoisonSpells & "|" & $sTxtEarthquakeSpells & "|" & $sTxtHasteSpells & "|" & $sTxtSkeletonSpells)
_GUICtrlSetTip(-1, GetTranslated(625,77, -1))
GUICtrlSetOnEvent(-1, "cmbABWaitForCCSpell")
$g_hTxtABWaitForCastleSpell = GUICtrlCreateLabel(GetTranslated(641, 40, "And"), $x + 80, $y + 53, -1, -1)
$g_hCmbABWaitForCastleSpell2 = GUICtrlCreateCombo(GetTranslated(625,76, "Any"),$x + 110, $y + 50, 70, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtPoisonSpells & "|" & $sTxtEarthquakeSpells & "|" & $sTxtHasteSpells & "|" & $sTxtSkeletonSpells)
_GUICtrlSetTip(-1, GetTranslated(625,75, -1))
$g_hChkABWaitForCastleTroops = GUICtrlCreateCheckbox(GetTranslated(625,78, -1), $x, $y + 75, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(625,79, -1))
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 220, $y = 45
$g_hGrpABFilter = GUICtrlCreateGroup(GetTranslated(625,14, -1), $x - 20, $y - 20, 225, 305)
$x -= 15
$g_hCmbABMeetGE = GUICtrlCreateCombo("", $x , $y + 10, 65, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslated(625,19, -1) &"|" & GetTranslated(625,20, -1) & "|" & GetTranslated(625,21, -1), GetTranslated(625,19, -1))
_GUICtrlSetTip(-1, GetTranslated(625,15, -1) & @CRLF & GetTranslated(625,16, -1) & @CRLF & GetTranslated(625,17, -1) & @CRLF & GetTranslated(625,18, -1))
GUICtrlSetOnEvent(-1, "cmbABGoldElixir")
$g_hTxtABMinGold = GUICtrlCreateInput("80000", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslated(625,23, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
$g_hPicABMinGold = GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 137, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
$g_hTxtABMinElixir = GUICtrlCreateInput("80000", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslated(625,24, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
$g_hPicABMinElixir = GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 137, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y -= 11
$g_hTxtABMinGoldPlusElixir = GUICtrlCreateInput("160000", $x + 85, $y, 50, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslated(625,25, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicABMinGPEGold = GUICtrlCreateIcon($g_sLibIconPath, $eIcnGoldElixir, $x + 137, $y + 1, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 34
$g_hChkABMeetDE = GUICtrlCreateCheckbox(GetTranslated(625,26, -1), $x, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkABMeetDE")
_GUICtrlSetTip(-1, GetTranslated(625,27, -1))
$g_hTxtABMinDarkElixir = GUICtrlCreateInput("0", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslated(625,28, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 5)
_GUICtrlEdit_SetReadOnly(-1, True)
$g_hPicABMinDarkElixir = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 137, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$g_hChkABMeetTrophy = GUICtrlCreateCheckbox(GetTranslated(625,4, -1), $x, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkABMeetTrophy")
_GUICtrlSetTip(-1, GetTranslated(625,29, -1))
$g_hTxtABMinTrophy = GUICtrlCreateInput("0", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslated(625,30, -1)
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlEdit_SetReadOnly(-1, True)
GUICtrlSetLimit(-1, 2)
$g_hPicABMinTrophies = GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 137, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$g_hChkABMeetTH = GUICtrlCreateCheckbox(GetTranslated(625,31, -1), $x, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkABMeetTH")
_GUICtrlSetTip(-1, GetTranslated(625,32, -1))
$g_hCmbABTH = GUICtrlCreateCombo("", $x + 85, $y - 1, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslated(625,33, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetData(-1, "4-6|7|8|9|10|11", "4-6")
$g_hPicABMaxTH10 = GUICtrlCreateIcon($g_sLibIconPath, $eIcnTH10, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$g_hChkABMeetTHO = GUICtrlCreateCheckbox(GetTranslated(625,34, -1), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(625,35, -1))
$y += 24
GUICtrlCreateGroup(GetTranslated(625,80, -1), $x, $y, 215, 100)
$x += 5
$y += 20
Local $xStartColumn = $x, $yStartColumn = $y
$g_ahChkMaxMortar[$LB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
_GUICtrlSetTip(-1, GetTranslated(625,59, -1))
GUICtrlSetOnEvent(-1, "chkABWeakBase")
$g_ahCmbWeakMortar[$LB] = GUICtrlCreateCombo("", $x + 19, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslated(625,38, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3|Lvl 4|Lvl 5|Lvl 6|Lvl 7|Lvl 8", "Lvl 5")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahPicWeakMortar[$LB] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnMortar, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y +=24
$g_ahChkMaxWizTower[$LB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
_GUICtrlSetTip(-1, GetTranslated(625,60, -1))
GUICtrlSetOnEvent(-1, "chkABWeakBase")
$g_ahCmbWeakWizTower[$LB] = GUICtrlCreateCombo("", $x + 19, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslated(625,39, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3|Lvl 4|Lvl 5|Lvl 6|Lvl 7|Lvl 8|Lvl 9", "Lvl 4")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahPicWeakWizTower[$LB] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnWizTower, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$g_ahChkMaxAirDefense[$LB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
_GUICtrlSetTip(-1, GetTranslated(625,64, -1))
GUICtrlSetOnEvent(-1, "chkABWeakBase")
$g_ahCmbWeakAirDefense[$LB] = GUICtrlCreateCombo("", $x + 19, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslated(625,81, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3|Lvl 4|Lvl 5|Lvl 6|Lvl 7|Lvl 8", "Lvl 7")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahPicWeakAirDefense[$LB] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnAirdefense, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$x = $xStartColumn + 104
$y = $yStartColumn
$g_ahChkMaxXBow[$LB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
_GUICtrlSetTip(-1, GetTranslated(625,61, -1))
GUICtrlSetOnEvent(-1, "chkABWeakBase")
$g_ahCmbWeakXBow[$LB] = GUICtrlCreateCombo("", $x + 19, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslated(625,51, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3|Lvl 4", "Lvl 2")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahPicWeakXBow[$LB] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnXBow3, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y +=24
$g_ahChkMaxInferno[$LB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
_GUICtrlSetTip(-1, GetTranslated(625,62, -1))
GUICtrlSetOnEvent(-1, "chkABWeakBase")
$g_ahCmbWeakInferno[$LB] = GUICtrlCreateCombo("", $x + 19, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslated(625,52, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3", "Lvl 2")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahPicWeakInferno[$LB] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnInferno4, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y +=24
$g_ahChkMaxEagle[$LB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
_GUICtrlSetTip(-1, GetTranslated(625,63, -1))
GUICtrlSetOnEvent(-1, "chkABWeakBase")
$g_ahCmbWeakEagle[$LB] = GUICtrlCreateCombo("", $x + 19, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslated(625,53, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2", "Lvl 1")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahPicWeakEagle[$LB] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnEagleArt, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 44
$x = $xStartColumn
$g_ahChkMeetOne[$LB] = GUICtrlCreateCheckbox(GetTranslated(625,40, -1), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(625,41, -1))
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hCmbABAlgorithm = 0, $g_hCmbABSelectTroop = 0, $g_hChkABKingAttack = 0, $g_hChkABQueenAttack = 0, $g_hChkABWardenAttack = 0, $g_hChkABDropCC = 0
Global $g_hChkABLightSpell = 0, $g_hChkABHealSpell = 0, $g_hChkABRageSpell = 0, $g_hChkABJumpSpell = 0, $g_hChkABFreezeSpell = 0, $g_hChkABCloneSpell = 0, $g_hChkABPoisonSpell = 0, $g_hChkABEarthquakeSpell = 0, $g_hChkABHasteSpell = 0, $g_hChkABSkeletonSpell = 0
Global $g_hGrpABAttack = 0, $g_hPicABKingAttack = 0, $g_hPicABQueenAttack = 0, $g_hPicABWardenAttack = 0, $g_hPicABDropCC = 0
Global $g_hPicABLightSpell = 0, $g_hPicABHealSpell = 0, $g_hPicABRageSpell = 0, $g_hPicABJumpSpell = 0, $g_hPicABFreezeSpell = 0, $g_hPicABCloneSpell = 0, $g_hPicABPoisonSpell = 0, $g_hPicABEarthquakeSpell = 0, $g_hPicABHasteSpell = 0, $g_hPicABSkeletonSpell = 0
Global $g_hChkTHSnipeBeforeLBEnable = 0, $g_hTxtTHSnipeBeforeLBTiles = 0, $g_hCmbTHSnipeBeforeLBScript = 0
Global $g_hLblTHSnipeBeforeLBTiles = 0
Func CreateAttackSearchActiveBaseAttack()
Local $sTxtTip = ""
Local $x = 25, $y = 40
$g_hGrpABAttack = GUICtrlCreateGroup(GetTranslated(624,1, -1), $x - 20, $y - 15, 145, 223)
$x -= 15
$y += 5
$g_hCmbABAlgorithm = GUICtrlCreateCombo("", $x, $y, 135, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, "")
GUICtrlSetData(-1, GetTranslated(624,3, -1) & "|" & GetTranslated(624,4, -1) , GetTranslated(624,3,-1))
GUICtrlSetOnEvent(-1, "cmbABAlgorithm")
$y += 30
$g_hCmbABSelectTroop=GUICtrlCreateCombo("", $x, $y, 135, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslated(624,7, -1) & "|" & GetTranslated(624,8, -1) & "|" & GetTranslated(624,9, -1) & "|" & GetTranslated(624,10, -1) & "|" & GetTranslated(624,11, -1) & "|" & GetTranslated(624,12, -1) & "|" & GetTranslated(624,13, -1) & "|" & GetTranslated(624,14, -1) & "|" & GetTranslated(624,15, -1) & "|" & GetTranslated(624,16, -1) & "|" & GetTranslated(624,17, -1), GetTranslated(624,7, -1))
_GUICtrlSetTip(-1, GetTranslated(624,18, -1))
$y += 30
$g_hPicABKingAttack=GUICtrlCreateIcon($g_sLibIconPath, $eIcnKing, $x , $y, 24, 24)
$sTxtTip = GetTranslated(624,20, -1) & @CRLF & GetTranslated(624, 41, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABKingAttack = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicABQueenAttack=GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueen, $x, $y, 24, 24)
$sTxtTip = GetTranslated(624,21, -1) & @CRLF & GetTranslated(624, 42, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABQueenAttack = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x +=46
$g_hPicABWardenAttack=GUICtrlCreateIcon($g_sLibIconPath, $eIcnWarden, $x, $y, 24, 24)
$sTxtTip = GetTranslated(624,22, -1) & @CRLF & GetTranslated(624, 43, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABWardenAttack = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$y +=27
$x -=92
$g_hPicABDropCC=GUICtrlCreateIcon($g_sLibIconPath, $eIcnCC, $x, $y, 24, 24)
$sTxtTip = GetTranslated(624,23, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABDropCC = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicABLightSpell=GUICtrlCreateIcon($g_sLibIconPath, $eIcnLightSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslated(624,24, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABLightSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x +=46
$g_hPicABHealSpell=GUICtrlCreateIcon($g_sLibIconPath, $eIcnHealSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslated(624,25, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABHealSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$y +=27
$x -=92
$g_hPicABRageSpell=GUICtrlCreateIcon($g_sLibIconPath, $eIcnRageSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslated(624,26, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABRageSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x +=46
$g_hPicABJumpSpell=GUICtrlCreateIcon($g_sLibIconPath, $eIcnJumpSpell , $x, $y, 24, 24)
$sTxtTip =GetTranslated(624,27, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABJumpSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicABFreezeSpell=GUICtrlCreateIcon($g_sLibIconPath, $eIcnFreezeSpell , $x, $y, 24, 24)
$sTxtTip = GetTranslated(624,28, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABFreezeSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$y +=27
$x -=92
$g_hPicABCloneSpell=GUICtrlCreateIcon($g_sLibIconPath, $eIcnCloneSpell , $x, $y, 24, 24)
$sTxtTip = GetTranslated(624,44, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABCloneSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x +=46
$g_hPicABPoisonSpell=GUICtrlCreateIcon($g_sLibIconPath, $eIcnPoisonSpell , $x, $y, 24, 24)
$sTxtTip = GetTranslated(624,29, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABPoisonSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x +=46
$g_hPicABEarthquakeSpell=GUICtrlCreateIcon($g_sLibIconPath, $eIcnEarthquakeSpell , $x, $y, 24, 24)
$sTxtTip = GetTranslated(624,30, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABEarthquakeSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$y +=27
$x -=92
$g_hPicABHasteSpell=GUICtrlCreateIcon($g_sLibIconPath, $eIcnHasteSpell, $x, $y, 24, 24)
$sTxtTip =GetTranslated(624,31, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABHasteSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x +=46
$g_hPicABSkeletonSpell=GUICtrlCreateIcon($g_sLibIconPath, $eIcnSkeletonSpell , $x, $y, 24, 24)
$sTxtTip = GetTranslated(624,45, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkABSkeletonSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 10, $y = 268
GUICtrlCreateGroup(GetTranslated(624,32, -1), $x - 5, $y - 20, 145, 84,$SS_CENTER)
$g_hChkTHSnipeBeforeLBEnable = GUICtrlCreateCheckbox(GetTranslated(624,33, -1) ,$x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(624,34, -1))
GUICtrlSetOnEvent(-1, "chkTHSnipeBeforeLBEnable")
$y += 16
$g_hLblTHSnipeBeforeLBTiles = GUICtrlCreateLabel(GetTranslated(624,35, -1)& ":", $x, $y + 3, 70, -1, $SS_RIGHT)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hTxtTHSnipeBeforeLBTiles = GUICtrlCreateInput("2", $x + 75, $y + 1, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslated(624,36, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnTiles, $x + 107, $y + 1, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
$g_hCmbTHSnipeBeforeLBScript = GUICtrlCreateCombo("", $x, $y, 130, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "")
_GUICtrlSetTip(-1, GetTranslated(624,37, -1))
GUICtrlSetState(-1, $GUI_DISABLE)
LoadABSnipeAttacks()
_GUICtrlComboBox_SetCurSel($g_hCmbTHSnipeBeforeLBScript,_GUICtrlComboBox_FindStringExact($g_hCmbTHSnipeBeforeLBScript, "Bam"))
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hChkStopAtkABNoLoot1 = 0, $g_hTxtStopAtkABNoLoot1 = 0, $g_hChkStopAtkABNoLoot2 = 0, $g_hTxtStopAtkABNoLoot2 = 0, $g_hTxtABMinGoldStopAtk2 = 0, $g_hTxtABMinElixirStopAtk2 = 0, $g_hTxtABMinDarkElixirStopAtk2 = 0, $g_hChkABEndNoResources = 0, $g_hChkABEndOneStar = 0, $g_hChkABEndTwoStars = 0, $g_hChkABEndPercentHigher = 0, $g_hTxtABPercentHigher = 0, $g_hChkABEndPercentChange = 0, $g_hTxtABPercentChange = 0
Global $g_hChkDESideEB = 0, $g_hTxtDELowEndMin = 0, $g_hChkDisableOtherEBO = 0, $g_hChkDEEndOneStar = 0, $g_hChkDEEndBk = 0, $g_hChkDEEndAq = 0
Global $g_hGrpABEndBattle = 0, $g_hLblABTimeStopAtka = 0, $g_hLblABTimeStopAtk = 0, $g_hLblABTimeStopAtk2a = 0, $g_hLblABTimeStopAtk2 = 0, $g_hLblABMinRerourcesAtk2 = 0, $g_hPicABMinGoldStopAtk2 = 0, $g_hPicABMinElixirStopAtk2 = 0, $g_hPicABMinDarkElixirStopAtk2 = 0
Global $g_hLblDELowEndMin = 0, $g_hLblDEEndAq = 0, $g_hLblABPercentHigher = 0, $g_hLblABPercentHigherSec = 0, $g_hLblABPercentChange = 0, $g_hLblABPercentChangeSec = 0
Func CreateAttackSearchActiveBaseEndBattle()
Local $sTxtTip = ""
Local $x = 10, $y = 45
$g_hGrpABEndBattle = GUICtrlCreateGroup(GetTranslated(606,1, -1), $x - 5, $y - 20, 155, 345)
$y -=5
$g_hChkStopAtkABNoLoot1 = GUICtrlCreateCheckbox(GetTranslated(606,2, -1) ,$x, $y, -1, -1)
$sTxtTip = GetTranslated(606,3, -1) & @CRLF & GetTranslated(606,4, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkStopAtkABNoLoot1")
GUICtrlSetState(-1, $GUI_CHECKED)
$y +=20
$g_hLblABTimeStopAtka = GUICtrlCreateLabel(GetTranslated(606,5, -1)& ":", $x + 16, $y + 3, -1, -1)
$g_hTxtStopAtkABNoLoot1 = GUICtrlCreateInput("20", $x + 85, $y + 1, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
$g_hLblABTimeStopAtk = GUICtrlCreateLabel(GetTranslated(603,6, -1), $x + 120, $y + 3, -1, -1)
$y += 20
$g_hChkStopAtkABNoLoot2 = GUICtrlCreateCheckbox(GetTranslated(606,2, -1) ,$x, $y, -1, -1)
$sTxtTip = GetTranslated(606,3, -1) & @CRLF & GetTranslated(606,4, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkStopAtkABNoLoot2")
GUICtrlSetState(-1, $GUI_UNCHECKED)
$y += 20
$g_hLblABTimeStopAtk2a = GUICtrlCreateLabel(GetTranslated(606,5, -1)& ":", $x + 16, $y + 3, -1, -1)
$g_hTxtStopAtkABNoLoot2 = GUICtrlCreateInput("5", $x + 85, $y + 1, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblABTimeStopAtk2 = GUICtrlCreateLabel(GetTranslated(603,6, -1), $x + 120, $y + 3, -1, -1)
$y += 21
$g_hLblABMinRerourcesAtk2 = GUICtrlCreateLabel(GetTranslated(606,7, -1) & ":", $x + 16 , $y + 2, -1, -1)
$sTxtTip = GetTranslated(606,8, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 21
$g_hTxtABMinGoldStopAtk2 = GUICtrlCreateInput("2000", $x + 65, $y , 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hPicABMinGoldStopAtk2 = GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 117, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
$g_hTxtABMinElixirStopAtk2 = GUICtrlCreateInput("2000", $x + 65, $y , 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hPicABMinElixirStopAtk2 = GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 117, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
$g_hTxtABMinDarkElixirStopAtk2 = GUICtrlCreateInput("50", $x + 65, $y , 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 4)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hPicABMinDarkElixirStopAtk2 = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 117, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
$g_hChkABEndNoResources = GUICtrlCreateCheckbox(GetTranslated(606,9, -1), $x , $y , -1, -1)
_GUICtrlSetTip(-1, GetTranslated(606,10, -1))
GUICtrlSetState(-1, $GUI_ENABLE)
$y += 21
$g_hChkABEndOneStar = GUICtrlCreateCheckbox(GetTranslated(606,11, -1) , $x, $y , -1, -1)
_GUICtrlSetTip(-1, GetTranslated(606,12, -1))
GUICtrlSetState(-1, $GUI_ENABLE)
$y += 21
$g_hChkABEndTwoStars = GUICtrlCreateCheckbox(GetTranslated(606,13,-1) , $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(606,14, -1))
GUICtrlSetState(-1, $GUI_ENABLE)
$y += 21
$g_hChkABEndPercentHigher = GUICtrlCreateCheckbox(GetTranslated(606,30, "When Percentage is"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(606,31, "End Battle if Overall Damage Percentage is above"))
GUICtrlSetState(-1, $GUI_ENABLE)
$y +=20
$g_hLblABPercentHigher = GUICtrlCreateLabel(GetTranslated(606,32,"above") & ":", $x + 16 , $y + 2, -1, -1)
$g_hTxtABPercentHigher = GUICtrlCreateInput("60", $x + 85, $y + 1, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(606,31, -1))
GUICtrlSetLimit(-1, 2)
$g_hLblABPercentHigherSec = GUICtrlCreateLabel("%", $x + 120, $y + 3, -1, -1)
$y += 21
$g_hChkABEndPercentChange = GUICtrlCreateCheckbox(GetTranslated(606,33,"When Percentage doesn't") , $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(606, 34,"End Battle when Percentage doesn't change in"))
GUICtrlSetState(-1, $GUI_ENABLE)
$y +=20
$g_hLblABPercentChange = GUICtrlCreateLabel(GetTranslated(606, 35,"change in")& ":", $x + 16, $y + 3, -1, -1)
$g_hTxtABPercentChange = GUICtrlCreateInput("15", $x + 85, $y + 1, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(606,34, -1))
GUICtrlSetLimit(-1, 2)
$g_hLblABPercentChangeSec = GUICtrlCreateLabel(GetTranslated(603,6, -1), $x + 120, $y + 3, -1, -1)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 185, $y = 45
GUICtrlCreateGroup(GetTranslated(606,15,"DE side End Battle options"), $x - 20, $y - 20, 259, 305)
GUICtrlCreateLabel(GetTranslated(606,16, "Attack Dark Elixir Side, End Battle Options") & ":", $x - 10, $y , -1, -1)
_GUICtrlSetTip(-1, GetTranslated(606,17, "Enabled by selecting DE side attack in ActiveBase Deploy - Attack On: options"))
$y += 15
$x -= 10
$g_hChkDESideEB = GUICtrlCreateCheckbox(GetTranslated(606,18, "When below") & ":", $x , $y , -1, -1)
$sTxtTip = GetTranslated(606,19, "Enables Special conditions for Dark Elixir side attack.") & @CRLF & GetTranslated(606,20, "If no additional filters are selected will end battle when below Total Dark Elixir Percent.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkDESideEB")
$g_hTxtDELowEndMin = GUICtrlCreateInput("25", $x + 92, $y , 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblDELowEndMin = GUICtrlCreateLabel("%", $x + 136 , $y + 2 , -1, -1)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 147, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
$g_hChkDisableOtherEBO = GUICtrlCreateCheckbox(GetTranslated(606,21, "Disable Normal End Battle Options"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(606,22, "Disable Normal End Battle Options when DE side attack is found."))
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 20
$g_hChkDEEndOneStar = GUICtrlCreateCheckbox(GetTranslated(606,11, -1) & ":", $x, $y , -1, -1)
$sTxtTip = GetTranslated(606,23, "Will End the Battle when below min DE and One Star is won.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnSilverStar, $x + 135, $y + 2, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
$g_hChkDEEndBk = GUICtrlCreateCheckbox(GetTranslated(606,24, "When"), $x, $y , -1, -1)
$sTxtTip = GetTranslated(606,25, "Will End the Battle when below min DE and King is weak")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnKing, $x + 50, $y + 2, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(606,26, "is weak"), $x + 70, $y + 4, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
$g_hChkDEEndAq = GUICtrlCreateCheckbox(GetTranslated(606,24, -1), $x, $y , -1, -1)
$sTxtTip = GetTranslated(606,27, "Will End the Battle when below min DE and Queen is weak")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueen, $x + 50, $y + 2, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblDEEndAq = GUICtrlCreateLabel(GetTranslated(606,26, -1), $x + 70, $y + 4, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_ACTIVEBASE_TAB = 0, $g_hGUI_ACTIVEBASE_TAB_ITEM1 = 0, $g_hGUI_ACTIVEBASE_TAB_ITEM2 = 0, $g_hGUI_ACTIVEBASE_TAB_ITEM3 = 0
Func CreateAttackSearchActiveBase()
$g_hGUI_ACTIVEBASE = GUICreate("", $_GUI_MAIN_WIDTH - 40, $_GUI_MAIN_HEIGHT - 315, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_SEARCH)
CreateAttackSearchActiveBaseStandard()
CreateAttackSearchActiveBaseScripted()
GUISwitch($g_hGUI_ACTIVEBASE)
$g_hGUI_ACTIVEBASE_TAB = GUICtrlCreateTab(0, 0, $_GUI_MAIN_WIDTH - 40, $_GUI_MAIN_HEIGHT - 315, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_ACTIVEBASE_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslated(600,28,"Search"))
CreateAttackSearchActiveBaseSearch()
$g_hGUI_ACTIVEBASE_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslated(600,29,"Attack"))
CreateAttackSearchActiveBaseAttack()
$g_hGUI_ACTIVEBASE_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslated(600,30,"End Battle"))
CreateAttackSearchActiveBaseEndBattle()
EndFunc
Global $g_hGUI_THSNIPE = 0
Global $g_hChkTSActivateSearches = 0, $g_hTxtTSSearchesMin = 0, $g_hTxtTSSearchesMax = 0, $g_hChkTSActivateTropies = 0, $g_hTxtTSTropiesMin = 0, $g_hTxtTSTropiesMax = 0, $g_hChkTSActivateCamps = 0, $g_hTxtTSArmyCamps = 0
Global $g_hLblTSSearches = 0, $g_hLblTSTropies = 0, $g_hLblTSArmyCamps = 0
Global $g_hCmbTSMeetGE = 0, $g_hTxtTSMinGold = 0, $g_hTxtTSMinElixir = 0, $g_hTxtTSMinGoldPlusElixir = 0
Global $g_hChkTSMeetDE = 0, $g_hTxtTSMinDarkElixir = 0
Global $g_hTxtSWTTiles = 0, $g_hTxtTHaddTiles = 0
Global $g_hGrpTSFilter = 0, $g_hPicTSMinGold = 0, $g_hPicTSMinElixir = 0, $g_hPicTSMinGPEGold = 0, $g_hPicTSMinDarkElixir = 0
Global $g_hLblAddTiles = 0, $g_hLblAddTiles2 = 0, $g_hLblSWTTiles = 0, $g_hLblTHadd = 0
Func CreateAttackSearchTHSnipeSearch()
Local $sTxtTip = ""
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslated(625,0, -1), $x - 20, $y - 20, 190, 305)
$x -= 15
$g_hChkTSActivateSearches = GUICtrlCreateCheckbox(GetTranslated(603,5, -1), $x, $y, 68, 18)
_GUICtrlSetTip(-1, GetTranslated(625,68, -1) & @CRLF & GetTranslated(625,69, -1))
GUICtrlSetState(-1,$GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "chkTSActivateSearches")
$g_hTxtTSSearchesMin = GUICtrlCreateInput("1", $x + 70, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(625,2, -1) & @CRLF & @CRLF & GetTranslated(625,68, -1) & @CRLF & GetTranslated(625,69, -1))
GUICtrlSetLimit(-1, 6)
$g_hLblTSSearches = GUICtrlCreateLabel("-", $x + 113, $y + 2, -1, -1)
$g_hTxtTSSearchesMax = GUICtrlCreateInput("9999", $x + 120, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(625,3, -1) & @CRLF & @CRLF & GetTranslated(625,68, -1) & @CRLF & GetTranslated(625,69,-1))
GUICtrlSetLimit(-1, 6)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnMagnifier, $x + 163, $y + 1, 16, 16)
$y +=21
$g_hChkTSActivateTropies = GUICtrlCreateCheckbox(GetTranslated(625,4, -1), $x, $y, 68, 18)
_GUICtrlSetTip(-1, GetTranslated(625,68, -1) & @CRLF & GetTranslated(625,70,-1))
GUICtrlSetOnEvent(-1, "chkTSActivateTropies")
$g_hTxtTSTropiesMin = GUICtrlCreateInput("0", $x + 70, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1,$GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(625,5, -1) & @CRLF & @CRLF & GetTranslated(625,68, -1) & @CRLF & GetTranslated(625,70,-1))
GUICtrlSetLimit(-1, 6)
$g_hLblTSTropies = GUICtrlCreateLabel("-", $x + 113, $y + 2, -1, -1)
GUICtrlSetState(-1,$GUI_DISABLE)
$g_hTxtTSTropiesMax = GUICtrlCreateInput("6000", $x + 120, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1,$GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(625,6, -1) & @CRLF & @CRLF & GetTranslated(625,68, -1) & @CRLF & GetTranslated(625,70,-1))
GUICtrlSetLimit(-1, 6)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 163, $y + 1, 16, 16)
$y +=21
$g_hChkTSActivateCamps = GUICtrlCreateCheckbox(GetTranslated(625,7, -1), $x, $y, 110, 18)
$sTxtTip = GetTranslated(625,8, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkTSActivateCamps")
$g_hLblTSArmyCamps = GUICtrlCreateLabel(ChrW(8805), $x + 113 - 1, $y + 2, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1,$GUI_DISABLE)
$g_hTxtTSArmyCamps = GUICtrlCreateInput("50", $x + 120, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1,$GUI_DISABLE)
GUICtrlSetLimit(-1, 6)
GUICtrlCreateLabel("%", $x + 163 + 3, $y + 4, -1, -1)
GUICtrlSetState(-1,$GUI_DISABLE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 220, $y = 45
$g_hGrpTSFilter = GUICtrlCreateGroup(GetTranslated(625,14, -1), $x - 20, $y - 20, 225, 305)
$x -= 15
$g_hCmbTSMeetGE = GUICtrlCreateCombo("", $x , $y + 10, 65, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$sTxtTip = GetTranslated(625,15, -1) & @CRLF & GetTranslated(625,16, -1) & @CRLF & GetTranslated(625,17, -1) & @CRLF & GetTranslated(625,18, -1)
GUICtrlSetData(-1, GetTranslated(625,19, -1) &"|" & GetTranslated(625,20, -1) & "|" & GetTranslated(625,21, -1), GetTranslated(625,19, -1))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "cmbTSGoldElixir")
$g_hTxtTSMinGold = GUICtrlCreateInput("80000", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslated(625,23, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
$g_hPicTSMinGold = GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 137, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
$g_hTxtTSMinElixir = GUICtrlCreateInput("80000", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslated(625,24, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
$g_hPicTSMinElixir = GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 137, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y -= 11
$g_hTxtTSMinGoldPlusElixir = GUICtrlCreateInput("160000", $x + 85, $y, 50, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslated(625,25, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 6)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hPicTSMinGPEGold = GUICtrlCreateIcon($g_sLibIconPath, $eIcnGoldElixir, $x + 137, $y + 1, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 34
$g_hChkTSMeetDE = GUICtrlCreateCheckbox(GetTranslated(625,26, -1), $x, $y, -1, -1)
$sTxtTip = GetTranslated(625,27, -1)
GUICtrlSetOnEvent(-1, "chkTSMeetDE")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtTSMinDarkElixir = GUICtrlCreateInput("600", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslated(625,28, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 5)
_GUICtrlEdit_SetReadOnly(-1, True)
$g_hPicTSMinDarkElixir = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 137, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$y +=35
$g_hLblAddTiles = GUICtrlCreateLabel(GetTranslated(625,42, "TownHall, Distance From") , $x , $y + 4, -1, -1, $SS_LEFT)
$y += 16
$g_hLblAddTiles2 = GUICtrlCreateLabel(GetTranslated(625,43, "Border, Add Tiles") & ":" , $x+5 , $y + 4, -1, -1, $SS_LEFT)
$y += 21
$g_hLblSWTTiles = GUICtrlCreateLabel("- " & GetTranslated(625,44, "While Train"), $x, $y + 4, 100, -1, $SS_LEFT)
$sTxtTip = GetTranslated(625,45, "Add number of tiles from Base Edges")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtSWTTiles = GUICtrlCreateInput("2", $x + 85, $y , 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 1)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnTiles, $x + 137, $y + 1, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 24
$g_hLblTHadd = GUICtrlCreateLabel("- " & GetTranslated(625,46, "Full Troops"), $x, $y + 4, -1, 17, $SS_LEFT)
$sTxtTip = GetTranslated(625,47, "Enter how many 'Grass' 1x1 tiles the TH may be from the Base edges to be seen as a TH Outside.") & @CRLF & GetTranslated(625,48, "Ex: (0) tiles; TH must be exactly at the edge. (4) tiles: TH may be 4 tiles farther from edges and closer to the center of the village.") & @CRLF & GetTranslated(625,49, "If the TH is farther away then the No. of tiles set, the base will be skipped.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtTHaddTiles = GUICtrlCreateInput("2", $x + 85, $y , 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 1)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnTiles, $x + 137, $y + 1, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hCmbAttackTHType = 0, $g_hCmbTSSelectTroop = 0, $g_hChkTSKingAttack = 0, $g_hChkTSQueenAttack = 0, $g_hChkTSWardenAttack = 0, $g_hChkTSDropCC = 0
Global $g_hChkTSLightSpell = 0, $g_hChkTSHealSpell = 0, $g_hChkTSRageSpell = 0, $g_hChkTSJumpSpell = 0, $g_hChkTSFreezeSpell = 0,$g_hChkTSPoisonSpell = 0, $g_hChkTSEarthquakeSpell = 0, $g_hChkTSHasteSpell = 0
Global $g_hLblAttackTHType = 0, $g_hLblTSSelectTroop = 0, $g_hLblTSSelectSpecialTroop = 0, $g_hPicTSKingAttack = 0, $g_hPicTSQueenAttack = 0, $g_hPicTSWardenAttack = 0, $g_hPicTSDropCC = 0
Global $g_hPicTSLightSpell = 0, $g_hPicTSHealSpell = 0, $g_hPicTSRageSpell = 0, $g_hPicTSJumpSpell = 0, $g_hPicTSFreezeSpell = 0, $g_hPicTSPoisonSpell = 0, $g_hPicTSEarthquakeSpell = 0, $g_hPicTSHasteSpell = 0
Func CreateAttackSearchTHSnipeAttack()
Local $sTxtTip
Local $x = 25, $y = 40
GUICtrlCreateGroup(GetTranslated(624,1, -1), $x - 20, $y - 15, 420, 305)
$x -= 15
$g_hLblAttackTHType = GUICtrlCreateLabel(GetTranslated(624,2, -1) & ":", $x , $y , 135, 18, $SS_LEFT)
$y += 15
$g_hCmbAttackTHType = GUICtrlCreateCombo("", $x, $y, 128, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "")
_GUICtrlSetTip(-1, GetTranslated(624,37, -1))
GUICtrlSetOnEvent(-1, "cmbAttackTHType")
LoadThSnipeAttacks()
$y += 25
$g_hLblTSSelectTroop=GUICtrlCreateLabel(GetTranslated(624,6,-1) & ":",$x, $y , 135 , 18,$SS_LEFT)
$y += 15
$g_hCmbTSSelectTroop=GUICtrlCreateCombo("", $x , $y, 128, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslated(624,7, -1) & "|" & GetTranslated(624,8, -1) & "|" & GetTranslated(624,9, -1) & "|" & GetTranslated(624,10, -1) & "|" & GetTranslated(624,11, -1) & "|" & GetTranslated(624,12, -1) & "|" & GetTranslated(624,13, -1) & "|" & GetTranslated(624,14, -1) & "|" & GetTranslated(624,15, -1) & "|" & GetTranslated(624,16, -1) & "|" & GetTranslated(624,17, -1), GetTranslated(624,7, -1))
_GUICtrlSetTip(-1, GetTranslated(624,18, -1))
$y += 25
$g_hLblTSSelectSpecialTroop=GUICtrlCreateLabel(GetTranslated(624,19, -1) & ":",$x, $y, 135, 18, $SS_LEFT)
$y += 18
$g_hPicTSKingAttack=GUICtrlCreateIcon($g_sLibIconPath, $eIcnKing, $x , $y, 24, 24)
$sTxtTip = GetTranslated(624,20, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkTSKingAttack = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicTSQueenAttack=GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueen, $x, $y, 24, 24)
$sTxtTip = GetTranslated(624,21, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkTSQueenAttack = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x +=46
$g_hPicTSWardenAttack=GUICtrlCreateIcon($g_sLibIconPath, $eIcnWarden, $x, $y, 24, 24)
$sTxtTip = GetTranslated(624,22, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkTSWardenAttack = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$y +=27
$x -=92
$g_hPicTSDropCC=GUICtrlCreateIcon($g_sLibIconPath, $eIcnCC, $x, $y, 24, 24)
$sTxtTip =GetTranslated(624,23, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkTSDropCC = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicTSLightSpell=GUICtrlCreateIcon($g_sLibIconPath, $eIcnLightSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslated(624,24, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkTSLightSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x +=46
$g_hPicTSHealSpell=GUICtrlCreateIcon($g_sLibIconPath, $eIcnHealSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslated(624,25, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkTSHealSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$y +=27
$x -=92
$g_hPicTSRageSpell=GUICtrlCreateIcon($g_sLibIconPath, $eIcnRageSpell, $x, $y, 24, 24)
$sTxtTip = GetTranslated(624,26, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkTSRageSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x +=46
$g_hPicTSJumpSpell=GUICtrlCreateIcon($g_sLibIconPath, $eIcnJumpSpell , $x, $y, 24, 24)
$sTxtTip =GetTranslated(624,27, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkTSJumpSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 46
$g_hPicTSFreezeSpell=GUICtrlCreateIcon($g_sLibIconPath, $eIcnFreezeSpell , $x, $y, 24, 24)
$sTxtTip = GetTranslated(624,28, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkTSFreezeSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$y +=27
$x -=92
$g_hPicTSPoisonSpell=GUICtrlCreateIcon($g_sLibIconPath, $eIcnPoisonSpell , $x, $y, 24, 24)
$sTxtTip = GetTranslated(624,29, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkTSPoisonSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x +=46
$g_hPicTSEarthquakeSpell=GUICtrlCreateIcon($g_sLibIconPath, $eIcnEarthquakeSpell , $x, $y, 24, 24)
$sTxtTip = GetTranslated(624,30, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkTSEarthquakeSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$x +=46
$g_hPicTSHasteSpell=GUICtrlCreateIcon($g_sLibIconPath, $eIcnHasteSpell, $x, $y, 24, 24)
$sTxtTip =GetTranslated(624,31, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hChkTSHasteSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hChkTSActivateCamps2 = 0, $g_hTxtTSArmyCamps2 = 0
Global $g_hGrpTSEndBattle = 0, $g_hLblTSArmyCamps2 = 0
Func CreateAttackSearchTHSnipeEndBattle()
Local $x = 10, $y = 45
$g_hGrpTSEndBattle = GUICtrlCreateGroup(GetTranslated(606,1, -1), $x - 5, $y - 20, 420, 305)
GUICtrlCreateLabel(GetTranslated(606,28,"Switch DB Attack at END") & ":",$x, $y , 143 , 18,$SS_LEFT)
$y += 15
$g_hChkTSActivateCamps2 = GUICtrlCreateCheckbox("",$x+2,$y+3,16,16)
GUICtrlSetOnEvent(-1, "chkTSActivateCamps2")
$g_hLblTSArmyCamps2 = GUICtrlCreateLabel("Camps >=", $x +20 , $y +4 , -1, -1)
GUICtrlSetState(-1,$GUI_DISABLE)
$g_hTxtTSArmyCamps2 = GUICtrlCreateInput("50", $x + 75, $y, 35, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1,$GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(606,29, "Set the % Army camps before activate this option"))
GUICtrlSetLimit(-1, 6)
GUICtrlCreateLabel("%", $x+115 , $y +4 , -1, -1)
GUICtrlSetState(-1,$GUI_DISABLE)
$y +=26
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_THSNIPE_TAB = 0, $g_hGUI_THSNIPE_TAB_ITEM1 = 0, $g_hGUI_THSNIPE_TAB_ITEM2 = 0, $g_hGUI_THSNIPE_TAB_ITEM3 = 0
Func CreateAttackSearchTHSnipe()
$g_hGUI_THSNIPE = GUICreate("", $_GUI_MAIN_WIDTH - 40, $_GUI_MAIN_HEIGHT - 315, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_SEARCH)
GUISwitch($g_hGUI_THSNIPE)
$g_hGUI_THSNIPE_TAB = GUICtrlCreateTab(0, 0, $_GUI_MAIN_WIDTH - 40, $_GUI_MAIN_HEIGHT - 315, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_THSNIPE_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslated(600,28,"Search"))
CreateAttackSearchTHSnipeSearch()
$g_hGUI_THSNIPE_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslated(600,29,"Attack"))
CreateAttackSearchTHSnipeAttack()
$g_hGUI_THSNIPE_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslated(600,30,"End Battle"))
CreateAttackSearchTHSnipeEndBattle()
EndFunc
Global $g_hGUI_BULLY = 0
Global $g_hTxtATBullyMode = 0, $g_hCmbBullyMaxTH = 0, $g_hRadBullyUseDBAttack = 0, $g_hRadBullyUseLBAttack = 0
Global $g_hGrpBullyAtkCombo = 0, $g_hLblBullyMode = 0, $g_hLblATBullyMode = 0
Func CreateAttackSearchBully()
$g_hGUI_BULLY = GUICreate("", $_GUI_MAIN_WIDTH - 30 - 10, $_GUI_MAIN_HEIGHT - 255 - 30 - 30, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_SEARCH)
GUISwitch($g_hGUI_BULLY)
Local $x = 20, $y = 130 - 105
$g_hGrpBullyAtkCombo = GUICtrlCreateGroup(GetTranslated(629,1, "Bully Attack Combo"), $x - 20, $y - 20, 430, 330)
$y -= 5
$x -= 10
$g_hLblBullyMode = GUICtrlCreateLabel(GetTranslated(629,2, "In Bully Mode, ALL bases that meet the TH level requirement below will be attacked.") , $x - 5, $y + 3, 209, 30, $SS_LEFT)
$y +=35
GUICtrlCreateLabel(GetTranslated(629,3,"Enable Bully after"), $x, $y+3)
$g_hTxtATBullyMode = GUICtrlCreateInput("150", $x + 95, $y, 35, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 3)
_GUICtrlSetTip(-1, GetTranslated(629,4, "TH Bully: No. of searches to wait before activating."))
GUICtrlCreateLabel(GetTranslated(603,5, -1), $x + 135, $y + 5, -1, -1)
$y +=25
$g_hLblATBullyMode = GUICtrlCreateLabel(GetTranslated(629,6, "Max TH level") & ":", $x - 5, $y + 3, 90, -1, $SS_RIGHT)
$g_hCmbBullyMaxTH = GUICtrlCreateCombo("", $x + 95, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslated(629,7, "TH Bully: Max. Townhall level to bully."))
GUICtrlSetData(-1, "4-6|7|8|9|10|11", "4-6")
$y += 24
GUICtrlCreateLabel(GetTranslated(629,8, "When found, Attack with settings from")&":", $x + 10, $y, -1, -1, $SS_RIGHT)
$y += 14
$g_hRadBullyUseDBAttack = GUICtrlCreateRadio(GetTranslated(629,9, "DeadBase Atk."), $x + 20, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(629,10, "Use Dead Base attack settings when attacking a TH Bully match."))
GUICtrlSetState(-1, $GUI_CHECKED)
$g_hRadBullyUseLBAttack = GUICtrlCreateRadio(GetTranslated(629,11, "Active Base Atk."), $x + 115, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(629,12, "Use Active Base attack settings when attacking a TH Bully match."))
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_ATTACKOPTION = 0
Global $g_hChkSearchReduction = 0, $g_hTxtSearchReduceCount = 0, $g_hTxtSearchReduceGold = 0, $g_hTxtSearchReduceElixir = 0, $g_hTxtSearchReduceGoldPlusElixir = 0, $g_hTxtSearchReduceDark = 0, $g_hTxtSearchReduceTrophy = 0
Global $g_hSldVSDelay = 0, $g_hSldMaxVSDelay = 0
Global $g_hChkAttackNow = 0, $g_hCmbAttackNowDelay = 0, $g_hChkRestartSearchLimit = 0, $g_hTxtRestartSearchlimit = 0, $g_hChkAlertSearch = 0
Global $g_hLblVSDelay = 0, $g_hLblTextVSDelay = 0, $g_hLblMaxVSDelay = 0, $g_hLblTextMaxVSDelay = 0, $g_hLblAttackNow = 0, $g_hLblAttackNowSec = 0
Func CreateAttackSearchOptionsSearch()
Local $sTxtTip = ""
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslated(630,1, "Search Reduction"), $x - 20, $y - 20, 223, 165)
$x -=13
$g_hChkSearchReduction = GUICtrlCreateCheckbox(GetTranslated(630,2, "Enable Search Reduction") , $x , $y-4, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(630,3, "Check this if you want the search values to automatically be lowered after a certain amount of searches."))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "chkSearchReduction")
$y+=15
GUICtrlCreateLabel(GetTranslated(630,4, "Reduce targets every"), $x , $y + 3, -1, -1)
$g_hTxtSearchReduceCount = GUICtrlCreateInput("20", $x +115, $y + 2, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(630,5, "Enter the No. of searches to wait before each reduction occurs."))
GUICtrlSetLimit(-1, 3)
GUICtrlCreateLabel(GetTranslated(603,11, "search(es)."), $x + 160 , $y + 3, -1, -1)
$y += 21
GUICtrlCreateLabel(GetTranslated(630,6,"- Reduce Gold"), $x, $y + 3, -1, 17)
$sTxtTip = GetTranslated(630,7, "Lower value for Gold by this amount on each step.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtSearchReduceGold = GUICtrlCreateInput("2000", $x + 115, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 5)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 160, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
GUICtrlCreateLabel(GetTranslated(630,8,"- Reduce Elixir"), $x, $y + 3, -1, 17)
$sTxtTip = GetTranslated(630,9, "Lower value for Elixir by this amount on each step.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtSearchReduceElixir = GUICtrlCreateInput("2000", $x + 115, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 5)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 160, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y +=21
GUICtrlCreateLabel(GetTranslated(630,10,"- Reduce Gold + Elixir"), $x, $y + 3, -1, 17)
$sTxtTip = GetTranslated(630,11, "Lower total sum for G+E by this amount on each step.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtSearchReduceGoldPlusElixir = GUICtrlCreateInput("4000", $x + 115, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 5)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 160, $y + 1, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel("+", $x + 176, $y + 1, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 182, $y + 1, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
GUICtrlCreateLabel(GetTranslated(630,12,"- Reduce Dark Elixir"), $x, $y + 3, -1, 17)
$sTxtTip = GetTranslated(630,13, "Lower value for Dark Elixir by this amount on each step.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtSearchReduceDark = GUICtrlCreateInput("100", $x + 115, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 3)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 160, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 21
GUICtrlCreateLabel(GetTranslated(630,14,"- Reduce Tropies"), $x, $y + 3, -1, 17)
$sTxtTip = GetTranslated(630,15, "Lower value for Trophies by this amount on each step.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtSearchReduceTrophy = GUICtrlCreateInput("2", $x + 115, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 1)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 160, $y, 16, 16)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25
$y = 212
GUICtrlCreateGroup(GetTranslated(636,75, "Village Search Delay"), $x - 20, $y - 20, 223, 72)
$x += 20
$sTxtTip = GetTranslated(636,76, "Use this slider to change the time to wait between Next clicks when searching for a Village to Attack.") & @CRLF & GetTranslated(636,77, "This might compensate for Out of Sync errors on some PC's.") & @CRLF & GetTranslated(636,78, "NO GUARANTEES! This will not always have the same results!")
GUICtrlCreateLabel(GetTranslated(603,9, "Min"), $x-20, $y-2, 25, 15, $SS_RIGHT)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblVSDelay = GUICtrlCreateLabel("0", $x+7, $y-2, 12, 15, $SS_RIGHT)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTextVSDelay = GUICtrlCreateLabel(GetTranslated(603,8, "seconds"), $x + 23, $y-2, -1, -1)
$g_hSldVSDelay = GUICtrlCreateSlider($x + 70, $y - 4, 105, 25, BITOR($TBS_TOOLTIPS, $TBS_AUTOTICKS))
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlSlider_SetTipSide(-1, $TBTS_BOTTOM)
_GUICtrlSlider_SetTicFreq(-1, 1)
GUICtrlSetLimit(-1, 12, 0)
GUICtrlSetData(-1, 1)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetOnEvent(-1, "sldVSDelay")
$y += 25
GUICtrlCreateLabel(GetTranslated(636,80, "Max"), $x-20, $y-2, 25, 15, $SS_RIGHT)
$sTxtTip = GetTranslated(636,81, "Enable random village search delay value by setting") & @CRLF & GetTranslated(636,82, "bottom Max slide value higher than the top minimum slide")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblMaxVSDelay = GUICtrlCreateLabel("0", $x+7, $y-2, 12, 15, $SS_RIGHT)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTextMaxVSDelay = GUICtrlCreateLabel(GetTranslated(603,8, -1), $x + 23, $y-2, 45, -1)
$g_hSldMaxVSDelay = GUICtrlCreateSlider($x + 70, $y - 4, 105, 25, BITOR($TBS_TOOLTIPS, $TBS_AUTOTICKS))
_GUICtrlSetTip(-1, $sTxtTip)
_GUICtrlSlider_SetTipSide(-1, $TBTS_BOTTOM)
_GUICtrlSlider_SetTicFreq(-1, 1)
GUICtrlSetLimit(-1, 15, 0)
GUICtrlSetData(-1, 4)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
GUICtrlSetOnEvent(-1, "sldMaxVSDelay")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 253
$y = 45
GUICtrlCreateGroup(GetTranslated(630,16, "Search Options"), $x - 20, $y - 20, 189, 165)
$x -= 5
$g_hChkAttackNow = GUICtrlCreateCheckbox(GetTranslated(630,17, "Attack Now! option."), $x-5, $y -4, -1, -1)
$sTxtTip = GetTranslated(630,18, "Check this if you want the option to have an 'Attack Now!' button next to") & @CRLF & GetTranslated(630,25, "the Start and Pause buttons to bypass the dead base or all base search values.") & @CRLF & GetTranslated(630,26, "The Attack Now! button will only appear when searching for villages to Attack.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkAttackNow")
$g_hLblAttackNow = GUICtrlCreateLabel(GetTranslated(630,19, "Add") & ":", $x +10 , $y + 20, 27, -1, $SS_RIGHT)
$sTxtTip = GetTranslated(630,20, "Add this amount of reaction time to slow down the search.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hCmbAttackNowDelay = GUICtrlCreateCombo("", $x + 45, $y + 17, 35, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetData(-1, "0|1|2|3|4|5", "3")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblAttackNowSec = GUICtrlCreateLabel(GetTranslated(603,6, "sec."), $x + 85, $y + 20, -1, -1)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 49
$g_hChkRestartSearchLimit = GUICtrlCreateCheckbox( GetTranslated(630,21, "Restart every") & ":", $x-5, $y-8, -1, -1)
$sTxtTip = GetTranslated(630,22, "Return To Base after x searches and restart to search enemy villages.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkRestartSearchLimit")
$g_hTxtRestartSearchlimit = GUICtrlCreateInput("50", $x+15, $y + 15, 25, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 3)
GUICtrlCreateLabel( GetTranslated(603,11, -1), $x + 47, $y + 17, -1, -1)
$y += 45
$g_hChkAlertSearch = GUICtrlCreateCheckbox(GetTranslated(630,23, "Alert me when Village found"), $x-5, $y , -1, -1)
_GUICtrlSetTip(-1, GetTranslated(630,24, "Check this if you want an Audio alarm & a Balloon Tip when a Base to attack is found."))
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hRadAutoAbilities = 0, $g_hRadManAbilities = 0, $g_hTxtManAbilities = 0, $g_hChkUseWardenAbility = 0, $g_hTxtWardenAbility = 0
Global $g_hChkAttackPlannerEnable = 0, $g_hChkAttackPlannerCloseCoC = 0, $g_hChkAttackPlannerCloseAll = 0, $g_hChkAttackPlannerRandom = 0, $g_hCmbAttackPlannerRandom = 0, $g_hChkAttackPlannerDayLimit = 0, $g_hCmbAttackPlannerDayMin = 0, $g_hCmbAttackPlannerDayMax = 0
Global $g_ahChkAttackWeekdays[7] = [0,0,0,0,0,0,0], $g_ahChkAttackHours[24] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Global $g_hLbAttackPlannerRandom = 0, $g_hLbAttackPlannerDayLimit = 0, $g_ahChkAttackWeekdaysE = 0, $g_ahChkAttackHoursE1 = 0, $g_ahChkAttackHoursE2 = 0
Global $g_hChkDropCCHoursEnable = 0, $g_ahChkDropCCHours[24] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Global $g_ahChkDropCCHoursE1 = 0, $g_ahChkDropCCHoursE2 = 0
Func CreateAttackSearchOptionsAttack()
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslated(634,20, "Attack Schedule"), $x - 20, $y - 20, 420, 130)
$x -= 5
$g_hChkAttackPlannerEnable = GUICtrlCreateCheckbox(GetTranslated(634,21, "Enable Schedule"), $x, $y-5, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(634,22, "This option will allow you to schedule attack times") & @CRLF & GetTranslated(634,23, "Bot continues to run and will attack only when schedule allows"))
GUICtrlSetOnEvent(-1, "chkAttackPlannerEnable")
$g_hChkAttackPlannerCloseCoC = GUICtrlCreateCheckbox(GetTranslated(634,24, "Close CoC"), $x, $y+14, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(634,25, "This option will close CoC app when not scheduled to Search & Attack!") & @CRLF & GetTranslated(634,26, "Bot Continues to run and will restart when schedule allows"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "chkAttackPlannerCloseCoC")
$g_hChkAttackPlannerCloseAll = GUICtrlCreateCheckbox(GetTranslated(634,27, "Close emulator"), $x, $y+33, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(634,28, "This option will close emulator when not scheduled to Search & Attack!") & @CRLF & GetTranslated(634,26, -1))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "chkAttackPlannerCloseAll")
$g_hChkAttackPlannerRandom = GUICtrlCreateCheckbox(GetTranslated(634,29, "Random Disable"), $x, $y+52, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(634,30, "This option will randomly stop attacking") & @CRLF & GetTranslated(634,26, -1))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "chkAttackPlannerRandom")
$g_hCmbAttackPlannerRandom = GUICtrlCreateCombo("", $x + 110 , $y+50, 37, 16, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslated(634,31, "Select number of hours to stop attacking"))
GUICtrlSetData(-1, "1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20", "4")
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "cmbAttackPlannerRandom")
$g_hLbAttackPlannerRandom = GUICtrlCreateLabel(GetTranslated(603,37, "hrs"), $x+148, $y+54, -1,-1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkAttackPlannerDayLimit = GUICtrlCreateCheckbox(GetTranslated(634,35, "Daily Limit"), $x, $y+71, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(634,36, "Will randomly stop attacking when exceed random number of attacks between range selected") & @CRLF & GetTranslated(634,26, -1))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "chkAttackPlannerDayLimit")
$g_hCmbAttackPlannerDayMin = GUICtrlCreateInput("12", $x+100 , $y+75, 37, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(634,37, "Enter minimum number of attacks allowed per day"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "cmbAttackPlannerDayMin")
$g_hLbAttackPlannerDayLimit = GUICtrlCreateLabel(GetTranslated(634,39,"to"), $x+142, $y+75, -1,-1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hCmbAttackPlannerDayMax = GUICtrlCreateInput("15", $x+157 , $y+75, 37, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(634,38, "Enter maximum number of attacks allowed per day"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "cmbAttackPlannerDayMax")
$x += 198
$y -= 5
GUICtrlCreateLabel(GetTranslated(603,36, "Day") & ":", $x, $y, -1, 15)
_GUICtrlSetTip(-1, GetTranslated(603,31, "Only during these day of week"))
GUICtrlCreateLabel(GetTranslated(603,16, "Su"), $x + 30, $y, -1, 15)
_GUICtrlSetTip(-1, GetTranslated(603,17, "Sunday"))
GUICtrlCreateLabel(GetTranslated(603,18, "Mo"), $x + 46, $y, -1, 15)
_GUICtrlSetTip(-1, GetTranslated(603,19, "Monday"))
GUICtrlCreateLabel(GetTranslated(603,20, "Tu"), $x + 63, $y, -1, 15)
_GUICtrlSetTip(-1, GetTranslated(603,21, "Tuesday"))
GUICtrlCreateLabel(GetTranslated(603,22, "We"), $x + 79, $y, -1, 15)
_GUICtrlSetTip(-1, GetTranslated(603,23, "Wednesday"))
GUICtrlCreateLabel(GetTranslated(603,24, "Th"), $x + 99, $y, -1, 15)
_GUICtrlSetTip(-1, GetTranslated(603,25, "Thursday"))
GUICtrlCreateLabel(GetTranslated(603,26, "Fr"), $x + 117, $y, -1, 15)
_GUICtrlSetTip(-1, GetTranslated(603,27, "Friday"))
GUICtrlCreateLabel(GetTranslated(603,28, "Sa"), $x + 133, $y, -1, 15)
_GUICtrlSetTip(-1, GetTranslated(603,29, "Saturday"))
GUICtrlCreateLabel("X", $x + 155, $y+1, -1, 15)
_GUICtrlSetTip(-1, GetTranslated(603,2, -1))
$y += 13
$g_ahChkAttackWeekdays[0] = GUICtrlCreateCheckbox("", $x + 30, $y, 16, 16)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(603,31, -1))
$g_ahChkAttackWeekdays[1] = GUICtrlCreateCheckbox("", $x + 47, $y, 16, 16)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(603,31, -1))
$g_ahChkAttackWeekdays[2] = GUICtrlCreateCheckbox("", $x + 64, $y, 16, 16)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(603,31, -1))
$g_ahChkAttackWeekdays[3] = GUICtrlCreateCheckbox("", $x + 81, $y, 16, 16)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(603,31, -1))
$g_ahChkAttackWeekdays[4] = GUICtrlCreateCheckbox("", $x + 99, $y, 16, 16)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(603,31, -1))
$g_ahChkAttackWeekdays[5] = GUICtrlCreateCheckbox("", $x + 117, $y, 16, 16)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(603,31, -1))
$g_ahChkAttackWeekdays[6] = GUICtrlCreateCheckbox("", $x + 133, $y, 16, 16)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(603,31, -1))
$g_ahChkAttackWeekdaysE = GUICtrlCreateCheckbox("", $x + 151, $y, 15, 15, BitOR($BS_PUSHLIKE, $BS_ICON))
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(603,2, -1))
GUICtrlSetOnEvent(-1, "chkattackWeekDaysE")
$x -= 25
$y += 17
Local $sTxtTip = ""
GUICtrlCreateLabel(GetTranslated(603,15,"Hour") & ":", $x , $y, -1, 15)
$sTxtTip = GetTranslated(603,30, "Only during these hours of each day")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(" 0", $x + 30, $y, 13, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(" 1", $x + 45, $y, 13, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(" 2", $x + 60, $y, 13, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(" 3", $x + 75, $y, 13, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(" 4", $x + 90, $y, 13, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(" 5", $x + 105, $y, 13, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(" 6", $x + 120, $y, 13, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(" 7", $x + 135, $y, 13, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(" 8", $x + 150, $y, 13, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(" 9", $x + 165, $y, 13, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel("10", $x + 180, $y, 13, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel("11", $x + 195, $y, 13, 15)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel("X", $x + 214, $y+1, 11, 11)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 15
$g_ahChkAttackHours[0] = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[1] = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[2] = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[3] = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[4] = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[5] = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[6] = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[7] = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[8] = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[9] = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[10] = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[11] = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_ahChkAttackHoursE1 = GUICtrlCreateCheckbox("", $x + 211, $y+1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(603,2, "This button will clear or set the entire row of boxes"))
GUICtrlSetOnEvent(-1, "chkattackHoursE1")
GUICtrlCreateLabel(GetTranslated(603,3, "AM"), $x + 10, $y)
$y += 15
$sTxtTip = GetTranslated(603,30, -1)
$g_ahChkAttackHours[12] = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[13] = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[14] = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[15] = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[16] = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[17] = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[18] = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[19] = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[20] = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[21] = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[22] = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHours[23] = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkAttackHoursE2 = GUICtrlCreateCheckbox("", $x + 211, $y+1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(603,2, -1))
GUICtrlSetOnEvent(-1, "chkattackHoursE2")
GUICtrlCreateLabel(GetTranslated(603,4, "PM"), $x + 10, $y)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 25, $y = 180
GUICtrlCreateGroup(GetTranslated(634,12, "ClanCastle"), $x - 20, $y - 20, 420, 100)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnCC, $x -10 , $y + 4, 24, 24)
$y -= 4
$g_hChkDropCCHoursEnable = GUICtrlCreateCheckbox(GetTranslated(634,40,"Enable CC Drop Schedule" ), $x +20, $y+2, -1, -1)
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, GetTranslated(634,41, "Use schedule to define when dropping CC is allowed, \r\n CC is always dropped when schedule is not enabled"))
GUICtrlSetOnEvent(-1, "chkDropCCHoursEnable")
$y += 22
$g_hChkUseCCBalanced = GUICtrlCreateCheckbox(GetTranslated(634,13,"Balance Donate/Receive" ), $x +20, $y+2, -1, -1)
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, GetTranslated(634,14, "Drop your Clan Castle only if your donated/received ratio is greater than D/R ratio below."))
GUICtrlSetOnEvent(-1, "chkBalanceDR")
$y += 28
$g_hCmbCCDonated = GUICtrlCreateCombo("", $x + 40 , $y, 30, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslated(634,15, "Donated ratio"))
GUICtrlSetData(-1, "1|2|3|4|5", "1")
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "cmbBalanceDR")
GUICtrlCreateLabel("/", $x + 73, $y + 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(634,16, "Wanted donated / received ratio") & @CRLF & GetTranslated(634,17, "1/1 means donated = received, 1/2 means donated = half the received etc."))
$g_hCmbCCReceived = GUICtrlCreateCombo("", $x +80, $y, 30, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslated(634,18, "Received ratio"))
GUICtrlSetData(-1, "1|2|3|4|5", "1")
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "cmbBalanceDR")
$x += 188
$y = 180
GUICtrlCreateLabel(GetTranslated(603,30, -1), $x+8, $y)
$y += 14
$x -= 21
GUICtrlCreateLabel(" 0", $x + 30, $y, 13, 15)
GUICtrlCreateLabel(" 1", $x + 45, $y, 13, 15)
GUICtrlCreateLabel(" 2", $x + 60, $y, 13, 15)
GUICtrlCreateLabel(" 3", $x + 75, $y, 13, 15)
GUICtrlCreateLabel(" 4", $x + 90, $y, 13, 15)
GUICtrlCreateLabel(" 5", $x + 105, $y, 13, 15)
GUICtrlCreateLabel(" 6", $x + 120, $y, 13, 15)
GUICtrlCreateLabel(" 7", $x + 135, $y, 13, 15)
GUICtrlCreateLabel(" 8", $x + 150, $y, 13, 15)
GUICtrlCreateLabel(" 9", $x + 165, $y, 13, 15)
GUICtrlCreateLabel("10", $x + 180, $y, 13, 15)
GUICtrlCreateLabel("11", $x + 195, $y, 13, 15)
GUICtrlCreateLabel("X", $x + 213, $y+2, 11, 11)
$y += 15
$g_ahChkDropCCHours[0] = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
$sTxtTip = GetTranslated(603,30, -1)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[1] = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[2] = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[3] = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[4] = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[5] = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[6] = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[7] = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[8] = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[9] = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[10] = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[11] = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHoursE1 = GUICtrlCreateCheckbox("", $x + 211, $y+1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED )
_GUICtrlSetTip(-1, GetTranslated(603,2, -1))
GUICtrlSetOnEvent(-1, "chkDropCCHoursE1")
GUICtrlCreateLabel(GetTranslated(603,3, -1), $x + 10, $y)
$y += 15
$sTxtTip = GetTranslated(603,30, -1)
$g_ahChkDropCCHours[12] = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[13] = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[14] = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[15] = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[16] = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[17] = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[18] = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[19] = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[20] = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[21] = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[22] = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHours[23] = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahChkDropCCHoursE2 = GUICtrlCreateCheckbox("", $x + 211, $y+1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
GUICtrlSetImage(-1, $g_sLibIconPath, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED )
_GUICtrlSetTip(-1, GetTranslated(603,2, -1))
GUICtrlSetOnEvent(-1, "chkDropCCHoursE2")
GUICtrlCreateLabel(GetTranslated(603,4, -1), $x + 10, $y)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hChkSmartLightSpell = 0, $g_hChkSmartEQSpell = 0, $g_hChkNoobZap = 0, $g_hChkSmartZapDB = 0, $g_hChkSmartZapSaveHeroes = 0, $g_hTxtSmartMinDark = 0, $g_hTxtSmartExpectedDE = 0, $g_hChkDebugSmartZap = 0
Global $g_hLblSmartUseLSpell = 0, $g_hLblSmartUseEQSpell = 0, $g_hLblSmartZap = 0, $g_hLblNoobZap = 0, $g_hLblSmartLightningUsed = 0, $g_hLblSmartEarthQuakeUsed = 0
Func CreateAttackNewSmartZap()
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslated(638, 1, "SmartZap/NoobZap"), $x - 20, $y - 20, 420, 175)
GUICtrlCreateLabel(GetTranslated(638, 2, "Use This Spell to Zap Dark Drills"), $x + 20, $y, -1, -1)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnNewSmartZap, $x - 10, $y, 25, 25)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnLightSpell, $x + 45, $y + 20, 25, 25)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnEarthQuakeSpell, $x + 125, $y + 20, 25, 25)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDrill, $x - 10, $y + 90, 25, 25)
$y += 50
$g_hLblSmartUseLSpell = GUICtrlCreateLabel(GetTranslated(638, 3, "Use LSpells"), $x + 27, $y + 15, -1, -1)
GUICtrlSetOnEvent(-1, "chkSmartLightSpell")
GUICtrlSetState(-1,$GUI_HIDE)
$g_hChkSmartLightSpell = GUICtrlCreateCheckbox(" ", $x + 51, $y -3, 16, 16)
_GUICtrlSetTip(-1, GetTranslated(638, 4, "Check this to drop Lightning Spells on top of Dark Elixir Drills.") & @CRLF & @CRLF & GetTranslated(638, 5, "Remember to go to the tab 'troops' and put the maximum capacity") & @CRLF & GetTranslated(638, 6, "of your spell factory and the number of spells so that the bot can function perfectly."))
GUICtrlSetOnEvent(-1, "chkSmartLightSpell")
GUICtrlSetState(-1, $GUI_UNCHECKED)
$g_hLblSmartUseEQSpell = GUICtrlCreateLabel(GetTranslated(638, 7, "Use EQSpell"), $x + 105, $y + 15, -1, -1)
GUICtrlSetOnEvent(-1, "chkEarthQuakeZap")
GUICtrlSetState(-1,$GUI_HIDE)
$g_hChkSmartEQSpell = GUICtrlCreateCheckbox(" ", $x + 131, $y -3, 16, 16)
_GUICtrlSetTip(-1, GetTranslated(638, 8, "Check this to drop EarthQuake Castle Spell on any Dark Elixir Drill"))
GUICtrlSetOnEvent(-1, "chkEarthQuakeZap")
GUICtrlSetState(-1, $GUI_UNCHECKED)
$g_hChkNoobZap = GUICtrlCreateCheckbox(GetTranslated(638, 9, "Use NoobZap"), $x + 20 + 2, $y + 35, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(638, 10, "Check this to drop lightning spells on any Dark Elixir Drills"))
GUICtrlSetOnEvent(-1, "chkNoobZap")
GUICtrlSetState(-1, $GUI_UNCHECKED)
$g_hChkSmartZapDB = GUICtrlCreateCheckbox(GetTranslated(638, 11, "Only Zap Drills in Dead Bases"), $x + 20 + 2, $y + 55, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(638, 12, "This will only SmartZap a Dead Base (Recommended)"))
GUICtrlSetOnEvent(-1, "chkSmartZapDB")
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hChkSmartZapSaveHeroes = GUICtrlCreateCheckbox(GetTranslated(638, 13, "TH Snipe Not Zap if Heroes Deployed"), $x + 20 + 2, $y + 75, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(638, 14, "This will stop SmartZap from zapping a base on a Town Hall Snipe if your Heroes were deployed"))
GUICtrlSetOnEvent(-1, "chkSmartZapSaveHeroes")
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
$y -= 55
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 200 + 9, $y + 11, 24, 24)
GUICtrlCreateGroup("", $x + 199, $y - 1, 192, 106)
$g_hLblSmartZap = GUICtrlCreateLabel(GetTranslated(638, 15, "Min. amount of Dark Elixir") & ":", $x + 160 + 79, $y + 12, -1, -1)
$g_hTxtSmartMinDark = GUICtrlCreateInput("350", $x + 289, $y + 32, 90, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(638, 16, "Set the Value of the minimum amount of Dark Elixir in the Drills"))
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "txtMinDark")
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 200 + 9, $y + 57, 24, 24)
$g_hLblNoobZap = GUICtrlCreateLabel(GetTranslated(638, 17, "Expected gain of Dark Drills") & ":", $x + 160 + 79, $y + 58, -1, -1)
$g_hTxtSmartExpectedDE = GUICtrlCreateInput("320", $x + 289, $y + 78, 90, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(638, 18, "Set value for expected gain every dark drill") & @CRLF & GetTranslated(638, 19, "NoobZap will be stopped if the last zap gained less DE than expected"))
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "txtExpectedDE")
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hChkShareAttack = 0, $g_hLblShareMinLoot = 0, $g_hTxtShareMinGold = 0, $g_hTxtShareMinElixir = 0, $g_hTxtShareMinDark = 0, $g_hTxtShareMessage = 0, $g_hChkTakeLootSS = 0, $g_hChkScreenshotLootInfo = 0
Global $g_hLblShareMinGold = 0, $g_hLblShareMinElixir = 0, $g_hLblShareMinDark = 0
Func CreateAttackSearchOptionsEndBattle()
Local $x = 20, $y = 45
GUICtrlCreateGroup(GetTranslated(633,1,"Share Replay"), $x-15, $y-20, 420, 204)
$g_hChkShareAttack = GUICtrlCreateCheckbox(GetTranslated(633,2, "Share Replays in your clan's chat."), $x, $y-7, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(633,3, "Check this to share your battle replay in the clan chat."))
GUICtrlSetOnEvent(-1, "chkShareAttack")
$x -= 15
$y -= 2
$y -=5
$y += 25
$g_hLblShareMinLoot = GUICtrlCreateLabel(GetTranslated(633,4, "When Loot Gained") & ":", $x + 20 , $y, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblShareMinGold = GUICtrlCreateLabel(">", $x + 112, $y, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hTxtShareMinGold = GUICtrlCreateInput("300000", $x + 120, $y - 2, 61, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(633,5, "Only Share Replay when the battle loot is more than this amount of Gold."))
GUICtrlSetLimit(-1, 6)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 182, $y, 16, 16)
$y += 22
$g_hLblShareMinElixir = GUICtrlCreateLabel(">", $x + 112, $y, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hTxtShareMinElixir = GUICtrlCreateInput("300000", $x + 120, $y - 2, 61, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(633,6, "Only Share Replay when the battle loot is more than this amount of Elixir."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetLimit(-1, 6)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 182, $y, 16, 16)
$y += 22
$g_hLblShareMinDark = GUICtrlCreateLabel(">", $x + 112, $y, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hTxtShareMinDark = GUICtrlCreateInput("0", $x + 120, $y - 2, 61, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(633,7, "Only Share Replay when the battle loot is more than this amount of Dark Elixir."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetLimit(-1, 5)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 182, $y, 16, 16)
$y += 25
$x += 5
GUICtrlCreateLabel(GetTranslated(633,8, "Use a random message from this list") &":", $x , $y -2 , -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 27
$g_hTxtShareMessage = GUICtrlCreateEdit("", $x, $y - 10 , 205, 72, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetData(-1, StringFormat(GetTranslated(633,9, "Nice\r\nGood\r\nThanks \r\nWowwww")))
_GUICtrlSetTip(-1, GetTranslated(633,10, "Message to send with the Share Replay"))
GUICtrlSetState(-1, $GUI_DISABLE)
$x = 20
$y+=100
GUICtrlCreateGroup(GetTranslated(633,11,"Take Loot Snapshot"), $x-15, $y-20, 420, 67)
$g_hChkTakeLootSS = GUICtrlCreateCheckbox(GetTranslated(633,11, -1), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(633,12, "Check this if you want to save a Loot snapshot of the Village that was attacked."))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "chkTakeLootSS")
$y += 18
$g_hChkScreenshotLootInfo = GUICtrlCreateCheckbox(GetTranslated(633,13, "Include loot info in filename"), $x , $y , -1, -1)
_GUICtrlSetTip(-1, GetTranslated(633,14, "Include loot info in the screenshot filename"))
GUICtrlSetState(-1,$GUI_DISABLE)
EndFunc
Global $g_hChkTrophyRange = 0, $g_hTxtDropTrophy = 0, $g_hTxtMaxTrophy = 0, $g_hChkTrophyHeroes = 0, $g_hCmbTrophyHeroesPriority = 0, $g_hChkTrophyAtkDead = 0, $g_hTxtDropTrophyArmyMin = 0
Global $g_hLblTrophyHeroesPriority = 0, $g_hLblDropTrophyArmyMin = 0, $g_hLblDropTrophyArmyPercent = 0
Func CreateAttackSearchOptionsTrophySettings()
Local $sTxtTip = ""
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslated(609,1, "Trophy Settings"), $x - 20, $y - 20, 420, 305)
$x += 25
$y += 25
GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x - 15, $y, 64, 64, $BS_ICON)
$x += 50
$g_hChkTrophyRange = GUICtrlCreateCheckbox(GetTranslated(609,2, "Trophy range") & ":",$x + 20, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkTrophyRange")
$g_hTxtDropTrophy = GUICtrlCreateInput("5000", $x + 110, $y, 35, -1, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 4)
_GUICtrlSetTip(-1, GetTranslated(609,3, "MIN: The Bot will drop trophies until below this value."))
GuiCtrlSetState(-1,$GUI_DISABLE)
GUICtrlCreateLabel(GetTranslated(603,13, "-"), $x + 148, $y + 4, -1, -1)
$g_hTxtMaxTrophy = GUICtrlCreateInput("5000", $x + 155, $y, 35, -1, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 4)
_GUICtrlSetTip(-1, GetTranslated(609,4, "MAX: The Bot will drop trophies if your trophy count is greater than this value."))
GuiCtrlSetState(-1,$GUI_DISABLE)
$y += 24
$x += 20
$g_hChkTrophyHeroes = GUICtrlCreateCheckbox(GetTranslated(609,5, "Use Heroes To Drop Trophies"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(609,6, "Use Heroes to drop Trophies if Heroes are available."))
GuiCtrlSetState(-1,$GUI_DISABLE)
GUICtrlSetOnEvent(-1, "chkTrophyHeroes")
$y += 25
$g_hLblTrophyHeroesPriority = GUICtrlCreateLabel(GetTranslated(609,11, "Priority Hero to Use") & ":", $x + 16 , $y , 110, -1)
$g_hCmbTrophyHeroesPriority = GUICtrlCreateCombo("", $x + 125, $y - 4 , 170, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslated(609,12, "Set the order on which Hero the Bot drops first when available."))
Local $txtPriorityConnector = ">"
Local $txtPriorityDefault = GetTranslated(644,2,-1) & $txtPriorityConnector & GetTranslated(644,1,-1) & $txtPriorityConnector & GetTranslated(644,3,-1)
Local $txtPriorityList = "" & GetTranslated(644,2,-1) & $txtPriorityConnector & GetTranslated(644,1,-1) & $txtPriorityConnector & GetTranslated(644,3,-1) & "|" & GetTranslated(644,2,-1) & $txtPriorityConnector & GetTranslated(644,3,-1) & $txtPriorityConnector & GetTranslated(644,1,-1) & "|" & GetTranslated(644,1,-1) & $txtPriorityConnector & GetTranslated(644,2,-1) & $txtPriorityConnector & GetTranslated(644,3,-1) & "|" & GetTranslated(644,1,-1) & $txtPriorityConnector & GetTranslated(644,3,-1) & $txtPriorityConnector & GetTranslated(644,2,-1) & "|" & GetTranslated(644,3,-1) & $txtPriorityConnector & GetTranslated(644,1,-1) & $txtPriorityConnector & GetTranslated(644,2,-1) & "|" & GetTranslated(644,3,-1) & $txtPriorityConnector & GetTranslated(644,2,-1) & $txtPriorityConnector & GetTranslated(644,1,-1) & "|" & ""
If $g_iDebugSetlog = 1 Then Setlog($txtPriorityDefault)
If $g_iDebugSetlog = 1 Then Setlog($txtPriorityList)
GUICtrlSetData(-1, $txtPriorityList , $txtPriorityDefault)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 20
$g_hChkTrophyAtkDead = GUICtrlCreateCheckbox(GetTranslated(609,7, "Attack Dead Bases During Drop"), $x , $y +2, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(609,8, "Attack a Deadbase found on the first search while dropping Trophies."))
GUICtrlSetOnEvent(-1, "chkTrophyAtkDead")
GuiCtrlSetState(-1,$GUI_DISABLE)
$y += 24
$g_hLblDropTrophyArmyMin = GUICtrlCreateLabel(GetTranslated(609,9, "Wait until Army Camp are at least") & " " & ChrW(8805), $x + 16 , $y + 6, 200, -1, $SS_LEFT)
$sTxtTip = GetTranslated(609,10, "Enter the percent of full army required for dead base attack before starting trophy drop.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtDropTrophyArmyMin = GUICtrlCreateInput("70", $x + 215, $y +2, 27, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hLblDropTrophyArmyPercent = GUICtrlCreateLabel(GetTranslated(603,12, "%"), $x + 245, $y +6, -1, -1)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_ATTACKOPTION_TAB = 0, $g_hGUI_ATTACKOPTION_TAB_ITEM1 = 0, $g_hGUI_ATTACKOPTION_TAB_ITEM2 = 0, $g_hGUI_ATTACKOPTION_TAB_ITEM3 = 0, $g_hGUI_ATTACKOPTION_TAB_ITEM4 = 0, $g_hGUI_ATTACKOPTION_TAB_ITEM5 = 0
Func CreateAttackSearchOptions()
$g_hGUI_ATTACKOPTION = GUICreate("", $_GUI_MAIN_WIDTH - 40, $_GUI_MAIN_HEIGHT - 315, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_SEARCH)
$g_hGUI_ATTACKOPTION_TAB = GUICtrlCreateTab(0, 0, $_GUI_MAIN_WIDTH - 40, $_GUI_MAIN_HEIGHT - 315, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_ATTACKOPTION_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslated(600,28,"Search"))
CreateAttackSearchOptionsSearch()
$g_hGUI_ATTACKOPTION_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslated(600,29,"Attack"))
CreateAttackSearchOptionsAttack()
$g_hGUI_ATTACKOPTION_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslated(600,56,"SmartZap"))
CreateAttackNewSmartZap()
$g_hGUI_ATTACKOPTION_TAB_ITEM4 = GUICtrlCreateTabItem(GetTranslated(600,30,"End Battle"))
CreateAttackSearchOptionsEndBattle()
$g_hGUI_ATTACKOPTION_TAB_ITEM5 = GUICtrlCreateTabItem(GetTranslated(600,32,"Trophy Settings"))
CreateAttackSearchOptionsTrophySettings()
GUICtrlCreateTabItem("")
EndFunc
Global $g_hGUI_SEARCH_TAB = 0, $g_hGUI_SEARCH_TAB_ITEM1 = 0, $g_hGUI_SEARCH_TAB_ITEM2 = 0, $g_hGUI_SEARCH_TAB_ITEM3 = 0, $g_hGUI_SEARCH_TAB_ITEM4 = 0, $g_hGUI_SEARCH_TAB_ITEM5 = 0
Global $g_hChkDeadbase = 0, $g_hChkActivebase = 0, $g_hChkTHSnipe = 0, $g_hChkBully = 0
Global $g_hLblDeadbaseDisabled = 0, $g_hLblActivebaseDisabled = 0, $g_hLblTHSnipeDisabled = 0, $g_hLblBullyDisabled = 0
Func CreateAttackSearch()
$g_hGUI_SEARCH = GUICreate("", $_GUI_MAIN_WIDTH - 28, $_GUI_MAIN_HEIGHT - 255 - 28, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_ATTACK)
Local $x = 82
$g_hChkDeadbase = GUICtrlCreateCheckbox("", $x, 6, 13, 13)
GUICtrlSetState(-1,$GUI_CHECKED)
GUICtrlSetOnEvent(-1, "DBcheck")
$g_hChkActivebase = GUICtrlCreateCheckbox("", $x + 100, 4, 13, 13)
GUICtrlSetState(-1,$GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "Abcheck")
$g_hChkTHSnipe = GUICtrlCreateCheckbox("", $x + 190, 4, 13, 13)
GUICtrlSetState(-1,$GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "TScheck")
$g_hChkBully = GUICtrlCreateCheckbox("", $x + 260, 4, 13, 13)
GUICtrlSetState(-1,$GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "Bullycheck")
CreateAttackSearchDeadBase()
CreateAttackSearchActiveBase()
CreateAttackSearchTHSnipe()
CreateAttackSearchBully()
CreateAttackSearchOptions()
GUISwitch($g_hGUI_SEARCH)
$g_hGUI_SEARCH_TAB = GUICtrlCreateTab(0, 0, $_GUI_MAIN_WIDTH - 30, $_GUI_MAIN_HEIGHT - 255 - 30, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_SEARCH_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslated(600,23,"DeadBase") & "    ")
$g_hLblDeadbaseDisabled = GUICtrlCreateLabel(GetTranslated(600,49,"Note: This Strategy is disabled, tick the checkmark on the") & " " & GetTranslated(600, 23, -1) & " " & GetTranslated(600,50,"tab to enable it!"), 20, 30, $_GUI_MAIN_WIDTH - 40, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hGUI_SEARCH_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslated(600,24,"ActiveBase") & "    ")
$g_hLblActivebaseDisabled = GUICtrlCreateLabel(GetTranslated(600,49, -1) & " " & GetTranslated(600, 24, -1) & " " & GetTranslated(600,50, -1), 20, 30, $_GUI_MAIN_WIDTH - 40, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hGUI_SEARCH_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslated(600,25,"TH Snipe") & "    ")
$g_hLblTHSnipeDisabled = GUICtrlCreateLabel(GetTranslated(600,49, -1) & " " & GetTranslated(600, 25, -1) & " " & GetTranslated(600,50, -1), 20, 30, $_GUI_MAIN_WIDTH - 40, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hGUI_SEARCH_TAB_ITEM4 = GUICtrlCreateTabItem(GetTranslated(600,26,"Bully") & "    ")
$g_hLblBullyDisabled = GUICtrlCreateLabel(GetTranslated(600,49, -1) & " " & GetTranslated(600, 26, -1) & " " & GetTranslated(600,50, -1), 20, 30, $_GUI_MAIN_WIDTH - 40, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$g_hGUI_SEARCH_TAB_ITEM5 = GUICtrlCreateTabItem(GetTranslated(600,27,"Options"))
GUICtrlCreateTabItem("")
EndFunc
Global $g_hGUI_STRATEGIES = 0
Global $g_hGUI_STRATEGIES_TAB = 0, $g_hGUI_STRATEGIES_TAB_ITEM1 = 0, $g_hGUI_STRATEGIES_TAB_ITEM2 = 0
Global $g_hCmbPresetList = 0, $g_hTxtPresetMessage = 0, $g_hLblLoadPresetMessage = 0, $g_hBtnGUIPresetLoadConf = 0, $g_hChkDeleteConf = 0, $g_hBtnGUIPresetDeleteConf = 0, $g_hBtnStrategyFolder = 0, $g_hTxtPresetSaveFilename = 0, $g_hTxtSavePresetMessage = 0, $g_hBtnGUIPresetSaveConf = 0
Func CreateAttackStrategies()
$g_hGUI_STRATEGIES = GUICreate("", $_GUI_MAIN_WIDTH - 28, $_GUI_MAIN_HEIGHT - 255 - 28, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_ATTACK)
GUISwitch($g_hGUI_STRATEGIES)
Local $xStart = 5, $yStart = 25
$g_hGUI_STRATEGIES_TAB = GUICtrlCreateTab(0, 0, $_GUI_MAIN_WIDTH - 30, $_GUI_MAIN_HEIGHT - 255 - 30, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_STRATEGIES_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslated(600,33,"Load Strategy"))
Local $x = $xStart, $y = $yStart
$g_hCmbPresetList = GUICtrlCreateCombo("",$x,$y,200,300,$WS_VSCROLL)
GUICtrlSetOnEvent(-1, "PresetLoadConfigInfo")
$x +=205
$g_hTxtPresetMessage = GUICtrlCreateEdit("", $x, $y , 225, 250, BitOR($ES_WANTRETURN, $ES_AUTOVSCROLL))
GuiCtrlSetState(-1, $GUI_HIDE)
Local $loadmessage = GetTranslated(627,1,"LOAD PRECONFIGURED SETTINGS.\n\n- Load ALL Train Army Tab Settings\n- Load ALL Search && Attack Tab Settings\n\n- EXCEPT: Share Replay Settings\n- EXCEPT: Take Loot Snapshot Settings\n- EXCEPT: Gem Boost Settings")
$g_hLblLoadPresetMessage = GUICtrlCreateLabel(StringReplace($loadmessage, "\n", @crlf ) ,$x+15, $y+25,400)
$x +=5
$y +=255
$g_hBtnGUIPresetLoadConf = GUICtrlCreateButton(GetTranslated(627,2,"Load Configuration"), $x , $y, 130, 20)
GUICtrlSetOnEvent(-1, "PresetLoadConf")
GuiCtrlSetState(-1, $GUI_HIDE)
$x +=145
$g_hChkDeleteConf = GUICtrlCreateCheckbox("", $x, $y + 2, 15, 15)
GUICtrlSetOnEvent(-1, "chkCheckDeleteConf")
GuiCtrlSetState(-1, $GUI_HIDE)
$g_hBtnGUIPresetDeleteConf = GUICtrlCreateButton(GetTranslated(627,3,"Delete"), $x + 15 , $y, 60, 20)
GUICtrlSetOnEvent(-1, "PresetDeleteConf")
GuiCtrlSetState(-1, $GUI_HIDE+$gui_DISABLE)
$g_hBtnStrategyFolder = GUICtrlCreateButton(GetTranslated(627,4, "Open Strategy folder"),$xStart + 40 , $y+ 40 , 120, 30)
GUICtrlSetOnEvent(-1, "btnStrategyFolder")
$g_hGUI_STRATEGIES_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslated(600,34,"Save Strategy"))
$x = $xStart
$y = $yStart
GUICtrlCreateLabel(GetTranslated(628,1,"Strategy file name") & ":" ,$x,$y+4,200,25, $SS_RIGHT)
$x += 205
$g_hTxtPresetSaveFilename = GUICtrlCreateInput("strategy " & @YEAR & "-" & @MON & "-" & @MDAY & " " & @HOUR & "." & @MIN & "." & @SEC,$x,$y,200,25)
$x = $xStart
$y +=30
GUICtrlCreateLabel(GetTranslated(628,2,"Notes") & ":" ,$x,$y+4,200,25, $SS_RIGHT)
Local $savemessage = GetTranslated(628,3,"SAVE SETTINGS\n--------------------------------------\nSave ALL:\n- Train Army Tab Settings\n- Search && Attack Tab Settings\n\nExcept:\n- Share Replay Settings\n- Take Loot Snapshot Settings\n- Gem Boost Settings\n--------------------------------------")
GUICtrlCreateLabel(StringReplace($savemessage, "\n", @crlf ) ,$x+15, $y+4+25,280)
$x +=205
$g_hTxtSavePresetMessage = GUICtrlCreateEdit("", $x, $y , 223, 230, BitOR($ES_WANTRETURN, $ES_AUTOVSCROLL))
$y += 235
$g_hBtnGUIPresetSaveConf = GUICtrlCreateButton(GetTranslated(628,4,"Save Configuration"), $x+13 , $y, 200, 20)
GUICtrlSetOnEvent(-1, "PresetSaveConf")
GUICtrlCreateTabItem("")
EndFunc
Global $g_hGUI_ATTACK_TAB = 0, $g_hGUI_ATTACK_TAB_ITEM1 = 0, $g_hGUI_ATTACK_TAB_ITEM2 = 0, $g_hGUI_ATTACK_TAB_ITEM3 = 0
Func CreateAttackTab()
$g_hGUI_ATTACK = GUICreate("", $_GUI_MAIN_WIDTH - 20, $_GUI_MAIN_HEIGHT - 255, $_GUI_CHILD_LEFT, $_GUI_CHILD_TOP, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hFrmBotEx)
CreateAttackTroops()
CreateAttackSearch()
CreateAttackStrategies()
GUISwitch($g_hGUI_ATTACK)
$g_hGUI_ATTACK_TAB = GUICtrlCreateTab(0, 0, $_GUI_MAIN_WIDTH - 20, $_GUI_MAIN_HEIGHT - 255, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_ATTACK_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslated(600,41,"Train Army"))
$g_hGUI_ATTACK_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslated(600,42,"Search && Attack"))
$g_hGUI_ATTACK_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslated(600,43,"Strategies"))
GUICtrlCreateTabItem("")
EndFunc
Global $g_hGUI_BOT = 0
Global $g_hCmbGUILanguage = 0
Global $g_hChkDisableSplash = 0, $g_hChkForMBRUpdates = 0, $g_hChkDeleteLogs = 0, $g_hTxtDeleteLogsDays = 0, $g_hChkDeleteTemp = 0, $g_hTxtDeleteTempDays = 0, $g_hChkDeleteLoots = 0, $g_hTxtDeleteLootsDays = 0
Global $g_hChkAutostart = 0, $g_hTxtAutostartDelay = 0, $g_hChkCheckGameLanguage = 0, $g_hChkAutoAlign = 0, $g_hTxtAlignOffsetX = 0, $g_hTxtAlignOffsetY = 0, $g_hCmbAlignmentOptions = 0
Global $g_hChkUpdatingWhenMinimized = 0, $g_hChkHideWhenMinimized = 0, $g_hChkUseRandomClick = 0, $g_hChkScreenshotType = 0, $g_hChkScreenshotHideName = 0, $g_hTxtTimeAnotherDevice = 0
Global $g_hChkSinglePBTForced = 0, $g_hTxtSinglePBTimeForced = 0, $g_hTxtPBTimeForcedExit = 0, $g_hChkFixClanCastle = 0, $g_hChkAutoResume = 0, $g_hTxtAutoResumeTime = 0
Func CreateBotOptions()
Local $sTxtTip = ""
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslated(636,83, "GUI Language"), $x - 20, $y - 20, 210, 47)
$y -=2
$g_hCmbGUILanguage = _GUICtrlComboBoxEx_Create($g_hGUI_BOT,"",$x - 8, $y, 185, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(_GUICtrlComboBoxEx_GetComboControl($g_hCmbGUILanguage), GetTranslated(636,84, "Use this to switch to a different GUI language"), Default, Default, Default, False)
LoadLanguagesComboBox()
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 54
GUICtrlCreateGroup(GetTranslated(636,2, "When Bot Loads"), $x - 20, $y - 20, 210, 120)
$y -= 4
$g_hChkDisableSplash = GUICtrlCreateCheckbox(GetTranslated(636,100, "Disable Splash Screen"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(636,101, "Disables the splash screen on startup."))
GUICtrlSetState(-1, $GUI_UNCHECKED)
$y += 20
$g_hChkForMBRUpdates = GUICtrlCreateCheckbox(GetTranslated(636,3, "Check for Updates"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(636,4, "Check if you are running the latest version of the bot."))
GUICtrlSetState(-1, $GUI_CHECKED)
$y += 20
$g_hChkDeleteLogs = GUICtrlCreateCheckbox(GetTranslated(636,5, "Delete Log Files")& ":", $x, $y, -1, -1)
$sTxtTip = GetTranslated(636,6, "Delete log files older than this specified No. of days.")
GUICtrlSetState(-1, $GUI_CHECKED)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkDeleteLogs")
$g_hTxtDeleteLogsDays = GUICtrlCreateInput("2", $x + 120, $y + 2, 25, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlSetFont(-1, 8)
GUICtrlCreateLabel(GetTranslated(636,7, "days"), $x + 150, $y + 4, 27, 15)
$y += 20
$g_hChkDeleteTemp = GUICtrlCreateCheckbox(GetTranslated(636,8, "Delete Temp Files") & ":", $x, $y, -1, -1)
GUICtrlSetState(-1, $GUI_CHECKED)
_GUICtrlSetTip(-1, GetTranslated(636,9, "Delete temp files older than this specified No. of days."))
GUICtrlSetOnEvent(-1, "chkDeleteTemp")
$g_hTxtDeleteTempDays = GUICtrlCreateInput("2", $x + 120, $y + 2, 25, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlSetFont(-1, 8)
GUICtrlCreateLabel(GetTranslated(636,7, "days"), $x + 150, $y + 4, 27, 15)
$y += 20
$g_hChkDeleteLoots = GUICtrlCreateCheckbox(GetTranslated(636,10, "Delete Loot Images"), $x, $y, -1, -1)
$sTxtTip = GetTranslated(636,11, "Delete loot image files older than this specified No. of days.")
GUICtrlSetState(-1, $GUI_CHECKED)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "chkDeleteLoots")
$g_hTxtDeleteLootsDays = GUICtrlCreateInput("2", $x + 120, $y + 2, 25, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlSetFont(-1, 8)
GUICtrlCreateLabel(GetTranslated(636,7, "days"), $x + 150, $y + 4, 27, 15)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 48
GUICtrlCreateGroup(GetTranslated(636,12, "When Bot Starts"), $x - 20, $y - 20, 210, 112)
$y -= 5
$g_hChkAutostart = GUICtrlCreateCheckbox(GetTranslated(636,13, "Auto START after") & ":", $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(636,58, "Auto START the Bot after this No. of seconds."))
GUICtrlSetOnEvent(-1, "chkAutostart")
$g_hTxtAutostartDelay = GUICtrlCreateInput("10", $x + 120, $y + 2, 25, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetFont(-1, 8)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel(GetTranslated(603,6, "sec."), $x + 150, $y + 4, 27, 18)
$y += 22
$g_hChkCheckGameLanguage = GUICtrlCreateCheckbox(GetTranslated(636,15, "Check Game Language (EN)"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(636,16, "Check if the Game is set to the correct language (Must be set to English)."))
GUICtrlSetState(-1, $GUI_CHECKED)
$y += 22
$g_hChkAutoAlign = GUICtrlCreateCheckbox(GetTranslated(636,17, "Auto Align"), $x, $y, -1, -1)
$sTxtTip = GetTranslated(636,18, "Reposition/Align Android Emulator and BOT windows on the screen.")
GUICtrlSetOnEvent(-1, "chkDisposeWindows")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlCreateLabel(GetTranslated(636,19, "Offset") & ":", $x + 85, $y + 4, -1, -1)
$g_hTxtAlignOffsetX = GUICtrlCreateInput("10", $x + 120, $y + 2, 25, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslated(636,20, "Offset horizontal pixels between Android Emulator and BOT windows.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlSetFont(-1, 8)
$g_hTxtAlignOffsetY= GUICtrlCreateInput("0", $x + 150, $y + 2, 25, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslated(636,21, "Offset vertical pixels between Android Emulator and BOT windows.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlSetFont(-1, 8)
$y += 23
$g_hCmbAlignmentOptions = GUICtrlCreateCombo("", $x, $y, 175, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslated(636,22, "0,0: Android Emulator-Bot") & "|" & GetTranslated(636,23, "0,0: Bot-Android Emulator") & "|" & GetTranslated(636,24, "SNAP: Bot TopRight to Android") &"|" & GetTranslated(636,25, "SNAP: Bot TopLeft to Android") & "|" & GetTranslated(636,26, "SNAP: Bot BottomRight to Android") & "|" & GetTranslated(636,27, "SNAP: Bot BottomLeft to Android") & "|" & GetTranslated(636,95, "DOCK: Android into Bot"), GetTranslated(636,24, "SNAP: Bot TopRight to Android"))
_GUICtrlSetTip(-1, GetTranslated(636,28, "0,0: Reposition Android Emulator screen to position 0,0 on windows desktop and align Bot window right or left to it.") & @CRLF & GetTranslated(636,29, "SNAP: Only reorder windows, Align Bot window to Android Emulator window at Top Right, Top Left, Bottom Right or Bottom Left.\r\n" & "DOCK: Integrate Android Screen into bot window."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 240, $y = 45
GUICtrlCreateGroup(GetTranslated(636,93, "Advanced"), $x - 20, $y - 20, 225, 102)
$g_hChkUpdatingWhenMinimized = GUICtrlCreateCheckbox(GetTranslated(636,96, "Updating when minimized"), $x, $y, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "chkUpdatingWhenMinimized")
_GUICtrlSetTip(-1, GetTranslated(636,97, "Enable different minimize routine for bot window.\r\nWhen bot is minimized, screen updates are shown in taskbar preview."))
$y += 19
$g_hChkHideWhenMinimized = GUICtrlCreateCheckbox(GetTranslated(636,98, "Hide when minimized"), $x, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkHideWhenMinimized")
_GUICtrlSetTip(-1, GetTranslated(636,99, "Hide bot window in taskbar when minimized.\r\nUse trayicon 'Show bot' to display bot window again."))
$y += 19
$g_hChkAutoResume = GUICtrlCreateCheckbox(GetTranslated(636, 122, "Auto resume Bot after"), $x, $y + 2, -1, -1)
_GUICtrlSetTip(-1,GetTranslated(636, 123, "This will auto resume your bot after x minutes"))
GUICtrlSetOnEvent(-1, "chkAutoResume")
$g_hTxtAutoResumeTime = GUICtrlCreateInput("5",$x + 132, $y + 5, 30, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlCreateLabel( GetTranslated(603,10, -1), $x+167, $y+5, 27, 15)
$y += 19
$g_hChkUseRandomClick = GUICtrlCreateCheckbox(GetTranslated(636,94, "Random Click"), $x, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkUseRandomClick")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 47
GUICtrlCreateGroup(GetTranslated(636,55, "Photo Screenshot Options"), $x - 20, $y - 17, 225, 60)
$g_hChkScreenshotType = GUICtrlCreateCheckbox(GetTranslated(636,56, "Make in PNG format"), $x, $y, -1, -1)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkScreenshotType")
$y += 19
$g_hChkScreenshotHideName = GUICtrlCreateCheckbox(GetTranslated(636,57, "Hide Village and Clan Castle Name"), $x, $y, -1, -1)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkScreenshotHideName")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y +=48
GUICtrlCreateGroup(GetTranslated(636,85, "Remote Device"), $x - 20, $y - 20 , 225, 42)
$y -= 5
GUICtrlCreateLabel(GetTranslated(636,86, "When 'Another Device' wait") & ":", $x - 10, $y + 2, -1, -1)
$sTxtTip = GetTranslated(636,87, "Enter the time to wait (in Minutes) before the Bot reconnects when another device took control.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtTimeAnotherDevice = GUICtrlCreateInput("2", $x + 127, $y - 1, 35, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 3)
GUICtrlCreateLabel(GetTranslated(603,10, "min."), $x + 165, $y + 2, -1, -1)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y+= 51
GUICtrlCreateGroup(GetTranslated(636,45, "Other Options"), $x - 20, $y - 20, 225, 85)
$g_hChkSinglePBTForced = GUICtrlCreateCheckbox(GetTranslated(636,61, "Force Single PB logoff"), $x-5, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkSinglePBTForced")
_GUICtrlSetTip(-1, GetTranslated(636,62, "This forces bot to exit CoC only one time prior to normal start of PB"))
$g_hTxtSinglePBTimeForced = GUICtrlCreateInput("18", $x + 130, $y-1, 30, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(636,63, "Type in number of minutes to keep CoC closed. Set to 15 minimum to reset PB timer!"))
GUICtrlSetOnEvent(-1, "txtSinglePBTimeForced")
GUICtrlSetLimit(-1, 3)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel( GetTranslated(603,10, -1), $x+162, $y+2, 27, 15)
$y += 20
GUICtrlCreateLabel( GetTranslated(636,65, "Subtract time for early PB exit"), $x-10, $y+3)
$sTxtTip = GetTranslated(636,66, "Type in number of minutes to quit CoC early! Setting below 10 minutes may not function!")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hTxtPBTimeForcedExit = GUICtrlCreateInput("16", $x + 130, $y, 30, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetOnEvent(-1, "txtSinglePBTimeForced")
GUICtrlSetLimit(-1, 3)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateLabel( GetTranslated(603,10, -1), $x+162, $y+1, 27, 15)
$y +=20
$g_hChkFixClanCastle = GUICtrlCreateCheckbox(GetTranslated(636,104, "Force Clan Castle Detection"), $x-5, $y + 2, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(636,105, "If clan Castle it is undetected and it is NOT placed in the last slot, force bot to consider the undetected slot as Clan Castle"))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hCmbCOCDistributors
Func CreateBotAndroid()
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslated(643,1, "Distributors"), $x - 20, $y - 20, 210, 47)
$y -=2
$g_hCmbCOCDistributors = GUICtrlCreateCombo("", $x - 8 , $y, 185, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslated(643,2, "Allow bot to launch COC based on the distribution chosen"))
LoadCOCDistributorsComboBox()
SetCurSelCmbCOCDistributors()
GUICtrlSetOnEvent(-1, "cmbCOCDistributors")
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hChkDebugClick = 0, $g_hChkDebugSetlog = 0, $g_hChkDebugOCR = 0, $g_hChkDebugImageSave = 0, $g_hChkdebugBuildingPos = 0, $g_hChkdebugTrain = 0, $g_hChkDebugOCRDonate = 0
Global $g_hChkdebugAttackCSV = 0, $g_hChkMakeIMGCSV = 0, $g_hChkDebugDisableZoomout = 0, $g_hChkDebugDisableVillageCentering = 0, $g_hChkDebugDeadbaseImage = 0
Global $g_hBtnTestTrain = 0, $g_hBtnTestDonateCC = 0, $g_hBtnTestRequestCC = 0, $g_hBtnTestAttackBar = 0, $g_hBtnTestClickDrag = 0, $g_hBtnTestImage = 0
Global $g_hBtnTestVillageSize = 0, $g_hBtnTestDeadBase = 0, $g_hBtnTestTHimgloc = 0, $g_hBtnTestTrainsimgloc = 0, $g_hBtnTestQuickTrainsimgloc = 0, $g_hTxtTestFindButton = 0
Global $g_hBtnTestFindButton = 0, $g_hBtnTestDeadBaseFolder = 0, $g_hBtnTestCleanYard = 0, $g_hBtnTestAttackCSV = 0, $g_hBtnTestimglocTroopBar = 0
Global $g_hBtnTestConfigSave = 0, $g_hBtnTestConfigApply = 0, $g_hBtnTestConfigRead = 0
Func CreateBotDebug()
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslated(636, 34, "Debug"), $x - 20, $y - 20, 440, 360)
$g_hChkDebugClick = GUICtrlCreateCheckbox(GetTranslated(636, 40, "Click"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(636, 35, "Debug: Write the clicked (x,y) coordinates to the log."))
$y += 20
$g_hChkDebugSetlog = GUICtrlCreateCheckbox(GetTranslated(636, 41, "Messages"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(636, 36, "Debug: Enables debug SetLog messages in code for Troubleshooting."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkDebugOCR = GUICtrlCreateCheckbox(GetTranslated(636, 42, "OCR"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(636, 37, "Debug: Enables Saving OCR images for troubleshooting."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkDebugImageSave = GUICtrlCreateCheckbox(GetTranslated(636, 43, "Images"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(636, 38, "Debug: Enables Saving images for troubleshooting."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkdebugBuildingPos = GUICtrlCreateCheckbox(GetTranslated(636, 44, "Buildings"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(636, 39, "Debug: Enables showing positions of buildings in log."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkdebugTrain = GUICtrlCreateCheckbox(GetTranslated(636, 73, "Training"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(636, 74, "Debug: Enables showing debug during training."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkDebugOCRDonate = GUICtrlCreateCheckbox(GetTranslated(636, 91, "Online debug donations"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(636, 92, "Debug: make ocr of donations and simulate only donate but no donate any troop"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkdebugAttackCSV = GUICtrlCreateCheckbox(GetTranslated(636, 106, "Attack CSV"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(636, 107, "Debug: Generates special CSV parse log files"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkMakeIMGCSV = GUICtrlCreateCheckbox(GetTranslated(636, 108, "Attack CSV Image"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(636, 109, "Debug: Enables saving clean and location marked up images of bases attacked by CSV scripts"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkDebugDisableZoomout = GUICtrlCreateCheckbox(GetTranslated(636, 112, "Disable Zoomout"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(636, 113, "Debug: Disables zoomout of village."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkDebugDisableVillageCentering = GUICtrlCreateCheckbox(GetTranslated(636, 114, "Disable Village Centering"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(636, 115, "Debug: Disables centering of village."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkDebugDeadbaseImage = GUICtrlCreateCheckbox(GetTranslated(636, 116, "Deadbase Image save"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(636, 117, "Debug: Saves images of skipped deadbase villages."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$g_hChkDebugSmartZap = GUICtrlCreateCheckbox(GetTranslated(638, 23, "Debug SmartZap"), $x, $y - 5, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(638, 24, "Use it to debug SmartZap"))
Local $x = 300
$y = 52
Local $yNext = 30
$g_hBtnTestTrain = GUICtrlCreateButton(GetTranslated(636, 88, "Test wallUpg"), $x, $y, 140, 25)
$y += $yNext
$g_hBtnTestDonateCC = GUICtrlCreateButton(GetTranslated(636, 89, "Test Donate"), $x, $y, 140, 25)
$y += $yNext
$g_hBtnTestRequestCC = GUICtrlCreateButton(GetTranslated(636, 110, "Test Request"), $x, $y, 140, 25)
$y += $yNext
$g_hBtnTestAttackBar = GUICtrlCreateButton(GetTranslated(636, 90, "Test Attack Bar"), $x, $y, 140, 25)
$y += $yNext
$g_hBtnTestClickDrag = GUICtrlCreateButton(GetTranslated(636, 102, "Test Click Drag (scrolling)"), $x, $y, 140, 25)
$y += $yNext
$g_hBtnTestImage = GUICtrlCreateButton(GetTranslated(636, 103, "Test Image"), $x, $y, 140, 25)
$y += $yNext
$g_hBtnTestVillageSize = GUICtrlCreateButton(GetTranslated(636, 111, "Test Village Size"), $x, $y, 140, 25)
$y += $yNext
$g_hBtnTestDeadBase = GUICtrlCreateButton(GetTranslated(636, 120, "Test Dead Base"), $x, $y, 140, 25)
$y += $yNext
$g_hBtnTestTHimgloc = GUICtrlCreateButton("imgloc TH", $x, $y, 140, 25)
$y += $yNext
$g_hBtnTestTrainsimgloc = GUICtrlCreateButton("New Train Test", $x, $y, 140, 25)
$y += $yNext
$g_hBtnTestQuickTrainsimgloc = GUICtrlCreateButton("Quick Train Test", $x, $y, 140, 25)
$x -= 145
$g_hTxtTestFindButton = GUICtrlCreateInput("BoostOne", $x - 90, $y + 3, 85, 20)
$g_hBtnTestFindButton = GUICtrlCreateButton(GetTranslated(636, 118, "Test Find Button"), $x, $y, 140, 25)
$y -= $yNext
$g_hBtnTestDeadBaseFolder = GUICtrlCreateButton(GetTranslated(636, 116, "Test Dead Base Folder"), $x, $y, 140, 25)
$g_hBtnTestCleanYard = GUICtrlCreateButton(GetTranslated(636, 119, "Test Clean Yard"), $x - 145, $y, 140, 25)
$y -= $yNext
$g_hBtnTestAttackCSV = GUICtrlCreateButton(GetTranslated(636, 121, "Test Attack CSV"), $x, $y, 140, 25)
$y -= $yNext
$g_hBtnTestimglocTroopBar = GUICtrlCreateButton("IMGLOC ATTACKBAR", $x, $y, 140, 25)
$y -= $yNext
$g_hBtnTestConfigSave = GUICtrlCreateButton("Config Save", $x + 20, $y, 120, 25)
$y -= $yNext
$g_hBtnTestConfigApply = GUICtrlCreateButton("Config Apply", $x + 20, $y, 120, 25)
$y -= $yNext
$g_hBtnTestConfigRead = GUICtrlCreateButton("Config Read", $x + 20, $y, 120, 25)
$y -= $yNext
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_STATS = 0, $g_hGUI_STATS_TAB = 0, $g_hGUI_STATS_TAB_ITEM1 = 0, $g_hGUI_STATS_TAB_ITEM2 = 0, $g_hGUI_STATS_TAB_ITEM3 = 0, $g_hGUI_STATS_TAB_ITEM4 = 0
Global $btnResetStats = 0
Global $g_ahPicTHLevels[12], $g_hLblTHLevels = 0
Global $g_ahPicLeague[$eLeagueCount] = [0,0,0,0,0,0,0,0,0], $g_hLblLeague = 0
Global $g_ahLblStatsStartedWith[$eLootCount] = [0,0,0,0], $g_ahLblStatsGainPerHour[$eLootCount] = [0,0,0,0]
Global $g_ahLblStatsTotalGain[$eLootCount] = [0,0,0,0], $g_ahLblStatsLastAttack[$eLootCount] = [0,0,0,0]
Global $g_ahLblStatsBonusLast[$eLootCount] = [0,0,0,0], $g_ahLblStatsTop[$eLootCount] = [0,0,0,0]
Global $g_hPicResultDEStart = 0, $g_hLblStatsSZRev1 = 0, $g_hLblStatsSZRev2 = 0, $g_hPicHourlyStatsDark = 0, $g_hPicDarkLoot = 0, $g_hPicDarkLastAttack = 0
Global $g_hLblResultRuntime = 0, $g_hLblNbrOfOoS = 0, $g_hLblResultVillagesAttacked = 0, $g_hLblResultVillagesSkipped = 0, $g_hLblResultTrophiesDropped = 0
Global $g_hLblSearchCost = 0, $g_hLblTrainCostElixir = 0, $g_hLblTrainCostDElixir = 0, $g_hLblGoldFromMines = 0, $g_hLblElixirFromCollectors = 0, $g_hLblDElixirFromDrills = 0
Global $g_hLblWallGoldMake = 0, $g_hLblWallElixirMake = 0, $g_hLblNbrOfBuildingUpgGold = 0, $g_hLblNbrOfBuildingUpgElixir = 0, $g_hLblNbrOfHeroUpg = 0
Global $g_hLblWallUpgCostGold = 0, $g_hLblWallUpgCostElixir = 0, $g_hLblBuildingUpgCostGold = 0, $g_hLblBuildingUpgCostElixir = 0, $g_hLblHeroUpgCost = 0
Global $g_hLblAttacked[$g_iModeCount + 3] = [0,0,0,0,0,0], $g_hLblTotalGoldGain[$g_iModeCount + 3] = [0,0,0,0,0,0], $g_hLblTotalElixirGain[$g_iModeCount + 3] = [0,0,0,0,0,0], $g_hLblTotalDElixirGain[$g_iModeCount + 3] = [0,0,0,0,0,0], $g_hLblTotalTrophyGain[$g_iModeCount + 3] = [0,0,0,0,0,0], $g_hLblNbrOfTSSuccess = 0, $g_hLblNbrOfTSFailed = 0
Global $g_hLblNbrOfDetectedMines[$g_iModeCount + 3] = [0,0,0,0,0,0], $g_hLblNbrOfDetectedCollectors[$g_iModeCount + 3] = [0,0,0,0,0,0], $g_hLblNbrOfDetectedDrills[$g_iModeCount + 3] = [0,0,0,0,0,0], $g_hLblSmartZap = 0, $g_hLblSmartLightningUsed = 0, $g_hLblSmartEarthQuakeUsed = 0
Global $g_hLblDonTroop[$eTroopCount] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Global $g_hLblDonSpell[$eSpellCount] = [0,0,0,0,0,0,0,0,0,0]
Global $g_hLblTotalTroopsQ = 0, $g_hLblTotalTroopsXP = 0, $g_hLblTotalSpellsQ = 0, $g_hLblTotalSpellsXP = 0
Func CreateBotStats()
GUISwitch($g_hGUI_STATS)
$g_hGUI_STATS_TAB = GUICtrlCreateTab(0, 0, $_GUI_MAIN_WIDTH - 30, $_GUI_MAIN_HEIGHT - 255 - 30, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$btnResetStats = GUICtrlCreateButton(GetTranslated(632,31, "Reset Stats"), 375, 0, 60, 20)
GUICtrlSetOnEvent(-1, "btnResetStats")
GUICtrlSetState(-1, $GUI_DISABLE)
$g_hGUI_STATS_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslated(600,38,"Gain"))
CreateGainSubTab()
$g_hGUI_STATS_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslated(600,39,"Misc"))
CreateMiscSubTab()
$g_hGUI_STATS_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslated(600,40,"Attacks"))
CreateAttacksSubTab()
$g_hGUI_STATS_TAB_ITEM4 = GUICtrlCreateTabItem(GetTranslated(600, 55,"Donations"))
CreateDonationsSubTab()
GUICtrlCreateTabItem("")
EndFunc
Func CreateGainSubTab()
Local $sTxtTip = ""
Local $xStart = 25, $yStart = 45
Local $x = $xStart, $y = $yStart
GUICtrlCreatePic(@ScriptDir & "\images\Stats\Stats001.jpg", $x - 18, $y - 20, 426, 80)
$x = $xStart + 276
$y = $yStart - 14
$g_ahPicTHLevels[4] = GUICtrlCreateIcon($g_sLibIconPath, $eHdV04, $x - 11, $y + 15, 52, 52)
GUICtrlSetState(-1,$GUI_HIDE)
$g_ahPicTHLevels[5] = GUICtrlCreateIcon($g_sLibIconPath, $eHdV05, $x - 11, $y + 15, 52, 52)
GUICtrlSetState(-1,$GUI_HIDE)
$g_ahPicTHLevels[6] = GUICtrlCreateIcon($g_sLibIconPath, $eHdV06, $x - 11, $y + 15, 52, 52)
GUICtrlSetState(-1,$GUI_HIDE)
$g_ahPicTHLevels[7] = GUICtrlCreateIcon($g_sLibIconPath, $eHdV07, $x - 11, $y + 15, 52, 52)
GUICtrlSetState(-1,$GUI_HIDE)
$g_ahPicTHLevels[8] = GUICtrlCreateIcon($g_sLibIconPath, $eHdV08, $x - 11, $y + 15, 52, 52)
GUICtrlSetState(-1,$GUI_HIDE)
$g_ahPicTHLevels[9] = GUICtrlCreateIcon($g_sLibIconPath, $eHdV09, $x - 11, $y + 15, 52, 52)
GUICtrlSetState(-1,$GUI_HIDE)
$g_ahPicTHLevels[10] = GUICtrlCreateIcon($g_sLibIconPath, $eHdV10, $x - 11, $y + 15, 52, 52)
GUICtrlSetState(-1,$GUI_HIDE)
$g_ahPicTHLevels[11] = GUICtrlCreateIcon($g_sLibIconPath, $eHdV11, $x - 11, $y + 15, 52, 52)
GUICtrlSetState(-1,$GUI_HIDE)
GUICtrlCreateLabel(GetTranslated(632,0, "TownHall"), $x - 11, $y, -1, -1, $SS_CENTER)
$g_hLblTHLevels = GUICtrlCreateLabel("", $x + 38, $y + 53, 17, 17, $SS_CENTER)
GUICtrlSetFont($g_hLblTHLevels, 11, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 340
$y = $yStart - 14
$g_ahPicLeague[$eLeagueUnranked] = GUICtrlCreateIcon($g_sLibIconPath, $eUnranked, $x - 2, $y - 5 + 15, 56, 56)
GUICtrlSetState(-1,$GUI_SHOW)
$g_ahPicLeague[$eLeagueBronze] = GUICtrlCreateIcon($g_sLibIconPath, $eBronze, $x - 2, $y - 5 + 15, 56, 56)
GUICtrlSetState(-1,$GUI_HIDE)
$g_ahPicLeague[$eLeagueSilver] = GUICtrlCreateIcon($g_sLibIconPath, $eSilver, $x - 2, $y - 5 + 15, 56, 56)
GUICtrlSetState(-1,$GUI_HIDE)
$g_ahPicLeague[$eLeagueGold] = GUICtrlCreateIcon($g_sLibIconPath, $eGold, $x - 2, $y - 5 + 15, 56, 56)
GUICtrlSetState(-1,$GUI_HIDE)
$g_ahPicLeague[$eLeagueCrystal] = GUICtrlCreateIcon($g_sLibIconPath, $eCrystal, $x - 2, $y - 5 + 15, 56, 56)
GUICtrlSetState(-1,$GUI_HIDE)
$g_ahPicLeague[$eLeagueMaster] = GUICtrlCreateIcon($g_sLibIconPath, $eMaster, $x - 2, $y - 5 + 15, 56, 56)
GUICtrlSetState(-1,$GUI_HIDE)
$g_ahPicLeague[$eLeagueChampion] = GUICtrlCreateIcon($g_sLibIconPath, $eChampion, $x - 2, $y - 5 + 15, 56, 56)
GUICtrlSetState(-1,$GUI_HIDE)
$g_ahPicLeague[$eLeagueTitan] = GUICtrlCreateIcon($g_sLibIconPath, $eTitan, $x - 2, $y - 5 + 15, 56, 56)
GUICtrlSetState(-1,$GUI_HIDE)
$g_ahPicLeague[$eLeagueLegend] = GUICtrlCreateIcon($g_sLibIconPath, $eLegend, $x - 2, $y - 5 + 15, 56, 56)
GUICtrlSetState(-1,$GUI_HIDE)
GUICtrlCreateLabel(GetTranslated(632,106, "League"), $x + 3, $y, -1, -1, $SS_CENTER)
$g_hLblLeague = GUICtrlCreateLabel("", $x + 43, $y + 53, 17, 17, $SS_CENTER)
GUICtrlSetFont(-1, 11, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 3
$y = $yStart + 100
GUICtrlCreateLabel(GetTranslated(632, 107, "Stats"), $x - 20, $y - 32, 87, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel(GetTranslated(632, 108, "Gold"), $x - 18 + 85, $y - 32, 95, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel(GetTranslated(632, 109, "Elixir"), $x - 18 +(60 * 3), $y - 32, 75, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel(GetTranslated(632, 110, "DarkE"), $x - 23 +(65 * 4), $y - 32, 90, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel(GetTranslated(632, 111, "Trophy"), $x - 23 +(70 * 5), $y - 32, 75, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateGroup("", $x - 20, $y - 20, 422, 28)
GUICtrlCreateLabel(GetTranslated(632, 2, "Started with") & ":", $x - 15, $y - 11, - 1, - 1)
$x += 85
GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslated(632, 7, "The amount of Gold you had when the bot started.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsStartedWith[$eLootGold] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 85
GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslated(632, 8, "The amount of Elixir you had when the bot started.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsStartedWith[$eLootElixir] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 85
$g_hPicResultDEStart = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslated(632, 9, "The amount of Dark Elixir you had when the bot started.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsStartedWith[$eLootDarkElixir] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 75
GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslated(632, 10, "The amount of Trophies you had when the bot started.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsStartedWith[$eLootTrophy] = GUICtrlCreateLabel("0", $x - 18 + 5, $y - 12, 60, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 3
$y = $yStart + 125
GUICtrlCreateGroup("", $x - 20, $y - 20, 422, 28)
GUICtrlCreateLabel(GetTranslated(632,26, "Gain per Hour") & ":", $x - 15, $y - 11, - 1, - 1)
$x += 85
GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslated(632,27, "Gold gain per hour")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsGainPerHour[$eLootGold] = GUICtrlCreateLabel("0/h", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 85
GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslated(632,28, "Elixir gain per hour")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsGainPerHour[$eLootElixir] = GUICtrlCreateLabel("0/h", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 85
$g_hPicHourlyStatsDark = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslated(632,29, "Dark Elixir gain per hour")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsGainPerHour[$eLootDarkElixir] = GUICtrlCreateLabel("0/h", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 75
GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslated(632,30, "Trophy gain per hour")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsGainPerHour[$eLootTrophy] = GUICtrlCreateLabel("0/h", $x - 18 + 5, $y - 12, 60, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 3
$y = $yStart + 150
GUICtrlCreateGroup("", $x - 20, $y - 20, 422, 28)
GUICtrlCreateLabel(GetTranslated(632,20, "Total Gain") & ":", $x - 15, $y - 11, - 1, - 1)
$x += 85
GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslated(632,21, "The total amount of Gold you gained or lost while the Bot is running.") & @CRLF & GetTranslated(632,22, "(This includes manual spending of resources on upgrade of buildings)")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsTotalGain[$eLootGold] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 85
GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslated(632,23, "The total amount of Elixir you gained or lost while the Bot is running.") & @CRLF & GetTranslated(632,22, "(This includes manual spending of resources on upgrade of buildings)")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsTotalGain[$eLootElixir] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 85
$g_hPicDarkLoot = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslated(632,24, "The total amount of Dark Elixir you gained or lost while the Bot is running.") & @CRLF & GetTranslated(632,22, "(This includes manual spending of resources on upgrade of buildings)")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsTotalGain[$eLootDarkElixir] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 75
GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslated(632,25, "The amount of Trophies you gained or lost while the Bot is running.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsTotalGain[$eLootTrophy] = GUICtrlCreateLabel("0", $x - 18 + 5, $y - 12, 60, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 3
$y = $yStart + 195
GUICtrlCreateGroup("", $x - 20, $y - 20, 422, 28)
GUICtrlCreateLabel(GetTranslated(632,102,"Last Attack") & ":", $x - 15, $y - 11, - 1, - 1)
$x += 85
GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslated(632, 12, "The amount of Gold you gained on the last attack.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsLastAttack[$eLootGold] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 85
GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslated(632, 13, "The amount of Elixir you gained on the last attack.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsLastAttack[$eLootElixir] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 85
$g_hPicDarkLastAttack = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslated(632,14, "The amount of Dark Elixir you gained on the last attack.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsLastAttack[$eLootDarkElixir] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 75
GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslated(632,15, "The amount of Trophies you gained or lost on the last attack.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsLastAttack[$eLootTrophy] = GUICtrlCreateLabel("0", $x - 18 + 5, $y - 12, 60, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 3
$y = $yStart + 220
GUICtrlCreateGroup("", $x - 20, $y - 20, 422, 28)
GUICtrlCreateLabel(GetTranslated(632,16, "League Bonus") & ":", $x - 15, $y - 11, - 1, - 1)
$x += 85
GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslated(632,17, "The amount of Bonus Gold you gained on the last attack.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsBonusLast[$eLootGold] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 85
GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslated(632,18, "The amount of Bonus Elixir you gained on the last attack.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsBonusLast[$eLootElixir] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 85
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslated(632,19, "The amount of Bonus Dark Elixir you gained on the last attack.")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsBonusLast[$eLootDarkElixir] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 3
$y = $yStart + 265
GUICtrlCreateGroup("", $x - 20, $y - 20, 422, 28)
GUICtrlCreateLabel(GetTranslated(632, 112, "Top Loot") & ":", $x - 15, $y - 11, - 1, - 1)
$x += 85
GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslated(632, 113, "Top Gold gained")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsTop[$eLootGold] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 85
GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslated(632, 114, "Top Elixir gained")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsTop[$eLootElixir] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 85
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslated(632, 115, "Top Dark gained")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsTop[$eLootDarkElixir] = GUICtrlCreateLabel("0", $x - 18, $y - 12, 65, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 75
GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 50, $y - 12, 16, 16)
$sTxtTip = GetTranslated(632, 116, "Top Trophy gained")
_GUICtrlSetTip(-1, $sTxtTip)
$g_ahLblStatsTop[$eLootTrophy] = GUICtrlCreateLabel("0", $x - 18 + 5, $y - 12, 60, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateMiscSubTab()
Local $sTxtTip = ""
Local $xStart = 25, $yStart = 45
Local $x = $xStart + 3, $y = $yStart + 20
GUICtrlCreateLabel(GetTranslated(632, 105, "Run"), $x - 20, $y - 32, 187, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel("", $x + 35 + 130, $y - 32, 30, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel(GetTranslated(632, 117, "Cost && Collect"), $x - 18 + 212, $y - 32, 207, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
$x -= 10
$y -= 10
GUICtrlCreateIcon($g_sLibIconPath, $eIcnHourGlass, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslated(632,48, "The total Running Time of the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,47, "Runtime") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblResultRuntime = GUICtrlCreateLabel("00:00:00", $x + 35, $y + 2, 150, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
GUICtrlCreateIcon($g_sLibIconPath, $eIcnRecycle, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslated(632,58, "The number of Out of Sync error occurred")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,57, "Nbr of OoS") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblNbrOfOoS = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgTarget, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslated(632,34, "The No. of Villages that were attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,33, "Attacked") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblResultVillagesAttacked = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgX, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslated(632,36, "The No. of Villages that were skipped during search by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,35, "Skipped")& ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblResultVillagesSkipped = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslated(632,46, "The amount of Trophies dropped by the Bot due to Trophy Settings (on Misc Tab).")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,45, "Dropped") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblResultTrophiesDropped = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 180
$y = $yStart + 25
$y -= 15
GUICtrlCreateIcon($g_sLibIconPath, $eIcnMagnifier, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslated(632,60, "Search cost for skipping villages in gold")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,59, "Search Cost") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblSearchCost = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
GUICtrlCreateIcon($g_sLibIconPath, $eIcnArcher, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslated(632,62, "Elixir spent for training Barrack Troops")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,61, "Train Cost Elixir") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTrainCostElixir = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
GUICtrlCreateIcon($g_sLibIconPath, $eIcnMinion, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslated(632,64, "Dark Elixir spent for training Dark Barrack Troops")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,63, "Train Cost DElixir") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTrainCostDElixir = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
GUICtrlCreateIcon($g_sLibIconPath, $eIcnMine, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslated(632,66, "Gold gained by collecting mines")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,65, "Gold collected") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblGoldFromMines = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslated(632,68, "Elixir gained by collecting collectors")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,67, "Elixir collected") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblElixirFromCollectors = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDrill, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslated(632,70, "Dark Elixir gained by collecting drills")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,69, "DElixir collected") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblDElixirFromDrills = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 5
$y = $yStart + 165
GUICtrlCreateLabel(GetTranslated(632, 103, "Upgrades Made"), $x - 20, $y - 32, 187, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xD4D4D4)
GUICtrlCreateLabel("", $x + 35 + 130, $y - 32, 30, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xD4D4D4)
GUICtrlCreateLabel(GetTranslated(632, 104, "Upgrade Costs"), $x - 18 + 212, $y - 32, 207, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xD4D4D4)
$x -= 10
$y -= 10
GUICtrlCreateIcon($g_sLibIconPath, $eIcnWallGold, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslated(632,38, "The No. of Walls upgraded by Gold.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,37, "Upg. by Gold") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblWallGoldMake = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
GUICtrlCreateIcon($g_sLibIconPath, $eIcnWallElixir, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslated(632,40, "The No. of Walls upgraded by Elixir.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,39, "Upg. by Elixir") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblWallElixirMake = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgGold, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslated(632,41, "The number of buildings upgraded using gold")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,37, "Upg. by Gold") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblNbrOfBuildingUpgGold = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgElixir, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslated(632,42, "The number of buildings upgraded using elixir")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,39, "Upg. by Elixir") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblNbrOfBuildingUpgElixir = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
GUICtrlCreateIcon($g_sLibIconPath, $eIcnHeroes, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslated(632,44, "The number of heroes upgraded")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,43, "Hero Upgrade") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblNbrOfHeroUpg = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 180
$y = $yStart + 165
$y -= 10
GUICtrlCreateIcon($g_sLibIconPath, $eIcnWallGold, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslated(632,50, "The cost of gold used by bot while upgrading walls")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,49, "Upg. Cost Gold") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblWallUpgCostGold = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
GUICtrlCreateIcon($g_sLibIconPath, $eIcnWallElixir, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslated(632,52, "The cost of elixir used by bot while upgrading walls")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,51, "Upg. Cost Elixir") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblWallUpgCostElixir = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgGold, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslated(632,53, "The cost of gold used by bot while upgrading buildings")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,49, "Upg. Cost Gold") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblBuildingUpgCostGold = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgElixir, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslated(632,54, "The cost of elixir used by bot while upgrading buildings")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,51, "Upg. Cost Elixir") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblBuildingUpgCostElixir = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
GUICtrlCreateIcon($g_sLibIconPath, $eIcnHeroes, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslated(632,56, "The cost of dark elixir used by bot while upgrading heroes")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,55, "Upg. Cost DElixir") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblHeroUpgCost = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x -= 20
$y -= 85
GUICtrlCreateLabel("", $x + 28, $y - 160, 5, 300)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateAttacksSubTab()
Local $sTxtTip = ""
Local $xStart = 25, $yStart = 45
Local $x = $xStart + 3, $y = $yStart + 20
GUICtrlCreateLabel(GetTranslated(632,71, "Dead Base"), $x - 20, $y - 32, 187, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel("", $x + 35 + 130, $y - 32, 30, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel(GetTranslated(632,78, "Live Base"), $x - 18 + 212, $y - 32, 207, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
$x -= 10
$y -= 10
GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgTarget, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslated(632,73, "The No. of Dead Base that were attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,72, "Attacked") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblAttacked[$DB] = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslated(632,75, "The amount of Gold gained from Dead Bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,74, "gain") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalGoldGain[$DB] = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslated(632,76, "The amount of Elixir gained from Dead Bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,74, -1) & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalElixirGain[$DB] = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslated(632,100, "The amount of Dark Elixir gained from Dead Bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,74, -1) & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalDElixirGain[$DB] = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslated(632,77, "The amount of Trophies gained from Dead Bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,74, -1) & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalTrophyGain[$DB] = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 30
$y += 25
$g_hLblNbrOfDetectedMines[$DB] = GUICtrlCreateLabel("0", $x - 18, $y - 2, 20, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnMine, $x + 6, $y - 4, 16, 16)
$x += 20
$g_hLblNbrOfDetectedCollectors[$DB] = GUICtrlCreateLabel("0", $x + 18, $y - 2, 20, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 43, $y - 4, 16, 16)
$x += 20
$g_hLblNbrOfDetectedDrills[$DB] = GUICtrlCreateLabel("0", $x + 54, $y - 2, 20, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDrill, $x + 79, $y - 4, 16, 16)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 180
$y = $yStart + 25
$y -= 15
GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgTarget, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslated(632,79, "The No. of Live Base that were attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,72, "Attacked") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblAttacked[$LB] = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslated(632,80, "The amount of Gold gained from Live Bases attacked by the Bot")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,74, -1) & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalGoldGain[$LB] = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslated(632,81, "The amount of Elixir gained from Live Bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,74, -1) & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalElixirGain[$LB] = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslated(632,82, "The amount of Dark Elixir gained from Live Bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,74, -1) & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalDElixirGain[$LB] = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslated(632,83, "The amount of Trophy gained from Live Bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,74, -1) & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalTrophyGain[$LB] = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 62
$y += 25
$g_hLblNbrOfDetectedMines[$LB] = GUICtrlCreateLabel("0", $x - 18, $y - 2, 20, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnMine, $x + 6, $y - 4, 16, 16)
$x += 20
$g_hLblNbrOfDetectedCollectors[$LB] = GUICtrlCreateLabel("0", $x + 18, $y - 2, 20, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 43, $y - 4, 16, 16)
$x += 20
$g_hLblNbrOfDetectedDrills[$LB] = GUICtrlCreateLabel("0", $x + 54, $y - 2, 20, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDrill, $x + 79, $y - 4, 16, 16)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 5
$y = $yStart + 165
GUICtrlCreateLabel(GetTranslated(632,90, "TH Snipe"), $x - 20, $y - 32, 187, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xD4D4D4)
GUICtrlCreateLabel("", $x + 35 + 130, $y - 32, 30, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xD4D4D4)
GUICtrlCreateLabel(GetTranslated(632,84, "TH Bully"), $x - 18 + 212, $y - 32, 207, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xD4D4D4)
$x -= 10
$y -= 10
GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgTarget, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslated(632,101,"The No. of TH Snipes attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,72, "Attacked") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblAttacked[$TS] = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslated(632,91, "The amount of Gold gained from TH Snipe bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,74, -1) & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalGoldGain[$TS] = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslated(632,92, "The amount of Elixir gained from TH Snipe bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,74, -1) & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalElixirGain[$TS] = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslated(632,93, "The amount of Dark Elixir gained from TH Snipe bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,74, -1) & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalDElixirGain[$TS] = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x - 10, $y, 16, 16)
$sTxtTip = GetTranslated(632,94, "The amount of Trophy gained from TH Snipe bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,74, -1) & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalTrophyGain[$TS] = GUICtrlCreateLabel("0", $x + 115, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 25
$y += 25
GUICtrlCreateIcon($g_sLibIconPath, $eIcnGreenLight, $x - 15, $y - 4, 16, 16)
$sTxtTip = GetTranslated(632,95, "The number of successful TH Snipes")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblNbrOfTSSuccess = GUICtrlCreateLabel("0", $x + 13, $y - 2, 25, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 50
GUICtrlCreateIcon($g_sLibIconPath, $eIcnRedLight, $x + 35, $y - 4, 16, 16)
$sTxtTip = GetTranslated(632,96, "The number of failed TH Snipe attempt")
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblNbrOfTSFailed = GUICtrlCreateLabel("0", $x + 63, $y - 2, 25, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 180
$y = $yStart + 165
$y -= 10
GUICtrlCreateIcon($g_sLibIconPath, $eIcnBldgTarget, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslated(632,85, "The No. of TH Bully bases that were attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,72, "Attacked") & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblAttacked[$TB] = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslated(632,86, "The amount of Gold gained from TH Bully bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,74, -1) & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalGoldGain[$TB] = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslated(632,87, "The amount of Elixir gained from TH Bully bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,74, -1) & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalElixirGain[$TB] = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslated(632,88, "The amount of Dark Elixir gained from TH Bully bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,74, -1) & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalDElixirGain[$TB] = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
$sTxtTip = GetTranslated(632,88, "The amount of Dark Elixir gained from TH Bully bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
$y += 20
GUICtrlCreateIcon($g_sLibIconPath, $eIcnTrophy, $x + 22, $y, 16, 16)
$sTxtTip = GetTranslated(632,89, "The amount of Trophy gained from TH Bully bases attacked by the Bot.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(632,74, -1) & ":", $x + 45, $y + 2, -1, 17)
_GUICtrlSetTip(-1, $sTxtTip)
$g_hLblTotalTrophyGain[$TB] = GUICtrlCreateLabel("0", $x + 150, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x += 64
$y += 25
$g_hLblNbrOfDetectedMines[$TB] = GUICtrlCreateLabel("0", $x - 18, $y - 2, 18, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnMine, $x + 6, $y - 4, 16, 16)
$x += 20
$g_hLblNbrOfDetectedCollectors[$TB] = GUICtrlCreateLabel("0", $x + 18, $y - 2, 18, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnCollector, $x + 43, $y - 4, 16, 16)
$x += 20
$g_hLblNbrOfDetectedDrills[$TB] = GUICtrlCreateLabel("0", $x + 54, $y - 2, 18, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDrill, $x + 79, $y - 4, 16, 16)
$x -= 124
$y -= 110
GUICtrlCreateLabel("", $x + 28, $y - 160, 5, 300)
GUICtrlSetBkColor(-1, 0xC3C3C3)
$x = $xStart + 5
$y = $yStart + 310
$g_hLblStatsSZRev1 = GUICtrlCreateLabel("", $x - 20, $y - 32, 420, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xD4D4D4)
$g_hLblStatsSZRev2 = GUICtrlCreateLabel(GetTranslated(632,122, "Smart Zap"), $x + 155, $y - 32, 60, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xD4D4D4)
$x -= 10
$y -= 10
GUICtrlCreateIcon($g_sLibIconPath, $eIcnLightSpell, $x - 10, $y, 16, 16)
_GUICtrlSetTip(-1, GetTranslated(632,125, "The amount of Lightning Spells used to zap"))
GUICtrlCreateLabel(GetTranslated(632,123, "Used") & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, GetTranslated(632,125, -1))
$g_hLblSmartLightningUsed = GUICtrlCreateLabel("0", $x + 45, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, GetTranslated(632,125, -1))
$x += 145
GUICtrlCreateIcon($g_sLibIconPath, $eIcnEarthQuakeSpell, $x - 10, $y, 16, 16)
_GUICtrlSetTip(-1, GetTranslated(632,126, "The amount of Earthquake Spells used to zap"))
GUICtrlCreateLabel(GetTranslated(632,123, -1) & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, GetTranslated(632,126, -1))
$g_hLblSmartEarthQuakeUsed = GUICtrlCreateLabel("0", $x + 45, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, GetTranslated(632,126, -1))
$x += 145
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x - 10, $y -1, 18, 18)
_GUICtrlSetTip(-1, GetTranslated(632,124,"The amount of Dark Elixir won while zapping"))
GUICtrlCreateLabel(GetTranslated(632,74, -1) & ":", $x + 13, $y + 2, -1, 17)
_GUICtrlSetTip(-1, GetTranslated(632,124, -1))
$g_hLblSmartZap = GUICtrlCreateLabel("0", $x + 45, $y + 2, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, GetTranslated(632,124, -1))
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CreateDonationsSubTab()
Local $sTxtTip = ""
Local $xStart = 25, $yStart = 45
Local $x = $xStart + 3, $y = $yStart + 20
GUICtrlCreateLabel(GetTranslated(632,127,"Elixir Troops"), $x - 20, $y - 32, 187, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel("", $x + 35 + 130, $y - 32, 30, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel(GetTranslated(632,128,"Dark Elixir Troops"), $x - 18 + 212, $y - 32, 207, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
$x -= 10
$y -= 10
GUICtrlCreateIcon($g_sLibIconPath, $eIcnBarbarian, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopBarbarian] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnWizard, $x + 95, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 122, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopWizard] = GUICtrlCreateLabel("0", $x + 115, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
GUICtrlCreateIcon($g_sLibIconPath, $eIcnArcher, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopArcher] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnHealer, $x + 95, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 122, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopHealer] = GUICtrlCreateLabel("0", $x + 115, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
GUICtrlCreateIcon($g_sLibIconPath, $eIcnGiant, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopGiant] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDragon, $x + 95, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 122, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopDragon] = GUICtrlCreateLabel("0", $x + 115, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
GUICtrlCreateIcon($g_sLibIconPath, $eIcnGoblin, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopGoblin] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnPekka, $x + 95, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 122, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopPekka] = GUICtrlCreateLabel("0", $x + 115, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
GUICtrlCreateIcon($g_sLibIconPath, $eIcnWallBreaker, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopWallBreaker] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnBabyDragon, $x + 95, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 122, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopBabyDragon] = GUICtrlCreateLabel("0", $x + 115, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
GUICtrlCreateIcon($g_sLibIconPath, $eIcnBalloon, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopBalloon] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnMiner, $x + 95, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 122, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopMiner] = GUICtrlCreateLabel("0", $x + 115, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x = $xStart + 212
$y = $yStart + 25
$y -= 15
GUICtrlCreateIcon($g_sLibIconPath, $eIcnMinion, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopMinion] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnBowler, $x + 95, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 122, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopBowler] = GUICtrlCreateLabel("0", $x + 115, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
GUICtrlCreateIcon($g_sLibIconPath, $eIcnHogRider, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopHogRider] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
GUICtrlCreateIcon($g_sLibIconPath, $eIcnValkyrie, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopValkyrie] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
GUICtrlCreateIcon($g_sLibIconPath, $eIcnGolem, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopGolem] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
GUICtrlCreateIcon($g_sLibIconPath, $eIcnWitch, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopWitch] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
GUICtrlCreateIcon($g_sLibIconPath, $eIcnLavaHound, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonTroop[$eTroopLavaHound] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x = $xStart + 3
$y = $yStart + 210
GUICtrlCreateLabel(GetTranslated(632,120,"Total Donated") & ":", $x - 20, $y - 32, 187, 17)
GUICtrlSetBkColor(-1, 0xD4D4D4)
GUICtrlCreateLabel("", $x + 35 + 130, $y - 32, 30, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xD4D4D4)
$g_hLblTotalTroopsQ = GUICtrlCreateLabel("0", $x + 105, $y - 32, 70, 17, $SS_RIGHT)
GUICtrlSetBkColor(-1, 0xD4D4D4)
GUICtrlCreateLabel(GetTranslated(632,121,"Total XP") & ":", $x - 18 + 212, $y - 32, 207, 17)
GUICtrlSetBkColor(-1, 0xD4D4D4)
$g_hLblTotalTroopsXP = GUICtrlCreateLabel("0", $x + 320, $y - 32, 70, 17, $SS_RIGHT)
GUICtrlSetBkColor(-1, 0xD4D4D4)
$x = $xStart + 3
$y = $yStart + 235
GUICtrlCreateLabel(GetTranslated(632,129, "Elixir Spells"), $x - 20, $y - 32, 187, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel("", $x + 35 + 130, $y - 32, 30, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel(GetTranslated(632,130, "Dark Elixir Spells"), $x - 18 + 212, $y - 32, 207, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xC3C3C3)
$x -= 10
$y -= 10
GUICtrlCreateIcon($g_sLibIconPath, $eIcnLightSpell, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonSpell[$eSpellLightning] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnFreezeSpell, $x + 95, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 122, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonSpell[$eSpellFreeze] = GUICtrlCreateLabel("0", $x + 115, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
GUICtrlCreateIcon($g_sLibIconPath, $eIcnHealSpell, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonSpell[$eSpellHeal] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
GUICtrlCreateIcon($g_sLibIconPath, $eIcnRageSpell, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonSpell[$eSpellRage] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
GUICtrlCreateIcon($g_sLibIconPath, $eIcnJumpSpell, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonSpell[$eSpellJump] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x = $xStart + 210
$y = $yStart + 235
$y -= 10
GUICtrlCreateIcon($g_sLibIconPath, $eIcnPoisonSpell, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonSpell[$eSpellPoison] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
GUICtrlCreateIcon($g_sLibIconPath, $eIcnEarthQuakeSpell, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonSpell[$eSpellEarthquake] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
GUICtrlCreateIcon($g_sLibIconPath, $eIcnHasteSpell, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonSpell[$eSpellHaste] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$y += 28
GUICtrlCreateIcon($g_sLibIconPath, $eIcnSkeletonSpell, $x - 10, $y, 24, 24)
$sTxtTip = ""
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(":", $x + 18, $y + 4, -1, 17)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
$g_hLblDonSpell[$eSpellSkeleton] = GUICtrlCreateLabel("0", $x + 15, $y + 4, 70, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
_GUICtrlSetTip(-1, $sTxtTip)
$x = $xStart + 5
$y = $yStart + 370
GUICtrlCreateLabel(GetTranslated(632,120,"Total Donated") & ":", $x - 20, $y - 32, 187, 17)
GUICtrlSetBkColor(-1, 0xD4D4D4)
GUICtrlCreateLabel("", $x + 35 + 130, $y - 32, 30, 17, $SS_CENTER)
GUICtrlSetBkColor(-1, 0xD4D4D4)
$g_hLblTotalSpellsQ = GUICtrlCreateLabel("0", $x + 105, $y - 32, 70, 17, $SS_RIGHT)
GUICtrlSetBkColor(-1, 0xD4D4D4)
GUICtrlCreateLabel(GetTranslated(632,121,"Total XP") & ":", $x - 18 + 212, $y - 32, 207, 17)
GUICtrlSetBkColor(-1, 0xD4D4D4)
$g_hLblTotalSpellsXP = GUICtrlCreateLabel("0", $x + 320, $y - 32, 70, 17, $SS_RIGHT)
GUICtrlSetBkColor(-1, 0xD4D4D4)
$x += 155
$y -= 250
GUICtrlCreateLabel("", $x + 28, $y - 130, 5, 188)
GUICtrlSetBkColor(-1, 0xC3C3C3)
GUICtrlCreateLabel("", $x + 28, $y + 90, 5, 128)
GUICtrlSetBkColor(-1, 0xC3C3C3)
EndFunc
Global $g_hGUI_BOT_TAB = 0, $g_hGUI_BOT_TAB_ITEM1 = 0, $g_hGUI_BOT_TAB_ITEM2 = 0, $g_hGUI_BOT_TAB_ITEM3 = 0, $g_hGUI_BOT_TAB_ITEM4 = 0, $g_hGUI_BOT_TAB_ITEM5 = 0
Func CreateBotTab()
$g_hGUI_BOT = GUICreate("", $_GUI_MAIN_WIDTH - 20, $_GUI_MAIN_HEIGHT - 255, $_GUI_CHILD_LEFT, $_GUI_CHILD_TOP, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hFrmBotEx)
$g_hGUI_STATS = GUICreate("", $_GUI_MAIN_WIDTH - 28, $_GUI_MAIN_HEIGHT - 255 - 28, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hGUI_BOT)
GUISwitch($g_hGUI_BOT)
$g_hGUI_BOT_TAB = GUICtrlCreateTab(0, 0, $_GUI_MAIN_WIDTH - 20, $_GUI_MAIN_HEIGHT - 255, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_BOT_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslated(600, 35, "Options"))
CreateBotOptions()
$g_hGUI_BOT_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslated(600, 53, "Android"))
CreateBotAndroid()
$g_hGUI_BOT_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslated(600, 51, "Debug"))
CreateBotDebug()
EndFunc
Global $g_hGUI_MOD = 0
Global $g_hGUI_MOD_TAB = 0, $g_hGUI_MOD_TAB_ITEM1 = 0 , $g_hGUI_MOD_TAB_ITEM2 = 0 ,$g_hGUI_MOD_TAB_ITEM3 = 0, $g_hGUI_MOD_TAB_ITEM4 = 0, $g_hGUI_MOD_TAB_ITEM5 = 0
Global $chkEnableTrCollect = 0, $chkForceTrCollect = 0, $chkGoldTrCollect = 0, $txtMinGoldTrCollect = 0, $txtMinElxTrCollect = 0, $chkFullElxTrCollect = 0, $chkDarkTrCollect = 0, $txtMinDarkTrCollect = 0
Global $chkFullDarkTrCollect = 0, $chkElxTrCollect = 0, $chkFullGoldTrCollect = 0
Global $Icon1 = 0 , $chkUseBotHumanization = 0 , $chkUseAltRClick = 0 , $Label1 = 0 , $g_acmbPriority , $Label20 = 0 , $challengeMessage = 0 , $g_ahumanMessage, $Label2 = 0 , $Label4 = 0 , $Label3= 0
Global $Icon2 = 0 , $Label5 = 0 , $Label6 = 0 , $Label7 = 0 , $Label8 = 0
Global $Icon3 = 0 , $Label9 = 0 , $Label10 = 0 , $Label11 = 0 , $Label12 = 0
Global $Icon4 = 0 , $Label14 = 0 , $Label15 = 0 , $Label16 = 0 , $Label13 = 0
Global $Icon5 = 0 , $Label17 = 0 , $Label18 = 0 , $chkCollectAchievements = 0 , $chkLookAtRedNotifications = 0 , $cmbMaxActionsNumber = 0
Global $grpSuperXP = 0 , $chkEnableSuperXP = 0 , $rbSXTraining= 0 , $lblLOCKEDSX = 0 , $rbSXIAttacking = 0 , $txtMaxXPtoGain = 0
Global $chkSXBK = 0 , $chkSXAQ = 0 , $chkSXGW = 0
Global $DocXP1 = 0 , $DocXP2 = 0 , $DocXP3 = 0 ,$DocXP4 = 0
Global $lblXPatStart = 0 , $lblXPCurrent = 0 , $lblXPSXWon = 0 , $lblXPSXWonHour = 0
Global $chkExtraPersian = 0
Global $g_hCmbProfile = 0, $g_hTxtVillageName = 0, $g_hBtnAddProfile = 0, $g_hBtnConfirmAddProfile = 0, $g_hBtnConfirmRenameProfile = 0, $g_hBtnDeleteProfile = 0, $g_hBtnCancelProfileChange = 0, $g_hBtnRenameProfile = 0
Global $chkEnableSwitchAccount, $lblNB, $cmbAccountsQuantity
Global $chkCanUse[9] = [0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $chkDonateAccount[9] = [0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $cmbAccount[9] = [0, 0, 0, 0, 0, 0, 0, 0, 0]
Func CreateModProfiles()
Local $x = 25, $y = 45
GUICtrlCreateGroup(GetTranslated(637,1, "Switch Profiles"), $x - 20, $y - 20, 440, 360)
$x -= 5
$g_hCmbProfile = GUICtrlCreateCombo("", $x - 3, $y + 1, 130, 18, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslated(637,2, "Use this to switch to a different profile")& @CRLF & GetTranslated(637,3, "Your profiles can be found in") & ": " & @CRLF & $g_sProfilePath)
setupProfileComboBox()
PopulatePresetComboBox()
GUICtrlSetState(-1, $GUI_SHOW)
GUICtrlSetOnEvent(-1, "cmbProfile")
$g_hTxtVillageName = GUICtrlCreateInput(GetTranslated(637,4, "MyVillage"), $x - 3, $y, 130, 22, $ES_AUTOHSCROLL)
GUICtrlSetLimit(-1, 100, 0)
GUICtrlSetFont(-1, 9, 400, 1)
_GUICtrlSetTip(-1, GetTranslated(637,5, "Your village/profile's name"))
GUICtrlSetState(-1, $GUI_HIDE)
Local $bIconAdd = _GUIImageList_Create(24, 24, 4)
_GUIImageList_AddBitmap($bIconAdd, @ScriptDir & "\images\Button\iconAdd.bmp")
_GUIImageList_AddBitmap($bIconAdd, @ScriptDir & "\images\Button\iconAdd_2.bmp")
_GUIImageList_AddBitmap($bIconAdd, @ScriptDir & "\images\Button\iconAdd_2.bmp")
_GUIImageList_AddBitmap($bIconAdd, @ScriptDir & "\images\Button\iconAdd_4.bmp")
_GUIImageList_AddBitmap($bIconAdd, @ScriptDir & "\images\Button\iconAdd.bmp")
Local $bIconConfirm = _GUIImageList_Create(24, 24, 4)
_GUIImageList_AddBitmap($bIconConfirm, @ScriptDir & "\images\Button\iconConfirm.bmp")
_GUIImageList_AddBitmap($bIconConfirm, @ScriptDir & "\images\Button\iconConfirm_2.bmp")
_GUIImageList_AddBitmap($bIconConfirm, @ScriptDir & "\images\Button\iconConfirm_2.bmp")
_GUIImageList_AddBitmap($bIconConfirm, @ScriptDir & "\images\Button\iconConfirm_4.bmp")
_GUIImageList_AddBitmap($bIconConfirm, @ScriptDir & "\images\Button\iconConfirm.bmp")
Local $bIconDelete = _GUIImageList_Create(24, 24, 4)
_GUIImageList_AddBitmap($bIconDelete, @ScriptDir & "\images\Button\iconDelete.bmp")
_GUIImageList_AddBitmap($bIconDelete, @ScriptDir & "\images\Button\iconDelete_2.bmp")
_GUIImageList_AddBitmap($bIconDelete, @ScriptDir & "\images\Button\iconDelete_2.bmp")
_GUIImageList_AddBitmap($bIconDelete, @ScriptDir & "\images\Button\iconDelete_4.bmp")
_GUIImageList_AddBitmap($bIconDelete, @ScriptDir & "\images\Button\iconDelete.bmp")
Local $bIconCancel = _GUIImageList_Create(24, 24, 4)
_GUIImageList_AddBitmap($bIconCancel, @ScriptDir & "\images\Button\iconCancel.bmp")
_GUIImageList_AddBitmap($bIconCancel, @ScriptDir & "\images\Button\iconCancel_2.bmp")
_GUIImageList_AddBitmap($bIconCancel, @ScriptDir & "\images\Button\iconCancel_2.bmp")
_GUIImageList_AddBitmap($bIconCancel, @ScriptDir & "\images\Button\iconCancel_4.bmp")
_GUIImageList_AddBitmap($bIconCancel, @ScriptDir & "\images\Button\iconCancel.bmp")
Local $bIconEdit = _GUIImageList_Create(24, 24, 4)
_GUIImageList_AddBitmap($bIconEdit, @ScriptDir & "\images\Button\iconEdit.bmp")
_GUIImageList_AddBitmap($bIconEdit, @ScriptDir & "\images\Button\iconEdit_2.bmp")
_GUIImageList_AddBitmap($bIconEdit, @ScriptDir & "\images\Button\iconEdit_2.bmp")
_GUIImageList_AddBitmap($bIconEdit, @ScriptDir & "\images\Button\iconEdit_4.bmp")
_GUIImageList_AddBitmap($bIconEdit, @ScriptDir & "\images\Button\iconEdit.bmp")
$g_hBtnAddProfile = GUICtrlCreateButton("", $x + 135, $y, 24, 24)
_GUICtrlButton_SetImageList($g_hBtnAddProfile, $bIconAdd, 4)
GUICtrlSetOnEvent(-1, "btnAddConfirm")
GUICtrlSetState(-1, $GUI_SHOW)
_GUICtrlSetTip(-1, GetTranslated(637,6, "Add New Profile"))
$g_hBtnConfirmAddProfile = GUICtrlCreateButton("", $x + 135, $y, 24, 24)
_GUICtrlButton_SetImageList($g_hBtnConfirmAddProfile, $bIconConfirm, 4)
GUICtrlSetOnEvent(-1, "btnAddConfirm")
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, GetTranslated(637,7, "Confirm"))
$g_hBtnConfirmRenameProfile = GUICtrlCreateButton("", $x + 135, $y, 24, 24)
_GUICtrlButton_SetImageList($g_hBtnConfirmRenameProfile, $bIconConfirm, 4)
GUICtrlSetOnEvent(-1, "btnRenameConfirm")
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, GetTranslated(637,7, -1))
$g_hBtnDeleteProfile = GUICtrlCreateButton("", $x + 164, $y, 24, 24)
_GUICtrlButton_SetImageList($g_hBtnDeleteProfile, $bIconDelete, 4)
GUICtrlSetOnEvent(-1, "btnDeleteCancel")
GUICtrlSetState(-1, $GUI_SHOW)
_GUICtrlSetTip(-1, GetTranslated(637,8, "Delete Profile"))
$g_hBtnCancelProfileChange = GUICtrlCreateButton("", $x + 164, $y, 24, 24)
_GUICtrlButton_SetImageList($g_hBtnCancelProfileChange, $bIconCancel, 4)
GUICtrlSetOnEvent(-1, "btnDeleteCancel")
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, GetTranslated(637,9, "Cancel"))
$g_hBtnRenameProfile = GUICtrlCreateButton("", $x + 194, $y, 24, 24)
_GUICtrlButton_SetImageList($g_hBtnRenameProfile, $bIconEdit, 4)
GUICtrlSetOnEvent(-1, "btnRenameConfirm")
_GUICtrlSetTip(-1, GetTranslated(637,10, "Rename Profile"))
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 10, $z = 189, $w = 357, $y = 85
GUICtrlCreateGroup(GetTranslated(108,1, "Smart Switch Accounts"), $x, $y, 430, 295)
$x += 10
$y += 20
$chkEnableSwitchAccount = GUICtrlCreateCheckbox(GetTranslated(108,2, "Use Smart Switch Accounts"), $x, $y, 152, 17)
GUICtrlSetOnEvent(-1, "chkSwitchAccount")
$lblNB = GUICtrlCreateLabel(GetTranslated(108,3, "Number of accounts on Emulator :"), $x + 195, $y + 2, 165, 17)
$cmbAccountsQuantity = GUICtrlCreateCombo("", $x + 365, $y - 2, 45, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetOnEvent(-1, "cmbAccountsQuantity")
GUICtrlSetData(-1, "2|3|4|5|6|7|8", "2")
$y += 35
$chkCanUse[1] = GUICtrlCreateCheckbox(GetTranslated(108,4, "Use Account 1 with Profile :"), $x, $y, 150, 17)
GUICtrlSetOnEvent(-1, "chkAccountsProperties")
$cmbAccount[1] = GUICtrlCreateCombo("", $z, $y - 2, 145, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
$chkDonateAccount[1] = GUICtrlCreateCheckbox(GetTranslated(108,5, "Donate only"), $w, $y, 77, 17)
GUICtrlSetOnEvent(-1, "chkAccountsProperties")
$y += 30
$chkCanUse[2] = GUICtrlCreateCheckbox(GetTranslated(108,6, "Use Account 2 with Profile :"), $x, $y, 150, 17)
GUICtrlSetOnEvent(-1, "chkAccountsProperties")
$cmbAccount[2] = GUICtrlCreateCombo("", $z, $y - 2, 145, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
$chkDonateAccount[2] = GUICtrlCreateCheckbox(GetTranslated(108,5, "Donate only"), $w, $y, 77, 17)
GUICtrlSetOnEvent(-1, "chkAccountsProperties")
$y += 30
$chkCanUse[3] = GUICtrlCreateCheckbox(GetTranslated(108,7, "Use Account 3 with Profile :"), $x, $y, 150, 17)
GUICtrlSetOnEvent(-1, "chkAccountsProperties")
$cmbAccount[3] = GUICtrlCreateCombo("", $z, $y - 2, 145, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
$chkDonateAccount[3] = GUICtrlCreateCheckbox(GetTranslated(108,5, "Donate only"), $w, $y, 77, 17)
GUICtrlSetOnEvent(-1, "chkAccountsProperties")
$y += 30
$chkCanUse[4] = GUICtrlCreateCheckbox(GetTranslated(108,8, "Use Account 4 with Profile :"), $x, $y, 150, 17)
GUICtrlSetOnEvent(-1, "chkAccountsProperties")
$cmbAccount[4] = GUICtrlCreateCombo("", $z, $y - 2, 145, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
$chkDonateAccount[4] = GUICtrlCreateCheckbox(GetTranslated(108,5, "Donate only"), $w, $y, 77, 17)
GUICtrlSetOnEvent(-1, "chkAccountsProperties")
$y += 30
$chkCanUse[5] = GUICtrlCreateCheckbox(GetTranslated(108,9, "Use Account 5 with Profile :"), $x, $y, 150, 17)
GUICtrlSetOnEvent(-1, "chkAccountsProperties")
$cmbAccount[5] = GUICtrlCreateCombo("", $z, $y - 2, 145, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
$chkDonateAccount[5] = GUICtrlCreateCheckbox(GetTranslated(108,5, "Donate only"), $w, $y, 77, 17)
GUICtrlSetOnEvent(-1, "chkAccountsProperties")
$y += 30
$chkCanUse[6] = GUICtrlCreateCheckbox(GetTranslated(108,10, "Use Account 6 with Profile :"), $x, $y, 150, 17)
GUICtrlSetOnEvent(-1, "chkAccountsProperties")
$cmbAccount[6] = GUICtrlCreateCombo("", $z, $y - 2, 145, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
$chkDonateAccount[6] = GUICtrlCreateCheckbox(GetTranslated(108,5, "Donate only"), $w, $y, 77, 17)
GUICtrlSetOnEvent(-1, "chkAccountsProperties")
$y += 30
$chkCanUse[7] = GUICtrlCreateCheckbox(GetTranslated(108,11, "Use Account 7 with Profile :"), $x, $y, 150, 17)
GUICtrlSetOnEvent(-1, "chkAccountsProperties")
$cmbAccount[7] = GUICtrlCreateCombo("", $z, $y - 2, 145, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
$chkDonateAccount[7] = GUICtrlCreateCheckbox(GetTranslated(108,5, "Donate only"), $w, $y, 77, 17)
GUICtrlSetOnEvent(-1, "chkAccountsProperties")
$y += 30
$chkCanUse[8] = GUICtrlCreateCheckbox(GetTranslated(108,12, "Use Account 8 with Profile :"), $x, $y, 150, 17)
GUICtrlSetOnEvent(-1, "chkAccountsProperties")
$cmbAccount[8] = GUICtrlCreateCombo("", $z, $y - 2, 145, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
$chkDonateAccount[8] = GUICtrlCreateCheckbox(GetTranslated(108,5, "Donate only"), $w, $y, 77, 17)
GUICtrlSetOnEvent(-1, "chkAccountsProperties")
GUICtrlCreateGroup("", -99, -99, 1, 1)
setupProfileComboBox()
PopulatePresetComboBox()
EndFunc
Global $g_icnGoldSW[9]
func CreateMultiStatsGUI()
Local $x = -5, $y = 7
$g_grpVillageSW[1] = GUICtrlCreateGroup("Account 1", $x + 16, $y + 18, 209, 97, BitOR($GUI_SS_DEFAULT_GROUP,$BS_FLAT))
$g_lblGoldNowSW[1] = GUICtrlCreateLabel("", $x + 40, $y + 36, 68, 17, $SS_RIGHT)
$g_lblElixirNowSW[1] = GUICtrlCreateLabel("", $x + 40, $y + 54, 68, 17, $SS_RIGHT)
$g_lblDarkNowSW[1] = GUICtrlCreateLabel("", $x + 40, $y + 72, 68, 17, $SS_RIGHT)
$g_icnGoldSW[1] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 112, $y + 34, 18, 18)
$g_icnElixirSW[1] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 112, $y + 52, 18, 18)
$g_icnDarkSW[1] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 112, $y + 70, 18, 18)
$g_lblHrStatsGoldSW[1] = GUICtrlCreateLabel("", $x + 130, $y + 36, 43, 17, $SS_RIGHT)
$g_lblHrStatsElixirSW[1]= GUICtrlCreateLabel("", $x + 130, $y + 54, 43, 17, $SS_RIGHT)
$g_lblHrStatsDarkSW[1] = GUICtrlCreateLabel("", $x + 130, $y + 72, 43, 17, $SS_RIGHT)
$g_lblUnitMeasureSW1[1] = GUICtrlCreateLabel("K/Hour", $x + 176, $y + 36, 45, 17)
$g_lblUnitMeasureSW2[1] = GUICtrlCreateLabel("K/Hour", $x + 176, $y + 54, 45, 17)
$g_lblUnitMeasureSW3[1] = GUICtrlCreateLabel("/Hour", $x + 183, $y + 72, 37, 17)
$g_icnGemSW[1] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnGem, $x + 76, $y + 90, 18, 18)
$g_icnBuliderSW[1] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnBuilder, $x + 126, $y + 90, 18, 18)
$g_icnHourGlassSW[1] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnHourGlass, $x + 204, $y + 90, 18, 18)
$g_lblKingStatus[1] = GUICtrlCreateLabel("K", $x + 22, $y + 36, 12, 14, $SS_CENTER)
GUICtrlSetState(-1, $GUI_HIDE)
$g_lblQueenStatus[1] = GUICtrlCreateLabel("Q", $x + 22, $y + 54, 12, 14, $SS_CENTER)
GUICtrlSetState(-1, $GUI_HIDE)
$g_lblWardenStatus[1] = GUICtrlCreateLabel("W", $x + 22, $y + 72, 12, 14, $SS_CENTER)
GUICtrlSetState(-1, $GUI_HIDE)
$g_lblLabStatus[1] = GUICtrlCreateLabel("Lab", $x + 22, $y + 93, 21, 14, $SS_RIGHT)
$g_lblGemNowSW[1] = GUICtrlCreateLabel("", $x + 35, $y + 93, 39, 17, $SS_RIGHT)
$g_lblBuilderNowSW[1] = GUICtrlCreateLabel("", $x + 93, $y + 93, 32, 17, $SS_RIGHT)
$g_lblTimeNowSW[1] = GUICtrlCreateLabel("No Data", $x + 146, $y + 93, 58, 17, $SS_CENTER)
$g_icnPopOutSW[1] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnMove, $x + 208, $y + 27, 12, 12)
GUICtrlSetOnEvent($g_icnPopOutSW[1],"PopOut1")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$g_grpVillageSW[2] = GUICtrlCreateGroup("Account 2", $x + 16, $y + 120, 209, 97, BitOR($GUI_SS_DEFAULT_GROUP,$BS_FLAT))
$g_lblGoldNowSW[2] = GUICtrlCreateLabel("", $x + 40, $y + 138, 68, 17, $SS_RIGHT)
$g_lblElixirNowSW[2] = GUICtrlCreateLabel("", $x + 40, $y + 156, 68, 17, $SS_RIGHT)
$g_lblDarkNowSW[2] = GUICtrlCreateLabel("", $x + 40, $y + 174, 68, 17, $SS_RIGHT)
$g_icnGoldSW[2] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 112, $y + 136, 18, 18)
$g_icnElixirSW[2] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 112, $y + 154, 18, 18)
$g_icnDarkSW[2] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 112, $y + 172, 18, 18)
$g_lblHrStatsGoldSW[2] = GUICtrlCreateLabel("", $x + 130, $y + 138, 43, 17, $SS_RIGHT)
$g_lblHrStatsElixirSW[2]= GUICtrlCreateLabel("", $x + 130, $y + 156, 43, 17, $SS_RIGHT)
$g_lblHrStatsDarkSW[2] = GUICtrlCreateLabel("", $x + 131, $y + 174, 43, 17, $SS_RIGHT)
$g_lblUnitMeasureSW1[2] = GUICtrlCreateLabel("K/Hour", $x + 176, $y + 138, 45, 17)
$g_lblUnitMeasureSW2[2] = GUICtrlCreateLabel("K/Hour", $x + 176, $y + 156, 45, 17)
$g_lblUnitMeasureSW3[2] = GUICtrlCreateLabel("/Hour", $x + 183, $y + 174, 37, 17)
$g_icnGemSW[2] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnGem, $x + 76, $y + 192, 18, 18)
$g_icnBuliderSW[2] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnBuilder, $x + 126, $y + 192, 18, 18)
$g_icnHourGlassSW[2] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnHourGlass, $x + 204, $y + 192, 18, 18)
$g_lblKingStatus[2] = GUICtrlCreateLabel("K", $x + 22, $y + 138, 12, 14, $SS_CENTER)
GUICtrlSetState(-1, $GUI_HIDE)
$g_lblQueenStatus[2] = GUICtrlCreateLabel("Q", $x + 22, $y + 156, 12, 14, $SS_CENTER)
GUICtrlSetState(-1, $GUI_HIDE)
$g_lblWardenStatus[2] = GUICtrlCreateLabel("W", $x + 22, $y + 174, 12, 14, $SS_CENTER)
GUICtrlSetState(-1, $GUI_HIDE)
$g_lblLabStatus[2] = GUICtrlCreateLabel("Lab", $x + 22, $y + 195, 21, 14, $SS_RIGHT)
$g_lblGemNowSW[2] = GUICtrlCreateLabel("", $x + 35, $y + 195, 39, 17, $SS_RIGHT)
$g_lblBuilderNowSW[2] = GUICtrlCreateLabel("", $x + 93, $y + 195, 32, 17, $SS_RIGHT)
$g_lblTimeNowSW[2] = GUICtrlCreateLabel("No Data", $x + 146, $y + 195, 58, 17, $SS_CENTER)
$g_icnPopOutSW[2] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnMove, $x + 208, $y + 129, 12, 12)
GUICtrlSetOnEvent($g_icnPopOutSW[2],"PopOut2")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$g_grpVillageSW[3] = GUICtrlCreateGroup("Account 3", $x + 16, $y + 222, 209, 97, BitOR($GUI_SS_DEFAULT_GROUP,$BS_FLAT))
$g_lblGoldNowSW[3] = GUICtrlCreateLabel("", $x + 40, $y + 240, 68, 17, $SS_RIGHT)
$g_lblElixirNowSW[3] = GUICtrlCreateLabel("", $x + 40, $y + 258, 68, 17, $SS_RIGHT)
$g_lblDarkNowSW[3] = GUICtrlCreateLabel("", $x + 40, $y + 276, 68, 17, $SS_RIGHT)
$g_icnGoldSW[3] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 112, $y + 238, 18, 18)
$g_icnElixirSW[3] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 112, $y + 256, 18, 18)
$g_icnDarkSW[3] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 112, $y + 274, 18, 18)
$g_lblHrStatsGoldSW[3] = GUICtrlCreateLabel("", $x + 130, $y + 240, 43, 17, $SS_RIGHT)
$g_lblHrStatsElixirSW[3]= GUICtrlCreateLabel("", $x + 130, $y + 258, 43, 17, $SS_RIGHT)
$g_lblHrStatsDarkSW[3] = GUICtrlCreateLabel("", $x + 131, $y + 276, 43, 17, $SS_RIGHT)
$g_lblUnitMeasureSW1[3] = GUICtrlCreateLabel("K/Hour", $x + 176, $y + 240, 45, 17)
$g_lblUnitMeasureSW2[3] = GUICtrlCreateLabel("K/Hour", $x + 176, $y + 258, 45, 17)
$g_lblUnitMeasureSW3[3] = GUICtrlCreateLabel("/Hour", $x + 183, $y + 276, 37, 17)
$g_icnGemSW[3] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnGem, $x + 76, $y + 294, 18, 18)
$g_icnBuliderSW[3] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnBuilder, $x + 126, $y + 294, 18, 18)
$g_icnHourGlassSW[3] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnHourGlass, $x + 204, $y + 294, 18, 18)
$g_lblKingStatus[3] = GUICtrlCreateLabel("K", $x + 22, $y + 240, 12, 14, $SS_CENTER)
GUICtrlSetState(-1, $GUI_HIDE)
$g_lblQueenStatus[3] = GUICtrlCreateLabel("Q", $x + 22, $y + 258, 12, 14, $SS_CENTER)
GUICtrlSetState(-1, $GUI_HIDE)
$g_lblWardenStatus[3] = GUICtrlCreateLabel("W", $x + 22, $y + 276, 12, 14, $SS_CENTER)
GUICtrlSetState(-1, $GUI_HIDE)
$g_lblLabStatus[3] = GUICtrlCreateLabel("Lab", $x + 22, $y + 297, 21, 14, $SS_RIGHT)
$g_lblGemNowSW[3] = GUICtrlCreateLabel("", $x + 35, $y + 297, 39, 17, $SS_RIGHT)
$g_lblBuilderNowSW[3] = GUICtrlCreateLabel("", $x + 93, $y + 297, 32, 17, $SS_RIGHT)
$g_lblTimeNowSW[3] = GUICtrlCreateLabel("No Data", $x + 146, $y + 297, 58, 17, $SS_CENTER)
$g_icnPopOutSW[3] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnMove, $x + 208, $y + 231, 12, 12)
GUICtrlSetOnEvent($g_icnPopOutSW[3],"PopOut3")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$g_grpVillageSW[4] = GUICtrlCreateGroup("Account 4", $x + 16, $y + 324, 209, 97, BitOR($GUI_SS_DEFAULT_GROUP,$BS_FLAT))
$g_lblGoldNowSW[4] = GUICtrlCreateLabel("", $x + 40, $y + 342, 68, 17, $SS_RIGHT)
$g_lblElixirNowSW[4] = GUICtrlCreateLabel("", $x + 40, $y + 360, 68, 17, $SS_RIGHT)
$g_lblDarkNowSW[4] = GUICtrlCreateLabel("", $x + 40, $y + 378, 68, 17, $SS_RIGHT)
$g_icnGoldSW[4] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 112, $y + 340, 18, 18)
$g_icnElixirSW[4] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 112, $y + 358, 18, 18)
$g_icnDarkSW[4] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 112, $y + 376, 18, 18)
$g_lblHrStatsGoldSW[4] = GUICtrlCreateLabel("", $x + 130, $y + 342, 43, 17, $SS_RIGHT)
$g_lblHrStatsElixirSW[4]= GUICtrlCreateLabel("", $x + 130, $y + 360, 43, 17, $SS_RIGHT)
$g_lblHrStatsDarkSW[4] = GUICtrlCreateLabel("", $x + 131, $y + 378, 43, 17, $SS_RIGHT)
$g_lblUnitMeasureSW1[4] = GUICtrlCreateLabel("K/Hour", $x + 176, $y + 342, 45, 17)
$g_lblUnitMeasureSW2[4] = GUICtrlCreateLabel("K/Hour", $x + 176, $y + 360, 45, 17)
$g_lblUnitMeasureSW3[4] = GUICtrlCreateLabel("/Hour", $x + 183, $y + 378, 37, 17)
$g_icnGemSW[4] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnGem, $x + 76, $y + 396, 18, 18)
$g_icnBuliderSW[4] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnBuilder, $x + 126, $y + 396, 18, 18)
$g_icnHourGlassSW[4] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnHourGlass, $x + 204, $y + 396, 18, 18)
$g_lblKingStatus[4] = GUICtrlCreateLabel("K", $x + 22, $y + 342, 12, 14, $SS_CENTER)
GUICtrlSetState(-1, $GUI_HIDE)
$g_lblQueenStatus[4] = GUICtrlCreateLabel("Q", $x + 22, $y + 360, 12, 14, $SS_CENTER)
GUICtrlSetState(-1, $GUI_HIDE)
$g_lblWardenStatus[4] = GUICtrlCreateLabel("W", $x + 22, $y + 378, 12, 14, $SS_CENTER)
GUICtrlSetState(-1, $GUI_HIDE)
$g_lblLabStatus[4] = GUICtrlCreateLabel("Lab", $x + 22, $y + 399, 21, 14, $SS_RIGHT)
$g_lblGemNowSW[4] = GUICtrlCreateLabel("", $x + 35, $y + 399, 39, 17, $SS_RIGHT)
$g_lblBuilderNowSW[4] = GUICtrlCreateLabel("", $x + 93, $y + 399, 32, 17, $SS_RIGHT)
$g_lblTimeNowSW[4] = GUICtrlCreateLabel("No Data", $x + 146, $y + 399, 58, 17, $SS_CENTER)
$g_icnPopOutSW[4] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnMove, $x + 208, $y + 333, 12, 12)
GUICtrlSetOnEvent($g_icnPopOutSW[4],"PopOut4")
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = -4
$g_grpVillageSW[5] = GUICtrlCreateGroup("Account 5", $x + 232, $y + 18, 209, 97, BitOR($GUI_SS_DEFAULT_GROUP,$BS_FLAT))
$g_lblGoldNowSW[5] = GUICtrlCreateLabel("", $x + 256, $y + 36, 68, 17, $SS_RIGHT)
$g_lblElixirNowSW[5] = GUICtrlCreateLabel("", $x + 256, $y + 54, 68, 17, $SS_RIGHT)
$g_lblDarkNowSW[5] = GUICtrlCreateLabel("", $x + 256, $y + 72, 68, 17, $SS_RIGHT)
$g_icnGoldSW[5] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 328, $y + 34, 18, 18)
$g_icnElixirSW[5] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 328, $y + 52, 18, 18)
$g_icnDarkSW[5] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 328, $y + 70, 18, 18)
$g_lblHrStatsGoldSW[5] = GUICtrlCreateLabel("", $x + 346, $y + 36, 43, 17, $SS_RIGHT)
$g_lblHrStatsElixirSW[5]= GUICtrlCreateLabel("", $x + 346, $y + 54, 43, 17, $SS_RIGHT)
$g_lblHrStatsDarkSW[5] = GUICtrlCreateLabel("", $x + 347, $y + 72, 43, 17, $SS_RIGHT)
$g_lblUnitMeasureSW1[5] = GUICtrlCreateLabel("K/Hour", $x + 392, $y + 36, 45, 17)
$g_lblUnitMeasureSW2[5] = GUICtrlCreateLabel("K/Hour", $x + 392, $y + 54, 45, 17)
$g_lblUnitMeasureSW3[5] = GUICtrlCreateLabel("/Hour", $x + 399, $y + 72, 37, 17)
$g_icnGemSW[5] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnGem, $x + 292, $y + 90, 18, 18)
$g_icnBuliderSW[5] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnBuilder, $x + 342, $y + 90, 18, 18)
$g_icnHourGlassSW[5] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnHourGlass, $x + 420, $y + 90, 18, 18)
$g_lblKingStatus[5] = GUICtrlCreateLabel("K", $x + 238, $y + 36, 12, 14, $SS_CENTER)
GUICtrlSetState(-1, $GUI_HIDE)
$g_lblQueenStatus[5] = GUICtrlCreateLabel("Q", $x + 238, $y + 54, 12, 14, $SS_CENTER)
GUICtrlSetState(-1, $GUI_HIDE)
$g_lblWardenStatus[5] = GUICtrlCreateLabel("W", $x + 238, $y + 72, 12, 14, $SS_CENTER)
GUICtrlSetState(-1, $GUI_HIDE)
$g_lblLabStatus[5] = GUICtrlCreateLabel("Lab", $x + 238, $y + 93, 21, 14, $SS_RIGHT)
$g_lblGemNowSW[5] = GUICtrlCreateLabel("", $x + 251, $y + 93, 39, 17, $SS_RIGHT)
$g_lblBuilderNowSW[5] = GUICtrlCreateLabel("", $x + 309, $y + 93, 32, 17, $SS_RIGHT)
$g_lblTimeNowSW[5] = GUICtrlCreateLabel("No Data", $x + 362, $y + 93, 58, 17, $SS_CENTER)
$g_icnPopOutSW[5] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnMove, $x + 424, $y + 27, 12, 12)
GUICtrlSetOnEvent($g_icnPopOutSW[5],"PopOut5")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$g_grpVillageSW[6] = GUICtrlCreateGroup("Account 6", $x + 232, $y + 120, 209, 97, BitOR($GUI_SS_DEFAULT_GROUP,$BS_FLAT))
$g_lblGoldNowSW[6] = GUICtrlCreateLabel("", $x + 256, $y + 138, 68, 17, $SS_RIGHT)
$g_lblElixirNowSW[6] = GUICtrlCreateLabel("", $x + 256, $y + 156, 68, 17, $SS_RIGHT)
$g_lblDarkNowSW[6] = GUICtrlCreateLabel("", $x + 256, $y + 174, 68, 17, $SS_RIGHT)
$g_icnGoldSW[6] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 328, $y + 136, 18, 18)
$g_icnElixirSW[6] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 328, $y + 154, 18, 18)
$g_icnDarkSW[6] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 328, $y + 172, 18, 18)
$g_lblHrStatsGoldSW[6] = GUICtrlCreateLabel("", $x + 346, $y + 138, 43, 17, $SS_RIGHT)
$g_lblHrStatsElixirSW[6]= GUICtrlCreateLabel("", $x + 346, $y + 156, 43, 17, $SS_RIGHT)
$g_lblHrStatsDarkSW[6] = GUICtrlCreateLabel("", $x + 347, $y + 174, 43, 17, $SS_RIGHT)
$g_lblUnitMeasureSW1[6] = GUICtrlCreateLabel("K/Hour", $x + 392, $y + 138, 45, 17)
$g_lblUnitMeasureSW2[6] = GUICtrlCreateLabel("K/Hour", $x + 392, $y + 156, 45, 17)
$g_lblUnitMeasureSW3[6] = GUICtrlCreateLabel("/Hour", $x + 399, $y + 174, 37, 17)
$g_icnGemSW[6] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnGem, $x + 292, $y + 192, 18, 18)
$g_icnBuliderSW[6] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnBuilder, $x + 342, $y + 192, 18, 18)
$g_icnHourGlassSW[6] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnHourGlass, $x + 420, $y + 192, 18, 18)
$g_lblKingStatus[6] = GUICtrlCreateLabel("K", $x + 238, $y + 138, 12, 14, $SS_CENTER)
$g_lblQueenStatus[6] = GUICtrlCreateLabel("Q", $x + 238, $y + 156, 12, 14, $SS_CENTER)
$g_lblWardenStatus[6] = GUICtrlCreateLabel("W", $x + 238, $y + 174, 12, 14, $SS_CENTER)
$g_lblLabStatus[6] = GUICtrlCreateLabel("Lab", $x + 238, $y + 195, 21, 14, $SS_RIGHT)
$g_lblGemNowSW[6] = GUICtrlCreateLabel("", $x + 251, $y + 195, 39, 17, $SS_RIGHT)
$g_lblBuilderNowSW[6] = GUICtrlCreateLabel("", $x + 309, $y + 195, 32, 17, $SS_RIGHT)
$g_lblTimeNowSW[6] = GUICtrlCreateLabel("No Data", $x + 362, $y + 195, 58, 17, $SS_CENTER)
$g_icnPopOutSW[6] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnMove, $x + 424, $y + 129, 12, 12)
GUICtrlSetOnEvent($g_icnPopOutSW[6],"PopOut6")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$g_grpVillageSW[7] = GUICtrlCreateGroup("Account 7", $x + 232, $y + 222, 209, 97, BitOR($GUI_SS_DEFAULT_GROUP,$BS_FLAT))
$g_lblGoldNowSW[7] = GUICtrlCreateLabel("", $x + 256, $y + 240, 68, 17, $SS_RIGHT)
$g_lblElixirNowSW[7] = GUICtrlCreateLabel("", $x + 256, $y + 258, 68, 17, $SS_RIGHT)
$g_lblDarkNowSW[7] = GUICtrlCreateLabel("", $x + 256, $y + 276, 68, 17, $SS_RIGHT)
$g_icnGoldSW[7] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 328, $y + 238, 18, 18)
$g_icnElixirSW[7] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 328, $y + 256, 18, 18)
$g_icnDarkSW[7] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 328, $y + 274, 18, 18)
$g_lblHrStatsGoldSW[7] = GUICtrlCreateLabel("", $x + 346, $y + 240, 43, 17, $SS_RIGHT)
$g_lblHrStatsElixirSW[7]= GUICtrlCreateLabel("", $x + 346, $y + 258, 43, 17, $SS_RIGHT)
$g_lblHrStatsDarkSW[7] = GUICtrlCreateLabel("", $x + 347, $y + 276, 43, 17, $SS_RIGHT)
$g_lblUnitMeasureSW1[7] = GUICtrlCreateLabel("K/Hour", $x + 392, $y + 240, 45, 17)
$g_lblUnitMeasureSW2[7] = GUICtrlCreateLabel("K/Hour", $x + 392, $y + 258, 45, 17)
$g_lblUnitMeasureSW3[7] = GUICtrlCreateLabel("/Hour", $x + 399, $y + 276, 37, 17)
$g_icnGemSW[7] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnGem, $x + 292, $y + 294, 18, 18)
$g_icnBuliderSW[7] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnBuilder, $x + 342, $y + 294, 18, 18)
$g_icnHourGlassSW[7] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnHourGlass, $x + 420, $y + 294, 18, 18)
$g_lblKingStatus[7] = GUICtrlCreateLabel("K", $x + 238, $y + 240, 12, 14, $SS_CENTER)
GUICtrlSetState(-1, $GUI_HIDE)
$g_lblQueenStatus[7] = GUICtrlCreateLabel("Q", $x + 238, $y + 258, 12, 14, $SS_CENTER)
GUICtrlSetState(-1, $GUI_HIDE)
$g_lblWardenStatus[7] = GUICtrlCreateLabel("W", $x + 238, $y + 276, 12, 14, $SS_CENTER)
GUICtrlSetState(-1, $GUI_HIDE)
$g_lblLabStatus[7] = GUICtrlCreateLabel("Lab", $x + 238, $y + 297, 21, 14, $SS_RIGHT)
$g_lblGemNowSW[7] = GUICtrlCreateLabel("", $x + 251, $y + 297, 39, 17, $SS_RIGHT)
$g_lblBuilderNowSW[7] = GUICtrlCreateLabel("", $x + 309, $y + 297, 32, 17, $SS_RIGHT)
$g_lblTimeNowSW[7] = GUICtrlCreateLabel("No Data", $x + 362, $y + 297, 58, 17, $SS_CENTER)
$g_icnPopOutSW[7] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnMove, $x + 424, $y + 231, 12, 12)
GUICtrlSetOnEvent($g_icnPopOutSW[7],"PopOut7")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$g_grpVillageSW[8] = GUICtrlCreateGroup("Account 8", $x + 232, $y + 324, 209, 97, BitOR($GUI_SS_DEFAULT_GROUP,$BS_FLAT))
$g_lblGoldNowSW[8] = GUICtrlCreateLabel("", $x + 256, $y + 344, 68, 17, $SS_RIGHT)
$g_lblElixirNowSW[8] = GUICtrlCreateLabel("", $x + 256, $y + 360, 68, 17, $SS_RIGHT)
$g_lblDarkNowSW[8] = GUICtrlCreateLabel("", $x + 256, $y + 378, 68, 17, $SS_RIGHT)
$g_icnGoldSW[8] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 328, $y + 340, 18, 18)
$g_icnElixirSW[8] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 328, $y + 358, 18, 18)
$g_icnDarkSW[8] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 328, $y + 376, 18, 18)
$g_lblHrStatsGoldSW[8] = GUICtrlCreateLabel("", $x + 346, $y + 342, 43, 17, $SS_RIGHT)
$g_lblHrStatsElixirSW[8]= GUICtrlCreateLabel("", $x + 346, $y + 360, 43, 17, $SS_RIGHT)
$g_lblHrStatsDarkSW[8] = GUICtrlCreateLabel("", $x + 347, $y + 378, 43, 17, $SS_RIGHT)
$g_lblUnitMeasureSW1[8] = GUICtrlCreateLabel("K/Hour", $x + 392, $y + 342, 45, 17)
$g_lblUnitMeasureSW2[8] = GUICtrlCreateLabel("K/Hour", $x + 392, $y + 360, 45, 17)
$g_lblUnitMeasureSW3[8] = GUICtrlCreateLabel("/Hour", $x + 399, $y + 378, 37, 17)
$g_icnGemSW[8] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnGem, $x + 292, $y + 396, 18, 18)
$g_icnBuliderSW[8] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnBuilder, $x + 342, $y + 396, 18, 18)
$g_icnHourGlassSW[8] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnHourGlass, $x + 420, $y + 396, 18, 18)
$g_lblKingStatus[8] = GUICtrlCreateLabel("K", $x + 238, $y + 342, 12, 14, $SS_CENTER)
GUICtrlSetState(-1, $GUI_HIDE)
$g_lblQueenStatus[8] = GUICtrlCreateLabel("Q", $x + 238, $y + 360, 12, 14, $SS_CENTER)
GUICtrlSetState(-1, $GUI_HIDE)
$g_lblWardenStatus[8] = GUICtrlCreateLabel("W", $x + 238, $y + 378, 12, 14, $SS_CENTER)
GUICtrlSetState(-1, $GUI_HIDE)
$g_lblLabStatus[8] = GUICtrlCreateLabel("Lab", $x + 238, $y + 399, 21, 14, $SS_RIGHT)
$g_lblGemNowSW[8] = GUICtrlCreateLabel("", $x + 251, $y + 399, 39, 17, $SS_RIGHT)
$g_lblBuilderNowSW[8] = GUICtrlCreateLabel("", $x + 309, $y + 399, 32, 17, $SS_RIGHT)
$g_lblTimeNowSW[8] = GUICtrlCreateLabel("No Data", $x + 362, $y + 399, 58, 17, $SS_CENTER)
$g_icnPopOutSW[8] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnMove, $x + 424, $y + 333, 12, 12)
GUICtrlSetOnEvent($g_icnPopOutSW[8],"PopOut8")
GUICtrlCreateGroup("", -99, -99, 1, 1)
For $i = $g_grpVillageSW[1] To $g_lblTimeNowSW[8]
GUICtrlSetFont($i, 9, 800, 0, "Arial", $CLEARTYPE_QUALITY)
Next
For $i = 1 To 8
_GUICtrlSetTip($g_lblKingStatus[$i], "Green - Avaible, Yellow - Healing, Red - Upgrading")
_GUICtrlSetTip($g_lblQueenStatus[$i], "Green - Avaible, Yellow - Healing, Red - Upgrading")
_GUICtrlSetTip($g_lblWardenStatus[$i], "Green - Avaible, Yellow - Healing, Red - Upgrading")
_GUICtrlSetTip($g_lblLabStatus[$i], "Green - Lab is Running, Red - Lab has Stopped")
Next
EndFunc
Func HideShowMultiStat($sState = "SHOW")
If $sState = "SHOW" Then
$sState = $GUI_SHOW
Else
$sState = $GUI_HIDE
EndIf
For $i = $g_grpVillageSW[1] To $g_lblTimeNowSW[8]
GUICtrlSetState($i, $sState)
Next
EndFunc
Func PopOut0()
Local $Number = 0
GUICtrlSetState($g_icnPopOutSW[0], $GUI_DISABLE)
PopOut($Number)
EndFunc
Func PopOut1()
Local $Number = 1
GUICtrlSetState($g_icnPopOutSW[1], $GUI_DISABLE)
PopOut($Number)
EndFunc
Func PopOut2()
Local $Number = 2
GUICtrlSetState($g_icnPopOutSW[2], $GUI_DISABLE)
PopOut($Number)
EndFunc
Func PopOut3()
Local $Number = 3
GUICtrlSetState($g_icnPopOutSW[3], $GUI_DISABLE)
PopOut($Number)
EndFunc
Func PopOut4()
Local $Number = 4
GUICtrlSetState($g_icnPopOutSW[4], $GUI_DISABLE)
PopOut($Number)
EndFunc
Func PopOut5()
Local $Number = 5
GUICtrlSetState($g_icnPopOutSW[5], $GUI_DISABLE)
PopOut($Number)
EndFunc
Func PopOut6()
Local $Number = 6
GUICtrlSetState($g_icnPopOutSW[6], $GUI_DISABLE)
PopOut($Number)
EndFunc
Func PopOut7()
Local $Number = 7
GUICtrlSetState($g_icnPopOutSW[7], $GUI_DISABLE)
PopOut($Number)
EndFunc
Func PopOut8()
Local $Number = 8
GUICtrlSetState($g_icnPopOutSW[8], $GUI_DISABLE)
PopOut($Number)
EndFunc
Func PopOut($Number = 1)
Select
Case $Number = 0
Global $hGuiPopOut0 = GUICreate("", 220, 105, 0, $g_iMonitorY - 315 , BitOR($WS_SYSMENU, $WS_POPUP))
GUISetBkColor($COLOR_WHITE, $hGuiPopOut0)
GUISwitch($hGuiPopOut0)
Case $Number = 1
Global $hGuiPopOut1 = GUICreate("", 220, 105, 0, $g_iMonitorY - 630 , BitOR($WS_SYSMENU, $WS_POPUP))
GUISetBkColor($COLOR_WHITE, $hGuiPopOut1)
GUISwitch($hGuiPopOut1)
Case $Number = 2
Global $hGuiPopOut2 = GUICreate("", 220, 105, 0, $g_iMonitorY - 525, BitOR($WS_SYSMENU, $WS_POPUP))
GUISetBkColor($COLOR_WHITE, $hGuiPopOut2)
GUISwitch($hGuiPopOut2)
Case $Number = 3
Global $hGuiPopOut3 = GUICreate("", 220, 105, 0, $g_iMonitorY - 420, BitOR($WS_SYSMENU, $WS_POPUP))
GUISetBkColor($COLOR_WHITE, $hGuiPopOut3)
GUISwitch($hGuiPopOut3)
Case $Number = 4
Global $hGuiPopOut4 = GUICreate("", 220, 105, 0, $g_iMonitorY - 315, BitOR($WS_SYSMENU, $WS_POPUP))
GUISetBkColor($COLOR_WHITE, $hGuiPopOut4)
GUISwitch($hGuiPopOut4)
Case $Number = 5
Global $hGuiPopOut5 = GUICreate("", 220, 105, -1, -1, BitOR($WS_SYSMENU, $WS_POPUP))
GUISetBkColor($COLOR_WHITE, $hGuiPopOut1)
GUISwitch($hGuiPopOut5)
Case $Number = 6
Global $hGuiPopOut6 = GUICreate("", 220, 105, -1, -1, BitOR($WS_SYSMENU, $WS_POPUP))
GUISetBkColor($COLOR_WHITE, $hGuiPopOut2)
GUISwitch($hGuiPopOut6)
Case $Number = 7
Global $hGuiPopOut7 = GUICreate("", 220, 105, -1, -1, BitOR($WS_SYSMENU, $WS_POPUP))
GUISetBkColor($COLOR_WHITE, $hGuiPopOut3)
GUISwitch($hGuiPopOut7)
Case $Number = 8
Global $hGuiPopOut8 = GUICreate("", 220, 105, -1, -1, BitOR($WS_SYSMENU, $WS_POPUP))
GUISetBkColor($COLOR_WHITE, $hGuiPopOut4)
GUISwitch($hGuiPopOut8)
EndSelect
Local $x = -10, $y = -15
$g_grpVillagePO[$Number] = GUICtrlCreateGroup("Account 1", $x + 16, $y + 18, 209, 97, BitOR($GUI_SS_DEFAULT_GROUP,$BS_FLAT))
GUICtrlSetFont(-1, 9, 800, 0, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetData(-1,GUICtrlRead($g_grpVillageSW[$Number]))
If $Number = 0 Then GUICtrlSetData(-1, GUICtrlRead($g_hGrpVillage))
$g_lblGoldNowPO[$Number] = GUICtrlCreateLabel("", $x + 40, $y + 36, 68, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, 800, 0, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetData(-1,GUICtrlRead($g_lblGoldNowSW[$Number]))
If $Number = 0 Then GUICtrlSetData(-1, "")
$g_lblElixirNowPO[$Number] = GUICtrlCreateLabel("", $x + 40, $y + 54, 68, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, 800, 0, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetData(-1,GUICtrlRead($g_lblElixirNowSW[$Number]))
If $Number = 0 Then GUICtrlSetData(-1, "")
$g_lblDarkNowPO[$Number] = GUICtrlCreateLabel("", $x + 40, $y + 72, 68, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, 800, 0, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetData(-1,GUICtrlRead($g_lblDarkNowSW[$Number]))
If $Number = 0 Then GUICtrlSetData(-1, "")
$g_icnGoldPO[$Number] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 112, $y + 34, 18, 18)
$g_icnElixirPO[$Number] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 112, $y + 52, 18, 18)
$g_icnDarkPO[$Number] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 112, $y + 70, 18, 18)
$g_lblHrStatsGoldPO[$Number] = GUICtrlCreateLabel("", $x + 130, $y + 36, 43, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, 800, 0, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetData(-1,GUICtrlRead($g_lblHrStatsGoldSW[$Number]))
If $Number = 0 Then GUICtrlSetData(-1, "")
$g_lblHrStatsElixirPO[$Number]= GUICtrlCreateLabel("", $x + 130, $y + 54, 43, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, 800, 0, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetData(-1,GUICtrlRead($g_lblHrStatsElixirSW[$Number]))
If $Number = 0 Then GUICtrlSetData(-1, "")
$g_lblHrStatsDarkPO[$Number] = GUICtrlCreateLabel("", $x + 130, $y + 72, 43, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, 800, 0, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetData(-1,GUICtrlRead($g_lblHrStatsDarkSW[$Number]))
If $Number = 0 Then GUICtrlSetData(-1, "")
$g_lblUnitMeasurePO1[$Number] = GUICtrlCreateLabel("K/Hour", $x + 176, $y + 36, 45, 17)
GUICtrlSetFont(-1, 9, 800, 0, "Arial", $CLEARTYPE_QUALITY)
$g_lblUnitMeasurePO2[$Number] = GUICtrlCreateLabel("K/Hour", $x + 176, $y + 54, 45, 17)
GUICtrlSetFont(-1, 9, 800, 0, "Arial", $CLEARTYPE_QUALITY)
$g_lblUnitMeasurePO3[$Number] = GUICtrlCreateLabel("/Hour", $x + 183, $y + 72, 37, 17)
GUICtrlSetFont(-1, 9, 800, 0, "Arial", $CLEARTYPE_QUALITY)
$g_icnGemPO[$Number] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnGem, $x + 76, $y + 90, 18, 18)
$g_icnBuliderPO[$Number] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnBuilder, $x + 126, $y + 90, 18, 18)
$g_icnHourGlassPO[$Number] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnHourGlass, $x + 204, $y + 90, 18, 18)
$g_lblKingStatusPO[$Number] = GUICtrlCreateLabel("K", $x + 22, $y + 36, 12, 14, $SS_CENTER)
GUICtrlSetFont(-1, 9, 800, 0, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetData(-1,GUICtrlRead($g_lblKingStatus[$Number]))
If $Number <> 0 Then GUICtrlSetBkColor($g_lblKingStatusPO[$Number], GUICtrlGetBkColor($g_lblKingStatus[$Number]))
If $Number = 0 Then GUICtrlSetData(-1, "K")
$g_lblQueenStatusPO[$Number] = GUICtrlCreateLabel("Q", $x + 22, $y + 54, 12, 14, $SS_CENTER)
GUICtrlSetFont(-1, 9, 800, 0, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetData(-1,GUICtrlRead($g_lblQueenStatus[$Number]))
If $Number <> 0 Then GUICtrlSetBkColor($g_lblQueenStatusPO[$Number], GUICtrlGetBkColor($g_lblQueenStatus[$Number]))
If $Number = 0 Then GUICtrlSetData(-1, "Q")
$g_lblWardenStatusPO[$Number] = GUICtrlCreateLabel("W", $x + 22, $y + 72, 12, 14, $SS_CENTER)
GUICtrlSetFont(-1, 9, 800, 0, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetData(-1,GUICtrlRead($g_lblWardenStatus[$Number]))
If $Number <> 0 Then GUICtrlSetBkColor($g_lblWardenStatusPO[$Number], GUICtrlGetBkColor($g_lblWardenStatus[$Number]))
If $Number = 0 Then GUICtrlSetData(-1, "W")
$g_lblLabStatusPO[$Number] = GUICtrlCreateLabel("Lab", $x + 22, $y + 93, 21, 14, $SS_CENTER)
GUICtrlSetFont(-1, 9, 800, 0, "Arial", $CLEARTYPE_QUALITY)
If $Number <> 0 Then GUICtrlSetBkColor($g_lblLabStatusPO[$Number], GUICtrlGetBkColor($g_lblLabStatus[$Number]))
$g_lblGemNowPO[$Number] = GUICtrlCreateLabel("", $x + 44, $y + 93, 30, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, 800, 0, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetData(-1,GUICtrlRead($g_lblGemNowSW[$Number]))
If $Number = 0 Then GUICtrlSetData(-1, "")
$g_lblBuilderNowPO[$Number] = GUICtrlCreateLabel("", $x + 93, $y + 93, 32, 17, $SS_RIGHT)
GUICtrlSetFont(-1, 9, 800, 0, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetData(-1,GUICtrlRead($g_lblBuilderNowSW[$Number]))
If $Number = 0 Then GUICtrlSetData(-1, "")
$g_lblTimeNowPO[$Number] = GUICtrlCreateLabel("No Data", $x + 146, $y + 93, 58, 17, $SS_CENTER)
GUICtrlSetFont(-1, 9, 800, 0, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetData(-1,GUICtrlRead($g_lblTimeNowSW[$Number]))
If $Number <> 0 Then GUICtrlSetBkColor($g_lblTimeNowPO[$Number], GUICtrlGetBkColor($g_lblTimeNowSW[$Number]))
Select
Case $Number = 0
$g_icnPopOutEX[$Number] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDelete, $x + 208, $y + 27, 12, 12)
GUICtrlSetOnEvent($g_icnPopOutEX[$Number],"PopOutEX0")
WinSetTrans($hGuiPopOut0, "", 204)
DllCall("user32.dll", "int", "AnimateWindow", "hwnd", $hGuiPopOut0, "int", 500, "long", 0x00040001)
GUISetState(@SW_SHOW)
Case $Number = 1
$g_icnPopOutEX[$Number] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDelete, $x + 208, $y + 27, 12, 12)
GUICtrlSetOnEvent($g_icnPopOutEX[$Number],"PopOutEX1")
WinSetTrans($hGuiPopOut1, "", 204)
DllCall("user32.dll", "int", "AnimateWindow", "hwnd", $hGuiPopOut1, "int", 500, "long", 0x00040001)
GUISetState(@SW_SHOW)
Case $Number = 2
$g_icnPopOutEX[$Number] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDelete, $x + 208, $y + 27, 12, 12)
GUICtrlSetOnEvent($g_icnPopOutEX[$Number],"PopOutEX2")
WinSetTrans($hGuiPopOut2, "", 204)
DllCall("user32.dll", "int", "AnimateWindow", "hwnd", $hGuiPopOut2, "int", 500, "long", 0x00040001)
GUISetState(@SW_SHOW)
Case $Number = 3
$g_icnPopOutEX[$Number] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDelete, $x + 208, $y + 27, 12, 12)
GUICtrlSetOnEvent($g_icnPopOutEX[$Number],"PopOutEX3")
WinSetTrans($hGuiPopOut3, "", 204)
DllCall("user32.dll", "int", "AnimateWindow", "hwnd", $hGuiPopOut3, "int", 500, "long", 0x00040001)
GUISetState(@SW_SHOW)
Case $Number = 4
$g_icnPopOutEX[$Number] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDelete, $x + 208, $y + 27, 12, 12)
GUICtrlSetOnEvent($g_icnPopOutEX[$Number],"PopOutEX4")
WinSetTrans($hGuiPopOut4, "", 204)
DllCall("user32.dll", "int", "AnimateWindow", "hwnd", $hGuiPopOut4, "int", 500, "long", 0x00040001)
GUISetState(@SW_SHOW)
Case $Number = 5
$g_icnPopOutEX[$Number] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDelete, $x + 208, $y + 27, 12, 12)
GUICtrlSetOnEvent($g_icnPopOutEX[$Number],"PopOutEX5")
WinSetTrans($hGuiPopOut5, "", 204)
DllCall("user32.dll", "int", "AnimateWindow", "hwnd", $hGuiPopOut5, "int", 500, "long", 0x00040001)
GUISetState(@SW_SHOW)
Case $Number = 6
$g_icnPopOutEX[$Number] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDelete, $x + 208, $y + 27, 12, 12)
GUICtrlSetOnEvent($g_icnPopOutEX[$Number],"PopOutEX6")
WinSetTrans($hGuiPopOut6, "", 204)
DllCall("user32.dll", "int", "AnimateWindow", "hwnd", $hGuiPopOut6, "int", 500, "long", 0x00040001)
GUISetState(@SW_SHOW)
Case $Number = 7
$g_icnPopOutEX[$Number] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDelete, $x + 208, $y + 27, 12, 12)
GUICtrlSetOnEvent($g_icnPopOutEX[$Number],"PopOutEX7")
WinSetTrans($hGuiPopOut7, "", 204)
DllCall("user32.dll", "int", "AnimateWindow", "hwnd", $hGuiPopOut7, "int", 500, "long", 0x00040001)
GUISetState(@SW_SHOW)
Case $Number = 8
$g_icnPopOutEX[$Number] = GUICtrlCreateIcon($g_sLibIconPath, $eIcnDelete, $x + 208, $y + 27, 12, 12)
GUICtrlSetOnEvent($g_icnPopOutEX[$Number],"PopOutEX8")
WinSetTrans($hGuiPopOut8, "", 204)
DllCall("user32.dll", "int", "AnimateWindow", "hwnd", $hGuiPopOut8, "int", 500, "long", 0x00040001)
GUISetState(@SW_SHOW)
EndSelect
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUIRegisterMsg($WM_NCHITTEST, "_MY_NCHITTEST")
EndFunc
Func PopOutEX0()
DllCall("user32.dll", "int", "AnimateWindow", "hwnd", $hGuiPopOut0, "int", 500, "long", 0x00050002)
GUIDelete($hGuiPopOut0)
GUICtrlSetState($g_icnPopOutSW[0], $GUI_ENABLE)
EndFunc
Func PopOutEX1()
DllCall("user32.dll", "int", "AnimateWindow", "hwnd", $hGuiPopOut1, "int", 500, "long", 0x00050002)
GUIDelete($hGuiPopOut1)
GUICtrlSetState($g_icnPopOutSW[1], $GUI_ENABLE)
EndFunc
Func PopOutEX2()
DllCall("user32.dll", "int", "AnimateWindow", "hwnd", $hGuiPopOut2, "int", 500, "long", 0x00050002)
GUIDelete($hGuiPopOut2)
GUICtrlSetState($g_icnPopOutSW[2], $GUI_ENABLE)
EndFunc
Func PopOutEX3()
DllCall("user32.dll", "int", "AnimateWindow", "hwnd", $hGuiPopOut3, "int", 500, "long", 0x00050002)
GUIDelete($hGuiPopOut3)
GUICtrlSetState($g_icnPopOutSW[3], $GUI_ENABLE)
EndFunc
Func PopOutEX4()
DllCall("user32.dll", "int", "AnimateWindow", "hwnd", $hGuiPopOut4, "int", 500, "long", 0x00050002)
GUIDelete($hGuiPopOut4)
GUICtrlSetState($g_icnPopOutSW[4], $GUI_ENABLE)
EndFunc
Func PopOutEX5()
DllCall("user32.dll", "int", "AnimateWindow", "hwnd", $hGuiPopOut5, "int", 500, "long", 0x00050002)
GUIDelete($hGuiPopOut5)
GUICtrlSetState($g_icnPopOutSW[5], $GUI_ENABLE)
EndFunc
Func PopOutEX6()
DllCall("user32.dll", "int", "AnimateWindow", "hwnd", $hGuiPopOut6, "int", 500, "long", 0x00050002)
GUIDelete($hGuiPopOut6)
GUICtrlSetState($g_icnPopOutSW[6], $GUI_ENABLE)
EndFunc
Func PopOutEX7()
DllCall("user32.dll", "int", "AnimateWindow", "hwnd", $hGuiPopOut7, "int", 500, "long", 0x00050002)
GUIDelete($hGuiPopOut7)
GUICtrlSetState($g_icnPopOutSW[7], $GUI_ENABLE)
EndFunc
Func PopOutEX8()
DllCall("user32.dll", "int", "AnimateWindow", "hwnd", $hGuiPopOut8, "int", 500, "long", 0x00050002)
GUIDelete($hGuiPopOut8)
GUICtrlSetState($g_icnPopOutSW[8], $GUI_ENABLE)
EndFunc
Func _MY_NCHITTEST($hWnd, $uMsg, $wParam, $lParam)
Switch $hWnd
Case $hGuiPopOut0
Local $aPos = WinGetPos($hWnd)
If Abs(BitAND(BitShift($lParam, 16), 0xFFFF) - $aPos[1]) < 50 Then Return $HTCAPTION
Case $hGuiPopOut1
Local $aPos = WinGetPos($hWnd)
If Abs(BitAND(BitShift($lParam, 16), 0xFFFF) - $aPos[1]) < 50 Then Return $HTCAPTION
Case $hGuiPopOut2
Local $aPos = WinGetPos($hWnd)
If Abs(BitAND(BitShift($lParam, 16), 0xFFFF) - $aPos[1]) < 50 Then Return $HTCAPTION
Case $hGuiPopOut3
Local $aPos = WinGetPos($hWnd)
If Abs(BitAND(BitShift($lParam, 16), 0xFFFF) - $aPos[1]) < 50 Then Return $HTCAPTION
Case $hGuiPopOut4
Local $aPos = WinGetPos($hWnd)
If Abs(BitAND(BitShift($lParam, 16), 0xFFFF) - $aPos[1]) < 50 Then Return $HTCAPTION
Case $hGuiPopOut5
Local $aPos = WinGetPos($hWnd)
If Abs(BitAND(BitShift($lParam, 16), 0xFFFF) - $aPos[1]) < 50 Then Return $HTCAPTION
Case $hGuiPopOut6
Local $aPos = WinGetPos($hWnd)
If Abs(BitAND(BitShift($lParam, 16), 0xFFFF) - $aPos[1]) < 50 Then Return $HTCAPTION
Case $hGuiPopOut7
Local $aPos = WinGetPos($hWnd)
If Abs(BitAND(BitShift($lParam, 16), 0xFFFF) - $aPos[1]) < 50 Then Return $HTCAPTION
Case $hGuiPopOut8
Local $aPos = WinGetPos($hWnd)
If Abs(BitAND(BitShift($lParam, 16), 0xFFFF) - $aPos[1]) < 50 Then Return $HTCAPTION
EndSwitch
Return $GUI_RUNDEFMSG
EndFunc
Func CreateMODTab()
$g_hGUI_MOD = GUICreate("", $_GUI_MAIN_WIDTH - 20, $_GUI_MAIN_HEIGHT - 255, $_GUI_CHILD_LEFT, $_GUI_CHILD_TOP, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hFrmBotEx)
GUISwitch($g_hGUI_MOD)
$g_hGUI_MOD_TAB = GUICtrlCreateTab(0, 0, $_GUI_MAIN_WIDTH - 20, $_GUI_MAIN_HEIGHT - 255, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$g_hGUI_MOD_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslated(600, 58, "Misc MODs"))
OptionsGUI()
$g_hGUI_MOD_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslated(600, 59, "Humanization"))
HumanizationGUI()
$g_hGUI_MOD_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslated(600, 60, "Goblin XP"))
GoblinXPGUI()
$g_hGUI_MOD_TAB_ITEM4 = GUICtrlCreateTabItem(GetTranslated(600, 36, "Profiles"))
CreateModProfiles()
$g_hGUI_MOD_TAB_ITEM5 = GUICtrlCreateTabItem("MultiStat's")
$g_hLastControlToHide = GUICtrlCreateDummy()
ReDim $g_aiControlPrevState[$g_hLastControlToHide + 1]
CreateMultiStatsGUI()
GUICtrlCreateTabItem("")
GUISwitch($g_hGUI_BOT)
$g_hGUI_BOT_TAB_ITEM5 = GUICtrlCreateTabItem(GetTranslated(600, 37, "Stats"))
CreateBotStats()
GUICtrlCreateTabItem("")
EndFunc
Func OptionsGUI()
Local $x = 5, $y = 30
Local $Group1 = GUICtrlCreateGroup("Treasury Collect", $x, $y, 440, 105)
$x -= 2
GUICtrlCreatePic(@ScriptDir & "\images\Treasury.jpg", $x + 12, $y + 25, 70, 38.6)
$chkEnableTrCollect = GUICtrlCreateCheckbox(GetTranslated(800, 1, "Enable"), $x + 93, $y + 35, 52, 17)
GUICtrlSetOnEvent(-1, "chkEnableTrCollect")
_GUICtrlSetTip(-1, GetTranslated(800, 50, "Check to enable automatic Treasury collecion"))
$chkForceTrCollect = GUICtrlCreateCheckbox(GetTranslated(800, 2, "Always collect Treasury"), $x + 15, $y + 75, 127, 17)
GUICtrlSetOnEvent(-1, "chkForceTrCollect")
_GUICtrlSetTip(-1, GetTranslated(800, 51, "Check to force Treasury collection" & @CRLF & "Treasury will be collected all the time, ignoring any criteria"))
GUICtrlCreateIcon($g_sLibIconPath, $eIcnGold, $x + 160, $y + 15, 24, 24)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnElixir, $x + 160, $y + 45, 24, 24)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnDark, $x + 160, $y + 75, 24, 24)
$chkGoldTrCollect = GUICtrlCreateCheckbox(GetTranslated(800, 3, "Collect when Gold <"), $x + 190, $y + 18, 112, 17)
GUICtrlSetOnEvent(-1, "chkResTrCollect")
_GUICtrlSetTip(-1, GetTranslated(800, 52, "When your Village Gold is below this value, it will collect Treasury"))
$txtMinGoldTrCollect = GUICtrlCreateInput("200000", $x + 305, $y + 17, 56, 21, BitOR($ES_CENTER, $ES_NUMBER))
$chkFullGoldTrCollect = GUICtrlCreateCheckbox(GetTranslated(800, 4, "When full"), $x + 370, $y + 18, 67, 17)
GUICtrlSetOnEvent(-1, "chkFullResTrCollect")
_GUICtrlSetTip(-1, GetTranslated(800, 53, "When your Gold level in Treasury is full, it will colect it to empty Treasury"))
$chkElxTrCollect = GUICtrlCreateCheckbox(GetTranslated(800, 5, "Collect when Elixir <"), $x + 190, $y + 48, 112, 17)
GUICtrlSetOnEvent(-1, "chkResTrCollect")
_GUICtrlSetTip(-1, GetTranslated(800, 54, "When your Village Elixir is below this value, it will collect Treasury"))
$txtMinElxTrCollect = GUICtrlCreateInput("200000", $x + 305, $y + 47, 56, 21, BitOR($ES_CENTER, $ES_NUMBER))
$chkFullElxTrCollect = GUICtrlCreateCheckbox(GetTranslated(800, 6, "When full"), $x + 370, $y + 48, 67, 17)
GUICtrlSetOnEvent(-1, "chkFullResTrCollect")
_GUICtrlSetTip(-1, GetTranslated(800, 55, "When your Elixir level in Treasury is full, it will colect it to empty Treasury"))
$chkDarkTrCollect = GUICtrlCreateCheckbox(GetTranslated(800, 7, "Collect when Dark <"), $x + 190, $y + 78, 112, 17)
GUICtrlSetOnEvent(-1, "chkResTrCollect")
_GUICtrlSetTip(-1, GetTranslated(800, 56, "When your Village Dark is below this value, it will collect Treasury"))
$txtMinDarkTrCollect = GUICtrlCreateInput("200000", $x + 305, $y + 77, 56, 21, BitOR($ES_CENTER, $ES_NUMBER))
$chkFullDarkTrCollect = GUICtrlCreateCheckbox(GetTranslated(800, 8, "When full"), $x + 370, $y + 78, 67, 17)
GUICtrlSetOnEvent(-1, "chkFullResTrCollect")
_GUICtrlSetTip(-1, GetTranslated(800, 57, "When your Dark level in Treasury is full, it will colect it to empty Treasury"))
chkEnableTrCollect()
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 110
$x = 5
Local $Group2 = GUICtrlCreateGroup("Donate Options", $x, $y, 440, 40)
$chkExtraPersian = GUICtrlCreateCheckbox(GetTranslated(800,100, "Enable Persian Alphabet Recognition for Donations"), $x + 12, $y + 15 , -1, -1)
_GUICtrlSetTip(-1, GetTranslated(800,101, "Check this to enable the Persian Alphabet Recognition."))
GUICtrlSetOnEvent(-1, "Donatelang")
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $sTxtTip = ""
$x = 25
$y = 205
Local $Group3 = GUICtrlCreateGroup(GetTranslated(634,1, "Hero Abilities"), $x - 20, $y - 20, 440, 60)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnKing, $x-10, $y, 24, 24)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueen, $x+ 15, $y, 24, 24)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnWarden, $x+ 40, $y, 24, 24)
$x += 70
$y -= 4
$g_hRadAutoAbilities = GUICtrlCreateRadio(GetTranslated(634,2, "Auto activate (red zone)"), $x, $y-4 , -1, -1)
$sTxtTip = GetTranslated(634,3, "Activate the Ability when the Hero becomes weak.") & @CRLF & GetTranslated(634,4, "Heroes are checked and activated individually.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_CHECKED)
$y += 15
$g_hRadManAbilities = GUICtrlCreateRadio(GetTranslated(634,5, "Timed after") & ":", $x , $y , -1, -1)
$sTxtTip = GetTranslated(634,6, "Activate the Ability on a timer.") & @CRLF & GetTranslated(634,7, "All Heroes are activated at the same time.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetState(-1, $GUI_UNCHECKED)
$g_hTxtManAbilities = GUICtrlCreateInput("9", $x + 80, $y+3, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslated(634,8, "Set the time in seconds for Timed Activation of Hero Abilities.")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlCreateLabel(GetTranslated(603,6, "sec."), $x + 115, $y + 4, -1, -1)
$x += 150
$y -= 15
GUICtrlCreateIcon($g_sLibIconPath, $eIcnWarden, $x - 7, $y + 2, 32, 32)
$y += 12
$g_hChkUseWardenAbility = GUICtrlCreateCheckbox(GetTranslated(634,9, "Force after") & ":", $x + 30, $y, -1, -1)
$sTxtTip = GetTranslated(634,10, "Use the ability of the Grand Warden on a timer.")
GUICtrlSetOnEvent(-1, "CheckWardenTimer")
_GUICtrlSetTip(-1, $sTxtTip)
CheckWardenTimer()
$g_hTxtWardenAbility = GUICtrlCreateInput("9", $x + 110, $y+3, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$sTxtTip = GetTranslated(634,11, "Set the time in seconds for Timed Activation of Grand Warden Ability.")
GUICtrlSetOnEvent(-1, "delayWardenTimer")
_GUICtrlSetTip(-1, $sTxtTip)
GUICtrlCreateLabel(GetTranslated(603,6, "sec."), $x + 145, $y + 4, -1, -1)
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func HumanizationGUI()
Local $x , $y
$chkUseBotHumanization = GUICtrlCreateCheckbox(GetTranslated(42, 0, "Enable Bot Humanization"), 10, 30, 137, 17)
GUICtrlSetOnEvent(-1, "chkUseBotHumanization")
GUICtrlSetState(-1, $GUI_UNCHECKED)
$chkUseAltRClick = GUICtrlCreateCheckbox(GetTranslated(42, 1, "Make ALL BOT clicks random"), 280, 30, 162, 17)
GUICtrlSetOnEvent(-1, "chkUseAltRClick")
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlCreateGroup(GetTranslated(42, 2, "Settings"), 4, 55, 440, 335)
Local $x = 0, $y = 20
$x += 10
$y += 50
$Icon1 = GUICtrlCreateIcon($g_sLibIconPath, $eIcnChat, $x, $y + 5, 32, 32)
$Label1 = GUICtrlCreateLabel(GetTranslated(42, 3, "Read the Clan Chat"), $x + 40, $y + 5, 110, 17)
$g_acmbPriority[0] = GUICtrlCreateCombo("", $x + 155, $y, 75, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $g_sFrequenceChain, "Never")
$Label2 = GUICtrlCreateLabel(GetTranslated(42, 4, "Read the Global Chat"), $x + 240, $y + 5, 110, 17)
$g_acmbPriority[1] = GUICtrlCreateCombo("", $x + 355, $y, 75, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $g_sFrequenceChain, "Never")
$Label4 = GUICtrlCreateLabel(GetTranslated(42, 5, "Say..."), $x + 40, $y + 30, 31, 17)
$g_ahumanMessage[0] = GUICtrlCreateInput(GetTranslated(42, 6, "Hello !"), $x + 75, $y + 25, 121, 21)
$Label3 = GUICtrlCreateLabel(GetTranslated(42, 7, "Or"), $x + 205, $y + 30, 15, 17)
$g_ahumanMessage[1] = GUICtrlCreateInput(GetTranslated(42, 8, "Re !"), $x + 225, $y + 25, 121, 21)
$g_acmbPriority[2] = GUICtrlCreateCombo("", $x + 355, $y + 25, 75, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $g_sFrequenceChain, "Never")
$Label20 = GUICtrlCreateLabel(GetTranslated(42, 9, "Launch Challenges with message"), $x + 40, $y + 55, 170, 17)
$challengeMessage = GUICtrlCreateInput(GetTranslated(42, 10, "Can you beat my village ?"), $x + 205, $y + 50, 141, 21)
$g_acmbPriority[12] = GUICtrlCreateCombo("", $x + 355, $y + 50, 75, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $g_sFrequenceChain, "Never")
$y += 81
$Icon2 = GUICtrlCreateIcon($g_sLibIconPath, $eIcnRepeat, $x, $y + 5, 32, 32)
$Label5 = GUICtrlCreateLabel(GetTranslated(42, 11, "Watch Defenses"), $x + 40, $y + 5, 110, 17)
$g_acmbPriority[3] = GUICtrlCreateCombo("", $x + 155, $y, 75, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $g_sFrequenceChain, "Never")
GUICtrlSetOnEvent(-1, "cmbStandardReplay")
$Label6 = GUICtrlCreateLabel(GetTranslated(42, 12, "Watch Attacks"), $x + 40, $y + 30, 110, 17)
$g_acmbPriority[4] = GUICtrlCreateCombo("", $x + 155, $y + 25, 75, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $g_sFrequenceChain, "Never")
GUICtrlSetOnEvent(-1, "cmbStandardReplay")
$Label7 = GUICtrlCreateLabel(GetTranslated(42, 13, "Max Replay Speed") & " ", $x + 240, $y + 5, 110, 17)
$g_acmbMaxSpeed[0] = GUICtrlCreateCombo("", $x + 355, $y, 75, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $g_sReplayChain, "2")
$Label8 = GUICtrlCreateLabel(GetTranslated(42, 14, "Pause Replay"), $x + 240, $y + 30, 110, 17)
$g_acmbPause[0] = GUICtrlCreateCombo("", $x + 355, $y + 25, 75, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $g_sFrequenceChain, "Never")
$y += 56
$Icon3 = GUICtrlCreateIcon($g_sLibIconPath, $eIcnClan, $x, $y + 5, 32, 32)
$Label9 = GUICtrlCreateLabel(GetTranslated(42, 15, "Watch War log"), $x + 40, $y + 5, 110, 17)
$g_acmbPriority[5] = GUICtrlCreateCombo("", $x + 155, $y, 75, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $g_sFrequenceChain, "Never")
$Label10 = GUICtrlCreateLabel(GetTranslated(42, 16, "Visit Clanmates"), $x + 40, $y + 30, 110, 17)
$g_acmbPriority[6] = GUICtrlCreateCombo("", $x + 155, $y + 25, 75, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $g_sFrequenceChain, "Never")
$Label11 = GUICtrlCreateLabel(GetTranslated(42, 17, "Look at Best Players"), $x + 240, $y + 5, 110, 17)
$g_acmbPriority[7] = GUICtrlCreateCombo("", $x + 355, $y, 75, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $g_sFrequenceChain, "Never")
$Label12 = GUICtrlCreateLabel(GetTranslated(42, 18, "Look at Best Clans"), $x + 240, $y + 30, 110, 17)
$g_acmbPriority[8] = GUICtrlCreateCombo("", $x + 355, $y + 25, 75, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $g_sFrequenceChain, "Never")
$y += 56
$Icon4 = GUICtrlCreateIcon($g_sLibIconPath, $eIcnSwords, $x, $y + 5, 32, 32)
$Label14 = GUICtrlCreateLabel(GetTranslated(42, 19, "Look at Current War"), $x + 40, $y + 5, 110, 17)
$g_acmbPriority[9] = GUICtrlCreateCombo("", $x + 155, $y, 75, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $g_sFrequenceChain, "Never")
$Label16 = GUICtrlCreateLabel(GetTranslated(42, 20, "Watch Replays"), $x + 40, $y + 30, 110, 17)
$g_acmbPriority[10] = GUICtrlCreateCombo("", $x + 155, $y + 25, 75, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $g_sFrequenceChain, "Never")
GUICtrlSetOnEvent(-1, "cmbWarReplay")
$Label13 = GUICtrlCreateLabel(GetTranslated(42, 13, "Max Replay Speed") & " ", $x + 240, $y + 5, 110, 17)
$g_acmbMaxSpeed[1] = GUICtrlCreateCombo("", $x + 355, $y, 75, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $g_sReplayChain, "2")
$Label15 = GUICtrlCreateLabel(GetTranslated(42, 14, "Pause Replay"), $x + 240, $y + 30, 110, 17)
$g_acmbPause[1] = GUICtrlCreateCombo("", $x + 355, $y + 25, 75, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $g_sFrequenceChain, "Never")
$y += 56
$Icon5 = GUICtrlCreateIcon($g_sLibIconPath, $eIcnLoop, $x, $y + 5, 32, 32)
$Label17 = GUICtrlCreateLabel(GetTranslated(42, 21, "Do nothing"), $x + 40, $y + 5, 110, 17)
$g_acmbPriority[11] = GUICtrlCreateCombo("", $x + 155, $y, 75, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $g_sFrequenceChain, "Never")
$Label18 = GUICtrlCreateLabel(GetTranslated(42, 22, "Max Actions by Loop"), $x + 240, $y + 5, 103, 17)
$cmbMaxActionsNumber = GUICtrlCreateCombo("", $x + 355, $y, 75, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "1|2|3|4|5", "2")
$y += 25
$chkCollectAchievements = GUICtrlCreateCheckbox(GetTranslated(42, 23, "Collect achievements automatically"), $x + 40, $y, 182, 17)
GUICtrlSetOnEvent(-1, "chkCollectAchievements")
GUICtrlSetState(-1, $GUI_UNCHECKED)
$chkLookAtRedNotifications = GUICtrlCreateCheckbox(GetTranslated(42, 24, "Look at red/purple flags on buttons"), $x + 240, $y, 187, 17)
GUICtrlSetOnEvent(-1, "chkLookAtRedNotifications")
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlCreateGroup("", -99, -99, 1, 1)
For $i = $Icon1 To $chkLookAtRedNotifications
GUICtrlSetState($i, $GUI_DISABLE)
Next
chkUseBotHumanization()
EndFunc
Func GoblinXPGUI()
Local $x = 25, $y = 50, $xStart = 25, $yStart = 50
$grpSuperXP = GUICtrlCreateGroup(GetTranslated(700, 1, "Goblin XP"), $x - 20, $y - 20, 440, 305)
$chkEnableSuperXP = GUICtrlCreateCheckbox(GetTranslated(700, 2, "Enable Goblin XP"), $x, $y, 102, 17)
GUICtrlSetOnEvent(-1, "chkEnableSuperXP")
$rbSXTraining = GUICtrlCreateRadio(GetTranslated(700, 3, "Farm XP during troops Training"), $x, $y + 23, 165, 17)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkEnableSuperXP2")
$lblLOCKEDSX = GUICtrlCreateLabel(GetTranslated(700, 13, "LOCKED"), $x + 210, $y + 23, 173, 50)
GUICtrlSetFont(-1, 30, 800, 0, "Arial")
GUICtrlSetColor(-1, 0xFF0000)
GUICtrlSetState(-1, $GUI_HIDE)
$rbSXIAttacking = GUICtrlCreateRadio(GetTranslated(700, 4, "Farm XP instead of Attacking"), $x, $y + 46, 158, 17)
GUICtrlCreateLabel(GetTranslated(700, 14, "Max XP to Gain") & ":", $x, $y + 69, -1, 17)
GUICtrlSetOnEvent(-1, "chkEnableSuperXP2")
$txtMaxXPtoGain = GUICtrlCreateInput("500", $x + 85, $y + 67, 70, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 8)
GUICtrlSetOnEvent(-1, "chkEnableSuperXP2")
$x += 129
$y += 100
GUICtrlCreateLabel(GetTranslated(700, 5, "Use"), $x - 35, $y + 13, 23, 17)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnKing, $x, $y, 32, 32)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnQueen, $x + 40, $y, 32, 32)
GUICtrlCreateIcon($g_sLibIconPath, $eIcnWarden, $x + 80, $y, 32, 32)
GUICtrlCreateLabel(GetTranslated(700, 6, "to gain XP"), $x + 123, $y + 13, 53, 17)
$x += 10
$chkSXBK = GUICtrlCreateCheckbox("", $x, $y + 35, 17, 17)
GUICtrlSetOnEvent(-1, "chkEnableSuperXP2")
$chkSXAQ = GUICtrlCreateCheckbox("", $x + 40, $y + 35, 17, 17)
GUICtrlSetOnEvent(-1, "chkEnableSuperXP2")
$chkSXGW = GUICtrlCreateCheckbox("", $x + 80, $y + 35, 17, 17)
GUICtrlSetOnEvent(-1, "chkEnableSuperXP2")
$x = $xStart + 25
$y += 73
GUICtrlCreateLabel("", $x - 25, $y, 5, 19)
GUICtrlSetBkColor(-1, 0xD8D8D8)
$DocXP1 = GUICtrlCreateLabel(GetTranslated(700, 7, "XP at Start"), $x - 20, $y, 98, 19)
GUICtrlSetBkColor(-1, 0xD8D8D8)
$DocXP2 = GUICtrlCreateLabel(GetTranslated(700, 8, "Current XP"), $x + 63 + 15, $y, 104, 19)
GUICtrlSetBkColor(-1, 0xD8D8D8)
$DocXP3 = GUICtrlCreateLabel(GetTranslated(700, 9, "XP Won"), $x + 71 + 76 + 35, $y, 103, 19)
GUICtrlSetBkColor(-1, 0xD8D8D8)
$DocXP4 = GUICtrlCreateLabel(GetTranslated(700, 10, "XP Won/Hour"), $x + 69 + 55 + 110 + 45, $y, 87, 19)
GUICtrlSetBkColor(-1, 0xD8D8D8)
$y += 15
GUICtrlCreateLabel("", $x - 25, $y + 7, 5, 36)
GUICtrlSetBkColor(-1, 0xbfdfff)
$lblXPatStart = GUICtrlCreateLabel("0", $x - 20, $y + 7, 99, 36)
GUICtrlSetFont(-1, 20, 800, 0, "Arial")
GUICtrlSetBkColor(-1, 0xbfdfff)
$lblXPCurrent = GUICtrlCreateLabel("0", $x + 78, $y + 7, 105, 36)
GUICtrlSetFont(-1, 20, 800, 0, "Arial")
GUICtrlSetBkColor(-1, 0xbfdfff)
$lblXPSXWon = GUICtrlCreateLabel("0", $x + 182, $y + 7, 97, 36)
GUICtrlSetFont(-1, 20, 800, 0, "Arial")
GUICtrlSetBkColor(-1, 0xbfdfff)
$lblXPSXWonHour = GUICtrlCreateLabel("0", $x + 279, $y + 7, 87, 36)
GUICtrlSetFont(-1, 20, 800, 0, "Arial")
GUICtrlSetBkColor(-1, 0xbfdfff)
$x = $xStart
$y += 57
GUICtrlCreateLabel(GetTranslated(700, 11, "Goblin XP attack continuously the TH of Goblin Picnic to farm XP."), $x, $y, 312, 17)
GUICtrlCreateLabel(GetTranslated(700, 12, "At each attack, you win 5 XP"), $x, $y + 20, 306, 17)
chkEnableSuperXP()
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Global $g_hGUI_ABOUT = 0
Global $g_hLblCreditsBckGrnd = 0, $g_hLblMyBotURL = 0, $g_hLblForumURL = 0
Func CreateAboutTab()
$g_hGUI_ABOUT = GUICreate("", $_GUI_MAIN_WIDTH - 20, $_GUI_MAIN_HEIGHT - 255, $_GUI_CHILD_LEFT, $_GUI_CHILD_TOP, BitOR($WS_CHILD, $WS_TABSTOP), -1, $g_hFrmBotEx)
GUISetBkColor($COLOR_WHITE,$g_hGUI_ABOUT)
Local $sText = ""
Local $x = 18, $y = 15 + $_GUI_MAIN_TOP
$sText = "My Bot is brought to you by a worldwide team of open source" & @CRLF & "programmers and a vibrant community of forum members!"
GUICtrlCreateLabel($sText, $x + 8, $y - 10, 400, 35, $SS_CENTER)
GUICtrlSetFont(-1, 10, $FW_BOLD, Default, "Arial")
GUICtrlSetColor(-1, $COLOR_NAVY)
$y += 30
$sText = "Please visit our web forums:"
GUICtrlCreateLabel($sText, $x + 44, $y, 180, 30, $SS_CENTER)
GUICtrlSetFont(-1, 9.5, $FW_BOLD, Default, "Arial")
$g_hLblMyBotURL = GUICtrlCreateLabel("https://mybot.run/forums", $x + 223, $y, 150, 20)
GUICtrlSetCursor(-1, 0)
GUICtrlSetFont(-1, 9.5, $FW_BOLD, Default, "Arial")
GUICtrlSetColor(-1, $COLOR_INFO)
$y += 22
GUICtrlCreateLabel("Credits belong to following programmers for donating their time:", $x - 5, $y, 420, 20)
GUICtrlSetFont(-1, 10, $FW_BOLD, Default, "Arial")
$y += 30
$sText = "Active developers: "
GUICtrlCreateLabel($sText, $x - 5, $y, 410, 20, BITOR($WS_VISIBLE, $ES_AUTOVSCROLL, $SS_LEFT),0)
GUICtrlSetFont(-1, 9.5, $FW_BOLD, Default, "Arial")
GUICtrlSetColor(-1, $COLOR_NAVY)
$sText = "Boju, Codeslinger69, Cosote, Ezeck0001, Fliegerfaust, Hervidero, IceCube, MMHK, MonkeyHunter, MR.ViPeR, ProMac, Sardo, TheRevenor, Trlopes, Zengzeng"
GUICtrlCreateLabel($sText, $x + 5, $y + 15, 410, 50, BITOR($WS_VISIBLE, $ES_AUTOVSCROLL, $SS_LEFT),0)
GUICtrlSetFont(-1,9, $FW_MEDIUM, Default, "Arial")
$y += 75
$sText = "Inactive developers: "
GUICtrlCreateLabel($sText, $x - 5, $y, 410, 20, BITOR($WS_VISIBLE, $ES_AUTOVSCROLL, $SS_LEFT), 0)
GUICtrlSetFont(-1, 9.5, $FW_BOLD, Default, "Arial")
GUICtrlSetColor(-1, $COLOR_NAVY)
$sText = "Kaganus"
GUICtrlCreateLabel($sText, $x + 5, $y + 15, 410, 20, BITOR($WS_VISIBLE, $ES_AUTOVSCROLL, $SS_LEFT), 0)
GUICtrlSetFont(-1, 9, $FW_MEDIUM, Default, "Arial")
$y += 45
$sText = "Retired developers: "
GUICtrlCreateLabel($sText, $x - 5, $y, 410, 20, BITOR($WS_VISIBLE, $ES_AUTOVSCROLL, $SS_LEFT), 0)
GUICtrlSetFont(-1, 9.5, $FW_BOLD, Default, "Arial")
GUICtrlSetColor(-1, $COLOR_NAVY)
$sText = "Antidote, AtoZ, Barracoda, Didipe, Dinobot, DixonHill, DkEd, GkevinOD, HungLe, KnowJack, LunaEclipse, Safar46, Saviart, TheMaster1st, and others"
GUICtrlCreateLabel($sText, $x + 5, $y + 15, 410, 50, BITOR($WS_VISIBLE, $ES_AUTOVSCROLL, $SS_LEFT), 0)
GUICtrlSetFont(-1, 9, $FW_MEDIUM, Default, "Arial")
$y += 76
$sText = "Special thanks to all contributing forum members helping to make this" & @CRLF & "software better! And a special note to: @KevinM our server admin!"
GUICtrlCreateLabel($sText, $x + 14, $y, 390, 30, BITOR($WS_VISIBLE, $ES_AUTOVSCROLL, $ES_CENTER), 0)
GUICtrlSetFont(-1, 9, $FW_MEDIUM, Default, "Arial")
$y += 40
$sText = "The latest release of 'My Bot' can be found at:"
GUICtrlCreateLabel($sText, $x - 5, $y, 400, 15, BITOR($WS_VISIBLE, $ES_AUTOVSCROLL, $SS_LEFT), 0)
GUICtrlSetFont(-1, 10, $FW_BOLD, Default, "Arial")
$y += 18
$g_hLblForumURL = GUICtrlCreateLabel("https://mybot.run/forums/index.php?/forum/4-official-releases/", $x + 25, $y, 450, 20)
GUICtrlSetCursor(-1, 0)
GUICtrlSetFont(-1, 9.5, $FW_BOLD, Default, "Arial")
GUICtrlSetColor(-1, $COLOR_INFO)
$y = 380
$sText = "By running this program, the user accepts all responsibility that arises from the use of this software." & @CRLF & "This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even " & @CRLF & "the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General " & @CRLF & "Public License for more details. The license can be found in the main code folder location." & @CRLF & "Copyright (C) 2015-2017 MyBot.run"
GUICtrlCreateLabel($sText, $x + 1, $y, 415, 56, BITOR($WS_VISIBLE, $ES_AUTOVSCROLL, $SS_LEFT, $ES_CENTER), 0)
GUICtrlSetColor(-1, 0x000053)
GUICtrlSetFont(-1, 6.5, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
EndFunc
Func CreateMainGUI()
SplashStep(GetTranslated(500, 23, "Loading Main GUI..."))
$g_hFrmBot = GUICreate($g_sBotTitle, $_GUI_MAIN_WIDTH, $_GUI_MAIN_HEIGHT + $_GUI_MAIN_TOP, $frmBotPosX, $frmBotPosY, BitOr($WS_MINIMIZEBOX, $WS_CAPTION, $WS_POPUP, $WS_SYSMENU, $WS_CLIPCHILDREN, $WS_CLIPSIBLINGS))
_WindowAppId($g_hFrmBot, "MyBot.run")
GUISetIcon($g_sLibIconPath, $eIcnGUI)
TraySetIcon($g_sLibIconPath, $eIcnGUI)
TraySetToolTip($g_sBotTitle)
$g_hFrmBotEx = GUICreate("", $_GUI_MAIN_WIDTH, $_GUI_MAIN_HEIGHT - $_GUI_BOTTOM_HEIGHT + $_GUI_MAIN_TOP, 0, 0, BitOR($WS_CHILD, $WS_TABSTOP), $WS_EX_TOPMOST, $g_hFrmBot)
GUICtrlCreateLabel("", 0, 0, $_GUI_MAIN_WIDTH, 5)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
$g_hFrmBot_MAIN_PIC = _GUICtrlCreatePic($g_sLogoPath, 0, $_GUI_MAIN_TOP, $_GUI_MAIN_WIDTH, 67)
$g_hFrmBot_URL_PIC = _GUICtrlCreatePic($g_sLogoUrlPath, 0, $_GUI_MAIN_TOP + 67, $_GUI_MAIN_WIDTH, 13)
GUICtrlSetCursor(-1, 0)
$hToolTip = _GUIToolTip_Create($g_hFrmBot)
_GUIToolTip_SetMaxTipWidth($hToolTip, $_GUI_MAIN_WIDTH)
GUISwitch($g_hFrmBot)
$g_hFrmBotEmbeddedShieldInput = GUICtrlCreateInput("", 0, 0, -1, -1, $WS_TABSTOP)
GUICtrlSetState($g_hFrmBotEmbeddedShieldInput, $GUI_HIDE)
$g_hFrmBotBottom = GUICreate("", $_GUI_MAIN_WIDTH, $_GUI_BOTTOM_HEIGHT, 0, $_GUI_MAIN_HEIGHT - $_GUI_BOTTOM_HEIGHT + $_GUI_MAIN_TOP, BitOR($WS_CHILD, $WS_TABSTOP), $WS_EX_TOPMOST, $g_hFrmBot)
GUISwitch($g_hFrmBot)
SplashStep(GetTranslated(500, 24, "Loading GUI Bottom..."))
GUISwitch($g_hFrmBotBottom)
CreateBottomPanel()
GUISwitch($g_hFrmBotEx)
$g_hFirstControlToHide = GUICtrlCreateDummy()
SplashStep(GetTranslated(500, 25, "Loading Log tab..."))
CreateLogTab()
SplashStep(GetTranslated(500, 26, "Loading Village tab..."))
CreateVillageTab()
SplashStep(GetTranslated(500, 27, "Loading Attack tab..."))
CreateAttackTab()
SplashStep(GetTranslated(500, 28, "Loading Bot tab..."))
CreateBotTab()
SplashStep(GetTranslated(500, 37, "Loading MOD tab..."))
CreateMODTab()
SplashStep(GetTranslated(500, 29, "Loading About Us tab..."))
CreateAboutTab()
SplashStep(GetTranslated(500, 30, "Initializing GUI..."))
GUISwitch($g_hFrmBotEx)
$g_hTabMain = GUICtrlCreateTab(5, 85 + $_GUI_MAIN_TOP, $_GUI_MAIN_WIDTH - 9, $_GUI_MAIN_HEIGHT - 225)
$g_hTabLog = GUICtrlCreateTabItem(GetTranslated(600,1, "Log"))
$g_hTabVillage = GUICtrlCreateTabItem(GetTranslated(600,2, "Village"))
$g_hTabAttack = GUICtrlCreateTabItem(GetTranslated(600,3,"Attack Plan"))
$g_hTabBot = GUICtrlCreateTabItem(GetTranslated(600,4,"Bot"))
$g_hTabMOD = GUICtrlCreateTabItem(GetTranslated(600,57,"DocOC"))
$g_hTabAbout = GUICtrlCreateTabItem(GetTranslated(600, 5, "About Us"))
GUICtrlCreateTabItem("")
GUICtrlSetResizing(-1, $GUI_DOCKBORDERS)
Bind_ImageList($g_hTabMain)
Bind_ImageList($g_hGUI_VILLAGE_TAB)
Bind_ImageList($g_hGUI_DONATE_TAB)
Bind_ImageList($g_hGUI_UPGRADE_TAB)
Bind_ImageList($g_hGUI_NOTIFY_TAB)
Bind_ImageList($g_hGUI_ATTACK_TAB)
Bind_ImageList($g_hGUI_TRAINARMY_TAB)
Bind_ImageList($g_hGUI_SEARCH_TAB)
Bind_ImageList($g_hGUI_DEADBASE_TAB)
Bind_ImageList($g_hGUI_ACTIVEBASE_TAB)
Bind_ImageList($g_hGUI_THSNIPE_TAB)
Bind_ImageList($g_hGUI_ATTACKOPTION_TAB)
Bind_ImageList($g_hGUI_STRATEGIES_TAB)
Bind_ImageList($g_hGUI_BOT_TAB)
Bind_ImageList($g_hGUI_MOD_TAB)
Bind_ImageList($g_hGUI_STATS_TAB)
GUICtrlSetState($g_hGUI_LOG, $GUI_SHOW)
cmbLog()
$g_hStatusBar = _GUICtrlStatusBar_Create($g_hFrmBotBottom)
_GUICtrlStatusBar_SetSimple($g_hStatusBar)
_GUICtrlStatusBar_SetText($g_hStatusBar, "Status : Idle")
$g_hTiShow = TrayCreateItem(GetTranslated(500,31,"Show bot"))
TrayItemSetOnEvent($g_hTiShow, "tiShow")
$g_hTiHide = TrayCreateItem(GetTranslated(500,32, "Hide when minimized"))
TrayItemSetOnEvent($g_hTiHide, "tiHide")
TrayCreateItem("")
$g_hTiDonate = TrayCreateItem(GetTranslated(500,33, "Support Development"))
TrayItemSetOnEvent($g_hTiDonate, "tiDonate")
$g_hTiAbout = TrayCreateItem(GetTranslated(500,34, "About"))
TrayItemSetOnEvent($g_hTiAbout, "tiAbout")
TrayCreateItem("")
$g_hTiExit = TrayCreateItem(GetTranslated(500,35, "Exit"))
TrayItemSetOnEvent($g_hTiExit, "tiExit")
If $g_hLibFunctions <> -1 Then
GUICtrlSetState($g_hBtnStart, $GUI_ENABLE)
If $iTownHallLevel > 2 Then
GUICtrlSetState($g_hBtnSearchMode, $GUI_ENABLE)
EndIf
EndIf
SetDebugLog("$g_hFrmBot=" & $g_hFrmBot, Default, True)
SetDebugLog("$g_hFrmBotEx=" & $g_hFrmBotEx, Default, True)
SetDebugLog("$g_hFrmBotBottom=" & $g_hFrmBotBottom, Default, True)
SetDebugLog("$g_hFrmBotEmbeddedShield=" & $g_hFrmBotEmbeddedShield, Default, True)
SetDebugLog("$g_hFrmBotEmbeddedShieldInput=" & $g_hFrmBotEmbeddedShieldInput, Default, True)
SetDebugLog("$g_hFrmBotEmbeddedGraphics=" & $g_hFrmBotEmbeddedGraphics, Default, True)
EndFunc
Func ShowMainGUI()
If Not $g_bNoFocusTampering Then
GUISetState(@SW_SHOW, $g_hFrmBot)
Else
GUISetState(@SW_SHOW, $g_hFrmBot)
EndIf
GUISetState(@SW_SHOWNOACTIVATE, $g_hFrmBotEx)
GUISetState(@SW_SHOWNOACTIVATE, $g_hFrmBotBottom)
GUISwitch($g_hFrmBotEx)
$g_bFrmBotMinimized = False
Local $p = WinGetPos($g_hFrmBot)
$g_aFrmBotPosInit[0] = $p[0]
$g_aFrmBotPosInit[1] = $p[1]
$g_aFrmBotPosInit[2] = $p[2]
$g_aFrmBotPosInit[3] = $p[3]
$g_aFrmBotPosInit[4] = _WinAPI_GetClientWidth($g_hFrmBot)
$g_aFrmBotPosInit[5] = _WinAPI_GetClientHeight($g_hFrmBot)
$g_aFrmBotPosInit[6] = ControlGetPos($g_hFrmBot, "", $g_hFrmBotEx)[3]
EndFunc
Func GUICtrlGetBkColor($hWnd)
If Not IsHWnd($hWnd) Then
$hWnd = GUICtrlGetHandle($hWnd)
EndIf
Local $hDC = _WinAPI_GetDC($hWnd)
Local $iColor = _WinAPI_GetPixel($hDC, 0, 0)
_WinAPI_ReleaseDC($hWnd, $hDC)
Return $iColor
EndFunc
Global $g_bRedrawBotWindow[3] = [True, False, False]
Global $g_hFrmBot_WNDPROC = 0
Global $g_hFrmBot_WNDPROC_ptr = 0
Global $groupSearchDB = "", $groupHerosDB = "", $groupSearchAB = "", $groupHerosAB = "", $groupSpellsDB = "", $groupSpellsAB = "", $groupSearchTS = ""
Global $groupAttackDB = "", $groupAttackDBSpell = "", $groupIMGAttackDB = "", $groupIMGAttackDBSpell = "", $groupAttackAB = "", $groupAttackABSpell = "", $groupIMGAttackAB = "", $groupIMGAttackABSpell = "", $groupAttackTS = "", $groupAttackTSSpell = "", $groupIMGAttackTS = "", $groupIMGAttackTSSpell = ""
Global $groupEndBattkeDB = "", $groupEndBattkeAB = "", $groupKingSleeping = "", $groupQueenSleeping = "", $groupWardenSleeping = "", $groupCloseWhileTraining = "", $grpTrainTroops = "", $grpCookSpell = ""
Global $groupLightning = "", $groupHeal = "", $groupRage = "", $groupJumpSpell = "", $groupFreeze = "", $groupClone = "", $groupIcnLightning = "", $groupIcnHeal = "", $groupIcnRage = "", $groupIcnJumpSpell = "", $groupIcnFreeze = "", $groupIcnClone = ""
Global $groupPoison = "", $groupEarthquake = "", $groupHaste = "", $groupSkeleton = "", $groupIcnPoison = "", $groupIcnEarthquake = "", $groupIcnHaste = "", $groupIcnSkeleton = "", $groupListSpells = ""
Global $groupListTHLevels = ""
Global $groupLeague = ""
Global $aTabControlsVillage, $aTabControlsDonate, $aTabControlsUpgrade, $aTabControlsNotify
Global $aTabControlsAttack, $aTabControlsArmy, $aTabControlsSearch, $aTabControlsDeadbase, $aTabControlsActivebase, $aTabControlsTHSnipe, $aTabControlsAttackOptions
Global $aTabControlsStrategies, $aTabControlsBot, $aTabControlsMOD, $aTabControlsStats
Global $oAlwaysEnabledControls = ObjCreate("Scripting.Dictionary")
Func InitializeControlVariables()
$groupSearchDB = $g_hGrpDBFilter&"#"&$g_hCmbDBMeetGE&"#"&$g_hTxtDBMinGold&"#"&$g_hPicDBMinGold&"#"&$g_hTxtDBMinElixir&"#"&$g_hPicDBMinElixir&"#"& $g_hTxtDBMinGoldPlusElixir&"#"&$g_hPicDBMinGPEGold&"#"&$g_hChkDBMeetDE&"#"&$g_hTxtDBMinDarkElixir&"#"&$g_hPicDBMinDarkElixir&"#"&$g_hChkDBMeetTrophy&"#"& $g_hTxtDBMinTrophy&"#"&$g_hPicDBMinTrophies&"#"&$g_hChkDBMeetTH&"#"&$g_hCmbDBTH&"#"&$g_hPicDBMaxTH10&"#"&$g_hChkDBMeetTHO&"#"& $g_ahChkMeetOne[$DB]&"#"& $g_ahChkMaxMortar[$DB]&"#"&$g_ahCmbWeakMortar[$DB]&"#"&$g_ahPicWeakMortar[$DB]&"#"&$g_ahChkMaxWizTower[$DB]&"#"&$g_ahCmbWeakWizTower[$DB]&"#"& $g_ahPicWeakWizTower[$DB]&"#"& $g_ahChkMaxXBow[$DB]&"#"&$g_ahCmbWeakXBow[$DB]&"#"&$g_ahPicWeakXBow[$DB]&"#"&$g_ahChkMaxInferno[$DB]&"#"&$g_ahCmbWeakInferno[$DB]&"#"& $g_ahPicWeakInferno[$DB]&"#"&$g_ahChkMaxEagle[$DB]&"#"&$g_ahCmbWeakEagle[$DB]&"#"&$g_ahPicWeakEagle[$DB]
$groupHerosDB = $g_hPicDBHeroesWait&"#"&$g_hTxtDBHeroesWait&"#"&$g_hChkDBKingWait&"#"&$g_hChkDBQueenWait&"#"&$g_hChkDBWardenWait&"#"&$g_hPicDBKingWait&"#"& $g_hPicDBQueenWait&"#"&$g_hPicDBWardenWait
$groupSearchAB = $g_hGrpABFilter&"#"&$g_hCmbABMeetGE&"#"&$g_hTxtABMinGold&"#"&$g_hPicABMinGold&"#"&$g_hTxtABMinElixir&"#"&$g_hPicABMinElixir&"#"& $g_hTxtABMinGoldPlusElixir&"#"&$g_hPicABMinGPEGold&"#"&$g_hChkABMeetDE&"#"&$g_hTxtABMinDarkElixir&"#"& $g_hPicABMinDarkElixir&"#"&$g_hChkABMeetTrophy&"#"& $g_hTxtABMinTrophy&"#"&$g_hPicABMinTrophies&"#"&$g_hChkABMeetTH&"#"&$g_hCmbABTH&"#"&$g_hPicABMaxTH10&"#"&$g_hChkABMeetTHO&"#"& $g_ahChkMeetOne[$LB]&"#"& $g_ahChkMaxMortar[$LB]&"#"&$g_ahCmbWeakMortar[$LB]&"#"&$g_ahPicWeakMortar[$LB]&"#"&$g_ahChkMaxWizTower[$LB]&"#"&$g_ahCmbWeakWizTower[$LB]&"#"& $g_ahPicWeakWizTower[$LB]&"#"&$g_ahChkMaxXBow[$LB]&"#"&$g_ahCmbWeakXBow[$LB]&"#"&$g_ahPicWeakXBow[$LB]&"#"&$g_ahChkMaxInferno[$LB]&"#"& $g_ahCmbWeakInferno[$LB]&"#"&$g_ahPicWeakInferno[$LB]&"#"&$g_ahChkMaxEagle[$LB]&"#"&$g_ahCmbWeakEagle[$LB]&"#"&$g_ahPicWeakEagle[$LB]
$groupHerosAB = $g_hPicABHeroesWait&"#"&$g_hTxtABHeroesWait&"#"&$g_hChkABKingWait&"#"&$g_hChkABQueenWait&"#"&$g_hChkABWardenWait&"#"&$g_hPicABKingWait&"#"& $g_hPicABQueenWait&"#"&$g_hPicABWardenWait
$groupSpellsDB = $g_hChkDBSpellsWait&"#"&$g_hPicDBLightSpellWait&"#"&$g_hPicDBHealSpellWait&"#"&$g_hPicDBRageSpellWait&"#"&$g_hPicDBJumpSpellWait&"#"& $g_hPicDBFreezeSpellWait&"#"&$g_hPicDBPoisonSpellWait&"#"&$g_hPicDBEarthquakeSpellWait&"#"&$g_hPicDBHasteSpellWait
$groupSpellsAB = $g_hChkABSpellsWait&"#"&$g_hPicABLightSpellWait&"#"&$g_hPicABHealSpellWait&"#"&$g_hPicABRageSpellWait&"#"&$g_hPicABJumpSpellWait&"#"& $g_hPicABFreezeSpellWait&"#"&$g_hPicABPoisonSpellWait&"#"&$g_hPicABEarthquakeSpellWait&"#"&$g_hPicABHasteSpellWait
$groupSearchTS = $g_hGrpTSFilter&"#"&$g_hCmbTSMeetGE&"#"&$g_hTxtTSMinGold&"#"&$g_hPicTSMinGold&"#"&$g_hTxtTSMinElixir&"#"&$g_hPicTSMinElixir&"#"& $g_hTxtTSMinGoldPlusElixir&"#"&$g_hPicTSMinGPEGold&"#"&$g_hChkTSMeetDE&"#"&$g_hTxtTSMinDarkElixir&"#"&$g_hPicTSMinDarkElixir&"#"& $g_hLblAddTiles&"#"&$g_hLblAddTiles2&"#"&$g_hLblSWTTiles&"#"&$g_hTxtSWTTiles&"#"&$g_hLblTHadd&"#"&$g_hTxtTHaddTiles
$groupAttackDB = $g_hCmbDBAlgorithm&"#"&$g_hCmbDBSelectTroop&"#"&$g_hChkDBKingAttack&"#"&$g_hChkDBQueenAttack&"#"&$g_hChkDBWardenAttack&"#"&$g_hChkDBDropCC&"#"& $g_hChkDBLightSpell&"#"&$g_hChkDBHealSpell&"#"&$g_hChkDBRageSpell&"#"&$g_hChkDBJumpSpell&"#"&$g_hChkDBFreezeSpell&"#"&$g_hChkDBPoisonSpell&"#"& $g_hChkDBEarthquakeSpell&"#"&$g_hChkDBHasteSpell&"#"&$g_hChkDBSkeletonSpell&"#"&$g_hChkDBCloneSpell
$groupAttackDBSpell = $g_hChkDBLightSpell&"#"&$g_hChkDBHealSpell&"#"&$g_hChkDBRageSpell&"#"&$g_hChkDBJumpSpell&"#"&$g_hChkDBFreezeSpell&"#"&$g_hChkDBPoisonSpell&"#"& $g_hChkDBEarthquakeSpell&"#"&$g_hChkDBHasteSpell&"#"&$g_hChkDBSkeletonSpell&"#"&$g_hChkDBCloneSpell
$groupIMGAttackDB = $g_hPicDBKingAttack&"#"&$g_hPicDBQueenAttack&"#"&$g_hPicDBWardenAttack&"#"&$g_hPicDBDropCC&"#"&$g_hPicDBLightSpell&"#"&$g_hPicDBHealSpell&"#"& $g_hPicDBRageSpell&"#"&$g_hPicDBJumpSpell&"#"&$g_hPicDBFreezeSpell&"#"&$g_hPicDBPoisonSpell&"#"&$g_hPicDBEarthquakeSpell&"#"&$g_hPicDBHasteSpell
$groupIMGAttackDBSpell = $g_hPicDBLightSpell&"#"&$g_hPicDBHealSpell&"#"&$g_hPicDBRageSpell&"#"&$g_hPicDBJumpSpell&"#"&$g_hPicDBFreezeSpell&"#"&$g_hPicDBPoisonSpell&"#"& $g_hPicDBEarthquakeSpell&"#"&$g_hPicDBHasteSpell&"#"&$g_hPicDBSkeletonSpell&"#"&$g_hPicDBCloneSpell
$groupAttackAB = $g_hCmbDBAlgorithm&"#"&$g_hCmbABSelectTroop&"#"&$g_hChkABKingAttack&"#"&$g_hChkABQueenAttack&"#"&$g_hChkABWardenAttack&"#"&$g_hChkABDropCC&"#"& $g_hChkABLightSpell&"#"&$g_hChkABHealSpell&"#"&$g_hChkABRageSpell&"#"&$g_hChkABJumpSpell&"#"&$g_hChkABFreezeSpell&"#"&$g_hChkABPoisonSpell&"#"& $g_hChkABEarthquakeSpell&"#"&$g_hChkABHasteSpell&"#"&$g_hChkABSkeletonSpell&"#"&$g_hChkABCloneSpell
$groupAttackABSpell = $g_hChkABLightSpell&"#"&$g_hChkABHealSpell&"#"&$g_hChkABRageSpell&"#"&$g_hChkABJumpSpell&"#"&$g_hChkABFreezeSpell&"#"&$g_hChkABPoisonSpell&"#"& $g_hChkABEarthquakeSpell&"#"&$g_hChkABHasteSpell&"#"&$g_hChkABSkeletonSpell&"#"&$g_hChkABCloneSpell
$groupIMGAttackAB = $g_hPicABKingAttack&"#"&$g_hPicABQueenAttack&"#"&$g_hPicABWardenAttack&"#"&$g_hPicABDropCC&"#"&$g_hPicABLightSpell&"#"&$g_hPicABHealSpell&"#"& $g_hPicABRageSpell&"#"&$g_hPicABJumpSpell&"#"&$g_hPicABFreezeSpell&"#"&$g_hPicABPoisonSpell&"#"&$g_hPicABEarthquakeSpell&"#"&$g_hPicABHasteSpell
$groupIMGAttackABSpell = $g_hPicABLightSpell&"#"&$g_hPicABHealSpell&"#"&$g_hPicABRageSpell&"#"&$g_hPicABJumpSpell&"#"&$g_hPicABFreezeSpell&"#"&$g_hPicABPoisonSpell&"#"& $g_hPicABEarthquakeSpell&"#"&$g_hPicABHasteSpell&"#"&$g_hPicABSkeletonSpell&"#"&$g_hPicABCloneSpell
$groupAttackTS = $g_hGrpABAttack&"#"&$g_hLblAttackTHType&"#"&$g_hCmbAttackTHType&"#"&$g_hLblTSSelectTroop&"#"&$g_hCmbTSSelectTroop&"#"& $g_hLblTSSelectSpecialTroop&"#"&$g_hChkTSKingAttack&"#"&$g_hChkTSQueenAttack&"#"&$g_hChkTSWardenAttack&"#"&$g_hChkTSDropCC&"#"&$g_hChkTSLightSpell&"#"& $g_hChkTSHealSpell&"#"&$g_hChkTSRageSpell&"#"&$g_hChkTSJumpSpell&"#"&$g_hChkTSFreezeSpell&"#"&$g_hChkTSPoisonSpell&"#"&$g_hChkTSEarthquakeSpell&"#"& $g_hChkTSHasteSpell
$groupAttackTSSpell = $g_hChkTSLightSpell&"#"&$g_hChkTSHealSpell&"#"&$g_hChkTSRageSpell&"#"&$g_hChkTSJumpSpell&"#"&$g_hChkTSFreezeSpell&"#"& $g_hChkTSPoisonSpell&"#"&$g_hChkTSEarthquakeSpell&"#"&$g_hChkTSHasteSpell
$groupIMGAttackTS = $g_hPicTSKingAttack&"#"&$g_hPicTSQueenAttack&"#"&$g_hPicTSWardenAttack&"#"&$g_hPicTSDropCC&"#"&$g_hPicTSLightSpell&"#"& $g_hPicTSHealSpell&"#"&$g_hPicTSRageSpell&"#"&$g_hPicTSJumpSpell&"#"&$g_hPicTSFreezeSpell&"#"&$g_hPicTSPoisonSpell&"#"&$g_hPicTSEarthquakeSpell&"#"& $g_hPicTSHasteSpell
$groupIMGAttackTSSpell = $g_hPicTSLightSpell&"#"&$g_hPicTSHealSpell&"#"&$g_hPicTSRageSpell&"#"&$g_hPicTSJumpSpell&"#"&$g_hPicTSFreezeSpell&"#"& $g_hPicTSPoisonSpell&"#"&$g_hPicTSEarthquakeSpell&"#"&$g_hPicTSHasteSpell
$groupEndBattkeDB = $g_hGrpDBEndBattle&"#"&$g_hChkStopAtkDBNoLoot1&"#"&$g_hLblStopAtkDBNoLoot1a&"#"&$g_hTxtStopAtkDBNoLoot1&"#"&$g_hLblStopAtkDBNoLoot1b&"#"& $g_hChkStopAtkDBNoLoot2&"#"&$g_hChkStopAtkDBNoLoot2&"#"&$g_hLblStopAtkDBNoLoot2a&"#"&$g_hTxtStopAtkDBNoLoot2&"#"&$g_hLblStopAtkDBNoLoot2b&"#"& $g_hLblDBMinRerourcesAtk2&"#"&$g_hTxtDBMinGoldStopAtk2&"#"&$g_hPicDBMinGoldStopAtk2&"#"&$g_hTxtDBMinElixirStopAtk2&"#"&$g_hPicDBMinElixirStopAtk2&"#"& $g_hTxtDBMinDarkElixirStopAtk2&"#"&$g_hPicDBMinDarkElixirStopAtk2&"#"&$g_hChkDBEndNoResources&"#"&$g_hChkDBEndOneStar&"#"&$g_hChkDBEndTwoStars
$groupEndBattkeAB = $g_hGrpABEndBattle&"#"&$g_hChkStopAtkABNoLoot1&"#"&$g_hLblABTimeStopAtka&"#"&$g_hTxtStopAtkABNoLoot1&"#"&$g_hLblABTimeStopAtk&"#"& $g_hChkStopAtkABNoLoot2&"#"&$g_hChkStopAtkABNoLoot2&"#"&$g_hLblABTimeStopAtk2a&"#"&$g_hTxtStopAtkABNoLoot2&"#"&$g_hLblABTimeStopAtk2&"#"& $g_hLblABMinRerourcesAtk2&"#"&$g_hTxtABMinGoldStopAtk2&"#"&$g_hPicABMinGoldStopAtk2&"#"&$g_hTxtABMinElixirStopAtk2&"#"&$g_hPicABMinElixirStopAtk2&"#"& $g_hTxtABMinDarkElixirStopAtk2&"#"&$g_hPicABMinDarkElixirStopAtk2&"#"&$g_hChkABEndNoResources&"#"&$g_hChkABEndOneStar&"#"&$g_hChkABEndTwoStars
$groupKingSleeping = $g_hPicDBKingSleepWait&"#"&$g_hPicABKingSleepWait&"#"&$g_hPicChkKingSleepWait
$groupQueenSleeping = $g_hPicDBQueenSleepWait&"#"&$g_hPicABQueenSleepWait&"#"&$g_hPicChkQueenSleepWait
$groupWardenSleeping = $g_hPicDBWardenSleepWait&"#"&$g_hPicABWardenSleepWait&"#"&$g_hPicChkWardenSleepWait
$groupCloseWhileTraining = $g_hChkCloseWithoutShield&"#"&$g_hChkCloseEmulator&"#"&$g_hPicCloseWaitTrain&"#"&$g_hChkRandomClose&"#"&$g_hPicCloseWaitStop&"#"& $g_hRdoCloseWaitExact&"#"&$g_hPicCloseWaitExact&"#"&$g_hRdoCloseWaitRandom&"#"&$g_hCmbCloseWaitRdmPercent&"#"&$g_hLblCloseWaitRdmPercent
$grpTrainTroops = $g_ahTxtTrainArmyTroopCount[$eTroopBarbarian]&"#"&$g_ahTxtTrainArmyTroopCount[$eTroopArcher]&"#"&$g_ahTxtTrainArmyTroopCount[$eTroopGiant]&"#"& $g_ahTxtTrainArmyTroopCount[$eTroopGoblin]&"#"&$g_ahTxtTrainArmyTroopCount[$eTroopWallBreaker]&"#"&$g_ahTxtTrainArmyTroopCount[$eTroopBalloon]&"#"& $g_ahTxtTrainArmyTroopCount[$eTroopWizard]&"#"&$g_ahTxtTrainArmyTroopCount[$eTroopHealer]&"#"&$g_ahTxtTrainArmyTroopCount[$eTroopDragon]&"#"& $g_ahTxtTrainArmyTroopCount[$eTroopPekka]&"#"&$g_ahTxtTrainArmyTroopCount[$eTroopBabyDragon]&"#"&$g_ahTxtTrainArmyTroopCount[$eTroopMiner]&"#"& $g_ahTxtTrainArmyTroopCount[$eTroopMinion]&"#"&$g_ahTxtTrainArmyTroopCount[$eTroopHogRider]&"#"&$g_ahTxtTrainArmyTroopCount[$eTroopValkyrie]&"#"& $g_ahTxtTrainArmyTroopCount[$eTroopGolem]&"#"&$g_ahTxtTrainArmyTroopCount[$eTroopWitch]&"#"&$g_ahTxtTrainArmyTroopCount[$eTroopLavaHound]&"#"& $g_ahTxtTrainArmyTroopCount[$eTroopBowler]
$grpCookSpell = $g_ahTxtTrainArmySpellCount[$eSpellLightning]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellHeal]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellRage]&"#"& $g_ahTxtTrainArmySpellCount[$eSpellJump]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellFreeze]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellClone]&"#"& $g_ahTxtTrainArmySpellCount[$eSpellPoison]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellEarthquake]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellHaste]&"#"& $g_ahTxtTrainArmySpellCount[$eSpellSkeleton]
$groupLightning = $g_ahPicTrainArmySpell[$eSpellLightning]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellLightning]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellLightning]
$groupHeal = $g_ahPicTrainArmySpell[$eSpellHeal]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellHeal]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellHeal]
$groupRage = $g_ahPicTrainArmySpell[$eSpellRage]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellRage]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellRage]
$groupJumpSpell = $g_ahPicTrainArmySpell[$eSpellJump]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellJump]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellJump]
$groupFreeze = $g_ahPicTrainArmySpell[$eSpellFreeze]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellFreeze]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellFreeze]
$groupClone = $g_ahPicTrainArmySpell[$eSpellClone]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellClone]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellClone]
$groupIcnLightning = $g_ahPicTrainArmySpell[$eSpellLightning]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellLightning]
$groupIcnHeal = $g_ahPicTrainArmySpell[$eSpellHeal]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellHeal]
$groupIcnRage = $g_ahPicTrainArmySpell[$eSpellRage]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellRage]
$groupIcnJumpSpell = $g_ahPicTrainArmySpell[$eSpellJump]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellJump]
$groupIcnFreeze = $g_ahPicTrainArmySpell[$eSpellFreeze]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellFreeze]
$groupIcnClone = $g_ahPicTrainArmySpell[$eSpellClone]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellClone]
$groupPoison = $g_ahPicTrainArmySpell[$eSpellPoison]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellPoison]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellPoison]
$groupEarthquake = $g_ahPicTrainArmySpell[$eSpellEarthquake]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellEarthquake]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellEarthquake]
$groupHaste = $g_ahPicTrainArmySpell[$eSpellHaste]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellHaste]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellHaste]
$groupSkeleton = $g_ahPicTrainArmySpell[$eSpellSkeleton]&"#"&$g_ahTxtTrainArmySpellCount[$eSpellSkeleton]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellSkeleton]
$groupIcnPoison = $g_ahPicTrainArmySpell[$eSpellPoison]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellPoison]
$groupIcnEarthquake = $g_ahPicTrainArmySpell[$eSpellEarthquake]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellEarthquake]
$groupIcnHaste = $g_ahPicTrainArmySpell[$eSpellHaste]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellHaste]
$groupIcnSkeleton = $g_ahPicTrainArmySpell[$eSpellSkeleton]&"#"&$g_ahLblTrainArmySpellLevel[$eSpellSkeleton]
$groupListSpells = $groupLightning&"#"&$groupHeal&"#"&$groupRage&"#"&$groupJumpSpell&"#"&$groupFreeze&"#"&$groupClone&"#"&$groupPoison&"#"& $groupEarthquake&"#"&$groupHaste&"#"&$groupSkeleton
$groupListTHLevels = $g_ahPicTHLevels[4]&"#"&$g_ahPicTHLevels[5]&"#"&$g_ahPicTHLevels[6]&"#"&$g_ahPicTHLevels[7]&"#"&$g_ahPicTHLevels[8]&"#"& $g_ahPicTHLevels[9]&"#"&$g_ahPicTHLevels[10]&"#"&$g_ahPicTHLevels[11]
$groupLeague = $g_ahPicLeague[$eLeagueUnranked]&"#"&$g_ahPicLeague[$eLeagueBronze]&"#"&$g_ahPicLeague[$eLeagueSilver]&"#"&$g_ahPicLeague[$eLeagueGold] &"#"& $g_ahPicLeague[$eLeagueCrystal]&"#"&$g_ahPicLeague[$eLeagueMaster]&"#"&$g_ahPicLeague[$eLeagueChampion]&"#"&$g_ahPicLeague[$eLeagueTitan]&"#"& $g_ahPicLeague[$eLeagueLegend]
Dim $aTabControlsVillage = [$g_hGUI_VILLAGE_TAB, $g_hGUI_VILLAGE_TAB_ITEM1, $g_hGUI_VILLAGE_TAB_ITEM2, $g_hGUI_VILLAGE_TAB_ITEM3, $g_hGUI_VILLAGE_TAB_ITEM4, $g_hGUI_VILLAGE_TAB_ITEM5]
Dim $aTabControlsDonate = [$g_hGUI_DONATE_TAB, $g_hGUI_DONATE_TAB_ITEM1, $g_hGUI_DONATE_TAB_ITEM2, $g_hGUI_DONATE_TAB_ITEM3]
Dim $aTabControlsUpgrade = [$g_hGUI_UPGRADE_TAB, $g_hGUI_UPGRADE_TAB_ITEM1, $g_hGUI_UPGRADE_TAB_ITEM2, $g_hGUI_UPGRADE_TAB_ITEM3, $g_hGUI_UPGRADE_TAB_ITEM4]
Dim $aTabControlsNotify = [$g_hGUI_NOTIFY_TAB, $g_hGUI_NOTIFY_TAB_ITEM2, $g_hGUI_NOTIFY_TAB_ITEM6]
Dim $aTabControlsAttack = [$g_hGUI_ATTACK_TAB, $g_hGUI_ATTACK_TAB_ITEM1, $g_hGUI_ATTACK_TAB_ITEM2, $g_hGUI_ATTACK_TAB_ITEM3]
Dim $aTabControlsArmy = [$g_hGUI_TRAINARMY_TAB, $g_hGUI_TRAINARMY_TAB_ITEM1, $g_hGUI_TRAINARMY_TAB_ITEM2, $g_hGUI_TRAINARMY_TAB_ITEM3, $g_hGUI_TRAINARMY_TAB_ITEM4]
Dim $aTabControlsSearch = [$g_hGUI_SEARCH_TAB, $g_hGUI_SEARCH_TAB_ITEM1, $g_hGUI_SEARCH_TAB_ITEM2, $g_hGUI_SEARCH_TAB_ITEM3, $g_hGUI_SEARCH_TAB_ITEM4, $g_hGUI_SEARCH_TAB_ITEM5]
Dim $aTabControlsDeadbase = [$g_hGUI_DEADBASE_TAB, $g_hGUI_DEADBASE_TAB_ITEM1, $g_hGUI_DEADBASE_TAB_ITEM2, $g_hGUI_DEADBASE_TAB_ITEM3, $g_hGUI_DEADBASE_TAB_ITEM4]
Dim $aTabControlsActivebase = [$g_hGUI_ACTIVEBASE_TAB, $g_hGUI_ACTIVEBASE_TAB_ITEM1, $g_hGUI_ACTIVEBASE_TAB_ITEM2, $g_hGUI_ACTIVEBASE_TAB_ITEM3]
Dim $aTabControlsTHSnipe = [$g_hGUI_THSNIPE_TAB, $g_hGUI_THSNIPE_TAB_ITEM1, $g_hGUI_THSNIPE_TAB_ITEM2, $g_hGUI_THSNIPE_TAB_ITEM3]
Dim $aTabControlsAttackOptions = [$g_hGUI_ATTACKOPTION_TAB, $g_hGUI_ATTACKOPTION_TAB_ITEM1, $g_hGUI_ATTACKOPTION_TAB_ITEM2, $g_hGUI_ATTACKOPTION_TAB_ITEM3, $g_hGUI_ATTACKOPTION_TAB_ITEM4, $g_hGUI_ATTACKOPTION_TAB_ITEM5]
Dim $aTabControlsStrategies = [$g_hGUI_STRATEGIES_TAB, $g_hGUI_STRATEGIES_TAB_ITEM1, $g_hGUI_STRATEGIES_TAB_ITEM2]
Dim $aTabControlsBot = [$g_hGUI_BOT_TAB, $g_hGUI_BOT_TAB_ITEM1, $g_hGUI_BOT_TAB_ITEM2, $g_hGUI_BOT_TAB_ITEM3, $g_hGUI_BOT_TAB_ITEM4, $g_hGUI_BOT_TAB_ITEM5]
Dim $aTabControlsStats = [$g_hGUI_STATS_TAB, $g_hGUI_STATS_TAB_ITEM1, $g_hGUI_STATS_TAB_ITEM2, $g_hGUI_STATS_TAB_ITEM3]
Dim $aTabControlsMOD = [$g_hGUI_MOD_TAB, $g_hGUI_MOD_TAB_ITEM1, $g_hGUI_MOD_TAB_ITEM2, $g_hGUI_MOD_TAB_ITEM3]
$oAlwaysEnabledControls($g_hChkUpdatingWhenMinimized) = 1
$oAlwaysEnabledControls($g_hChkHideWhenMinimized) = 1
$oAlwaysEnabledControls($g_hChkDebugClick) = 1
$oAlwaysEnabledControls($g_hChkDebugSetlog) = 1
$oAlwaysEnabledControls($g_hChkDebugDisableZoomout) = 1
$oAlwaysEnabledControls($g_hChkDebugDisableVillageCentering) = 1
$oAlwaysEnabledControls($g_hChkDebugDeadbaseImage) = 1
$oAlwaysEnabledControls($g_hChkDebugOCR) = 1
$oAlwaysEnabledControls($g_hChkDebugImageSave) = 1
$oAlwaysEnabledControls($g_hChkdebugBuildingPos) = 1
$oAlwaysEnabledControls($g_hChkdebugTrain) = 1
$oAlwaysEnabledControls($g_hChkDebugOCRDonate) = 1
$oAlwaysEnabledControls($g_hBtnTestTrain) = 1
$oAlwaysEnabledControls($g_hBtnTestDonateCC) = 1
$oAlwaysEnabledControls($g_hBtnTestRequestCC) = 1
$oAlwaysEnabledControls($g_hBtnTestAttackBar) = 1
$oAlwaysEnabledControls($g_hBtnTestClickDrag) = 1
$oAlwaysEnabledControls($g_hBtnTestImage) = 1
$oAlwaysEnabledControls($g_hBtnTestVillageSize) = 1
$oAlwaysEnabledControls($g_hBtnTestDeadBase) = 1
$oAlwaysEnabledControls($g_hBtnTestDeadBaseFolder) = 1
$oAlwaysEnabledControls($g_hBtnTestTHimgloc) = 1
$oAlwaysEnabledControls($g_hBtnTestimglocTroopBar) = 1
$oAlwaysEnabledControls($g_hBtnTestQuickTrainsimgloc) = 1
$oAlwaysEnabledControls($g_hChkdebugAttackCSV) = 1
$oAlwaysEnabledControls($g_hChkMakeIMGCSV) = 1
$oAlwaysEnabledControls($g_hBtnTestAttackCSV) = 1
$oAlwaysEnabledControls($g_hBtnTestFindButton) = 1
$oAlwaysEnabledControls($g_hTxtTestFindButton) = 1
$oAlwaysEnabledControls($g_hBtnTestCleanYard) = 1
$oAlwaysEnabledControls($g_hLblSmartLightningUsed) = 1
$oAlwaysEnabledControls($g_hLblSmartZap) = 1
$oAlwaysEnabledControls($g_hLblSmartEarthQuakeUsed) = 1
$oAlwaysEnabledControls($g_hBtnTestConfigSave) = 1
$oAlwaysEnabledControls($g_hBtnTestConfigRead) = 1
$oAlwaysEnabledControls($g_hBtnTestConfigApply) = 1
$oAlwaysEnabledControls($g_hBtnMakeScreenshot) = 1
$oAlwaysEnabledControls($g_hDivider) = 1
$oAlwaysEnabledControls($g_hTabMain) = 1
$oAlwaysEnabledControls($g_hTabLog) = 1
$oAlwaysEnabledControls($g_hTabVillage) = 1
$oAlwaysEnabledControls($g_hTabAttack) = 1
$oAlwaysEnabledControls($g_hTabBot) = 1
$oAlwaysEnabledControls($g_hTabMOD) = 1
$oAlwaysEnabledControls($g_hTabAbout) = 1
For $i in $aTabControlsVillage
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsDonate
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsUpgrade
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsNotify
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsAttack
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsArmy
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsSearch
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsDeadbase
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsActivebase
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsTHSnipe
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsAttackOptions
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsStrategies
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsBot
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsStats
$oAlwaysEnabledControls($i) = 1
Next
For $i in $aTabControlsMOD
$oAlwaysEnabledControls($i) = 1
Next
EndFunc
Global $ichklanguageFirst = 0
Global $g_aFrmBotBottomCtrlState, $g_hFrmBotEmbeddedShield = 0, $g_hFrmBotEmbeddedMouse = 0, $g_hFrmBotEmbeddedGraphics = 0
Func Initiate()
WinGetAndroidHandle()
If $HWnD <> 0 And($g_bAndroidBackgroundLaunched = True Or AndroidControlAvailable()) Then
SetLog(_PadStringCenter(" " & $g_sBotTitle & " Powered by MyBot.run ", 50, "~"), $COLOR_DEBUG)
Local $Compiled = @ScriptName &(@Compiled ? " Executable" : " Script")
SetLog($Compiled & " running on " & @OSVersion & " " & @OSServicePack & " " & @OSArch)
If Not $bSearchMode Then
SetLog(_PadStringCenter(" Bot Start ", 50, "="), $COLOR_SUCCESS)
Else
SetLog(_PadStringCenter(" Search Mode Start ", 50, "="), $COLOR_SUCCESS)
EndIf
SetLog(_PadStringCenter("  Current Profile: " & $g_sProfileCurrentName & " ", 73, "-"), $COLOR_INFO)
If $g_iDebugSetlog = 1 Or $g_iDebugOcr = 1 Or $g_iDebugRedArea = 1 Or $g_bDevMode = True Or $g_iDebugImageSave = 1 Or $g_iDebugBuildingPos = 1 Or $g_iDebugOCRdonate = 1 Or $g_iDebugAttackCSV = 1 Then
SetLog(_PadStringCenter(" Warning Debug Mode Enabled! Setlog: " & $g_iDebugSetlog & " OCR: " & $g_iDebugOcr & " RedArea: " & $g_iDebugRedArea & " ImageSave: " & $g_iDebugImageSave & " BuildingPos: " & $g_iDebugBuildingPos & " OCRDonate: " & $g_iDebugOCRdonate & " AttackCSV: " & $g_iDebugAttackCSV, 55, "-"), $COLOR_ERROR)
EndIf
$g_bFirstStart = True
If $g_bNotifyDeleteAllPushesOnStart = True Then _DeletePush()
If Not $bSearchMode Then
$g_hTimerSinceStarted = TimerInit()
EndIf
AndroidBotStartEvent()
If Not $g_bRunState Then Return
If Not $bSearchMode Then
If $g_bRestarted = True Then
$g_bRestarted = False
IniWrite($g_sProfileConfigPath, "general", "Restarted", 0)
PushMsg("Restarted")
EndIf
EndIf
If Not $g_bRunState Then Return
AndroidShield("Initiate", True)
checkMainScreen()
If Not $g_bRunState Then Return
ZoomOut()
If Not $g_bRunState Then Return
If $FirstInit = False And $ichkSwitchAccount = 1 Then
SwitchAccount(False, True)
EndIf
If Not $bSearchMode Then
BotDetectFirstTime()
If Not $g_bRunState Then Return
If $ichklanguageFirst = 0 And $ichklanguage = 1 Then $ichklanguageFirst = TestLanguage()
If Not $g_bRunState Then Return
runBot()
EndIf
Else
SetLog("Not in Game!", $COLOR_ERROR)
btnStop()
EndIf
EndFunc
Func InitiateLayout()
Local $AdjustScreenIfNecessarry = True
WinGetAndroidHandle()
Local $BSsize = getAndroidPos()
If IsArray($BSsize) Then
Local $BSx = $BSsize[2]
Local $BSy = $BSsize[3]
SetDebugLog("InitiateLayout: " & $title & " Android-ClientSize: " & $BSx & " x " & $BSy, $COLOR_INFO)
If Not CheckScreenAndroid($BSx, $BSy) Then
If $AdjustScreenIfNecessarry = True Then
Local $MsgRet = $IDOK
If $MsgRet = $IDOK Then
Return RebootAndroidSetScreen()
EndIf
Else
SetLog("Cannot use " & $g_sAndroidEmulator & ".", $COLOR_ERROR)
SetLog("Please set its screen size manually to " & $g_iAndroidClientWidth & " x " & $g_iAndroidClientHeight, $COLOR_ERROR)
btnStop()
Return False
EndIf
EndIf
DisposeWindows()
Return True
EndIf
Return False
EndFunc
Func chkBackground()
If GUICtrlRead($g_hChkBackgroundMode) = $GUI_CHECKED Then
$g_bChkBackgroundMode = True
updateBtnHideState($GUI_ENABLE)
Else
$g_bChkBackgroundMode = False
updateBtnHideState($GUI_DISABLE)
EndIf
EndFunc
Func IsStopped()
If $g_bRunState Then Return False
If $g_bRestart Then Return True
Return False
EndFunc
Func btnStart()
EnableControls($g_hFrmBotBottom, False, $g_aFrmBotBottomCtrlState)
Local $RunNow = $g_iBotAction <> $eBotNoAction
If $RunNow Then
BotStart()
Else
$g_iBotAction = $eBotStart
EndIf
$actual_train_skip = 0
EndFunc
Func btnStop()
If $g_bRunState Then
EnableControls($g_hFrmBotBottom, False, $g_aFrmBotBottomCtrlState)
$g_bRunState = False
$g_iBotAction = $eBotStop
EndIf
EndFunc
Func btnSearchMode()
EnableControls($g_hFrmBotBottom, False, $g_aFrmBotBottomCtrlState)
Local $RunNow = $g_iBotAction <> $eBotNoAction
If $RunNow Then
BotSearchMode()
Else
$g_iBotAction = $eBotSearchMode
EndIf
EndFunc
Func btnPause($RunNow = True)
TogglePause()
EndFunc
Func btnResume()
TogglePause()
EndFunc
Func btnAttackNowDB()
If $g_bRunState Then
$g_bBtnAttackNowPressed = True
$g_iMatchMode = $DB
EndIf
EndFunc
Func btnAttackNowLB()
If $g_bRunState Then
$g_bBtnAttackNowPressed = True
$g_iMatchMode = $LB
EndIf
EndFunc
Func btnAttackNowTS()
If $g_bRunState Then
$g_bBtnAttackNowPressed = True
$g_iMatchMode = $TS
EndIf
EndFunc
Func reHide()
WinGetAndroidHandle()
If $Hide = True And $HWnD <> 0 And $g_bAndroidEmbedded = False Then
SetDebugLog("Hide " & $g_sAndroidEmulator & " Window after restart")
Return WinMove2($HWnD, "", -32000, -32000)
EndIf
Return 0
EndFunc
Func updateBtnHideState($newState = $GUI_ENABLE)
Local $hideState = GUICtrlGetState($g_hBtnHide)
Local $newHideState =($g_bAndroidEmbedded = True ? $GUI_DISABLE : $newState)
If $hideState <> $newHideState Then GUICtrlSetState($g_hBtnHide, $newHideState)
EndFunc
Func btnHide()
If $Hide = False Then
GUICtrlSetData($g_hBtnHide, GetTranslated(602, 26, "Show"))
HideAndroidWindow(True)
$Hide = True
ElseIf $Hide = True Then
GUICtrlSetData($g_hBtnHide, GetTranslated(602, 11, "Hide"))
HideAndroidWindow(False)
$Hide = False
EndIf
EndFunc
Func updateBtnEmbed()
If $g_hBtnEmbed = 0 Then Return False
UpdateFrmBotStyle()
Local $state = GUICtrlGetState($g_hBtnEmbed)
If $HWnD = 0 Or $g_bAndroidBackgroundLaunched = True Or $g_bAndroidEmbed = False Then
If $state <> $GUI_DISABLE Then GUICtrlSetState($g_hBtnEmbed, $GUI_DISABLE)
Return False
EndIf
Local $text = GUICtrlRead($g_hBtnEmbed)
Local $newText
If $g_bAndroidEmbedded = True Then
$newText = GetTranslated(602, 28, "Undock")
Else
$newText = GetTranslated(602, 27, "Dock")
EndIf
If $text <> $newText Then GUICtrlSetData($g_hBtnEmbed, $newText)
If $state <> $GUI_ENABLE Then GUICtrlSetState($g_hBtnEmbed, $GUI_ENABLE)
updateBtnHideState()
Return True
EndFunc
Func btnEmbed()
ResumeAndroid()
WinGetAndroidHandle()
WinGetPos($HWnD)
If @error <> 0 Then Return SetError(0, 0, 0)
AndroidEmbed(Not $g_bAndroidEmbedded)
EndFunc
Func btnMakeScreenshot()
If $g_bRunState Then $g_bMakeScreenshotNow = True
EndFunc
Func GetFont()
Local $i, $sText = "", $DefaultFont
$DefaultFont = __EMB_GetDefaultFont()
For $i = 0 To UBound($DefaultFont) - 1
$sText &= " $DefaultFont[" & $i & "]= " & $DefaultFont[$i] & ", "
Next
Setlog($sText, $COLOR_DEBUG)
EndFunc
Func btnAnalyzeVillage()
$g_iDebugBuildingPos = 1
$g_iDebugDeadBaseImage = 1
SETLOG("DEADBASE CHECK..................")
checkDeadBase()
SETLOG("TOWNHALL CHECK imgloc..................")
$searchTH = imgloccheckTownhallADV2()
SETLOG("TOWNHALL C# CHECK. IMGLOC..............")
imglocTHSearch()
SETLOG("MINE CHECK C#...................")
$PixelMine = GetLocationMine()
SetLog("[" & UBound($PixelMine) & "] Gold Mines")
SETLOG("ELIXIR CHECK C#.................")
$PixelElixir = GetLocationElixir()
SetLog("[" & UBound($PixelElixir) & "] Elixir Collectors")
SETLOG("DARK ELIXIR CHECK C#............")
$PixelDarkElixir = GetLocationDarkElixir()
SetLog("[" & UBound($PixelDarkElixir) & "] Dark Elixir Drill/s")
SETLOG("DARK ELIXIR STORAGE CHECK C#....")
$BuildingToLoc = GetLocationDarkElixirStorage
SetLog("[" & UBound($BuildingToLoc) & "] Dark Elixir Storage")
For $i = 0 To UBound($BuildingToLoc) - 1
Local $pixel = $BuildingToLoc[$i]
If $g_iDebugSetlog = 1 Then SetLog("- Dark Elixir Storage " & $i + 1 & ": (" & $pixel[0] & "," & $pixel[1] & ")", $COLOR_DEBUG)
Next
SETLOG("LOCATE BARRACKS C#..............")
Local $PixelBarrackHere = GetLocationItem("getLocationBarrack")
SetLog("Total No. of Barracks: " & UBound($PixelBarrackHere), $COLOR_DEBUG)
For $i = 0 To UBound($PixelBarrackHere) - 1
Local $pixel = $PixelBarrackHere[$i]
If $g_iDebugSetlog = 1 Then SetLog("- Barrack " & $i + 1 & ": (" & $pixel[0] & "," & $pixel[1] & ")", $COLOR_DEBUG)
Next
SETLOG("LOCATE BARRACKS C#..............")
Local $PixelDarkBarrackHere = GetLocationItem("getLocationDarkBarrack")
SetLog("Total No. of Dark Barracks: " & UBound($PixelBarrackHere), $COLOR_DEBUG)
For $i = 0 To UBound($PixelDarkBarrackHere) - 1
Local $pixel = $PixelDarkBarrackHere[$i]
If $g_iDebugSetlog = 1 Then SetLog("- Dark Barrack " & $i + 1 & ": (" & $pixel[0] & "," & $pixel[1] & ")", $COLOR_DEBUG)
Next
SetLog("WEAK BASE C#.....................", $COLOR_DEBUG1)
Local $weakBaseValues
If IsWeakBaseActive($DB) Or IsWeakBaseActive($LB) Then
$weakBaseValues = IsWeakBase()
EndIf
For $i = 0 To $g_iModeCount - 2
If IsWeakBaseActive($i) Then
If getIsWeak($weakBaseValues, $i) Then
SetLog(StringUpper($g_asModeText[$i]) & " IS A WEAK BASE: TRUE", $COLOR_DEBUG)
Else
SetLog(StringUpper($g_asModeText[$i]) & " IS A WEAK BASE: FALSE", $COLOR_DEBUG)
EndIf
SetLog("Time taken: " & $weakBaseValues[5][0] & " " & $weakBaseValues[5][1], $COLOR_DEBUG)
EndIf
Next
Setlog("--------------------------------------------------------------", $COLOR_DEBUG1)
$g_iDebugBuildingPos = 0
$g_iDebugDeadBaseImage = 0
EndFunc
Func btnVillageStat($source = "")
If $g_iFirstRun = 0 And $g_bRunState = True And $g_bBotPaused = False Then SetTime(True)
If GUICtrlGetState($g_hLblResultGoldNow) = $GUI_ENABLE + $GUI_SHOW Then
GUICtrlSetState($g_hLblResultGoldNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hLblResultElixirNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hLblResultDENow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hLblResultTrophyNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hLblResultBuilderNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hLblResultGemNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hLblResultGoldHourNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hLblResultElixirHourNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hLblResultDEHourNow, $GUI_ENABLE + $GUI_SHOW)
If $g_iFirstRun = 0 or $source = "UpdateStats" Then
GUICtrlSetState($g_hLblResultRuntimeNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hLblResultAttackedHourNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hLblResultSkippedHourNow, $GUI_ENABLE + $GUI_SHOW)
EndIf
GUICtrlSetState($g_hPicResultTrophyNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hPicResultBuilderNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hPicResultGemNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hPicResultRuntimeNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hPicResultAttackedHourNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hPicResultSkippedHourNow, $GUI_ENABLE + $GUI_SHOW)
Else
GUICtrlSetState($g_hLblResultGoldNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hLblResultElixirNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hLblResultDENow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hLblResultTrophyNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hLblResultBuilderNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hLblResultGemNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hLblResultGoldHourNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hLblResultElixirHourNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hLblResultDEHourNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hLblResultRuntimeNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hLblResultAttackedHourNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hLblResultSkippedHourNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hPicResultTrophyNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hPicResultBuilderNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hPicResultGemNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($g_hPicResultRuntimeNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hPicResultAttackedHourNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($g_hPicResultSkippedHourNow, $GUI_ENABLE + $GUI_HIDE)
EndIf
EndFunc
Func btnTestDonate()
Local $wasRunState = $g_bRunState
$g_bRunState = True
SETLOG("DONATE TEST..................START")
ZoomOut()
saveconfig()
readconfig()
applyconfig()
DonateCC()
SETLOG("DONATE TEST..................STOP")
$g_bRunState = $wasRunState
EndFunc
Func btnTestButtons()
Local $wasRunState = $g_bRunState
$g_bRunState = True
Local $ButtonX, $ButtonY
Local $hTimer = TimerInit()
Local $res
Local $ImagesToUse[3]
$ImagesToUse[0] = @ScriptDir & "\imgxml\rearm\Traps_0_90.xml"
$ImagesToUse[1] = @ScriptDir & "\imgxml\rearm\Xbow_0_90.xml"
$ImagesToUse[2] = @ScriptDir & "\imgxml\rearm\Inferno_0_90.xml"
Local $x = 1
Local $y = 1
Local $w = 615
Local $h = 105
$ToleranceImgLoc = 0.950
SETLOG("SearchTile TEST..................START")
Local $SearchArea = String($x & "|" & $y & "|" & $w & "|" & $h)
Local $AreaInRectangle = String($x + 1 & "," & $y + 1 & "|" & $w - 1 & "," & $y + 1 & "|" & $w - 1 & "," & $h - 1 & "|" & $x + 1 & "," & $h - 1)
_CaptureRegion(125, 610, 740, 715)
For $i = 0 To 2
If FileExists($ImagesToUse[$i]) Then
$res = DllCall($g_sLibImgLocPath, "str", "FindTile", "handle", $hHBitmap2, "str", $ImagesToUse[$i], "str", $SearchArea, "str", $AreaInRectangle)
If @error Then _logErrorDLLCall($g_sLibImgLocPath, @error)
If IsArray($res) Then
If $g_iDebugSetlog = 1 Then SetLog("DLL Call succeeded " & $res[0], $COLOR_ERROR)
If $res[0] = "0" Then
SetLog("No Button found")
ElseIf $res[0] = "-1" Then
SetLog("DLL Error", $COLOR_ERROR)
ElseIf $res[0] = "-2" Then
SetLog("Invalid Resolution", $COLOR_ERROR)
Else
Local $expRet = StringSplit($res[0], "|", 2)
$ButtonX = 125 + Int($expRet[1])
$ButtonY = 610 + Int($expRet[2])
SetLog("found (" & $ButtonX & "," & $ButtonY & ")", $COLOR_SUCCESS)
_Sleep(200)
_Sleep(200)
If isGemOpen(True) = True Then
Setlog("Not enough loot to rearm traps.....", $COLOR_ERROR)
Click(585, 252, 1, 0, "#0227")
_Sleep(200)
Else
If $i = 0 Then SetLog("Rearmed Trap(s)", $COLOR_SUCCESS)
If $i = 1 Then SetLog("Reloaded XBow(s)", $COLOR_SUCCESS)
If $i = 2 Then SetLog("Reloaded Inferno(s)", $COLOR_SUCCESS)
_Sleep(200)
EndIf
EndIf
EndIf
EndIf
Next
SetLog("  - Calculated  in: " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds ", $COLOR_DEBUG1)
SETLOG("SearchTile TEST..................STOP")
Local $hTimer = TimerInit()
SETLOG("MBRSearchImage TEST..................STOP")
For $i = 0 To 2
If FileExists($ImagesToUse[$i]) Then
_CaptureRegion2(125, 610, 740, 715)
$res = DllCall($g_hLibImgLoc, "str", "FindTile", "handle", $hHBitmap2, "str", $ImagesToUse[$i], "str", "FV", "int", 1)
If @error Then _logErrorDLLCall($g_sLibImgLocPath, @error)
If IsArray($res) Then
If $g_iDebugSetlog = 1 Then SetLog("DLL Call succeeded " & $res[0], $COLOR_ERROR)
If $res[0] = "0" Then
SetLog("No Button found")
ElseIf $res[0] = "-1" Then
SetLog("DLL Error", $COLOR_ERROR)
ElseIf $res[0] = "-2" Then
SetLog("Invalid Resolution", $COLOR_ERROR)
Else
$expRet = StringSplit($res[0], "|", 2)
$ButtonX = 125 + Int($expRet[1])
$ButtonY = 610 + Int($expRet[2])
SetLog("found (" & $ButtonX & "," & $ButtonY & ")", $COLOR_SUCCESS)
_Sleep(200)
_Sleep(200)
If isGemOpen(True) = True Then
Setlog("Not enough loot to rearm traps.....", $COLOR_ERROR)
Click(585, 252, 1, 0, "#0227")
_Sleep(200)
Else
If $i = 0 Then SetLog("Rearmed Trap(s)", $COLOR_SUCCESS)
If $i = 1 Then SetLog("Reloaded XBow(s)", $COLOR_SUCCESS)
If $i = 2 Then SetLog("Reloaded Inferno(s)", $COLOR_SUCCESS)
_Sleep(200)
EndIf
EndIf
EndIf
EndIf
Next
SetLog("  - Calculated  in: " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds ", $COLOR_DEBUG1)
SETLOG("MBRSearchImage TEST..................STOP")
$g_bRunState = $wasRunState
EndFunc
Func ButtonBoost()
Local $wasRunState = $g_bRunState
$g_bRunState = True
Local $ButtonX, $ButtonY
Local $hTimer = TimerInit()
Local $res
Local $ImagesToUse[2]
$ImagesToUse[0] = @ScriptDir & "\imgxml\boostbarracks\BoostBarrack_0_92.xml"
$ImagesToUse[1] = @ScriptDir & "\imgxml\boostbarracks\BarrackBoosted_0_92.xml"
$ToleranceImgLoc = 0.90
SETLOG("MBRSearchImage TEST..................STARTED")
_CaptureRegion2(125, 610, 740, 715)
For $i = 0 To 1
If FileExists($ImagesToUse[$i]) Then
$res = DllCall($g_hLibImgLoc, "str", "FindTile", "handle", $hHBitmap2, "str", $ImagesToUse[$i], "str", "FV", "int", 1)
If @error Then _logErrorDLLCall($g_sLibImgLocPath, @error)
If IsArray($res) Then
If $g_iDebugSetlog = 1 Then SetLog("DLL Call succeeded " & $res[0], $COLOR_ERROR)
If $res[0] = "0" Then
If $i = 1 Then SetLog("No Button found")
ElseIf $res[0] = "-1" Then
SetLog("DLL Error", $COLOR_ERROR)
ElseIf $res[0] = "-2" Then
SetLog("Invalid Resolution", $COLOR_ERROR)
Else
_Sleep(200)
If $i = 0 Then
SetLog("Found the Button to Boost individual")
Local $expRet = StringSplit($res[0], "|", 2)
$ButtonX = 125 + Int($expRet[1])
$ButtonY = 610 + Int($expRet[2])
SetLog("found (" & $ButtonX & "," & $ButtonY & ")", $COLOR_SUCCESS)
ExitLoop
Else
SetLog("The Barrack is already boosted!")
EndIf
EndIf
EndIf
EndIf
Next
SetLog("  - Calculated  in: " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds ", $COLOR_DEBUG1)
SETLOG("MBRSearchImage TEST..................STOP")
$g_bRunState = $wasRunState
EndFunc
Func arrows()
getArmyHeroCount()
EndFunc
Func EnableGuiControls($OptimizedRedraw = True)
Return ToggleGuiControls(True, $OptimizedRedraw)
EndFunc
Func DisableGuiControls($OptimizedRedraw = True)
Return ToggleGuiControls(False, $OptimizedRedraw)
EndFunc
Func ToggleGuiControls($Enable, $OptimizedRedraw = True)
If $OptimizedRedraw = True Then Local $bWasRedraw = SetRedrawBotWindow(False, Default, Default, Default, "ToggleGuiControls")
If $Enable = False Then
SetDebugLog("Disable GUI Controls")
Else
SetDebugLog("Enable GUI Controls")
EndIf
$GUIControl_Disabled = True
For $i = $g_hFirstControlToHide To $g_hLastControlToHide
If IsAlwaysEnabledControl($i) Then ContinueLoop
If $g_bNotifyPBEnable And $i = $g_hBtnNotifyDeleteMessages Then ContinueLoop
If $Enable = False Then
$g_aiControlPrevState[$i] = BitAND(GUICtrlGetState($i), $GUI_ENABLE)
If $g_aiControlPrevState[$i] Then GUICtrlSetState($i, $GUI_DISABLE)
Else
If $g_aiControlPrevState[$i] Then GUICtrlSetState($i, $g_aiControlPrevState[$i])
EndIf
Next
If $Enable = False Then
ControlDisable("","",$g_hCmbGUILanguage)
Else
ControlEnable("","",$g_hCmbGUILanguage)
EndIf
$GUIControl_Disabled = False
If $OptimizedRedraw = True Then SetRedrawBotWindow($bWasRedraw, Default, Default, Default, "ToggleGuiControls")
EndFunc
Func btnReport()
Run(@ScriptDir & "\Bug Reporter.exe","")
EndFunc
Func btnAtkLogClear()
_GUICtrlRichEdit_SetText($g_hTxtAtkLog, "")
AtkLogHead()
EndFunc
Func btnAtkLogCopyClipboard()
Local $text = _GUICtrlRichEdit_GetText($g_hTxtAtkLog)
$text = StringReplace($text, @CR, @CRLF)
ClipPut($text)
EndFunc
Func cmbLog()
Local $x = 0, $y = 0, $w = $_GUI_MAIN_WIDTH - 20, $h = $_GUI_MAIN_HEIGHT - 490 + Int($frmBotAddH / 2)
If($g_iLogDividerY > $h + Int($h / 2) + $y And $g_iLogDividerY < $h * 2 + $g_iLogDividerHeight + $y) Or $g_iLogDividerY > $h * 2 + $g_iLogDividerHeight + $y Then $g_iLogDividerY = $h + Int($h / 2) + $y
If($g_iLogDividerY < Int($h / 2) + $y And $g_iLogDividerY > 0) Or $g_iLogDividerY < 0 Then $g_iLogDividerY = Int($h / 2)
_SendMessage($g_hTxtLog, $WM_SETREDRAW, False, 0)
_WINAPI_EnableWindow($g_hTxtLog, False)
_SendMessage($g_hTxtAtkLog, $WM_SETREDRAW, False, 0)
_WINAPI_EnableWindow($g_hTxtAtkLog, False)
Switch _GUICtrlComboBox_GetCurSel($g_hCmbLogDividerOption)
Case 0
ControlShow($g_hGUI_LOG, "", $g_hDivider)
ControlMove($g_hGUI_LOG, "", $g_hDivider, $x, $g_iLogDividerY - $y, $w, $g_iLogDividerHeight)
ControlShow($g_hGUI_LOG, "", $g_hTxtLog)
ControlMove($g_hGUI_LOG, "", $g_hTxtLog, $x, $y, $w, $g_iLogDividerY - $y)
ControlShow($g_hGUI_LOG, "", $g_hTxtAtkLog)
ControlMove($g_hGUI_LOG, "", $g_hTxtAtkLog, $x, $g_iLogDividerY + $g_iLogDividerHeight, $w,($h * 2) -($g_iLogDividerY - $y))
Case 1
ControlShow($g_hGUI_LOG, "", $g_hTxtLog)
ControlMove($g_hGUI_LOG, "", $g_hTxtLog, $x, $y, $w, $h)
$y += $h
ControlHide($g_hGUI_LOG, "", $g_hDivider)
$y += $g_iLogDividerHeight
ControlShow($g_hGUI_LOG, "", $g_hTxtAtkLog)
ControlMove($g_hGUI_LOG, "", $g_hTxtAtkLog, $x, $y, $w, $h)
Case 2
ControlShow($g_hGUI_LOG, "", $g_hTxtLog)
ControlMove($g_hGUI_LOG, "", $g_hTxtLog, $x, $y, $w, $h +($h / 2))
$y += $h +($h / 2) + $g_iLogDividerHeight
ControlHide($g_hGUI_LOG, "", $g_hDivider)
ControlShow($g_hGUI_LOG, "", $g_hTxtAtkLog)
ControlMove($g_hGUI_LOG, "", $g_hTxtAtkLog, $x, $y, $w, $h -($h / 2))
Case 3
ControlShow($g_hGUI_LOG, "", $g_hTxtLog)
ControlMove($g_hGUI_LOG, "", $g_hTxtLog, $x, $y, $w, $h -($h / 2))
$y +=($h / 2) + $g_iLogDividerHeight
ControlHide($g_hGUI_LOG, "", $g_hDivider)
ControlShow($g_hGUI_LOG, "", $g_hTxtAtkLog)
ControlMove($g_hGUI_LOG, "", $g_hTxtAtkLog, $x, $y, $w, $h +($h / 2))
Case 4
ControlShow($g_hGUI_LOG, "", $g_hTxtLog)
ControlMove($g_hGUI_LOG, "", $g_hTxtLog, $x, $y, $w, $h * 2 + $g_iLogDividerHeight)
ControlHide($g_hGUI_LOG, "", $g_hTxtAtkLog)
ControlMove($g_hGUI_LOG, "", $g_hTxtAtkLog, $x, $y + $h * 2 + $g_iLogDividerHeight, $w, 0)
ControlHide($g_hGUI_LOG, "", $g_hDivider)
Case 5
ControlHide($g_hGUI_LOG, "", $g_hTxtLog)
ControlMove($g_hGUI_LOG, "", $g_hTxtLog, $x, $y, $w, 0)
ControlShow($g_hGUI_LOG, "", $g_hTxtAtkLog)
ControlMove($g_hGUI_LOG, "", $g_hTxtAtkLog, $x, $y, $w, $h * 2 + $g_iLogDividerHeight)
ControlHide($g_hGUI_LOG, "", $g_hDivider)
EndSwitch
_SendMessage($g_hTxtLog, $WM_SETREDRAW, True, 0)
_WINAPI_EnableWindow($g_hTxtLog, True)
_SendMessage($g_hTxtAtkLog, $WM_SETREDRAW, True, 0)
_WINAPI_EnableWindow($g_hTxtAtkLog, True)
CheckRedrawControls(True, "cmbLog")
EndFunc
Func MoveDivider()
Local $PPos = ControlGetPos($g_hFrmBot, "", $g_hGUI_LOG)
Local $TPos = ControlGetPos($g_hGUI_LOG, "", $g_hTxtLog)
Local $BPos = ControlGetPos($g_hGUI_LOG, "", $g_hTxtAtkLog)
Local $logAndDividerX = $TPos[0] - $PPos[0]
Local $logAndDividerWidth = $TPos[2]
Local $totalLogsHeight = $TPos[3] + $BPos[3]
Local $minVisibleHeight = Ceiling($totalLogsHeight / 4)
Local $snapToMinMax = Ceiling($minVisibleHeight / 3)
Local $halfDividerTopHeight = Ceiling($g_iLogDividerHeight / 2)
Local $halfDividerBottomHeight = Floor($g_iLogDividerHeight / 2)
Local $startLogsY = $TPos[1] - $_GUI_CHILD_TOP
Local $endLogsY = $BPos[1] - $_GUI_CHILD_TOP + $BPos[3]
Do
Local $pos = GUIGetCursorInfo($g_hGUI_LOG)
Local $clickY = $pos[1]
If $clickY - $halfDividerTopHeight <= $startLogsY + $snapToMinMax Then
$clickY = $startLogsY + $halfDividerTopHeight
ElseIf $clickY + $halfDividerBottomHeight >= $endLogsY - $snapToMinMax Then
$clickY = $endLogsY - $halfDividerBottomHeight
ElseIf $clickY - $halfDividerTopHeight > $startLogsY + $snapToMinMax And $clickY - $halfDividerTopHeight <= $startLogsY + $minVisibleHeight Then
$clickY = $startLogsY + $minVisibleHeight + $halfDividerTopHeight
ElseIf $clickY + $halfDividerBottomHeight < $endLogsY - $snapToMinMax And $clickY + $halfDividerBottomHeight >= $endLogsY - $minVisibleHeight Then
$clickY = $endLogsY - $minVisibleHeight - $halfDividerBottomHeight
EndIf
$g_iLogDividerY = $clickY - $halfDividerTopHeight
ControlMove($g_hGUI_LOG, "", $g_hDivider, $logAndDividerX, $g_iLogDividerY, $logAndDividerWidth, $g_iLogDividerHeight)
ControlMove($g_hGUI_LOG, "", $g_hTxtLog, $logAndDividerX, $startLogsY, $logAndDividerWidth, $clickY - $startLogsY - $halfDividerTopHeight)
If $endLogsY -($clickY + $halfDividerBottomHeight) < 0 Then
ControlMove($g_hGUI_LOG, "", $g_hTxtAtkLog, $logAndDividerX, $endLogsY, $logAndDividerWidth, 0)
Else
ControlMove($g_hGUI_LOG, "", $g_hTxtAtkLog, $logAndDividerX, $clickY + $halfDividerBottomHeight, $logAndDividerWidth, $endLogsY - $clickY - $halfDividerBottomHeight)
EndIf
_WinAPI_UpdateWindow(WinGetHandle($g_hGUI_LOG))
Until $pos[2] = 0
_GUICtrlRichEdit_SetSel($g_hTxtLog, - 1, -1)
_GUICtrlRichEdit_SetSel($g_hTxtAtkLog, - 1, -1)
SetDebugLog("MoveDivider exit", Default, True)
EndFunc
Func XPStyleToggle($Off = 1)
Local $XS_n
If Not StringInStr(@OSType, "WIN32_NT") Then Return 0
If $Off Then
$XS_n = DllCall("uxtheme.dll", "int", "GetThemeAppProperties")
DllCall("uxtheme.dll", "none", "SetThemeAppProperties", "int", 0)
Return 1
ElseIf IsArray($XS_n) Then
DllCall("uxtheme.dll", "none", "SetThemeAppProperties", "int", $XS_n[0])
$XS_n = ""
Return 1
EndIf
Return 0
EndFunc
Func chkUseQTrain()
If GUICtrlRead($g_hChkUseQuickTrain) = $GUI_CHECKED Then
_GUI_Value_STATE("ENABLE", $g_hRdoArmy1 & "#" & $g_hRdoArmy2 & "#" & $g_hRdoArmy3)
_GUI_Value_STATE("DISABLE", $grpTrainTroops)
_GUI_Value_STATE("DISABLE", $grpCookSpell)
GUICtrlSetData($g_hLblTotalTimeCamp, " 0s")
GUICtrlSetData($g_hLblTotalTimeSpell, " 0s")
GUICtrlSetData($g_hLblElixirCostCamp, "0")
GUICtrlSetData($g_hLblDarkCostCamp, "0")
GUICtrlSetData($g_hLblElixirCostSpell, "0")
GUICtrlSetData($g_hLblDarkCostSpell, "0")
Else
_GUI_Value_STATE("DISABLE", $g_hRdoArmy1 & "#" & $g_hRdoArmy2 & "#" & $g_hRdoArmy3)
_GUI_Value_STATE("ENABLE", $grpTrainTroops)
_GUI_Value_STATE("ENABLE", $grpCookSpell)
lblTotalCountTroop1()
TotalSpellCountClick()
EndIf
EndFunc
Func SetComboTroopComp()
Local $bWasRedraw = SetRedrawBotWindow(False, Default, Default, Default, "SetComboTroopComp")
Local $ArmyCampTemp = 0
If GUICtrlRead($g_hChkTotalCampForced) = $GUI_CHECKED Then
$ArmyCampTemp = Floor(GUICtrlRead($g_hTxtTotalCampForced) * GUICtrlRead($g_hTxtFullTroop) / 100)
Else
$ArmyCampTemp = Floor($TotalCamp * GUICtrlRead($g_hTxtFullTroop) / 100)
EndIf
lblTotalCountTroop1()
SetRedrawBotWindow($bWasRedraw, Default, Default, Default, "SetComboTroopComp")
EndFunc
Func chkTotalCampForced()
GUICtrlSetState($g_hTxtTotalCampForced, GUICtrlRead($g_hChkTotalCampForced) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func lblTotalCountTroop1()
Local $TotalTroopsToTrain = 0
Local $ArmyCampTemp = 0
If GUICtrlRead($g_hChkTotalCampForced) = $GUI_CHECKED Then
$ArmyCampTemp = Floor(GUICtrlRead($g_hTxtTotalCampForced) * GUICtrlRead($g_hTxtFullTroop) / 100)
Else
$ArmyCampTemp = Floor($TotalCamp * GUICtrlRead($g_hTxtFullTroop) / 100)
EndIf
For $i = 0 To $eTroopCount - 1
Local $iCount = GUICtrlRead($g_ahTxtTrainArmyTroopCount[$i])
If $iCount > 0 Then
$TotalTroopsToTrain += $iCount * $g_aiTroopSpace[$i]
Else
GUICtrlSetData($g_ahTxtTrainArmyTroopCount[$i], 0)
EndIf
Next
GUICtrlSetData($g_hLblCountTotal, String($TotalTroopsToTrain))
If GUICtrlRead($g_hChkTotalCampForced) = $GUI_CHECKED And GUICtrlRead($g_hLblCountTotal) = GUICtrlRead($g_hTxtTotalCampForced) Then
GUICtrlSetBkColor($g_hLblCountTotal, $COLOR_MONEYGREEN)
ElseIf GUICtrlRead($g_hLblCountTotal) = $ArmyCampTemp Then
GUICtrlSetBkColor($g_hLblCountTotal, $COLOR_MONEYGREEN)
ElseIf GUICtrlRead($g_hLblCountTotal) > $ArmyCampTemp / 2 And GUICtrlRead($g_hLblCountTotal) < $ArmyCampTemp Then
GUICtrlSetBkColor($g_hLblCountTotal, $COLOR_ORANGE)
Else
GUICtrlSetBkColor($g_hLblCountTotal, $COLOR_RED)
EndIf
Local $fPctOfForced = Floor((GUICtrlRead($g_hLblCountTotal) / GUICtrlRead($g_hTxtTotalCampForced)) * 100)
Local $fPctOfCalculated = Floor((GUICtrlRead($g_hLblCountTotal) / $ArmyCampTemp) * 100)
If GUICtrlRead($g_hChkTotalCampForced) = $GUI_CHECKED Then
GUICtrlSetData($g_hCalTotalTroops, $fPctOfForced < 1 ?(GUICtrlRead($g_hLblCountTotal) > 0 ? 1 : 0) : $fPctOfForced)
Else
GUICtrlSetData($g_hCalTotalTroops, $fPctOfCalculated < 1 ?(GUICtrlRead($g_hLblCountTotal) > 0 ? 1 : 0) : $fPctOfCalculated)
EndIf
If GUICtrlRead($g_hChkTotalCampForced) = $GUI_CHECKED And GUICtrlRead($g_hLblCountTotal) > GUICtrlRead($g_hTxtTotalCampForced) Then
GUICtrlSetState($g_hLblTotalProgress, $GUI_SHOW)
ElseIf GUICtrlRead($g_hLblCountTotal) > $ArmyCampTemp Then
GUICtrlSetState($g_hLblTotalProgress, $GUI_SHOW)
Else
GUICtrlSetState($g_hLblTotalProgress, $GUI_HIDE)
EndIf
lblTotalCountTroop2()
EndFunc
Func lblTotalCountTroop2()
Local $TotalTotalTimeTroop = 0
Local $NbrOfBarrack = 4
Local $NbrOfDarkBarrack = 2
For $i = $eTroopBarbarian To $eTroopMiner
Local $NbrOfTroop = GUICtrlRead($g_ahTxtTrainArmyTroopCount[$i])
Local $LevOfTroop = $g_aiTrainArmyTroopLevel[$i]
If $NbrOfTroop > 0 And $LevOfTroop > 0 Then
If IsInt($NbrOfTroop / $NbrOfBarrack) = 1 then
$TotalTotalTimeTroop +=($NbrOfTroop / $NbrOfBarrack) * $g_aiTroopTrainTime[$i]
Else
$TotalTotalTimeTroop +=(Ceiling($NbrOfTroop / $NbrOfBarrack)) * $g_aiTroopTrainTime[$i]
$TotalTotalTimeTroop +=((Ceiling($NbrOfTroop / $NbrOfBarrack) - 1) -(Floor($NbrOfTroop / $NbrOfBarrack))) * $g_aiTroopTrainTime[$i]
EndIf
EndIf
Next
For $i = $eTroopMinion To $eTroopBowler
Local $NbrOfTroop = GUICtrlRead($g_ahTxtTrainArmyTroopCount[$i])
Local $LevOfTroop = $g_aiTrainArmyTroopLevel[$i]
If $NbrOfTroop > 0 And $LevOfTroop > 0 Then
If IsInt($NbrOfTroop / $NbrOfDarkBarrack) = 1 then
$TotalTotalTimeTroop +=($NbrOfTroop / $NbrOfDarkBarrack) * $g_aiTroopTrainTime[$i]
Else
$TotalTotalTimeTroop +=(Ceiling($NbrOfTroop / $NbrOfDarkBarrack)) * $g_aiTroopTrainTime[$i]
$TotalTotalTimeTroop +=((Ceiling($NbrOfTroop / $NbrOfDarkBarrack) - 1) -(Floor($NbrOfTroop / $NbrOfDarkBarrack))) * $g_aiTroopTrainTime[$i]
EndIf
EndIf
Next
$TotalTotalTimeTroop = CalculTimeTo($TotalTotalTimeTroop)
GUICtrlSetData($g_hLblTotalTimeCamp, $TotalTotalTimeTroop)
CalCostCamp()
EndFunc
Func lblTotalCountSpell2()
Local $iTotalTotalTimeSpell = 0
$iTotalTrainSpaceSpell = 0
For $i = 0 To $eSpellCount-1
$iTotalTrainSpaceSpell += $g_aiArmyCompSpells[$i] * $g_aiSpellSpace[$i]
$iTotalTotalTimeSpell += $g_aiArmyCompSpells[$i] * $g_aiSpellTrainTime[$i]
Next
For $i = 0 To $eSpellCount - 1
GUICtrlSetBkColor($g_ahTxtTrainArmySpellCount[$i], $iTotalTrainSpaceSpell <= GUICtrlRead($g_hTxtTotalCountSpell) ? $COLOR_WHITE : $COLOR_RED)
Next
GUICtrlSetData($g_hLblTotalTimeSpell, CalculTimeTo($iTotalTotalTimeSpell))
CalCostSpell()
EndFunc
Func TotalSpellCountClick()
Local $bWasRedraw = SetRedrawBotWindow(False, Default, Default, Default, "TotalSpellCountClick")
_GUI_Value_STATE("HIDE", $groupListSpells)
$iTownHallLevel = Int($iTownHallLevel)
If $iTownHallLevel > 4 Or $iTownHallLevel = 0 Then
_GUI_Value_STATE("SHOW", $g_aiTrainArmySpellLevel[$eSpellLightning] > 0 ? $groupLightning : $groupIcnLightning)
Else
For $i = 0 To $eSpellCount - 1
GUICtrlSetData($g_ahTxtTrainArmySpellCount[$i], 0)
GUICtrlSetData($g_ahLblTrainArmySpellLevel[$i], 0)
Next
GUICtrlSetData($g_hTxtTotalCountSpell, 0)
EndIf
If $iTownHallLevel > 5 Or $iTownHallLevel = 0 Then
_GUI_Value_STATE("SHOW", $g_aiTrainArmySpellLevel[$eSpellHeal] > 0 ? $groupHeal : $groupIcnHeal)
Else
For $i = $eSpellRage To $eSpellSkeleton
GUICtrlSetData($g_ahTxtTrainArmySpellCount[$i], 0)
GUICtrlSetData($g_ahLblTrainArmySpellLevel[$i], 0)
Next
EndIf
If $iTownHallLevel > 6 Or $iTownHallLevel = 0 Then
_GUI_Value_STATE("SHOW", $g_aiTrainArmySpellLevel[$eSpellRage] > 0 ? $groupRage : $groupIcnRage)
Else
For $i = $eSpellJump To $eSpellSkeleton
GUICtrlSetData($g_ahTxtTrainArmySpellCount[$i], 0)
GUICtrlSetData($g_ahLblTrainArmySpellLevel[$i], 0)
Next
EndIf
If $iTownHallLevel > 7 Or $iTownHallLevel = 0 Then
_GUI_Value_STATE("SHOW", $g_aiTrainArmySpellLevel[$eSpellPoison] > 0 ? $groupPoison : $groupIcnPoison)
_GUI_Value_STATE("SHOW", $g_aiTrainArmySpellLevel[$eSpellEarthquake] > 0 ? $groupEarthquake : $groupIcnEarthquake)
Else
GUICtrlSetData($g_ahTxtTrainArmySpellCount[$eSpellJump], 0)
GUICtrlSetData($g_ahTxtTrainArmySpellCount[$eSpellFreeze], 0)
GUICtrlSetData($g_ahTxtTrainArmySpellCount[$eSpellClone], 0)
GUICtrlSetData($g_ahTxtTrainArmySpellCount[$eSpellHaste], 0)
GUICtrlSetData($g_ahTxtTrainArmySpellCount[$eSpellSkeleton], 0)
GUICtrlSetData($g_ahLblTrainArmySpellLevel[$eSpellJump], 0)
GUICtrlSetData($g_ahLblTrainArmySpellLevel[$eSpellFreeze], 0)
GUICtrlSetData($g_ahLblTrainArmySpellLevel[$eSpellClone], 0)
GUICtrlSetData($g_ahLblTrainArmySpellLevel[$eSpellHaste], 0)
GUICtrlSetData($g_ahLblTrainArmySpellLevel[$eSpellSkeleton], 0)
EndIf
If $iTownHallLevel > 8 Or $iTownHallLevel = 0 Then
_GUI_Value_STATE("SHOW", $g_aiTrainArmySpellLevel[$eSpellJump] > 0 ? $groupJumpSpell : $groupIcnJumpSpell)
_GUI_Value_STATE("SHOW", $g_aiTrainArmySpellLevel[$eSpellFreeze] > 0 ? $groupFreeze : $groupIcnFreeze)
_GUI_Value_STATE("SHOW", $g_aiTrainArmySpellLevel[$eSpellHaste] > 0 ? $groupHaste : $groupIcnHaste)
_GUI_Value_STATE("SHOW", $g_aiTrainArmySpellLevel[$eSpellSkeleton] > 0 ? $groupSkeleton : $groupIcnSkeleton)
Else
GUICtrlSetData($g_ahTxtTrainArmySpellCount[$eSpellClone], 0)
GUICtrlSetData($g_ahLblTrainArmySpellLevel[$eSpellClone], 0)
EndIf
If $iTownHallLevel > 9 Or $iTownHallLevel = 0 Then
_GUI_Value_STATE("SHOW", $g_aiTrainArmySpellLevel[$eSpellClone] > 0 ? $groupClone : $groupIcnClone)
EndIf
lblTotalCountSpell2()
SetRedrawBotWindow($bWasRedraw, Default, Default, Default, "TotalSpellCountClick")
EndFunc
Func chkBoostBarracksHoursE1()
If GUICtrlRead($g_hChkBoostBarracksHoursE1) = $GUI_CHECKED And GUICtrlRead($g_hChkBoostBarracksHours[0]) = $GUI_CHECKED Then
For $i = 0 To 11
GUICtrlSetState($g_hChkBoostBarracksHours[$i], $GUI_UNCHECKED)
Next
Else
For $i = 0 To 11
GUICtrlSetState($g_hChkBoostBarracksHours[$i], $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($g_hChkBoostBarracksHoursE1, $GUI_UNCHECKED)
EndFunc
Func chkBoostBarracksHoursE2()
If GUICtrlRead($g_hChkBoostBarracksHoursE2) = $GUI_CHECKED And GUICtrlRead($g_hChkBoostBarracksHours[12]) = $GUI_CHECKED Then
For $i = 12 To 23
GUICtrlSetState($g_hChkBoostBarracksHours[$i], $GUI_UNCHECKED)
Next
Else
For $i = 12 To 23
GUICtrlSetState($g_hChkBoostBarracksHours[$i], $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($g_hChkBoostBarracksHoursE2, $GUI_UNCHECKED)
EndFunc
Func chkCloseWaitEnable()
If GUICtrlRead($g_hChkCloseWhileTraining) = $GUI_CHECKED Then
$g_bCloseWhileTrainingEnable = True
_GUI_Value_STATE("ENABLE", $groupCloseWhileTraining)
_GUI_Value_STATE("ENABLE", $g_hLblCloseWaitingTroops & "#" & $g_hCmbMinimumTimeClose & "#" & $g_hLblSymbolWaiting & "#" & $g_hLblWaitingInMinutes)
Else
$g_bCloseWhileTrainingEnable = False
_GUI_Value_STATE("DISABLE", $groupCloseWhileTraining)
_GUI_Value_STATE("DISABLE", $g_hLblCloseWaitingTroops & "#" & $g_hCmbMinimumTimeClose & "#" & $g_hLblSymbolWaiting & "#" & $g_hLblWaitingInMinutes)
EndIf
If GUICtrlRead($g_hChkRandomClose) = $GUI_CHECKED Then
GUICtrlSetState($g_hChkCloseEmulator, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
Else
If GUICtrlRead($g_hChkCloseWhileTraining) = $GUI_CHECKED Then GUICtrlSetState($g_hChkCloseEmulator, $GUI_ENABLE)
EndIf
EndFunc
Func chkCloseWaitTrain()
$g_bCloseWithoutShield =(GUICtrlRead($g_hChkCloseWithoutShield) = $GUI_CHECKED)
EndFunc
Func btnCloseWaitStop()
$g_bCloseEmulator =(GUICtrlRead($g_hChkCloseEmulator) = $GUI_CHECKED)
EndFunc
Func btnCloseWaitStopRandom()
If GUICtrlRead($g_hChkRandomClose) = $GUI_CHECKED Then
$g_bCloseRandom = True
$g_bCloseEmulator = False
GUICtrlSetState($g_hChkCloseEmulator, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
Else
$g_bCloseRandom = False
If GUICtrlRead($g_hChkCloseWhileTraining) = $GUI_CHECKED Then GUICtrlSetState($g_hChkCloseEmulator, $GUI_ENABLE)
EndIf
EndFunc
Func btnCloseWaitRandom()
If GUICtrlRead($g_hRdoCloseWaitExact) = $GUI_CHECKED Then
$g_bCloseExactTime = True
$g_bCloseRandomTime = False
GUICtrlSetState($g_hCmbCloseWaitRdmPercent, $GUI_DISABLE)
ElseIf GUICtrlRead($g_hRdoCloseWaitRandom) = $GUI_CHECKED Then
$g_bCloseExactTime = False
$g_bCloseRandomTime = True
If GUICtrlRead($g_hChkCloseWhileTraining) = $GUI_CHECKED Then GUICtrlSetState($g_hCmbCloseWaitRdmPercent, $GUI_ENABLE)
Else
$g_bCloseExactTime = False
$g_bCloseRandomTime = False
GUICtrlSetState($g_hCmbCloseWaitRdmPercent, $GUI_DISABLE)
EndIf
EndFunc
Func sldTrainITDelay()
$g_iTrainClickDelay = GUICtrlRead($g_hSldTrainITDelay)
GUICtrlSetData($g_hLblTrainITDelayTime, $g_iTrainClickDelay & " ms")
EndFunc
Func chkTroopOrder2()
chkTroopOrder()
EndFunc
Func chkTroopOrder($bNoiseMode = True)
If GUICtrlRead($g_hChkCustomTrainOrderEnable) = $GUI_CHECKED Then
$g_bCustomTrainOrderEnable = True
GUICtrlSetState($g_hBtnTroopOrderSet, $GUI_ENABLE)
For $i = 0 To UBound($g_ahCmbTroopOrder) - 1
GUICtrlSetState($g_ahCmbTroopOrder[$i], $GUI_ENABLE)
Next
If IsUseCustomTroopOrder() = True Then GUICtrlSetImage($g_ahImgTroopOrderSet, $g_sLibIconPath, $eIcnRedLight)
Else
$g_bCustomTrainOrderEnable = False
GUICtrlSetState($g_hBtnTroopOrderSet, $GUI_DISABLE)
For $i = 0 To UBound($g_ahCmbTroopOrder) - 1
GUICtrlSetState($g_ahCmbTroopOrder[$i], $GUI_DISABLE)
Next
SetDefaultTroopGroup($bNoiseMode)
If $bNoiseMode Or $g_iDebugSetlogTrain = 1 Then
Local $sNewTrainList = ""
For $i = 0 To $eTroopCount - 1
$sNewTrainList &= $g_asTroopShortNames[$g_aiTrainOrder[$i]] & ", "
Next
$sNewTrainList = StringTrimRight($sNewTrainList, 2)
Setlog("Current train order= " & $sNewTrainList, $COLOR_BLUE)
EndIf
EndIf
EndFunc
Func GUITrainOrder()
Local $bDuplicate = False
Local $iGUI_CtrlId = @GUI_CtrlId
Local $iCtrlIdImage = $iGUI_CtrlId + 1
Local $iTroopIndex = _GUICtrlComboBox_GetCurSel($iGUI_CtrlId) + 1
GUICtrlSetImage($iCtrlIdImage, $g_sLibIconPath, $g_aiTroopOrderIcon[$iTroopIndex])
For $i = 0 To UBound($g_ahCmbTroopOrder) - 1
If $iGUI_CtrlId = $g_ahCmbTroopOrder[$i] Then ContinueLoop
If _GUICtrlComboBox_GetCurSel($iGUI_CtrlId) = _GUICtrlComboBox_GetCurSel($g_ahCmbTroopOrder[$i]) Then
GUICtrlSetImage($g_ahImgTroopOrder[$i], $g_sLibIconPath, $eIcnOptions)
_GUICtrlComboBox_SetCurSel($g_ahCmbTroopOrder[$i], -1)
GUISetState()
$bDuplicate = True
EndIf
Next
If $bDuplicate = True Then
GUICtrlSetState($g_hBtnTroopOrderSet, $GUI_DISABLE)
Return
Else
GUICtrlSetState($g_hBtnTroopOrderSet, $GUI_ENABLE)
GUICtrlSetImage($g_ahImgTroopOrderSet, $g_sLibIconPath, $eIcnRedLight)
EndIf
EndFunc
Func BtnTroopOrderSet()
Local $bWasRedraw = SetRedrawBotWindow(False, Default, Default, Default, "BtnTroopOrderSet")
Local $bReady = True
Local $sNewTrainList = ""
For $i = 0 To UBound($g_ahCmbTroopOrder) - 1
For $j = 0 To UBound($g_ahCmbTroopOrder) - 1
If $i = $j Then ContinueLoop
If _GUICtrlComboBox_GetCurSel($g_ahCmbTroopOrder[$i]) = _GUICtrlComboBox_GetCurSel($g_ahCmbTroopOrder[$j]) Then
_GUICtrlComboBox_SetCurSel($g_ahCmbTroopOrder[$j], -1)
GUICtrlSetImage($g_ahImgTroopOrder[$j], $g_sLibIconPath, $eIcnOptions)
$bReady = False
Else
GUICtrlSetColor($g_ahCmbTroopOrder[$j], $COLOR_BLACK)
EndIf
Next
$g_aiCmbCustomTrainOrder[$i] = _GUICtrlComboBox_GetCurSel($g_ahCmbTroopOrder[$i])
Next
If $bReady Then
ChangeTroopTrainOrder()
If @error Then
Switch @error
Case 1
Setlog("Code problem, can not continue till fixed!", $COLOR_RED)
Case 2
Setlog("Bad Combobox selections, please fix!", $COLOR_RED)
Case 3
Setlog("Unable to Change Troop Train Order due bad change count!", $COLOR_RED)
Case Else
Setlog("Monkey ate bad banana, something wrong with ChangeTroopTrainOrder() code!", $COLOR_RED)
EndSwitch
GUICtrlSetImage($g_ahImgTroopOrderSet, $g_sLibIconPath, $eIcnRedLight)
Else
Setlog("Troop training order changed successfully!", $COLOR_GREEN)
For $i = 0 To $eTroopCount - 1
$sNewTrainList &= $g_asTroopShortNames[$g_aiTrainOrder[$i]] & ", "
Next
$sNewTrainList = StringTrimRight($sNewTrainList, 2)
Setlog("Troop train order= " & $sNewTrainList, $COLOR_BLUE)
EndIf
Else
Setlog("Must use all troops and No duplicate troop names!", $COLOR_RED)
GUICtrlSetImage($g_ahImgTroopOrderSet, $g_sLibIconPath, $eIcnRedLight)
EndIf
GUICtrlSetState(BtnTroopOrderSet, $GUI_DISABLE)
SetRedrawBotWindow($bWasRedraw, Default, Default, Default, "BtnTroopOrderSet")
EndFunc
Func ChangeTroopTrainOrder()
If $g_iDebugSetlog = 1 Or $g_iDebugSetlogTrain = 1 Then Setlog("Begin Func ChangeTroopTrainOrder()", $COLOR_DEBUG)
Local $NewTroopOrder[$eTroopCount]
Local $iUpdateCount = 0
If IsUseCustomTroopOrder() = False Then
SetError(2, 0, False)
Return
EndIf
For $i = 0 To UBound($g_ahCmbTroopOrder) - 1
Local $sComboText = GUICtrlRead($g_ahCmbTroopOrder[$i])
For $j = 0 To UBound($g_asTroopOrderList) - 1
If $sComboText = $g_asTroopOrderList[$j] Then
$NewTroopOrder[$i] = $j - 1
$iUpdateCount += 1
ExitLoop
EndIf
Next
Next
If $iUpdateCount = $eTroopCount Then
For $i = 0 To $eTroopCount - 1
$g_aiTrainOrder[$i] = $NewTroopOrder[$i]
Next
GUICtrlSetImage($g_ahImgTroopOrderSet, $g_sLibIconPath, $eIcnGreenLight)
Else
Setlog($iUpdateCount & "|" & $eTroopCount & " - Error - Bad troop assignment in ChangeTroopTrainOrder()", $COLOR_RED)
SetError(3, 0, False)
Return
EndIf
Return True
EndFunc
Func SetDefaultTroopGroup($bNoiseMode = True)
For $i = 0 To $eTroopCount - 1
$g_aiTrainOrder[$i] = $i
Next
If $bNoiseMode Or $g_iDebugSetlogTrain = 1 Then Setlog("Default troop training order set", $COLOR_GREEN)
EndFunc
Func IsUseCustomTroopOrder()
For $i = 0 To UBound($g_aiCmbCustomTrainOrder) - 1
If $g_aiCmbCustomTrainOrder[$i] = -1 Then
If $g_iDebugSetlogTrain = 1 Then Setlog("Custom train order not used...", $COLOR_DEBUG)
Return False
EndIf
Next
If $g_iDebugSetlogTrain = 1 Then Setlog("Custom train order used...", $COLOR_DEBUG)
Return True
EndFunc
Func LevUpDownTroop($iTroopIndex, $NoChangeLev = True)
Local $MaxLev = $g_aiTroopCostPerLevel[$iTroopIndex][0]
Local $TempLev = 0
If $NoChangeLev Then
If _IsPressed("10") Or _IsPressed("02") Then
$TempLev = $g_aiTrainArmyTroopLevel[$iTroopIndex] - 1
Else
$TempLev = $g_aiTrainArmyTroopLevel[$iTroopIndex] + 1
EndIf
Else
$TempLev = $g_aiTrainArmyTroopLevel[$iTroopIndex]
EndIf
Local $hLevel = $g_ahLblTrainArmyTroopLevel[$iTroopIndex]
Local $hCount = $g_ahTxtTrainArmyTroopCount[$iTroopIndex]
If $TempLev > $MaxLev Or $TempLev = 0 Then
$TempLev = 0
GUICtrlSetData($hCount, 0)
$g_aiArmyCompTroops[$iTroopIndex] = 0
If IsGUICtrlHidden($hCount) = False Then GUICtrlSetState($hCount, $GUI_HIDE)
If $NoChangeLev Then lblTotalCountTroop1()
ElseIf $TempLev < 0 Then
$TempLev = $MaxLev
If IsGUICtrlHidden($hCount) Then GUICtrlSetState($hCount, $GUI_SHOW)
ElseIf $TempLev > 0 And $TempLev <= $MaxLev And IsGUICtrlHidden($hCount) Then
GUICtrlSetState($hCount, $GUI_SHOW)
EndIf
$g_aiTrainArmyTroopLevel[$iTroopIndex] = $TempLev
Local $iColor =($TempLev = $MaxLev ? $COLOR_YELLOW : $COLOR_WHITE)
GUICtrlSetData($hLevel, $TempLev)
If GUICtrlGetBkColor($hLevel) <> $iColor Then GUICtrlSetBkColor($hLevel, $iColor)
EndFunc
Func LevUpDownSpell($iSpellIndex, $NoChangeLev = True)
Local $MaxLev = $g_aiSpellCostPerLevel[$iSpellIndex][0]
Local $TempLev = 0
If $NoChangeLev Then
If _IsPressed("10") Or _IsPressed("02") Then
$TempLev = $g_aiTrainArmySpellLevel[$iSpellIndex] - 1
Else
$TempLev = $g_aiTrainArmySpellLevel[$iSpellIndex] + 1
EndIf
Else
$TempLev = $g_aiTrainArmySpellLevel[$iSpellIndex]
EndIf
Local $hLevel = $g_ahLblTrainArmySpellLevel[$iSpellIndex]
Local $hCount = $g_ahTxtTrainArmySpellCount[$iSpellIndex]
If $TempLev > $MaxLev Or $TempLev = 0 Then
$TempLev = 0
GUICtrlSetData($hCount, 0)
$g_aiArmyCompSpells[$iSpellIndex] = 0
If IsGUICtrlHidden($hCount) = False Then GUICtrlSetState($hCount, $GUI_HIDE)
If $NoChangeLev Then lblTotalCountSpell2()
ElseIf $TempLev < 0 Then
$TempLev = $MaxLev
If IsGUICtrlHidden($hCount) Then GUICtrlSetState($hCount, $GUI_SHOW)
ElseIf $TempLev > 0 And $TempLev <= $MaxLev And IsGUICtrlHidden($hCount) Then
GUICtrlSetState($hCount, $GUI_SHOW)
EndIf
$g_aiTrainArmySpellLevel[$iSpellIndex] = $TempLev
Local $iColor =($TempLev = $MaxLev ? $COLOR_YELLOW : $COLOR_WHITE)
GUICtrlSetData($hLevel, $TempLev)
If GUICtrlGetBkColor($hLevel) <> $iColor Then GUICtrlSetBkColor($hLevel, $iColor)
EndFunc
Func TrainTroopLevelClick()
If $g_bRunState = True Then Return
Local $iTroop = -1
For $i = 0 To $eTroopCount - 1
If @GUI_CtrlId = $g_ahPicTrainArmyTroop[$i] Then
$iTroop = $i
ExitLoop
EndIf
Next
If $iTroop = -1 Then Return
While _IsPressed(01)
LevUpDownTroop($iTroop)
Sleep($iDelayLvUP)
lblTotalCountTroop2()
WEnd
EndFunc
Func TrainSpellLevelClick()
If $g_bRunState = True Then Return
Local $iSpell = -1
For $i = 0 To $eSpellCount - 1
If @GUI_CtrlId = $g_ahPicTrainArmySpell[$i] Then
$iSpell = $i
ExitLoop
EndIf
Next
If $iSpell = -1 Then Return
While _IsPressed(01)
LevUpDownSpell($iSpell)
Sleep($iDelayLvUP)
lblTotalCountSpell2()
WEnd
EndFunc
Func CalCostCamp()
Local $iElixirCostCamp = 0, $iDarkCostCamp = 0
For $i = $eTroopBarbarian To $eTroopMiner
$iElixirCostCamp += $g_aiArmyCompTroops[$i] * $g_aiTroopCostPerLevel[$i][$g_aiTrainArmyTroopLevel[$i]]
Next
For $i = $eTroopMinion To $eTroopBowler
$iDarkCostCamp += $g_aiArmyCompTroops[$i] * $g_aiTroopCostPerLevel[$i][$g_aiTrainArmyTroopLevel[$i]]
Next
GUICtrlSetData($g_hLblElixirCostCamp, _NumberFormat($iElixirCostCamp, True))
GUICtrlSetData($g_hLblDarkCostCamp, _NumberFormat($iDarkCostCamp, True))
EndFunc
Func CalCostSpell()
Local $iElixirCostSpell = 0, $iDarkCostSpell = 0
For $i = $eSpellLightning To $eSpellClone
$iElixirCostSpell += $g_aiArmyCompSpells[$i] * $g_aiSpellCostPerLevel[$i][$g_aiTrainArmySpellLevel[$i]]
Next
For $i = $eSpellPoison To $eSpellSkeleton
$iDarkCostSpell += $g_aiArmyCompSpells[$i] * $g_aiSpellCostPerLevel[$i][$g_aiTrainArmySpellLevel[$i]]
Next
GUICtrlSetData($g_hLblElixirCostSpell, _NumberFormat($iElixirCostSpell, True))
GUICtrlSetData($g_hLblDarkCostSpell, _NumberFormat($iDarkCostSpell, True))
EndFunc
Func CalculTimeTo($TotalTotalTime)
Local $HourToTrain = 0
Local $MinToTrain = 0
Local $SecToTrain = 0
Local $TotalTotalTimeTo
If $TotalTotalTime >= 3600 Then
$HourToTrain = Int($TotalTotalTime / 3600)
$MinToTrain = Int(($TotalTotalTime - $HourToTrain * 3600) / 60)
$SecToTrain = $TotalTotalTime - $HourToTrain * 3600 - $MinToTrain * 60
$TotalTotalTimeTo = " " & $HourToTrain & "h " & $MinToTrain & "m " & $SecToTrain & "s"
ElseIf $TotalTotalTime < 3600 And $TotalTotalTime >= 60 Then
$MinToTrain = Int(($TotalTotalTime - $HourToTrain * 3600) / 60)
$SecToTrain = $TotalTotalTime - $HourToTrain * 3600 - $MinToTrain * 60
$TotalTotalTimeTo = " " & $MinToTrain & "m " & $SecToTrain & "s"
Else
$SecToTrain = $TotalTotalTime
$TotalTotalTimeTo = " " & $SecToTrain & "s"
EndIf
Return $TotalTotalTimeTo
EndFunc
Func Removecamp()
For $T = 0 To $eTroopCount - 1
$g_aiArmyCompTroops[$T] = 0
GUICtrlSetData($g_ahTxtTrainArmyTroopCount[$T], 0)
Next
For $S = 0 To $eSpellCount - 1
$g_aiArmyCompSpells[$S] = 0
GUICtrlSetData($g_ahTxtTrainArmySpellCount[$S], $g_aiArmyCompSpells[$S])
Next
GUICtrlSetData($g_hLblTotalTimeCamp, " 0s")
GUICtrlSetData($g_hLblTotalTimeSpell, " 0s")
GUICtrlSetData($g_hLblElixirCostCamp, "0")
GUICtrlSetData($g_hLblDarkCostCamp, "0")
GUICtrlSetData($g_hLblElixirCostSpell, "0")
GUICtrlSetData($g_hLblDarkCostSpell, "0")
GUICtrlSetData($g_hLblCountTotal, 0)
EndFunc
Func TrainTroopCountEdit()
For $i = 0 To $eTroopCount - 1
If @GUI_CtrlId = $g_ahTxtTrainArmyTroopCount[$i] Then
$g_aiArmyCompTroops[$i] = GUICtrlRead($g_ahTxtTrainArmyTroopCount[$i])
lblTotalCountTroop1()
Return
EndIf
Next
EndFunc
Func TrainSpellCountEdit()
For $i = 0 To $eSpellCount - 1
If @GUI_CtrlId = $g_ahTxtTrainArmySpellCount[$i] Then
$g_aiArmyCompSpells[$i] = GUICtrlRead($g_ahTxtTrainArmySpellCount[$i])
lblTotalCountSpell2()
Return
EndIf
Next
EndFunc
Func chkAddDelayIdlePhaseEnable()
$g_bTrainAddRandomDelayEnable =(GUICtrlRead($g_hChkTrainAddRandomDelayEnable) = $GUI_CHECKED)
For $i = $g_hLblAddDelayIdlePhaseBetween to $g_hLblAddDelayIdlePhaseSec
GUICtrlSetState($i, $g_bTrainAddRandomDelayEnable ? $GUI_ENABLE : $GUI_DISABLE)
Next
EndFunc
Func chkRequestCCHours()
Local $bWasRedraw = SetRedrawBotWindow(False, Default, Default, Default, "chkRequestCCHours")
If GUICtrlRead($g_hChkRequestTroopsEnable) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtRequestCC, $GUI_SHOW + $GUI_ENABLE)
For $i = $g_ahLblRequestCCHours0 To $g_hLblRequestCCHoursPM
GUICtrlSetState($i, $GUI_ENABLE)
Next
Else
GUICtrlSetState($g_hTxtRequestCC, $GUI_SHOW + $GUI_DISABLE)
For $i = $g_ahLblRequestCCHours0 To $g_hLblRequestCCHoursPM
GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
SetRedrawBotWindowControls($bWasRedraw, $g_hGrpRequestCC, "chkRequestCCHours")
EndFunc
Func chkRequestCCHoursE1()
If GUICtrlRead($g_hChkRequestCCHoursE1) = $GUI_CHECKED And GUICtrlRead($g_ahChkRequestCCHours[0]) = $GUI_CHECKED Then
For $i = 0 To 11
GUICtrlSetState($g_ahChkRequestCCHours[$i], $GUI_UNCHECKED)
Next
Else
For $i = 0 To 11
GUICtrlSetState($g_ahChkRequestCCHours[$i], $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($g_hChkRequestCCHoursE1, $GUI_UNCHECKED)
EndFunc
Func chkRequestCCHoursE2()
If GUICtrlRead($g_hChkRequestCCHoursE2) = $GUI_CHECKED And GUICtrlRead($g_ahChkRequestCCHours[12]) = $GUI_CHECKED Then
For $i = 12 To 23
GUICtrlSetState($g_ahChkRequestCCHours[$i], $GUI_UNCHECKED)
Next
Else
For $i = 12 To 23
GUICtrlSetState($g_ahChkRequestCCHours[$i], $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($g_hChkRequestCCHoursE2, $GUI_UNCHECKED)
EndFunc
Func chkDonateHours()
Local $bWasRedraw = SetRedrawBotWindow(False, Default, Default, Default, "chkDonateHours")
If GUICtrlRead($g_hChkDonateHoursEnable) = $GUI_CHECKED Then
For $i = $g_hLblDonateHours1 To $g_hLblDonateHoursPM
GUICtrlSetState($i, $GUI_ENABLE)
Next
Else
For $i = $g_hLblDonateHours1 To $g_hLblDonateHoursPM
GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
SetRedrawBotWindowControls($bWasRedraw, $g_hGrpDonateCC, "chkDonateHours")
EndFunc
Func chkDonateHoursE1()
If GUICtrlRead($g_ahChkDonateHoursE1) = $GUI_CHECKED And GUICtrlRead($g_ahChkDonateHours[0]) = $GUI_CHECKED Then
For $i = 0 To 11
GUICtrlSetState($g_ahChkDonateHours[$i], $GUI_UNCHECKED)
Next
Else
For $i = 0 To 11
GUICtrlSetState($g_ahChkDonateHours[$i], $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($g_ahChkDonateHoursE1, $GUI_UNCHECKED)
EndFunc
Func chkDonateHoursE2()
If GUICtrlRead($g_ahChkDonateHoursE2) = $GUI_CHECKED And GUICtrlRead($g_ahChkDonateHours[12]) = $GUI_CHECKED Then
For $i = 12 To 23
GUICtrlSetState($g_ahChkDonateHours[$i], $GUI_UNCHECKED)
Next
Else
For $i = 12 To 23
GUICtrlSetState($g_ahChkDonateHours[$i], $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($g_ahChkDonateHoursE2, $GUI_UNCHECKED)
EndFunc
Func cmbDBGoldElixir()
If _GUICtrlComboBox_GetCurSel($g_hCmbDBMeetGE) < 2 Then
GUICtrlSetState($g_hTxtDBMinGold, $GUI_SHOW)
GUICtrlSetState($g_hPicDBMinGold, $GUI_SHOW)
GUICtrlSetState($g_hTxtDBMinElixir, $GUI_SHOW)
GUICtrlSetState($g_hPicDBMinElixir, $GUI_SHOW)
GUICtrlSetState($g_hTxtDBMinGoldPlusElixir, $GUI_HIDE)
GUICtrlSetState($g_hPicDBMinGPEGold, $GUI_HIDE)
Else
GUICtrlSetState($g_hTxtDBMinGold, $GUI_HIDE)
GUICtrlSetState($g_hPicDBMinGold, $GUI_HIDE)
GUICtrlSetState($g_hTxtDBMinElixir, $GUI_HIDE)
GUICtrlSetState($g_hPicDBMinElixir, $GUI_HIDE)
GUICtrlSetState($g_hTxtDBMinGoldPlusElixir, $GUI_SHOW)
GUICtrlSetState($g_hPicDBMinGPEGold, $GUI_SHOW)
EndIf
EndFunc
Func chkDBMeetDE()
_GUICtrlEdit_SetReadOnly($g_hTxtDBMinDarkElixir, GUICtrlRead($g_hChkDBMeetDE) = $GUI_CHECKED ? False : True)
EndFunc
Func chkDBMeetTrophy()
_GUICtrlEdit_SetReadOnly($g_hTxtDBMinTrophy, GUICtrlRead($g_hChkDBMeetTrophy) = $GUI_CHECKED ? False : True)
EndFunc
Func chkDBMeetTH()
GUICtrlSetState($g_hCmbDBTH, GUICtrlRead($g_hChkDBMeetTH) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func chkDBWeakBase()
GUICtrlSetState($g_ahCmbWeakMortar[$DB], GUICtrlRead($g_ahChkMaxMortar[$DB]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
GUICtrlSetState($g_ahCmbWeakWizTower[$DB], GUICtrlRead($g_ahChkMaxWizTower[$DB]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
GUICtrlSetState($g_ahCmbWeakAirDefense[$DB], GUICtrlRead($g_ahChkMaxAirDefense[$DB]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
GUICtrlSetState($g_ahCmbWeakXBow[$DB], GUICtrlRead($g_ahChkMaxXBow[$DB]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
GUICtrlSetState($g_ahCmbWeakInferno[$DB], GUICtrlRead($g_ahChkMaxInferno[$DB]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
GUICtrlSetState($g_ahCmbWeakEagle[$DB], GUICtrlRead($g_ahChkMaxEagle[$DB]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func cmbABGoldElixir()
If _GUICtrlComboBox_GetCurSel($g_hCmbABMeetGE) < 2 Then
GUICtrlSetState($g_hTxtABMinGold, $GUI_SHOW)
GUICtrlSetState($g_hPicABMinGold, $GUI_SHOW)
GUICtrlSetState($g_hTxtABMinElixir, $GUI_SHOW)
GUICtrlSetState($g_hPicABMinElixir, $GUI_SHOW)
GUICtrlSetState($g_hTxtABMinGoldPlusElixir, $GUI_HIDE)
GUICtrlSetState($g_hPicABMinGPEGold, $GUI_HIDE)
Else
GUICtrlSetState($g_hTxtABMinGold, $GUI_HIDE)
GUICtrlSetState($g_hPicABMinGold, $GUI_HIDE)
GUICtrlSetState($g_hTxtABMinElixir, $GUI_HIDE)
GUICtrlSetState($g_hPicABMinElixir, $GUI_HIDE)
GUICtrlSetState($g_hTxtABMinGoldPlusElixir, $GUI_SHOW)
GUICtrlSetState($g_hPicABMinGPEGold, $GUI_SHOW)
EndIf
EndFunc
Func chkABMeetDE()
_GUICtrlEdit_SetReadOnly($g_hTxtABMinDarkElixir, GUICtrlRead($g_hChkABMeetDE) = $GUI_CHECKED ? False : True)
EndFunc
Func chkABMeetTrophy()
_GUICtrlEdit_SetReadOnly($g_hTxtABMinTrophy, GUICtrlRead($g_hChkABMeetTrophy) = $GUI_CHECKED ? False : True)
EndFunc
Func chkABMeetTH()
GUICtrlSetState($g_hCmbABTH, GUICtrlRead($g_hChkABMeetTH) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func chkABWeakBase()
GUICtrlSetState($g_ahCmbWeakMortar[$LB], GUICtrlRead($g_ahChkMaxMortar[$LB]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
GUICtrlSetState($g_ahCmbWeakWizTower[$LB], GUICtrlRead($g_ahChkMaxWizTower[$LB]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
GUICtrlSetState($g_ahCmbWeakAirDefense[$LB], GUICtrlRead($g_ahChkMaxAirDefense[$LB]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
GUICtrlSetState($g_ahCmbWeakXBow[$LB], GUICtrlRead($g_ahChkMaxXBow[$LB]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
GUICtrlSetState($g_ahCmbWeakInferno[$LB], GUICtrlRead($g_ahChkMaxInferno[$LB]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
GUICtrlSetState($g_ahCmbWeakEagle[$LB], GUICtrlRead($g_ahChkMaxEagle[$LB]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func chkRestartSearchLimit()
GUICtrlSetState($g_hTxtRestartSearchlimit, GUICtrlRead($g_hChkRestartSearchLimit) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func btnConfigureCollectors()
EndFunc
Func btnConfigureReduction()
EndFunc
Func btnConfigureTHBully()
EndFunc
Func btnConfigureDBWeakBase()
EndFunc
Func btnConfigureABWeakBase()
EndFunc
Func chkDBActivateSearches()
If GUICtrlRead($g_hChkDBActivateSearches) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtDBSearchesMin, $GUI_ENABLE)
GUICtrlSetState($g_hLblDBSearches, $GUI_ENABLE)
GUICtrlSetState($g_hTxtDBSearchesMax, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtDBSearchesMin, $GUI_DISABLE)
GUICtrlSetState($g_hLblDBSearches, $GUI_DISABLE)
GUICtrlSetState($g_hTxtDBSearchesMax, $GUI_DISABLE)
EndIf
dbCheckall()
EndFunc
Func chkDBActivateTropies()
If GUICtrlRead($g_hChkDBActivateTropies) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtDBTropiesMin, $GUI_ENABLE)
GUICtrlSetState($g_hLblDBTropies, $GUI_ENABLE)
GUICtrlSetState($g_hTxtDBTropiesMax, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtDBTropiesMin, $GUI_DISABLE)
GUICtrlSetState($g_hLblDBTropies, $GUI_DISABLE)
GUICtrlSetState($g_hTxtDBTropiesMax, $GUI_DISABLE)
EndIf
dbCheckall()
EndFunc
Func chkDBActivateCamps()
If GUICtrlRead($g_hChkDBActivateCamps) = $GUI_CHECKED Then
GUICtrlSetState($g_hLblDBArmyCamps, $GUI_ENABLE)
GUICtrlSetState($g_hTxtDBArmyCamps, $GUI_ENABLE)
Else
GUICtrlSetState($g_hLblDBArmyCamps, $GUI_DISABLE)
GUICtrlSetState($g_hTxtDBArmyCamps, $GUI_DISABLE)
EndIf
dbCheckall()
EndFunc
Func EnableSearchPanels($mode)
Switch $mode
Case $DB
If GUICtrlRead($g_hChkDBActivateSearches) = $GUI_CHECKED Or GUICtrlRead($g_hChkDBActivateTropies) = $GUI_CHECKED Or GUICtrlRead($g_hChkDBActivateCamps) = $GUI_CHECKED Or GUICtrlRead($g_hChkDBKingWait) = $GUI_CHECKED Or GUICtrlRead($g_hChkDBQueenWait) = $GUI_CHECKED Or GUICtrlRead($g_hChkDBWardenWait) = $GUI_CHECKED Or GUICtrlRead($g_hChkDBSpellsWait) = $GUI_CHECKED Then
_GUI_Value_STATE("SHOW", $groupHerosDB)
_GUI_Value_STATE("SHOW", $groupSearchDB)
_GUI_Value_STATE("SHOW", $groupSpellsDB)
cmbDBGoldElixir()
Else
_GUI_Value_STATE("HIDE", $groupHerosDB)
_GUI_Value_STATE("HIDE", $groupSearchDB)
_GUI_Value_STATE("HIDE", $groupSpellsDB)
EndIf
Case $LB
If GUICtrlRead($g_hChkABActivateSearches) = $GUI_CHECKED Or GUICtrlRead($g_hChkABActivateTropies) = $GUI_CHECKED Or GUICtrlRead($g_hChkABActivateCamps) = $GUI_CHECKED Or GUICtrlRead($g_hChkABKingWait) = $GUI_CHECKED Or GUICtrlRead($g_hChkABQueenWait) = $GUI_CHECKED Or GUICtrlRead($g_hChkABWardenWait) = $GUI_CHECKED Or GUICtrlRead($g_hChkABSpellsWait) = $GUI_CHECKED Then
_GUI_Value_STATE("SHOW", $groupHerosAB)
_GUI_Value_STATE("SHOW", $groupSearchAB)
_GUI_Value_STATE("SHOW", $groupSpellsAB)
cmbABGoldElixir()
Else
_GUI_Value_STATE("HIDE", $groupHerosAB)
_GUI_Value_STATE("HIDE", $groupSearchAB)
_GUI_Value_STATE("HIDE", $groupSpellsAB)
EndIf
Case $TS
If GUICtrlRead($g_hChkTSActivateSearches) = $GUI_CHECKED Or GUICtrlRead($g_hChkTSActivateTropies) = $GUI_CHECKED Or GUICtrlRead($g_hChkTSActivateCamps) = $GUI_CHECKED Then
_GUI_Value_STATE("SHOW", $groupSearchTS)
cmbTSGoldElixir()
Else
_GUI_Value_STATE("HIDE", $groupSearchTS)
EndIf
EndSwitch
EndFunc
Func chkABActivateSearches()
If GUICtrlRead($g_hChkABActivateSearches) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtABSearchesMin, $GUI_ENABLE)
GUICtrlSetState($g_hLblABSearches, $GUI_ENABLE)
GUICtrlSetState($g_hTxtABSearchesMax, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtABSearchesMin, $GUI_DISABLE)
GUICtrlSetState($g_hLblABSearches, $GUI_DISABLE)
GUICtrlSetState($g_hTxtABSearchesMax, $GUI_DISABLE)
EndIf
abCheckall()
EndFunc
Func chkABActivateTropies()
If GUICtrlRead($g_hChkABActivateTropies) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtABTropiesMin, $GUI_ENABLE)
GUICtrlSetState($g_hLblABTropies, $GUI_ENABLE)
GUICtrlSetState($g_hTxtABTropiesMax, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtABTropiesMin, $GUI_DISABLE)
GUICtrlSetState($g_hLblABTropies, $GUI_DISABLE)
GUICtrlSetState($g_hTxtABTropiesMax, $GUI_DISABLE)
EndIf
abCheckall()
EndFunc
Func chkABActivateCamps()
If GUICtrlRead($g_hChkABActivateCamps) = $GUI_CHECKED Then
GUICtrlSetState($g_hLblABArmyCamps, $GUI_ENABLE)
GUICtrlSetState($g_hTxtABArmyCamps, $GUI_ENABLE)
Else
GUICtrlSetState($g_hLblABArmyCamps, $GUI_DISABLE)
GUICtrlSetState($g_hTxtABArmyCamps, $GUI_DISABLE)
EndIf
abCheckall()
EndFunc
Func chkTSActivateSearches()
If GUICtrlRead($g_hChkTSActivateSearches) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtTSSearchesMin, $GUI_ENABLE)
GUICtrlSetState($g_hLblTSSearches, $GUI_ENABLE)
GUICtrlSetState($g_hTxtTSSearchesMax, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtTSSearchesMin, $GUI_DISABLE)
GUICtrlSetState($g_hLblTSSearches, $GUI_DISABLE)
GUICtrlSetState($g_hTxtTSSearchesMax, $GUI_DISABLE)
EndIf
tsCheckall()
EndFunc
Func chkTSActivateTropies()
If GUICtrlRead($g_hChkTSActivateTropies) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtTSTropiesMin, $GUI_ENABLE)
GUICtrlSetState($g_hLblTSTropies, $GUI_ENABLE)
GUICtrlSetState($g_hTxtTSTropiesMax, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtTSTropiesMin, $GUI_DISABLE)
GUICtrlSetState($g_hLblTSTropies, $GUI_DISABLE)
GUICtrlSetState($g_hTxtTSTropiesMax, $GUI_DISABLE)
EndIf
tsCheckAll()
EndFunc
Func chkTSActivateCamps()
If GUICtrlRead($g_hChkTSActivateCamps) = $GUI_CHECKED Then
GUICtrlSetState($g_hLblTSArmyCamps, $GUI_ENABLE)
GUICtrlSetState($g_hTxtTSArmyCamps, $GUI_ENABLE)
Else
GUICtrlSetState($g_hLblTSArmyCamps, $GUI_DISABLE)
GUICtrlSetState($g_hTxtTSArmyCamps, $GUI_DISABLE)
EndIf
tsCheckAll()
EndFunc
Func chkDBKingWait()
If $iTownHallLevel > 6 Or $iTownHallLevel = 0 Then
If GUICtrlRead($g_hChkDBKingWait) = $GUI_CHECKED Then
If $g_bUpgradeKingEnable = False Then
GUICtrlSetState($g_hChkDBKingAttack, $GUI_CHECKED)
Else
GUICtrlSetState($g_hChkDBKingWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
Else
If $g_bUpgradeKingEnable = False Then
GUICtrlSetState($g_hChkDBKingWait, $GUI_ENABLE)
Else
GUICtrlSetState($g_hChkDBKingWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndIf
Else
GUICtrlSetState($g_hChkDBKingWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
GUICtrlSetState($g_hChkDBKingAttack, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndFunc
Func chkDBQueenWait()
If $iTownHallLevel > 8 Or $iTownHallLevel = 0 Then
If GUICtrlRead($g_hChkDBQueenWait) = $GUI_CHECKED Then
If $g_bUpgradeQueenEnable = False Then
GUICtrlSetState($g_hChkDBQueenAttack, $GUI_CHECKED)
Else
GUICtrlSetState($g_hChkDBQueenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
Else
If $g_bUpgradeQueenEnable = False Then
GUICtrlSetState($g_hChkDBQueenWait, $GUI_ENABLE)
Else
GUICtrlSetState($g_hChkDBQueenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndIf
Else
GUICtrlSetState($g_hChkDBQueenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
GUICtrlSetState($g_hChkDBQueenAttack, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndFunc
Func chkDBWardenWait()
If $iTownHallLevel > 10 Or $iTownHallLevel = 0 Then
If GUICtrlRead($g_hChkDBWardenWait) = $GUI_CHECKED Then
If $g_bUpgradeWardenEnable = False Then
GUICtrlSetState($g_hChkDBWardenAttack, $GUI_CHECKED)
GUICtrlSetState($g_hPicDBWardenWait, $GUI_ENABLE)
Else
GUICtrlSetState($g_hChkDBWardenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
Else
If $g_bUpgradeWardenEnable = False Then
GUICtrlSetState($g_hChkDBWardenWait, $GUI_ENABLE)
Else
GUICtrlSetState($g_hChkDBWardenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndIf
Else
GUICtrlSetState($g_hChkDBWardenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
GUICtrlSetState($g_hChkDBWardenAttack, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndFunc
Func chkABKingWait()
If $iTownHallLevel > 6 Or $iTownHallLevel = 0 Then
If GUICtrlRead($g_hChkABKingWait) = $GUI_CHECKED Then
If $g_bUpgradeKingEnable = False Then
GUICtrlSetState($g_hChkABKingAttack, $GUI_CHECKED)
Else
GUICtrlSetState($g_hChkABKingWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
Else
If $g_bUpgradeKingEnable = False Then
GUICtrlSetState($g_hChkABKingWait, $GUI_ENABLE)
Else
GUICtrlSetState($g_hChkABKingWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndIf
Else
GUICtrlSetState($g_hChkABKingWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
GUICtrlSetState($g_hChkABKingAttack, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndFunc
Func chkABQueenWait()
If $iTownHallLevel > 8 Or $iTownHallLevel = 0 Then
If GUICtrlRead($g_hChkABQueenWait) = $GUI_CHECKED Then
If $g_bUpgradeQueenEnable = False Then
GUICtrlSetState($g_hChkABQueenAttack, $GUI_CHECKED)
Else
GUICtrlSetState($g_hChkABQueenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
Else
If $g_bUpgradeQueenEnable = False Then
GUICtrlSetState($g_hChkABQueenWait, $GUI_ENABLE)
Else
GUICtrlSetState($g_hChkABQueenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndIf
Else
GUICtrlSetState($g_hChkABQueenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
GUICtrlSetState($g_hChkABQueenAttack, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndFunc
Func chkABWardenWait()
If $iTownHallLevel > 10 Or $iTownHallLevel = 0 Then
If GUICtrlRead($g_hChkABWardenWait) = $GUI_CHECKED Then
If $g_bUpgradeWardenEnable = False Then
GUICtrlSetState($g_hChkABWardenAttack, $GUI_CHECKED)
Else
GUICtrlSetState($g_hChkABWardenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
Else
If $g_bUpgradeWardenEnable = False Then
GUICtrlSetState($g_hChkABWardenWait, $GUI_ENABLE)
Else
GUICtrlSetState($g_hChkABWardenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndIf
Else
GUICtrlSetState($g_hChkABWardenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
GUICtrlSetState($g_hChkABWardenAttack, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndFunc
Func chkDBWaitForCCSpell()
If GUICtrlRead($g_hChkDBWaitForCastleSpell) = $GUI_CHECKED Then
GUICtrlSetState($g_hCmbDBWaitForCastleSpell, $GUI_ENABLE)
cmbDBWaitForCCSpell()
Else
GUICtrlSetState($g_hCmbDBWaitForCastleSpell, $GUI_DISABLE)
GUICtrlSetState($g_hTxtDBWaitForCastleSpell, $GUI_DISABLE)
GUICtrlSetState($g_hCmbDBWaitForCastleSpell2, $GUI_DISABLE)
EndIf
EndFunc
Func chkABWaitForCCSpell()
If GUICtrlRead($g_hChkABWaitForCastleSpell) = $GUI_CHECKED Then
GUICtrlSetState($g_hCmbABWaitForCastleSpell, $GUI_ENABLE)
cmbABWaitForCCSpell()
Else
GUICtrlSetState($g_hCmbABWaitForCastleSpell, $GUI_DISABLE)
GUICtrlSetState($g_hTxtABWaitForCastleSpell, $GUI_DISABLE)
GUICtrlSetState($g_hCmbABWaitForCastleSpell2, $GUI_DISABLE)
EndIf
EndFunc
Func cmbDBWaitForCCSpell()
Local $iSpellSelection = _GUICtrlComboBox_GetCurSel($g_hCmbDBWaitForCastleSpell)
If $iSpellSelection > 0 And $iSpellSelection < 6 Then
GUICtrlSetState($g_hCmbDBWaitForCastleSpell2, $GUI_DISABLE)
GUICtrlSetState($g_hTxtDBWaitForCastleSpell, $GUI_DISABLE)
Else
GUICtrlSetState($g_hCmbDBWaitForCastleSpell2, $GUI_ENABLE)
GUICtrlSetState($g_hTxtDBWaitForCastleSpell, $GUI_ENABLE)
EndIf
EndFunc
Func cmbABWaitForCCSpell()
Local $iSpellSelection = _GUICtrlComboBox_GetCurSel($g_hCmbABWaitForCastleSpell)
If $iSpellSelection > 0 And $iSpellSelection < 6 Then
GUICtrlSetState($g_hCmbABWaitForCastleSpell2, $GUI_DISABLE)
GUICtrlSetState($g_hTxtABWaitForCastleSpell, $GUI_DISABLE)
Else
GUICtrlSetState($g_hCmbABWaitForCastleSpell2, $GUI_ENABLE)
GUICtrlSetState($g_hTxtABWaitForCastleSpell, $GUI_ENABLE)
EndIf
EndFunc
Func chkDBSpellsWait()
If $iTownHallLevel > 4 Or $iTownHallLevel = 0 Then
For $i = $g_hPicDBLightSpellWait To $g_hPicDBHasteSpellWait
GUICtrlSetState($i, $GUI_ENABLE)
Next
If GUICtrlRead($g_hChkDBSpellsWait) = $GUI_CHECKED Then
$g_abSearchSpellsWaitEnable[$DB] = True
chkSpellWaitError()
If @error Then
GUICtrlSetState($g_hChkDBSpellsWait, $GUI_UNCHECKED)
$g_abSearchSpellsWaitEnable[$DB] = False
Setlog("Wait for Spells disabled due training count error", $COLOR_ERROR)
EndIf
Else
$g_abSearchSpellsWaitEnable[$DB] = False
EndIf
Else
GUICtrlSetState($g_hChkDBSpellsWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
For $i = $g_hPicDBLightSpellWait To $g_hPicDBHasteSpellWait
GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
EndFunc
Func chkABSpellsWait()
If $iTownHallLevel > 4 Or $iTownHallLevel = 0 Then
For $i = $g_hPicABLightSpellWait To $g_hPicABHasteSpellWait
GUICtrlSetState($i, $GUI_ENABLE)
Next
If GUICtrlRead($g_hChkABSpellsWait) = $GUI_CHECKED Then
$g_abSearchSpellsWaitEnable[$LB] = True
chkSpellWaitError()
If @error Then
GUICtrlSetState($g_hChkABSpellsWait, $GUI_UNCHECKED)
$g_abSearchSpellsWaitEnable[$LB] = False
Setlog("Wait for Spells disabled due training count error", $COLOR_ERROR)
EndIf
Else
$g_abSearchSpellsWaitEnable[$LB] = False
EndIf
Else
GUICtrlSetState($g_hChkABSpellsWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
For $i = $g_hPicABLightSpellWait To $g_hPicABHasteSpellWait
GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
EndFunc
Func chkSpellWaitError()
Local Static $bHaveBeenWarned = False
Local $bErrorCondition = False
Local $sErrorText, $sText, $MsgBox1, $MsgBox2, $MsgBox3
If $iTotalTrainSpaceSpell > GUICtrlRead($g_hTxtTotalCountSpell) Then
$sErrorText = GetTranslated(625,110, "Total number of trained spells exceeds total set in GUI!") & @CRLF & GetTranslated(625,111, "Reduce number of trained spells,") & @CRLF & GetTranslated(625,112, "OR ELSE BOT WILL NEVER ATTACK!!") & @CRLF
$bErrorCondition = True
Else
Return
EndIf
If $bHaveBeenWarned = True And $bErrorCondition = True Then
SetError(1)
Return
ElseIf $bErrorCondition = False Then
Return
EndIf
Local $iCount = 0
While 1
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0xE00000, 0xFFFF00, 12, "Comic Sans MS", 480)
$sText = $sErrorText & @CRLF & GetTranslated(625,113,"Click YES to close this warning message") & @CRLF
$MsgBox1 = _ExtMsgBox(48, GetTranslated(625,114,"YES, I Understand Warning|No"), GetTranslated(625,115,"Wait for Spells Warning!"), $sText, 30, $g_hFrmBot)
Switch $MsgBox1
Case 1
$bHaveBeenWarned = True
ExitLoop
Case Else
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0xFFFF00 , 0xE00000, 12, "Comic Sans MS", 480)
$stext = GetTranslated(625,116,"Sorry, must understand warning and click Yes!") & @CRLF
$MsgBox2 = _ExtMsgBox(16, GetTranslated(625,117,"OK"), GetTranslated(625,118,"User Input Error"), $stext, 15, $g_hFrmBot)
If $iCount = 1 And $MsgBox1 = 9 And $MsgBox2 = 9 Then ExitLoop
EndSwitch
$iCount += 1
If $iCount > 2 Then
$sText = GetTranslated(625,119,"CONGRATULATIONS!!") & @CRLF & GetTranslated(625,120,"You found the secret message in Bot!") & @CRLF & GetTranslated(625,121,"Can you find the randomly selected button to close this message?") & @CRLF & GetTranslated(625,122, "HaHaHaHa...") & @CRLF & @CRLF & @CRLF
Local $sFunnyText = $sText
Local $iControl = 0
$iCount = 1
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 480)
While 1
$MsgBox3 = _ExtMsgBox(128, "1|2|3|4|5|6|7", GetTranslated(625,123,"You are a WINNER!!"), $sFunnyText, 900, $g_hFrmBot)
If @error Then Setlog("_ExtMsgBox error: " & @error, $COLOR_ERROR)
If $iCount > 7 And Int($MsgBox3) = Random(1,8,1) Then
ExitLoop
Else
If $iCount <= 7 Then
$iControl = $iCount
Else
$iControl = $MsgBox3
EndIf
Switch $iControl
Case 1
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x61FF00, 0x020028, 12, "Arial", 480)
$sFunnyText = $sText & GetTranslated(625,124,"Sorry not that button!") & @CRLF
Case 2
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0xDC00FF, 0x011E00, 12, "Comic Sans MS", 480)
$sFunnyText = $sText & GetTranslated(625,125,"Donate £5000 to MyBot.run while you wait 15 minutes for this to time out?") & @CRLF
Case 3
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x000000, 0xFFFFFF, 12, "Tahoma", 480)
$sFunnyText = $sText & GetTranslated(625,126,"Having trouble finding the exit button?") & @CRLF
Case 4
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x4800FF, 0xD800FF, 12, "Comic Sans MS", 480)
$sFunnyText = $sText & GetTranslated(625,127,"This is fun, can we keep going all day?") & @CRLF
Case 5
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Times New Roman", 480)
$sFunnyText = $sText & GetTranslated(625,128,"Try four more times, you have to get lucky sooner or later!") & @CRLF
Case 6
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x00FFED, 0x010051, 12, "Comic Sans MS", 480)
$sFunnyText = $sText & GetTranslated(625,129,"Do you have a Banana? This code monkey is Hungry!") & @CRLF
Case 7
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0xFF6600, 0x013000, 12, "Lucida Console", 480)
$sFunnyText = $sText & GetTranslated(625,130,"Maybe try hitting same button till you and Mr. Random pick same?") & @CRLF
Case 0
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x000000, 0xFFFFFF, 12, "Tahoma", 480)
$sFunnyText = $sText & GetTranslated(625,131,"Sorry, can not 'escape' from this!") & @CRLF
Case Else
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 480)
$sFunnyText = $sText & GetTranslated(625,132,"Program error! Programmers can ruin a good joke.") & @CRLF
ExitLoop 2
EndSwitch
$iCount += 1
EndIf
WEnd
EndIf
WEnd
If $bErrorCondition = True Then
SetError(1)
Return
EndIf
EndFunc
Func chkBalanceDR()
If GUICtrlRead($g_hChkUseCCBalanced) = $GUI_CHECKED Then
GUICtrlSetState($g_hCmbCCDonated, $GUI_ENABLE)
GUICtrlSetState($g_hCmbCCReceived, $GUI_ENABLE)
Else
GUICtrlSetState($g_hCmbCCDonated, $GUI_DISABLE)
GUICtrlSetState($g_hCmbCCReceived, $GUI_DISABLE)
EndIf
EndFunc
Func cmbBalanceDR()
If _GUICtrlComboBox_GetCurSel($g_hCmbCCDonated) = _GUICtrlComboBox_GetCurSel($g_hCmbCCReceived) Then
_GUICtrlComboBox_SetCurSel($g_hCmbCCDonated, 0)
_GUICtrlComboBox_SetCurSel($g_hCmbCCReceived, 0)
EndIf
EndFunc
Func btnMilkingOptions()
EndFunc
Func btnDBAttackConfigure()
Switch _GUICtrlComboBox_GetCurSel($g_hCmbDBAlgorithm)
Case 0
Case 1
Case 2
EndSwitch
EndFunc
Func btnABAttackConfigure()
Switch _GUICtrlComboBox_GetCurSel($g_hCmbDBAlgorithm)
Case 0
Case 1
EndSwitch
EndFunc
Func cmbDBAlgorithm()
Local $iCmbValue = _GUICtrlComboBox_GetCurSel($g_hCmbDBAlgorithm)
_GUI_Value_STATE(($iCmbValue = 1 Or $iCmbValue = 2) ? "SHOW" : "HIDE", $groupAttackDBSpell & "#" & $groupIMGAttackDBSpell)
If BitAND(GUICtrlGetState($g_hGUI_DEADBASE), $GUI_SHOW) And GUICtrlRead($g_hGUI_DEADBASE_TAB) = 1 Then
Select
Case $iCmbValue = 0
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_DEADBASE_ATTACK_STANDARD)
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE_ATTACK_SCRIPTED)
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE_ATTACK_MILKING)
Case $iCmbValue = 1
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE_ATTACK_STANDARD)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_DEADBASE_ATTACK_SCRIPTED)
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE_ATTACK_MILKING)
Case $iCmbValue = 2
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE_ATTACK_STANDARD)
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE_ATTACK_SCRIPTED)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_DEADBASE_ATTACK_MILKING)
Case Else
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE_ATTACK_STANDARD)
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE_ATTACK_SCRIPTED)
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE_ATTACK_MILKING)
EndSelect
EndIf
EndFunc
Func cmbABAlgorithm()
Local $iCmbValue = _GUICtrlComboBox_GetCurSel($g_hcmbABAlgorithm)
_GUI_Value_STATE($iCmbValue = 1 ? "SHOW" : "HIDE", $groupAttackABSpell & "#" & $groupIMGAttackABSpell)
If BitAND(GUICtrlGetState($g_hGUI_ACTIVEBASE), $GUI_SHOW) And GUICtrlRead($g_hGUI_ACTIVEBASE_TAB) = 1 Then
Select
Case $iCmbValue = 0
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_ACTIVEBASE_ATTACK_STANDARD)
GUISetState(@SW_HIDE, $g_hGUI_ACTIVEBASE_ATTACK_SCRIPTED)
Case $iCmbValue = 1
GUISetState(@SW_HIDE, $g_hGUI_ACTIVEBASE_ATTACK_STANDARD)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_ACTIVEBASE_ATTACK_SCRIPTED)
Case Else
GUISetState(@SW_HIDE, $g_hGUI_ACTIVEBASE_ATTACK_STANDARD)
GUISetState(@SW_HIDE, $g_hGUI_ACTIVEBASE_ATTACK_SCRIPTED)
EndSelect
EndIf
EndFunc
Func chkAttackNow()
If GUICtrlRead($g_hChkAttackNow) = $GUI_CHECKED Then
$g_bSearchAttackNowEnable = True
GUICtrlSetState($g_hLblAttackNow, $GUI_ENABLE)
GUICtrlSetState($g_hLblAttackNowSec, $GUI_ENABLE)
GUICtrlSetState($g_hCmbAttackNowDelay, $GUI_ENABLE)
GUICtrlSetState($g_hCmbAttackNowDelay, $GUI_ENABLE)
Else
$g_bSearchAttackNowEnable = False
GUICtrlSetState($g_hLblAttackNow, $GUI_DISABLE)
GUICtrlSetState($g_hLblAttackNowSec, $GUI_DISABLE)
GUICtrlSetState($g_hCmbAttackNowDelay, $GUI_DISABLE)
EndIf
EndFunc
Func LoadThSnipeAttacks()
Dim $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($g_sTHSnipeAttacksPath & "\*.csv")
Dim $output = ""
While True
$NewFile = FileFindNextFile($FileSearch)
If @error Then ExitLoop
$output = $output & StringLeft($NewFile, StringLen($NewFile) - 4) & "|"
WEnd
FileClose($FileSearch)
$output = StringLeft($output, StringLen($output) - 1)
_GUICtrlComboBox_ResetContent($g_hCmbAttackTHType)
GUICtrlSetData($g_hCmbAttackTHType, $output)
_GUICtrlComboBox_SetCurSel($g_hCmbAttackTHType, _GUICtrlComboBox_FindStringExact($g_hCmbAttackTHType, $g_sAtkTSType))
EndFunc
Func LoadDBSnipeAttacks()
Dim $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($g_sTHSnipeAttacksPath & "\*.csv")
Dim $output = ""
While True
$NewFile = FileFindNextFile($FileSearch)
If @error Then ExitLoop
$output = $output & StringLeft($NewFile, StringLen($NewFile) - 4) & "|"
WEnd
FileClose($FileSearch)
$output = StringLeft($output, StringLen($output) - 1)
_GUICtrlComboBox_ResetContent($g_hCmbTHSnipeBeforeDBScript)
GUICtrlSetData($g_hCmbTHSnipeBeforeDBScript, $output)
_GUICtrlComboBox_SetCurSel($g_hCmbTHSnipeBeforeDBScript, _GUICtrlComboBox_FindStringExact($g_hCmbTHSnipeBeforeDBScript, $g_iTHSnipeBeforeTiles[$DB]))
EndFunc
Func LoadABSnipeAttacks()
Dim $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($g_sTHSnipeAttacksPath & "\*.csv")
Dim $output = ""
While True
$NewFile = FileFindNextFile($FileSearch)
If @error Then ExitLoop
$output = $output & StringLeft($NewFile, StringLen($NewFile) - 4) & "|"
WEnd
FileClose($FileSearch)
$output = StringLeft($output, StringLen($output) - 1)
_GUICtrlComboBox_ResetContent($g_hCmbTHSnipeBeforeLBScript)
GUICtrlSetData($g_hCmbTHSnipeBeforeLBScript, $output)
_GUICtrlComboBox_SetCurSel($g_hCmbTHSnipeBeforeLBScript, _GUICtrlComboBox_FindStringExact($g_hCmbTHSnipeBeforeLBScript, $g_iTHSnipeBeforeScript[$LB]))
EndFunc
Func cmbAttackTHType()
Local $arrayattack = _GUICtrlComboBox_GetListArray($g_hCmbAttackTHType)
$g_sAtkTSType = $arrayattack[_GUICtrlComboBox_GetCurSel($g_hCmbAttackTHType) + 1]
EndFunc
Func btnTestTHcsv()
AttackTHParseCSV(True)
EndFunc
Func cmbTSGoldElixir()
If _GUICtrlComboBox_GetCurSel($g_hCmbTSMeetGE) < 2 Then
GUICtrlSetState($g_hTxtTSMinGold, $GUI_SHOW)
GUICtrlSetState($g_hPicTSMinGold, $GUI_SHOW)
GUICtrlSetState($g_hTxtTSMinElixir, $GUI_SHOW)
GUICtrlSetState($g_hPicTSMinElixir, $GUI_SHOW)
GUICtrlSetState($g_hTxtTSMinGoldPlusElixir, $GUI_HIDE)
GUICtrlSetState($g_hPicTSMinGPEGold, $GUI_HIDE)
Else
GUICtrlSetState($g_hTxtTSMinGold, $GUI_HIDE)
GUICtrlSetState($g_hPicTSMinGold, $GUI_HIDE)
GUICtrlSetState($g_hTxtTSMinElixir, $GUI_HIDE)
GUICtrlSetState($g_hPicTSMinElixir, $GUI_HIDE)
GUICtrlSetState($g_hTxtTSMinGoldPlusElixir, $GUI_SHOW)
GUICtrlSetState($g_hPicTSMinGPEGold, $GUI_SHOW)
EndIf
EndFunc
Func chkTHSnipeBeforeDBEnable()
If GUICtrlRead($g_hChkTHSnipeBeforeDBEnable) = $GUI_CHECKED Then
GUICtrlSetState($g_hLblTHSnipeBeforeDBTiles, $GUI_ENABLE)
GUICtrlSetState($g_hTxtTHSnipeBeforeDBTiles, $GUI_ENABLE)
GUICtrlSetState($g_hCmbTHSnipeBeforeDBScript, $GUI_ENABLE)
Else
GUICtrlSetState($g_hLblTHSnipeBeforeDBTiles, $GUI_DISABLE)
GUICtrlSetState($g_hTxtTHSnipeBeforeDBTiles, $GUI_DISABLE)
GUICtrlSetState($g_hCmbTHSnipeBeforeDBScript, $GUI_DISABLE)
EndIf
EndFunc
Func chkTHSnipeBeforeLBEnable()
If GUICtrlRead($g_hChkTHSnipeBeforeLBEnable) = $GUI_CHECKED Then
GUICtrlSetState($g_hLblTHSnipeBeforeLBTiles, $GUI_ENABLE)
GUICtrlSetState($g_hTxtTHSnipeBeforeLBTiles, $GUI_ENABLE)
GUICtrlSetState($g_hCmbTHSnipeBeforeLBScript, $GUI_ENABLE)
Else
GUICtrlSetState($g_hLblTHSnipeBeforeLBTiles, $GUI_DISABLE)
GUICtrlSetState($g_hTxtTHSnipeBeforeLBTiles, $GUI_DISABLE)
GUICtrlSetState($g_hCmbTHSnipeBeforeLBScript, $GUI_DISABLE)
EndIf
EndFunc
Func chkattackHoursE1()
If GUICtrlRead($g_ahChkAttackHoursE1) = $GUI_CHECKED And IschkattackHoursE1() Then
For $i = 0 To 11
GUICtrlSetState($g_ahChkAttackHours[$i], $GUI_UNCHECKED)
Next
Else
For $i = 0 To 11
GUICtrlSetState($g_ahChkAttackHours[$i], $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($g_ahChkAttackHoursE1, $GUI_UNCHECKED)
EndFunc
Func IschkattackHoursE1()
For $i = 0 To 11
If GUICtrlRead($g_ahChkAttackHours[$i]) = $GUI_CHECKED Then Return True
Next
Return False
EndFunc
Func chkattackHoursE2()
If GUICtrlRead($g_ahChkAttackHoursE2) = $GUI_CHECKED And IschkattackHoursE2() Then
For $i = 12 To 23
GUICtrlSetState($g_ahChkAttackHours[$i], $GUI_UNCHECKED)
Next
Else
For $i = 12 To 23
GUICtrlSetState($g_ahChkAttackHours[$i], $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($g_ahChkAttackHoursE2, $GUI_UNCHECKED)
EndFunc
Func IschkattackHoursE2()
For $i = 12 To 23
If GUICtrlRead($g_ahChkAttackHours[$i]) = $GUI_CHECKED Then Return True
Next
Return False
EndFunc
Func chkattackWeekDaysE()
If GUICtrlRead($g_ahChkAttackWeekdaysE) = $GUI_CHECKED And IschkAttackWeekdays() Then
For $i = 0 To 6
GUICtrlSetState($g_ahChkAttackWeekdays[$i], $GUI_UNCHECKED)
Next
Else
For $i = 0 To 6
GUICtrlSetState($g_ahChkAttackWeekdays[$i], $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($g_ahChkAttackWeekdaysE, $GUI_UNCHECKED)
EndFunc
Func IschkAttackWeekdays()
For $i = 0 To 6
If GUICtrlRead($g_ahChkAttackWeekdays[$i]) = $GUI_CHECKED Then Return True
Next
Return False
EndFunc
Func chkAttackPlannerEnable()
If GUICtrlRead($g_hChkAttackPlannerEnable) = $GUI_CHECKED Then
$ichkAttackPlannerEnable = 1
If GUICtrlRead($g_hChkAttackPlannerCloseAll) = $GUI_UNCHECKED Then
GUICtrlSetState($g_hChkAttackPlannerCloseAll, $GUI_ENABLE)
GUICtrlSetState($g_hChkAttackPlannerCloseCoC, $GUI_ENABLE)
Else
GUICtrlSetState($g_hChkAttackPlannerCloseAll, $GUI_ENABLE)
GUICtrlSetState($g_hChkAttackPlannerCloseCoC, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
GUICtrlSetState($g_hChkAttackPlannerRandom, $GUI_ENABLE)
GUICtrlSetState($g_hChkAttackPlannerDayLimit, $GUI_ENABLE)
chkAttackPlannerDayLimit()
cmbAttackPlannerRandom()
If GUICtrlRead($g_hChkAttackPlannerRandom) = $GUI_CHECKED Then
GUICtrlSetState($g_hCmbAttackPlannerRandom, $GUI_ENABLE)
GUICtrlSetState($g_hLbAttackPlannerRandom, $GUI_ENABLE)
For $i = 0 To 6
GUICtrlSetState($g_ahChkAttackWeekdays[$i], $GUI_DISABLE)
Next
GUICtrlSetState($g_ahChkAttackWeekdaysE, $GUI_DISABLE)
For $i = 0 To 23
GUICtrlSetState($g_ahChkAttackHours[$i], $GUI_DISABLE)
Next
GUICtrlSetState($g_ahChkAttackHoursE1, $GUI_DISABLE)
GUICtrlSetState($g_ahChkAttackHoursE2, $GUI_DISABLE)
Else
GUICtrlSetState($g_hCmbAttackPlannerRandom, $GUI_DISABLE)
GUICtrlSetState($g_hLbAttackPlannerRandom, $GUI_DISABLE)
For $i = 0 To 6
GUICtrlSetState($g_ahChkAttackWeekdays[$i], $GUI_ENABLE)
Next
GUICtrlSetState($g_ahChkAttackWeekdaysE, $GUI_ENABLE)
For $i = 0 To 23
GUICtrlSetState($g_ahChkAttackHours[$i], $GUI_ENABLE)
Next
GUICtrlSetState($g_ahChkAttackHoursE1, $GUI_ENABLE)
GUICtrlSetState($g_ahChkAttackHoursE2, $GUI_ENABLE)
EndIf
Else
$ichkAttackPlannerEnable = 0
GUICtrlSetState($g_hChkAttackPlannerCloseCoC, $GUI_DISABLE)
GUICtrlSetState($g_hChkAttackPlannerCloseAll, $GUI_DISABLE)
GUICtrlSetState($g_hChkAttackPlannerRandom, $GUI_DISABLE)
GUICtrlSetState($g_hCmbAttackPlannerRandom, $GUI_DISABLE)
GUICtrlSetState($g_hLbAttackPlannerRandom, $GUI_DISABLE)
GUICtrlSetState($g_hChkAttackPlannerDayLimit, $GUI_DISABLE)
GUICtrlSetState($g_hCmbAttackPlannerDayMin, $GUI_DISABLE)
GUICtrlSetState($g_hCmbAttackPlannerDayMax, $GUI_DISABLE)
For $i = 0 To 6
GUICtrlSetState($g_ahChkAttackWeekdays[$i], $GUI_DISABLE)
Next
GUICtrlSetState($g_ahChkAttackWeekdaysE, $GUI_DISABLE)
For $i = 0 To 23
GUICtrlSetState($g_ahChkAttackHours[$i], $GUI_DISABLE)
Next
GUICtrlSetState($g_ahChkAttackHoursE2, $GUI_DISABLE)
EndIf
EndFunc
Func chkAttackPlannerCloseCoC()
If GUICtrlRead($g_hChkAttackPlannerCloseCoC) = $GUI_CHECKED Then
$ichkAttackPlannerCloseCoC = 1
Else
$ichkAttackPlannerCloseCoC = 0
EndIf
EndFunc
Func chkAttackPlannerCloseAll()
If GUICtrlRead($g_hChkAttackPlannerCloseAll) = $GUI_CHECKED Then
$ichkAttackPlannerCloseAll = 1
GUICtrlSetState($g_hChkAttackPlannerCloseCoC, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
Else
$ichkAttackPlannerCloseAll = 0
GUICtrlSetState($g_hChkAttackPlannerCloseCoC, $GUI_ENABLE)
EndIf
EndFunc
Func chkAttackPlannerRandom()
If GUICtrlRead($g_hChkAttackPlannerRandom) = $GUI_CHECKED Then
$ichkAttackPlannerRandom = 1
GUICtrlSetState($g_hCmbAttackPlannerRandom, $GUI_ENABLE)
GUICtrlSetState($g_hLbAttackPlannerRandom, $GUI_ENABLE)
For $i = 0 To 6
GUICtrlSetState($g_ahChkAttackWeekdays[$i], $GUI_DISABLE)
Next
GUICtrlSetState($g_ahChkAttackWeekdaysE, $GUI_DISABLE)
For $i = 0 To 23
GUICtrlSetState($g_ahChkAttackHours[$i], $GUI_DISABLE)
Next
GUICtrlSetState($g_ahChkAttackHoursE1, $GUI_DISABLE)
GUICtrlSetState($g_ahChkAttackHoursE2, $GUI_DISABLE)
Else
$ichkAttackPlannerRandom = 0
chkAttackPlannerEnable()
EndIf
EndFunc
Func cmbAttackPlannerRandom()
$icmbAttackPlannerRandom = Int(_GUICtrlComboBox_GetCurSel($g_hCmbAttackPlannerRandom))
GUICtrlSetData($g_hLbAttackPlannerRandom, $icmbAttackPlannerRandom > 0 ? GetTranslated(603, 37, -1) : GetTranslated(603, 38, "hr"))
EndFunc
Func chkAttackPlannerDayLimit()
If GUICtrlRead($g_hChkAttackPlannerDayLimit) = $GUI_CHECKED Then
$ichkAttackPlannerDayLimit = 1
GUICtrlSetState($g_hCmbAttackPlannerDayMin, $GUI_ENABLE)
GUICtrlSetState($g_hLbAttackPlannerDayLimit, $GUI_ENABLE)
GUICtrlSetState($g_hCmbAttackPlannerDayMax, $GUI_ENABLE)
Else
$ichkAttackPlannerDayLimit = 0
GUICtrlSetState($g_hCmbAttackPlannerDayMin, $GUI_DISABLE)
GUICtrlSetState($g_hLbAttackPlannerDayLimit, $GUI_DISABLE)
GUICtrlSetState($g_hCmbAttackPlannerDayMax, $GUI_DISABLE)
EndIf
_cmbAttackPlannerDayLimit()
EndFunc
Func cmbAttackPlannerDayMin()
If Int(GUICtrlRead($g_hCmbAttackPlannerDayMax)) < Int(GUICtrlRead($g_hCmbAttackPlannerDayMin)) Then
GUICtrlSetData($g_hCmbAttackPlannerDayMin, GUICtrlRead($g_hCmbAttackPlannerDayMax))
EndIf
$icmbAttackPlannerDayMin = Int(GUICtrlRead($g_hCmbAttackPlannerDayMin))
_cmbAttackPlannerDayLimit()
EndFunc
Func cmbAttackPlannerDayMax()
If Int(GUICtrlRead($g_hCmbAttackPlannerDayMax)) < Int(GUICtrlRead($g_hCmbAttackPlannerDayMin)) Then
GUICtrlSetData($g_hCmbAttackPlannerDayMax, GUICtrlRead($g_hCmbAttackPlannerDayMin))
EndIf
$icmbAttackPlannerDayMax = Int(GUICtrlRead($g_hCmbAttackPlannerDayMax))
_cmbAttackPlannerDayLimit()
EndFunc
Func _cmbAttackPlannerDayLimit()
Switch Int(GUICtrlRead($g_hCmbAttackPlannerDayMin))
Case 0 To 15
GUICtrlSetBkColor($g_hCmbAttackPlannerDayMin, $COLOR_MONEYGREEN)
Case 16 To 20
GUICtrlSetBkColor($g_hCmbAttackPlannerDayMin, $COLOR_YELLOW)
Case 21 To 999
GUICtrlSetBkColor($g_hCmbAttackPlannerDayMin, $COLOR_RED)
EndSwitch
Switch Int(GUICtrlRead($g_hCmbAttackPlannerDayMax))
Case 0 To 15
GUICtrlSetBkColor($g_hCmbAttackPlannerDayMax, $COLOR_MONEYGREEN)
Case 16 To 25
GUICtrlSetBkColor($g_hCmbAttackPlannerDayMax, $COLOR_YELLOW)
Case 26 To 999
GUICtrlSetBkColor($g_hCmbAttackPlannerDayMax, $COLOR_RED)
EndSwitch
EndFunc
Func chkDropCCHoursEnable()
Local $bChk = GUICtrlRead($g_hChkDropCCHoursEnable) = $GUI_CHECKED
$iPlannedDropCCHoursEnable = $bChk ? 1 : 0
For $i = 0 To 23
GUICtrlSetState($g_ahChkDropCCHours[$i], $bChk ? $GUI_ENABLE : $GUI_DISABLE)
Next
GUICtrlSetState($g_ahChkDropCCHoursE1, $bChk ? $GUI_ENABLE : $GUI_DISABLE)
GUICtrlSetState($g_ahChkDropCCHoursE2, $bChk ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func chkDropCCHoursE1()
Local $bChk = GUICtrlRead($g_ahChkDropCCHoursE1) = $GUI_CHECKED And GUICtrlRead($g_ahChkDropCCHours[0]) = $GUI_CHECKED
For $i = 0 To 11
GUICtrlSetState($g_ahChkDropCCHours[$i], $bChk ? $GUI_UNCHECKED : $GUI_CHECKED)
Next
Sleep(300)
GUICtrlSetState($g_ahChkDropCCHoursE1, $GUI_UNCHECKED)
EndFunc
Func chkDropCCHoursE2()
Local $bChk = GUICtrlRead($g_ahChkDropCCHoursE2) = $GUI_CHECKED And GUICtrlRead($g_ahChkDropCCHours[12]) = $GUI_CHECKED
For $i = 12 To 23
GUICtrlSetState($g_ahChkDropCCHours[$i], $bChk ? $GUI_UNCHECKED : $GUI_CHECKED)
Next
Sleep(300)
GUICtrlSetState($g_ahChkDropCCHoursE2, $GUI_UNCHECKED)
EndFunc
Func chkShareAttack()
If GUICtrlRead($g_hChkShareAttack) = $GUI_CHECKED Then
For $i = $g_hLblShareMinLoot To $g_hTxtShareMessage
GUICtrlSetState($i, $GUI_ENABLE)
Next
Else
For $i = $g_hLblShareMinLoot To $g_hTxtShareMessage
GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
EndFunc
Func chkSearchReduction()
If GUICtrlRead($g_hChkSearchReduction) = $GUI_CHECKED Then
_GUICtrlEdit_SetReadOnly($g_hTxtSearchReduceCount, False)
_GUICtrlEdit_SetReadOnly($g_hTxtSearchReduceGold, False)
_GUICtrlEdit_SetReadOnly($g_hTxtSearchReduceElixir, False)
_GUICtrlEdit_SetReadOnly($g_hTxtSearchReduceGoldPlusElixir, False)
_GUICtrlEdit_SetReadOnly($g_hTxtSearchReduceDark, False)
_GUICtrlEdit_SetReadOnly($g_hTxtSearchReduceTrophy, False)
Else
_GUICtrlEdit_SetReadOnly($g_hTxtSearchReduceCount, True)
_GUICtrlEdit_SetReadOnly($g_hTxtSearchReduceGold, True)
_GUICtrlEdit_SetReadOnly($g_hTxtSearchReduceGoldPlusElixir, True)
_GUICtrlEdit_SetReadOnly($g_hTxtSearchReduceElixir, True)
_GUICtrlEdit_SetReadOnly($g_hTxtSearchReduceDark, True)
_GUICtrlEdit_SetReadOnly($g_hTxtSearchReduceTrophy, True)
EndIf
EndFunc
Func sldMaxVSDelay()
$g_iSearchDelayMax = GUICtrlRead($g_hSldMaxVSDelay)
GUICtrlSetData($g_hLblMaxVSDelay, $g_iSearchDelayMax)
If $g_iSearchDelayMax < $g_iSearchDelayMin Then
GUICtrlSetData($g_hLblVSDelay, $g_iSearchDelayMax)
GUICtrlSetData($g_hSldVSDelay, $g_iSearchDelayMax)
$g_iSearchDelayMin = $g_iSearchDelayMax
EndIf
If $g_iSearchDelayMin = 1 Then
GUICtrlSetData($g_hLblTextVSDelay, GetTranslated(603, 7, "second"))
Else
GUICtrlSetData($g_hLblTextVSDelay, GetTranslated(603, 8, "seconds"))
EndIf
If $g_iSearchDelayMax = 1 Then
GUICtrlSetData($g_hLblTextMaxVSDelay, GetTranslated(603, 7, "second"))
Else
GUICtrlSetData($g_hLblTextMaxVSDelay, GetTranslated(603, 8, "seconds"))
EndIf
EndFunc
Func sldVSDelay()
$g_iSearchDelayMin = GUICtrlRead($g_hSldVSDelay)
GUICtrlSetData($g_hLblVSDelay, $g_iSearchDelayMin)
If $g_iSearchDelayMin > $g_iSearchDelayMax Then
GUICtrlSetData($g_hLblMaxVSDelay, $g_iSearchDelayMin)
GUICtrlSetData($g_hSldMaxVSDelay, $g_iSearchDelayMin)
$g_iSearchDelayMax = $g_iSearchDelayMin
EndIf
If $g_iSearchDelayMin = 1 Then
GUICtrlSetData($g_hLblTextVSDelay, GetTranslated(603, 7, "second"))
Else
GUICtrlSetData($g_hLblTextVSDelay, GetTranslated(603, 8, "seconds"))
EndIf
If $g_iSearchDelayMax = 1 Then
GUICtrlSetData($g_hLblTextMaxVSDelay, GetTranslated(603, 7, "second"))
Else
GUICtrlSetData($g_hLblTextMaxVSDelay, GetTranslated(603, 8, "seconds"))
EndIf
EndFunc
Func chkStopAtkDBNoLoot1()
If GUICtrlRead($g_hChkStopAtkDBNoLoot1) = $GUI_CHECKED Then
$g_abStopAtkNoLoot1Enable[$DB] = True
GUICtrlSetState($g_hTxtStopAtkDBNoLoot1, $GUI_ENABLE)
GUICtrlSetState($g_hLblStopAtkDBNoLoot1b, $GUI_ENABLE)
Else
$g_abStopAtkNoLoot1Enable[$DB] = False
GUICtrlSetState($g_hTxtStopAtkDBNoLoot1, $GUI_DISABLE)
GUICtrlSetState($g_hLblStopAtkDBNoLoot1b, $GUI_DISABLE)
EndIf
EndFunc
Func chkStopAtkDBNoLoot2()
If GUICtrlRead($g_hChkStopAtkDBNoLoot2) = $GUI_CHECKED Then
$g_abStopAtkNoLoot2Enable[$DB] = True
GUICtrlSetState($g_hTxtStopAtkDBNoLoot2, $GUI_ENABLE)
GUICtrlSetState($g_hLblStopAtkDBNoLoot2b, $GUI_ENABLE)
GUICtrlSetState($g_hTxtDBMinGoldStopAtk2, $GUI_ENABLE)
GUICtrlSetState($g_hTxtDBMinElixirStopAtk2, $GUI_ENABLE)
GUICtrlSetState($g_hTxtDBMinDarkElixirStopAtk2, $GUI_ENABLE)
GUICtrlSetState($g_hLblDBMinRerourcesAtk2, $GUI_ENABLE)
Else
$g_abStopAtkNoLoot2Enable[$DB] = False
GUICtrlSetState($g_hTxtStopAtkDBNoLoot2, $GUI_DISABLE)
GUICtrlSetState($g_hLblStopAtkDBNoLoot2b, $GUI_DISABLE)
GUICtrlSetState($g_hTxtDBMinGoldStopAtk2, $GUI_DISABLE)
GUICtrlSetState($g_hTxtDBMinElixirStopAtk2, $GUI_DISABLE)
GUICtrlSetState($g_hTxtDBMinDarkElixirStopAtk2, $GUI_DISABLE)
GUICtrlSetState($g_hLblDBMinRerourcesAtk2, $GUI_DISABLE)
EndIf
EndFunc
Func chkStopAtkABNoLoot1()
If GUICtrlRead($g_hChkStopAtkABNoLoot1) = $GUI_CHECKED Then
$g_abStopAtkNoLoot1Enable[$LB] = True
GUICtrlSetState($g_hTxtStopAtkABNoLoot1, $GUI_ENABLE)
GUICtrlSetState($g_hLblABTimeStopAtk, $GUI_ENABLE)
Else
$g_abStopAtkNoLoot1Enable[$LB] = False
GUICtrlSetState($g_hTxtStopAtkABNoLoot1, $GUI_DISABLE)
GUICtrlSetState($g_hLblABTimeStopAtk, $GUI_DISABLE)
EndIf
EndFunc
Func chkStopAtkABNoLoot2()
If GUICtrlRead($g_hChkStopAtkABNoLoot2) = $GUI_CHECKED Then
$g_abStopAtkNoLoot2Enable[$LB] = True
GUICtrlSetState($g_hTxtStopAtkABNoLoot2, $GUI_ENABLE)
GUICtrlSetState($g_hLblABTimeStopAtk2, $GUI_ENABLE)
GUICtrlSetState($g_hTxtABMinGoldStopAtk2, $GUI_ENABLE)
GUICtrlSetState($g_hTxtABMinElixirStopAtk2, $GUI_ENABLE)
GUICtrlSetState($g_hTxtABMinDarkElixirStopAtk2, $GUI_ENABLE)
GUICtrlSetState($g_hLblABMinRerourcesAtk2, $GUI_ENABLE)
Else
$g_abStopAtkNoLoot2Enable[$LB] = False
GUICtrlSetState($g_hTxtStopAtkABNoLoot2, $GUI_DISABLE)
GUICtrlSetState($g_hLblABTimeStopAtk2, $GUI_DISABLE)
GUICtrlSetState($g_hTxtABMinGoldStopAtk2, $GUI_DISABLE)
GUICtrlSetState($g_hTxtABMinElixirStopAtk2, $GUI_DISABLE)
GUICtrlSetState($g_hTxtABMinDarkElixirStopAtk2, $GUI_DISABLE)
GUICtrlSetState($g_hLblABMinRerourcesAtk2, $GUI_DISABLE)
EndIf
EndFunc
Func chkDESideEB()
If GUICtrlRead($g_hChkDESideEB) = $GUI_CHECKED Then
For $i = $g_hTxtDELowEndMin To $g_hLblDEEndAq
GUICtrlSetState($i, $GUI_ENABLE)
Next
Else
For $i = $g_hTxtDELowEndMin To $g_hLblDEEndAq
GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
EndFunc
Func chkTSMeetDE()
_GUICtrlEdit_SetReadOnly($g_hTxtTSMinDarkElixir, GUICtrlRead($g_hChkTSMeetDE) = $GUI_CHECKED ? False : True)
EndFunc
Func btnConfigureReplayShare()
EndFunc
Func chkTakeLootSS()
GUICtrlSetState($g_hChkScreenshotLootInfo, GUICtrlRead($g_hChkTakeLootSS) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func chkTSActivateCamps2()
If GUICtrlRead($g_hChkTSActivateCamps2) = $GUI_CHECKED Then
GUICtrlSetState($g_hLblTSArmyCamps2, $GUI_ENABLE)
GUICtrlSetState($g_hTxtTSArmyCamps2, $GUI_ENABLE)
Else
GUICtrlSetState($g_hLblTSArmyCamps2, $GUI_DISABLE)
GUICtrlSetState($g_hTxtTSArmyCamps2, $GUI_DISABLE)
EndIf
EndFunc
Func chkSmartLightSpell()
If GUICtrlRead($g_hChkSmartLightSpell) = $GUI_CHECKED Then
GUICtrlSetState($g_hChkSmartZapDB, $GUI_ENABLE)
GUICtrlSetState($g_hChkSmartZapSaveHeroes, $GUI_ENABLE)
GUICtrlSetState($g_hChkNoobZap, $GUI_ENABLE)
GUICtrlSetState($g_hChkSmartEQSpell, $GUI_ENABLE)
GUICtrlSetState($g_hLblSmartUseLSpell, $GUI_SHOW)
If GUICtrlRead($g_hChkNoobZap) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtSmartMinDark, $GUI_ENABLE)
GUICtrlSetState($g_hTxtSmartExpectedDE, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtSmartMinDark, $GUI_DISABLE)
GUICtrlSetState($g_hTxtSmartExpectedDE, $GUI_DISABLE)
EndIf
$ichkSmartZap = 1
Else
GUICtrlSetState($g_hChkSmartZapDB, $GUI_DISABLE)
GUICtrlSetState($g_hChkSmartZapSaveHeroes, $GUI_DISABLE)
GUICtrlSetState($g_hTxtSmartMinDark, $GUI_DISABLE)
GUICtrlSetState($g_hChkNoobZap, $GUI_DISABLE)
GUICtrlSetState($g_hChkSmartEQSpell, $GUI_DISABLE)
GUICtrlSetState($g_hLblSmartUseLSpell, $GUI_HIDE)
GUICtrlSetState($g_hTxtSmartExpectedDE, $GUI_DISABLE)
$ichkSmartZap = 0
EndIf
EndFunc
Func chkNoobZap()
If GUICtrlRead($g_hChkNoobZap) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtSmartMinDark, $GUI_ENABLE)
GUICtrlSetState($g_hTxtSmartExpectedDE, $GUI_ENABLE)
$ichkNoobZap = 1
Else
GUICtrlSetState($g_hTxtSmartMinDark, $GUI_DISABLE)
GUICtrlSetState($g_hTxtSmartExpectedDE, $GUI_DISABLE)
$ichkNoobZap = 0
EndIf
EndFunc
Func chkEarthQuakeZap()
If GUICtrlRead($g_hChkSmartEQSpell) = $GUI_CHECKED Then
GUICtrlSetState($g_hLblSmartUseEQSpell, $GUI_SHOW)
$ichkEarthQuakeZap = 1
Else
GUICtrlSetState($g_hLblSmartUseEQSpell, $GUI_HIDE)
$ichkEarthQuakeZap = 0
EndIf
EndFunc
Func chkSmartZapDB()
$ichkSmartZapDB = GUICtrlRead($g_hChkSmartZapDB) = $GUI_CHECKED ? 1 : 0
EndFunc
Func chkSmartZapSaveHeroes()
$ichkSmartZapSaveHeroes = GUICtrlRead($g_hChkSmartZapSaveHeroes) = $GUI_CHECKED ? 1 : 0
EndFunc
Func txtMinDark()
$itxtMinDE = GUICtrlRead($g_hTxtSmartMinDark)
EndFunc
Func txtExpectedDE()
$itxtExpectedDE = GUICtrlRead($g_hTxtSmartExpectedDE)
EndFunc
Func btnLoots()
Run("Explorer.exe " & $g_sProfilePath & "\" & $g_sProfileCurrentName & "\Loots")
EndFunc
Func btnLogs()
Run("Explorer.exe " & $g_sProfilePath & "\" & $g_sProfileCurrentName & "\Logs")
EndFunc
Func btnResetStats()
ResetStats()
EndFunc
Func checkCollectors($log = False, $showLabel = True)
Local $anyCollectorsEnabled = 0
For $i = 6 To 12
If $g_abCollectorLevelEnabled[$i] Then
$anyCollectorsEnabled = 1
ExitLoop
EndIf
Next
If $anyCollectorsEnabled = 0 Then
If $showLabel Then GUICtrlSetState($g_hLblCollectorWarning, $GUI_SHOW)
If $log Then
SetLog("Warning: Dead base is enabled, but no collectors are selected!", $COLOR_ERROR)
SetLog("Dead base will never be found!", $COLOR_ERROR)
SetLog("Select some in Attack Plan-Search&Attack-DeadBase-Collectors", $COLOR_ERROR)
Return False
EndIf
ElseIf $anyCollectorsEnabled = 1 Then
If $showLabel Then GUICtrlSetState($g_hLblCollectorWarning, $GUI_HIDE)
Return True
EndIf
Return False
EndFunc
Func chkDBCollector()
For $i = 6 To 12
If $g_ahChkDBCollectorLevel[$i] = @GUI_CtrlId Then
If $i = 6 Then
$g_abCollectorLevelEnabled[6] = False
GUICtrlSetState($g_ahCmbDBCollectorLevel[6], $GUI_DISABLE)
Else
$g_abCollectorLevelEnabled[$i] =(GUICtrlRead($g_ahChkDBCollectorLevel[$i]) = $GUI_CHECKED ? True : False)
GUICtrlSetState($g_ahCmbDBCollectorLevel[$i], GUICtrlRead($g_ahChkDBCollectorLevel[$i]) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndIf
ExitLoop
EndIf
Next
checkCollectors()
EndFunc
Func cmbDBCollector()
For $i = 6 To 12
If $g_ahCmbDBCollectorLevel[$i] = @GUI_CtrlId Then
$g_aiCollectorLevelFill[$i] = _GUICtrlComboBox_GetCurSel($g_ahCmbDBCollectorLevel[$i])
ExitLoop
EndIf
Next
EndFunc
Func sldCollectorTolerance()
$g_iCollectorToleranceOffset = GUICtrlRead($g_hSldCollectorTolerance)
EndFunc
Func cmbMinCollectorMatches()
$g_iCollectorMatchesMin = _GUICtrlComboBox_GetCurSel($g_hCmbMinCollectorMatches) + 1
EndFunc
Func chkAtkGoldMines()
If GUICtrlRead($g_hChkAtkGoldMines) = $GUI_CHECKED Then
GUICtrlSetState($g_hCmbAtkGoldMinesLevel, $GUI_ENABLE)
Else
GUICtrlSetState($g_hCmbAtkGoldMinesLevel, $GUI_DISABLE)
EndIf
EndFunc
Func chkAtkDarkDrills()
If GUICtrlRead($g_hChkAtkDarkDrills) = $GUI_CHECKED Then
GUICtrlSetState($g_hCmbAtkDarkDrillsLevel, $GUI_ENABLE)
Else
GUICtrlSetState($g_hCmbAtkDarkDrillsLevel, $GUI_DISABLE)
EndIf
EndFunc
Func chkAttackMinesifGold()
If GUICtrlRead($g_hChkAttackMinesIfGold) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtAttackMinesIfGold, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtAttackMinesIfGold, $GUI_DISABLE)
EndIf
EndFunc
Func chkAttackMinesifelixir()
If GUICtrlRead($g_hChkAttackMinesIfElixir) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtAttackMinesIfElixir, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtAttackMinesIfElixir, $GUI_DISABLE)
EndIf
EndFunc
Func chkAttackMinesifdarkElixir()
If GUICtrlRead($g_hChkAttackMinesIfDarkElixir) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtAttackMinesIfDarkElixir, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtAttackMinesIfDarkElixir, $GUI_DISABLE)
EndIf
EndFunc
Func chkMilkFarmForcetolerance()
If GUICtrlRead($g_hChkMilkFarmForceTolerance) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtMilkFarmForceToleranceNormal, $GUI_ENABLE)
GUICtrlSetState($g_hTxtMilkFarmForceToleranceBoosted, $GUI_ENABLE)
GUICtrlSetState($g_hTxtMilkFarmForceToleranceDestroyed, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtMilkFarmForceToleranceNormal, $GUI_DISABLE)
GUICtrlSetState($g_hTxtMilkFarmForceToleranceBoosted, $GUI_DISABLE)
GUICtrlSetState($g_hTxtMilkFarmForceToleranceDestroyed, $GUI_DISABLE)
EndIf
EndFunc
Func chkMilkAfterAttackTHSnipe()
If GUICtrlRead($g_hChkMilkAfterAttackTHSnipe) = $GUI_CHECKED Then
For $i = $g_hGrpSnipeOutsideTHAtEnd To $g_hGrpDeploy - 1
GUICtrlSetState($i, $GUI_ENABLE)
Next
Else
For $i = $g_hGrpSnipeOutsideTHAtEnd To $g_hGrpDeploy - 1
If $i <> $g_hChkMilkAfterAttackTHSnipe Then GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
EndFunc
Func PopulateComboMilkingCSVScriptsFiles()
Dim $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($g_sCSVAttacksPath & "\*.csv")
Dim $output = ""
While True
$NewFile = FileFindNextFile($FileSearch)
If @error Then ExitLoop
$output = $output & StringLeft($NewFile, StringLen($NewFile) - 4) & "|"
WEnd
FileClose($FileSearch)
$output = StringLeft($output, StringLen($output) - 1)
_GUICtrlComboBox_ResetContent($g_hCmbMilkingCSVScriptName)
GUICtrlSetData($g_hCmbMilkingCSVScriptName, $output)
_GUICtrlComboBox_SetCurSel($g_hCmbMilkingCSVScriptName, _GUICtrlComboBox_FindStringExact($g_hCmbMilkingCSVScriptName, ""))
GUICtrlSetData($g_hLblMilkingCSVNotesScript, "")
EndFunc
Func PopulateCmbMilkSnipeAlgorithm()
Dim $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($g_sTHSnipeAttacksPath & "\*.csv")
Dim $output = ""
While True
$NewFile = FileFindNextFile($FileSearch)
If @error Then ExitLoop
$output = $output & StringLeft($NewFile, StringLen($NewFile) - 4) & "|"
WEnd
FileClose($FileSearch)
$output = StringLeft($output, StringLen($output) - 1)
_GUICtrlComboBox_ResetContent($g_hCmbMilkSnipeAlgorithm)
GUICtrlSetData($g_hCmbMilkSnipeAlgorithm, $output)
EndFunc
Func chkRandomSpeedAtkAB()
If GUICtrlRead($g_hChkRandomSpeedAtkAB) = $GUI_CHECKED Then
GUICtrlSetState($g_hCmbStandardUnitDelayAB, $GUI_DISABLE)
GUICtrlSetState($g_hCmbStandardWaveDelayAB, $GUI_DISABLE)
Else
GUICtrlSetState($g_hCmbStandardUnitDelayAB, $GUI_ENABLE)
GUICtrlSetState($g_hCmbStandardWaveDelayAB, $GUI_ENABLE)
EndIf
EndFunc
Func chkSmartAttackRedAreaAB()
If GUICtrlRead($g_hChkSmartAttackRedAreaAB) = $GUI_CHECKED Then
$g_abAttackStdSmartAttack[$LB] = 1
For $i = $g_hLblSmartDeployAB To $g_hPicAttackNearDarkElixirDrillAB
GUICtrlSetState($i, $GUI_SHOW)
Next
Else
$g_abAttackStdSmartAttack[$LB] = 0
For $i = $g_hLblSmartDeployAB To $g_hPicAttackNearDarkElixirDrillAB
GUICtrlSetState($i, $GUI_HIDE)
Next
EndIf
EndFunc
Func chkRandomSpeedAtkDB()
If GUICtrlRead($g_hChkRandomSpeedAtkDB) = $GUI_CHECKED Then
GUICtrlSetState($g_hCmbStandardUnitDelayDB, $GUI_DISABLE)
GUICtrlSetState($g_hCmbStandardWaveDelayDB, $GUI_DISABLE)
Else
GUICtrlSetState($g_hCmbStandardUnitDelayDB, $GUI_ENABLE)
GUICtrlSetState($g_hCmbStandardWaveDelayDB, $GUI_ENABLE)
EndIf
EndFunc
Func chkSmartAttackRedAreaDB()
If GUICtrlRead($g_hChkSmartAttackRedAreaDB) = $GUI_CHECKED Then
$g_abAttackStdSmartAttack[$DB] = 1
For $i = $g_hLblSmartDeployDB To $g_hPicAttackNearDarkElixirDrillDB
GUICtrlSetState($i, $GUI_SHOW)
Next
Else
$g_abAttackStdSmartAttack[$DB] = 0
For $i = $g_hLblSmartDeployDB To $g_hPicAttackNearDarkElixirDrillDB
GUICtrlSetState($i, $GUI_HIDE)
Next
EndIf
EndFunc
Func PopulateComboScriptsFilesDB()
Dim $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($g_sCSVAttacksPath & "\*.csv")
Dim $output = ""
While True
$NewFile = FileFindNextFile($FileSearch)
If @error Then ExitLoop
$output = $output & StringLeft($NewFile, StringLen($NewFile) - 4) & "|"
WEnd
FileClose($FileSearch)
$output = StringLeft($output, StringLen($output) - 1)
_GUICtrlComboBox_ResetContent($g_hCmbScriptNameDB)
GUICtrlSetData($g_hCmbScriptNameDB, $output)
_GUICtrlComboBox_SetCurSel($g_hCmbScriptNameDB, _GUICtrlComboBox_FindStringExact($g_hCmbScriptNameDB, ""))
GUICtrlSetData($g_hLblNotesScriptDB, "")
EndFunc
Func PopulateComboScriptsFilesAB()
Dim $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($g_sCSVAttacksPath & "\*.csv")
Dim $output = ""
While True
$NewFile = FileFindNextFile($FileSearch)
If @error Then ExitLoop
$output = $output & StringLeft($NewFile, StringLen($NewFile) - 4) & "|"
WEnd
FileClose($FileSearch)
$output = StringLeft($output, StringLen($output) - 1)
_GUICtrlComboBox_ResetContent($g_hCmbScriptNameAB)
GUICtrlSetData($g_hCmbScriptNameAB, $output)
_GUICtrlComboBox_SetCurSel($g_hCmbScriptNameAB, _GUICtrlComboBox_FindStringExact($g_hCmbScriptNameAB, ""))
GUICtrlSetData($g_hLblNotesScriptAB, "")
EndFunc
Func cmbScriptNameDB()
Local $tempvect1 = _GUICtrlComboBox_GetListArray($g_hCmbScriptNameDB)
Local $filename = $tempvect1[_GUICtrlComboBox_GetCurSel($g_hCmbScriptNameDB) + 1]
Local $f, $result = ""
Local $tempvect, $line, $t
If FileExists($g_sCSVAttacksPath & "\" & $filename & ".csv") Then
$f = FileOpen($g_sCSVAttacksPath & "\" & $filename & ".csv", 0)
While 1
$line = FileReadLine($f)
If @error = -1 Then ExitLoop
$tempvect = StringSplit($line, "|", 2)
If UBound($tempvect) >= 2 Then
If StringStripWS(StringUpper($tempvect[0]), 2) = "NOTE" Then $result &= $tempvect[1] & @CRLF
EndIf
WEnd
FileClose($f)
EndIf
GUICtrlSetData($g_hLblNotesScriptDB, $result)
EndFunc
Func cmbScriptNameAB()
Local $tempvect1 = _GUICtrlComboBox_GetListArray($g_hCmbScriptNameAB)
Local $filename = $tempvect1[_GUICtrlComboBox_GetCurSel($g_hCmbScriptNameAB) + 1]
Local $f, $result = ""
Local $tempvect, $line, $t
If FileExists($g_sCSVAttacksPath & "\" & $filename & ".csv") Then
$f = FileOpen($g_sCSVAttacksPath & "\" & $filename & ".csv", 0)
While 1
$line = FileReadLine($f)
If @error = -1 Then ExitLoop
$tempvect = StringSplit($line, "|", 2)
If UBound($tempvect) >= 2 Then
If StringStripWS(StringUpper($tempvect[0]), 2) = "NOTE" Then $result &= $tempvect[1] & @CRLF
EndIf
WEnd
FileClose($f)
EndIf
GUICtrlSetData($g_hLblNotesScriptAB, $result)
EndFunc
Func UpdateComboScriptNameDB()
Local $indexofscript = _GUICtrlComboBox_GetCurSel($g_hCmbScriptNameDB)
Local $scriptname
_GUICtrlComboBox_GetLBText($g_hCmbScriptNameDB, $indexofscript, $scriptname)
PopulateComboScriptsFilesDB()
_GUICtrlComboBox_SetCurSel($g_hCmbScriptNameDB, _GUICtrlComboBox_FindStringExact($g_hCmbScriptNameDB, $scriptname))
cmbScriptNameDB()
EndFunc
Func UpdateComboScriptNameAB()
Local $indexofscript = _GUICtrlComboBox_GetCurSel($g_hCmbScriptNameAB)
Local $scriptname
_GUICtrlComboBox_GetLBText($g_hCmbScriptNameAB, $indexofscript, $scriptname)
PopulateComboScriptsFilesAB()
_GUICtrlComboBox_SetCurSel($g_hCmbScriptNameAB, _GUICtrlComboBox_FindStringExact($g_hCmbScriptNameAB, $scriptname))
cmbScriptNameAB()
EndFunc
Func EditScriptDB()
Local $tempvect1 = _GUICtrlComboBox_GetListArray($g_hCmbScriptNameDB)
Local $filename = $tempvect1[_GUICtrlComboBox_GetCurSel($g_hCmbScriptNameDB) + 1]
If FileExists($g_sCSVAttacksPath & "\" & $filename & ".csv") Then
ShellExecute("notepad.exe", $g_sCSVAttacksPath & "\" & $filename & ".csv")
EndIf
EndFunc
Func EditScriptAB()
Local $tempvect1 = _GUICtrlComboBox_GetListArray($g_hCmbScriptNameAB)
Local $filename = $tempvect1[_GUICtrlComboBox_GetCurSel($g_hCmbScriptNameAB) + 1]
If FileExists($g_sCSVAttacksPath & "\" & $filename & ".csv") Then
ShellExecute("notepad.exe", $g_sCSVAttacksPath & "\" & $filename & ".csv")
EndIf
EndFunc
Func AttackCSVAssignDefaultScriptName()
Dim $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($g_sCSVAttacksPath & "\*.csv")
Dim $output = ""
$NewFile = FileFindNextFile($FileSearch)
If @error Then $output = ""
$output = StringLeft($NewFile, StringLen($NewFile) - 4)
FileClose($FileSearch)
_GUICtrlComboBox_SetCurSel($g_hCmbScriptNameDB, _GUICtrlComboBox_FindStringExact($g_hCmbScriptNameDB, $output))
_GUICtrlComboBox_SetCurSel($g_hCmbScriptNameAB, _GUICtrlComboBox_FindStringExact($g_hCmbScriptNameAB, $output))
cmbScriptNameDB()
cmbScriptNameAB()
EndFunc
Local $temp1 = GetTranslated(635, 1, "Create New Script File"), $temp2 = GetTranslated(635, 2, "New Script Filename")
Local $temp3 = GetTranslated(635, 3, "File exists, please input a new name"), $temp4 = GetTranslated(635, 4, "An error occurred when creating the file.")
Local $temp1 = 0, $temp2 = 0, $temp3 = 0, $temp4 = 0
Func NewScriptDB()
Local $filenameScript = InputBox(GetTranslated(635, 1, -1), GetTranslated(635, 2, -1) & ":")
If StringLen($filenameScript) > 0 Then
If FileExists($g_sCSVAttacksPath & "\" & $filenameScript & ".csv") Then
MsgBox("", "", GetTranslated(635, 3, -1))
Else
Local $hFileOpen = FileOpen($g_sCSVAttacksPath & "\" & $filenameScript & ".csv", $FO_APPEND)
If $hFileOpen = -1 Then
MsgBox($MB_SYSTEMMODAL, "", GetTranslated(635, 4, -1))
Return False
Else
FileClose($hFileOpen)
$g_sAttackScrScriptName[$DB] = $filenameScript
UpdateComboScriptNameDB()
UpdateComboScriptNameAB()
EndIf
EndIf
EndIf
EndFunc
Func NewScriptAB()
Local $filenameScript = InputBox(GetTranslated(635, 1, -1), GetTranslated(635, 2, -1) & ":")
If StringLen($filenameScript) > 0 Then
If FileExists($g_sCSVAttacksPath & "\" & $filenameScript & ".csv") Then
MsgBox("", "", GetTranslated(635, 3, -1))
Else
Local $hFileOpen = FileOpen($g_sCSVAttacksPath & "\" & $filenameScript & ".csv", $FO_APPEND)
If $hFileOpen = -1 Then
MsgBox($MB_SYSTEMMODAL, "", GetTranslated(635, 4, -1))
Return False
Else
FileClose($hFileOpen)
$g_sAttackScrScriptName[$LB] = $filenameScript
UpdateComboScriptNameAB()
UpdateComboScriptNameDB()
EndIf
EndIf
EndIf
EndFunc
Local $temp1 = GetTranslated(635, 5, "Copy to New Script File"), $temp2 = GetTranslated(635, 6, "Copy"), $temp3 = GetTranslated(635, 7, "to New Script Filename")
Local $temp1 = 0, $temp2 = 0, $temp3 = 0
Func DuplicateScriptDB()
Local $indexofscript = _GUICtrlComboBox_GetCurSel($g_hCmbScriptNameDB)
Local $scriptname
_GUICtrlComboBox_GetLBText($g_hCmbScriptNameDB, $indexofscript, $scriptname)
$g_sAttackScrScriptName[$DB] = $scriptname
Local $filenameScript = InputBox(GetTranslated(635, 5, -1), GetTranslated(635, 6, -1) & ": <" & $g_sAttackScrScriptName[$DB] & ">" & @CRLF & GetTranslated(635, 7, -1) & ":")
If StringLen($filenameScript) > 0 Then
If FileExists($g_sCSVAttacksPath & "\" & $filenameScript & ".csv") Then
MsgBox("", "", GetTranslated(635, 3, -1))
Else
Local $hFileOpen = FileCopy($g_sCSVAttacksPath & "\" & $g_sAttackScrScriptName[$DB] & ".csv", $g_sCSVAttacksPath & "\" & $filenameScript & ".csv")
If $hFileOpen = -1 Then
MsgBox($MB_SYSTEMMODAL, "", GetTranslated(635, 4, -1))
Return False
Else
FileClose($hFileOpen)
$g_sAttackScrScriptName[$DB] = $filenameScript
UpdateComboScriptNameDB()
UpdateComboScriptNameAB()
EndIf
EndIf
EndIf
EndFunc
Func DuplicateScriptAB()
Local $indexofscript = _GUICtrlComboBox_GetCurSel($g_hCmbScriptNameAB)
Local $scriptname
_GUICtrlComboBox_GetLBText($g_hCmbScriptNameAB, $indexofscript, $scriptname)
$g_sAttackScrScriptName[$LB] = $scriptname
Local $filenameScript = InputBox(GetTranslated(635, 5, -1), GetTranslated(635, 6, -1) & ": <" & $g_sAttackScrScriptName[$LB] & ">" & @CRLF & GetTranslated(635, 7, -1) & ":")
If StringLen($filenameScript) > 0 Then
If FileExists($g_sCSVAttacksPath & "\" & $filenameScript & ".csv") Then
MsgBox("", "", GetTranslated(635, 3, -1))
Else
Local $hFileOpen = FileCopy($g_sCSVAttacksPath & "\" & $g_sAttackScrScriptName[$LB] & ".csv", $g_sCSVAttacksPath & "\" & $filenameScript & ".csv")
If $hFileOpen = -1 Then
MsgBox($MB_SYSTEMMODAL, "", GetTranslated(635, 4, -1))
Return False
Else
FileClose($hFileOpen)
$g_sAttackScrScriptName[$LB] = $filenameScript
UpdateComboScriptNameAB()
UpdateComboScriptNameDB()
EndIf
EndIf
EndIf
EndFunc
Func cmbScriptRedlineImplDB()
$g_aiAttackScrRedlineRoutine[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbScriptRedlineImplDB)
If $g_aiAttackScrRedlineRoutine[$DB] = 3 then
GUICtrlSetState($g_hCmbScriptDroplineDB, $GUI_HIDE)
$g_aiAttackScrDroplineEdge[$DB] = $DROPLINE_FULL_EDGE_FIXED
Else
GUICtrlSetState($g_hCmbScriptDroplineDB, $GUI_SHOW)
Endif
EndFunc
Func cmbScriptRedlineImplAB()
$g_aiAttackScrRedlineRoutine[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbScriptRedlineImplAB)
If $g_aiAttackScrRedlineRoutine[$LB] = 3 then
GUICtrlSetState($g_hCmbScriptDroplineAB, $GUI_HIDE)
$g_aiAttackScrDroplineEdge[$LB] = $DROPLINE_FULL_EDGE_FIXED
Else
GUICtrlSetState($g_hCmbScriptDroplineAB, $GUI_SHOW)
EndIf
EndFunc
Func cmbScriptDroplineDB()
$g_aiAttackScrDroplineEdge[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbScriptDroplineDB)
EndFunc
Func cmbScriptDroplineAB()
$g_aiAttackScrDroplineEdge[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbScriptDroplineAB)
EndFunc
Func chkUnbreakable()
If GUICtrlRead($g_hChkUnbreakable) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtUnbreakable, $GUI_ENABLE)
GUICtrlSetState($g_hTxtUnBrkMinGold, $GUI_ENABLE)
GUICtrlSetState($g_hTxtUnBrkMaxGold, $GUI_ENABLE)
GUICtrlSetState($g_hTxtUnBrkMinElixir, $GUI_ENABLE)
GUICtrlSetState($g_hTxtUnBrkMaxElixir, $GUI_ENABLE)
GUICtrlSetState($g_hTxtUnBrkMinDark, $GUI_ENABLE)
GUICtrlSetState($g_hTxtUnBrkMaxDark, $GUI_ENABLE)
$g_iUnbrkMode = 1
ElseIf GUICtrlRead($g_hChkUnbreakable) = $GUI_UNCHECKED Then
GUICtrlSetState($g_hTxtUnbreakable, $GUI_DISABLE)
GUICtrlSetState($g_hTxtUnBrkMinGold, $GUI_DISABLE)
GUICtrlSetState($g_hTxtUnBrkMaxGold, $GUI_DISABLE)
GUICtrlSetState($g_hTxtUnBrkMinElixir, $GUI_DISABLE)
GUICtrlSetState($g_hTxtUnBrkMaxElixir, $GUI_DISABLE)
GUICtrlSetState($g_hTxtUnBrkMinDark, $GUI_DISABLE)
GUICtrlSetState($g_hTxtUnBrkMaxDark, $GUI_DISABLE)
$g_iUnbrkMode = 0
EndIf
EndFunc
Func chkPBTGenabled()
If GUICtrlRead($g_hChkNotifyPBEnable) = $GUI_CHECKED Then
$g_bNotifyPBEnable = True
GUICtrlSetState($g_hTxtNotifyPBToken, $GUI_ENABLE)
GUICtrlSetState($g_hBtnNotifyDeleteMessages, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyDeleteAllPBPushes, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyDeleteOldPBPushes, $GUI_ENABLE)
GUICtrlSetState($g_hBtnNotifyDeleteMessages, $GUI_ENABLE)
If $g_bNotifyDeletePushesOlderThan = True Then
GUICtrlSetState($g_hCmbNotifyPushHours, $GUI_ENABLE)
Else
GUICtrlSetState($g_hCmbNotifyPushHours, $GUI_DISABLE)
EndIf
Else
$g_bNotifyPBEnable = False
GUICtrlSetState($g_hChkNotifyTGEnable, $GUI_ENABLE)
GUICtrlSetState($g_hTxtNotifyPBToken, $GUI_DISABLE)
GUICtrlSetState($g_hBtnNotifyDeleteMessages, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyDeleteAllPBPushes, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyDeleteOldPBPushes, $GUI_ENABLE)
GUICtrlSetState($g_hBtnNotifyDeleteMessages, $GUI_ENABLE)
GUICtrlSetState($g_hCmbNotifyPushHours, $GUI_DISABLE)
EndIf
If GUICtrlRead($g_hChkNotifyTGEnable) = $GUI_CHECKED Then
$g_bNotifyTGEnable = True
GUICtrlSetState($g_hTxtNotifyTGToken, $GUI_ENABLE)
Else
$g_bNotifyTGEnable = False
GUICtrlSetState($g_hTxtNotifyTGToken, $GUI_DISABLE)
EndIf
If $g_bNotifyPBEnable = True Or $g_bNotifyTGEnable = True Then
GUICtrlSetState($g_hChkNotifyRemote, $GUI_ENABLE)
GUICtrlSetState($g_hTxtNotifyOrigin, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertMatchFound, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertLastRaidIMG, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertUpgradeWall, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertLastRaidTXT, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertOutOfSync, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertTakeBreak, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertVillageStats, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertLastAttack, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertAnotherDevice, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertCampFull, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertBuilderIdle, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertMaintenance, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyAlertBAN, $GUI_ENABLE)
GUICtrlSetState($g_hChkNotifyBOTUpdate, $GUI_ENABLE)
Else
GUICtrlSetState($g_hChkNotifyRemote, $GUI_DISABLE)
GUICtrlSetState($g_hTxtNotifyOrigin, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertMatchFound, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertLastRaidIMG, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertUpgradeWall, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertLastRaidTXT, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertOutOfSync, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertTakeBreak, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertVillageStats, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertLastAttack, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertAnotherDevice, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertCampFull, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertBuilderIdle, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertMaintenance, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyAlertBAN, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyBOTUpdate, $GUI_DISABLE)
GUICtrlSetState($g_hCmbNotifyPushHours, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyDeleteAllPBPushes, $GUI_DISABLE)
GUICtrlSetState($g_hChkNotifyDeleteOldPBPushes, $GUI_DISABLE)
GUICtrlSetState($g_hBtnNotifyDeleteMessages, $GUI_DISABLE)
EndIf
EndFunc
Func chkDeleteOldPBPushes()
If GUICtrlRead($g_hChkNotifyDeleteOldPBPushes) = $GUI_CHECKED Then
$g_bNotifyDeletePushesOlderThan = True
If $g_bNotifyPBEnable Then GUICtrlSetState($g_hCmbNotifyPushHours, $GUI_ENABLE)
Else
$g_bNotifyDeletePushesOlderThan = False
GUICtrlSetState($g_hCmbNotifyPushHours, $GUI_DISABLE)
EndIf
EndFunc
Func btnDeletePBMessages()
$g_bNotifyDeleteAllPushesNow = True
EndFunc
Func NotifyHelp()
If FileExists(@ScriptDir & "\Help\NotifyHelp_" & $sLanguage & ".mht") Then
ShellExecute(@ScriptDir & "\Help\NotifyHelp_" & $sLanguage & ".mht")
ElseIf FileExists(@ScriptDir & "\Help\NotifyHelp_English.mht") Then
ShellExecute(@ScriptDir & "\Help\NotifyHelp_English.mht")
EndIf
EndFunc
Func chkNotifyHours()
Local $b = GUICtrlRead($g_hChkNotifyOnlyHours) = $GUI_CHECKED
For $i = 0 To 23
GUICtrlSetState($g_hChkNotifyhours[$i], $b ? $GUI_ENABLE : $GUI_DISABLE)
Next
_GUI_Value_STATE($b ? "ENABLE" : "DISABLE", $g_hChkNotifyOnlyWeekDays&"#"&$g_hChkNotifyhoursE1&"#"&$g_hChkNotifyhoursE2)
If $b = False Then
GUICtrlSetState($g_hChkNotifyOnlyWeekDays, $GUI_UNCHECKED)
chkNotifyWeekDays()
EndIf
EndFunc
Func chkNotifyhoursE1()
Local $b = GUICtrlRead($g_hChkNotifyhoursE1) = $GUI_CHECKED And GUICtrlRead($g_hChkNotifyhours[0]) = $GUI_CHECKED
For $i = 0 To 11
GUICtrlSetState($g_hChkNotifyhours[$i], $b ? $GUI_UNCHECKED : $GUI_CHECKED)
Next
Sleep(300)
GUICtrlSetState($g_hChkNotifyhoursE1, $GUI_UNCHECKED)
EndFunc
Func chkNotifyhoursE2()
Local $b = GUICtrlRead($g_hChkNotifyhoursE2) = $GUI_CHECKED And GUICtrlRead($g_hChkNotifyhours[12]) = $GUI_CHECKED
For $i = 12 To 23
GUICtrlSetState($g_hChkNotifyhours[$i], $b ? $GUI_UNCHECKED : $GUI_CHECKED)
Next
Sleep(300)
GUICtrlSetState($g_hChkNotifyhoursE2, $GUI_UNCHECKED)
EndFunc
Func chkNotifyWeekDays()
Local $b = GUICtrlRead($g_hChkNotifyOnlyWeekDays) = $GUI_CHECKED
For $i = 0 To 6
GUICtrlSetState($g_hChkNotifyWeekdays[$i], $b ? $GUI_ENABLE : $GUI_DISABLE)
Next
GUICtrlSetState($g_ahChkNotifyWeekdaysE, $b ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func ChkNotifyWeekdaysE()
Local $b = BitOR(GUICtrlRead($g_hChkNotifyWeekdays[0]), GUICtrlRead($g_hChkNotifyWeekdays[1]), GUICtrlRead($g_hChkNotifyWeekdays[2]), GUICtrlRead($g_hChkNotifyWeekdays[3]), GUICtrlRead($g_hChkNotifyWeekdays[4]), GUICtrlRead($g_hChkNotifyWeekdays[5]), GUICtrlRead($g_hChkNotifyWeekdays[6])) = $GUI_CHECKED
For $i = 0 To 6
GUICtrlSetState($g_hChkNotifyWeekdays[$i], $b ? $GUI_UNCHECKED : $GUI_CHECKED)
Next
Sleep(300)
GUICtrlSetState($g_ahChkNotifyWeekdaysE, $GUI_UNCHECKED)
EndFunc
Func btnLocateUpgrades()
Local $wasRunState = $g_bRunState
$g_bRunState = True
LocateUpgrades()
$g_bRunState = $wasRunState
EndFunc
Func btnchkbxUpgrade()
For $i = 0 To UBound($g_avBuildingUpgrades, 1) - 1
If GUICtrlRead($g_hChkUpgrade[$i]) = $GUI_CHECKED Then
$g_abBuildingUpgradeEnable[$i] = True
Else
$g_abBuildingUpgradeEnable[$i] = False
EndIf
Next
EndFunc
Func btnchkbxRepeat()
For $i = 0 To UBound($g_avBuildingUpgrades, 1) - 1
If GUICtrlRead($g_hChkUpgradeRepeat[$i]) = $GUI_CHECKED Then
$g_abUpgradeRepeatEnable[$i] = True
Else
$g_abUpgradeRepeatEnable[$i] = False
EndIf
Next
EndFunc
Func picUpgradeTypeLocation()
Local $wasRunState = $g_bRunState
$g_bRunState = True
PureClick(1, 40, 1, 0, "#9999")
Sleep(100)
Zoomout()
Local $inum
For $inum = 0 To UBound($g_avBuildingUpgrades, 1) - 1
If @GUI_CtrlId = $g_hPicUpgradeType[$inum] Then
Local $x = $g_avBuildingUpgrades[$inum][0]
Local $y = $g_avBuildingUpgrades[$inum][1]
Local $n = $g_avBuildingUpgrades[$inum][4]
SetDebugLog("Selecting #" & $inum + 1 & ": " & $n & ", " & $x & "/" & $y)
If isInsideDiamondXY($x, $y) Then
BuildingClick($g_avBuildingUpgrades[$inum][0], $g_avBuildingUpgrades[$inum][1], "#9999")
Sleep(100)
If StringInStr($n, "collect", $STR_NOCASESENSEBASIC) Or StringInStr($n, "mine", $STR_NOCASESENSEBASIC) Or StringInStr($n, "drill", $STR_NOCASESENSEBASIC) Then
Click(1, 40, 1, 0, "#0999")
Sleep(100)
BuildingClick($g_avBuildingUpgrades[$inum][0], $g_avBuildingUpgrades[$inum][1], "#9999")
EndIf
EndIf
ExitLoop
EndIf
Next
$g_bRunState = $wasRunState
EndFunc
Func btnResetUpgrade()
For $i = 0 To UBound($g_avBuildingUpgrades, 1) - 1
If GUICtrlRead($g_hChkUpgradeRepeat[$i]) = $GUI_CHECKED Then ContinueLoop
$g_avBuildingUpgrades[$i][0] = -1
$g_avBuildingUpgrades[$i][1] = -1
$g_avBuildingUpgrades[$i][2] = -1
$g_avBuildingUpgrades[$i][3] = ""
$g_avBuildingUpgrades[$i][4] = ""
$g_avBuildingUpgrades[$i][5] = ""
$g_avBuildingUpgrades[$i][6] = ""
$g_avBuildingUpgrades[$i][7] = ""
GUICtrlSetData($g_hTxtUpgradeName[$i], "")
GUICtrlSetData($g_hTxtUpgradeLevel[$i], "")
GUICtrlSetData($g_hTxtUpgradeValue[$i], "")
GUICtrlSetData($g_hTxtUpgradeTime[$i], "")
GUICtrlSetImage($g_hPicUpgradeType[$i], $g_sLibIconPath, $eIcnBlank)
$g_aiPicUpgradeStatus[$i] = $eIcnTroops
GUICtrlSetImage($g_hPicUpgradeStatus[$i], $g_sLibIconPath, $g_aiPicUpgradeStatus[$i])
GUICtrlSetState($g_hChkUpgrade[$i], $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtUpgradeEndTime[$i], "")
GUICtrlSetState($g_hChkUpgradeRepeat[$i], $GUI_UNCHECKED)
Next
EndFunc
Func chkLab()
If GUICtrlRead($g_hChkAutoLabUpgrades) = $GUI_CHECKED Then
$g_bAutoLabUpgradeEnable = True
GUICtrlSetState($g_hPicLabUpgrade, $GUI_SHOW)
GUICtrlSetState($g_hLblNextUpgrade, $GUI_ENABLE)
GUICtrlSetState($g_hCmbLaboratory, $GUI_ENABLE)
GUICtrlSetImage($g_hPicLabUpgrade, $g_sLibIconPath, $aLabTroops[$g_iCmbLaboratory][4])
Else
$g_bAutoLabUpgradeEnable = False
GUICtrlSetState($g_hPicLabUpgrade, $GUI_HIDE)
GUICtrlSetState($g_hLblNextUpgrade, $GUI_DISABLE)
GUICtrlSetState($g_hCmbLaboratory, $GUI_DISABLE)
GUICtrlSetImage($g_hPicLabUpgrade, $g_sLibIconPath, $aLabTroops[0][4])
EndIf
LabStatusGUIUpdate()
EndFunc
Func LabStatusGUIUpdate()
If _DateIsValid($sLabUpgradeTime) Then
_GUICtrlSetTip($g_hBtnResetLabUpgradeTime, GetTranslated(614, 8, "Visible Red button means that laboratory upgrade in process") & @CRLF & GetTranslated(614, 9, "This will automatically disappear when near time for upgrade to be completed.") & @CRLF & GetTranslated(614, 10, "If upgrade has been manually finished with gems before normal end time,") & @CRLF & GetTranslated(614, 11, "Click red button to reset internal upgrade timer BEFORE STARTING NEW UPGRADE") & @CRLF & GetTranslated(614, 12, "Caution - Unnecessary timer reset will force constant checks for lab status") & @CRLF & @CRLF & GetTranslated(614, 19, "Troop Upgrade started") & ", " & GetTranslated(614, 20, "Will begin to check completion at:") & " " & $sLabUpgradeTime & @CRLF & " ")
GUICtrlSetState($g_hBtnResetLabUpgradeTime, $GUI_SHOW)
GUICtrlSetState($g_hBtnResetLabUpgradeTime, $GUI_ENABLE)
Else
GUICtrlSetState($g_hBtnResetLabUpgradeTime, $GUI_HIDE)
GUICtrlSetState($g_hBtnResetLabUpgradeTime, $GUI_DISABLE)
EndIf
EndFunc
Func cmbLab()
$g_iCmbLaboratory = _GUICtrlComboBox_GetCurSel($g_hCmbLaboratory)
GUICtrlSetImage($g_hPicLabUpgrade, $g_sLibIconPath, $aLabTroops[$g_iCmbLaboratory][4])
EndFunc
Func ResetLabUpgradeTime()
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 600)
Local $stext = @CRLF & GetTranslated(614, 13, "Are you 100% sure you want to reset lab upgrade timer?") & @CRLF & GetTranslated(614, 14, "Click OK to reset") & @CRLF & GetTranslated(614, 15, "Or Click Cancel to exit") & @CRLF
Local $MsgBox = _ExtMsgBox(0, GetTranslated(614, 16, "Reset timer") & "|" & GetTranslated(614, 17, "Cancel and Return"), GetTranslated(614, 18, "Reset laboratory upgrade timer?"), $stext, 120, $g_hFrmBot)
If $g_iDebugSetlog = 1 Then Setlog("$MsgBox= " & $MsgBox, $COLOR_DEBUG)
If $MsgBox = 1 Then
$sLabUpgradeTime = ""
_GUICtrlSetTip($g_hBtnResetLabUpgradeTime, GetTranslated(614, 8, "Visible Red button means that laboratory upgrade in process") & @CRLF & GetTranslated(614, 9, "This will automatically disappear when near time for upgrade to be completed.") & @CRLF & GetTranslated(614, 10, "If upgrade has been manually finished with gems before normal end time,") & @CRLF & GetTranslated(614, 11, "Click red button to reset internal upgrade timer BEFORE STARTING NEW UPGRADE") & @CRLF & GetTranslated(614, 12, "Caution - Unnecessary timer reset will force constant checks for lab status"))
EndIf
If _DateIsValid($sLabUpgradeTime) Then
GUICtrlSetState($g_hBtnResetLabUpgradeTime, $GUI_SHOW)
GUICtrlSetState($g_hBtnResetLabUpgradeTime, $GUI_ENABLE)
Else
GUICtrlSetState($g_hBtnResetLabUpgradeTime, $GUI_HIDE)
GUICtrlSetState($g_hBtnResetLabUpgradeTime, $GUI_DISABLE)
EndIf
EndFunc
Func chkUpgradeKing()
If $iTownHallLevel > 6 Or $iTownHallLevel = 0 Then
GUICtrlSetState($g_hChkUpgradeKing, $GUI_ENABLE)
If GUICtrlRead($g_hChkUpgradeKing) = $GUI_CHECKED Then
$g_bUpgradeKingEnable = True
GUICtrlSetState($g_hChkDBKingWait, $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABKingWait, $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBKingWait, $GUI_DISABLE)
GUICtrlSetState($g_hChkABKingWait, $GUI_DISABLE)
_GUI_Value_STATE("SHOW", $groupKingSleeping)
Else
$g_bUpgradeKingEnable = False
GUICtrlSetState($g_hChkDBKingWait, $GUI_ENABLE)
GUICtrlSetState($g_hChkABKingWait, $GUI_ENABLE)
_GUI_Value_STATE("HIDE", $groupKingSleeping)
EndIf
If GUICtrlRead($g_hCmbBoostBarbarianKing) > 0 Then
GUICtrlSetState($g_hChkUpgradeKing, $GUI_DISABLE)
GUICtrlSetState($g_hChkUpgradeKing, $GUI_UNCHECKED)
$g_bUpgradeKingEnable = False
Else
GUICtrlSetState($g_hChkUpgradeKing, $GUI_ENABLE)
EndIf
Else
GUICtrlSetState($g_hChkUpgradeKing, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndFunc
Func chkUpgradeQueen()
If $iTownHallLevel > 8 Or $iTownHallLevel = 0 Then
GUICtrlSetState($g_hChkUpgradeQueen, $GUI_ENABLE)
If GUICtrlRead($g_hChkUpgradeQueen) = $GUI_CHECKED Then
$g_bUpgradeQueenEnable = True
GUICtrlSetState($g_hChkDBQueenWait, $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABQueenWait, $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBQueenWait, $GUI_DISABLE)
GUICtrlSetState($g_hChkABQueenWait, $GUI_DISABLE)
_GUI_Value_STATE("SHOW", $groupQueenSleeping)
Else
$g_bUpgradeQueenEnable = False
GUICtrlSetState($g_hChkDBQueenWait, $GUI_ENABLE)
GUICtrlSetState($g_hChkABQueenWait, $GUI_ENABLE)
_GUI_Value_STATE("HIDE", $groupQueenSleeping)
EndIf
If GUICtrlRead($g_hCmbBoostArcherQueen) > 0 Then
GUICtrlSetState($g_hChkUpgradeQueen, $GUI_DISABLE)
GUICtrlSetState($g_hChkUpgradeQueen, $GUI_UNCHECKED)
$g_bUpgradeQueenEnable = False
Else
GUICtrlSetState($g_hChkUpgradeQueen, $GUI_ENABLE)
EndIf
Else
GUICtrlSetState($g_hChkUpgradeQueen, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndFunc
Func chkUpgradeWarden()
If $iTownHallLevel > 10 Or $iTownHallLevel = 0 Then
GUICtrlSetState($g_hChkUpgradeWarden, $GUI_ENABLE)
If GUICtrlRead($g_hChkUpgradeWarden) = $GUI_CHECKED Then
$g_bUpgradeWardenEnable = True
GUICtrlSetState($g_hChkDBWardenWait, $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABWardenWait, $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBWardenWait, $GUI_DISABLE)
GUICtrlSetState($g_hChkABWardenWait, $GUI_DISABLE)
_GUI_Value_STATE("SHOW", $groupWardenSleeping)
Else
$g_bUpgradeWardenEnable = False
GUICtrlSetState($g_hChkDBWardenWait, $GUI_ENABLE)
GUICtrlSetState($g_hChkABWardenWait, $GUI_ENABLE)
_GUI_Value_STATE("HIDE", $groupWardenSleeping)
EndIf
If GUICtrlRead($g_hCmbBoostWarden) > 0 Then
GUICtrlSetState($g_hChkUpgradeWarden, $GUI_DISABLE)
GUICtrlSetState($g_hChkUpgradeWarden, $GUI_UNCHECKED)
$g_bUpgradeWardenEnable = False
Else
GUICtrlSetState($g_hChkUpgradeWarden, $GUI_ENABLE)
EndIf
Else
GUICtrlSetState($g_hChkUpgradeWarden, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndFunc
Func chkWalls()
If GUICtrlRead($g_hChkWalls) = $GUI_CHECKED Then
$g_bAutoUpgradeWallsEnable = True
GUICtrlSetState($g_hRdoUseGold, $GUI_ENABLE)
GUICtrlSetState($g_hCmbWalls, $GUI_ENABLE)
GUICtrlSetState($g_hTxtWallMinGold, $GUI_ENABLE)
cmbWalls()
Else
$g_bAutoUpgradeWallsEnable = False
GUICtrlSetState($g_hRdoUseGold, $GUI_DISABLE)
GUICtrlSetState($g_hRdoUseElixir, $GUI_DISABLE)
GUICtrlSetState($g_hRdoUseElixirGold, $GUI_DISABLE)
GUICtrlSetState($g_hCmbWalls, $GUI_DISABLE)
GUICtrlSetState($g_hTxtWallMinGold, $GUI_DISABLE)
GUICtrlSetState($g_hTxtWallMinElixir, $GUI_DISABLE)
EndIf
EndFunc
Func chkSaveWallBldr()
$g_bUpgradeWallSaveBuilder =(GUICtrlRead($g_hChkSaveWallBldr) = $GUI_CHECKED)
EndFunc
Func cmbWalls()
$g_iCmbUpgradeWallsLevel = _GUICtrlComboBox_GetCurSel($g_hCmbWalls)
$g_iWallCost = $g_iaWallCost[$g_iCmbUpgradeWallsLevel]
GUICtrlSetData($g_hLblWallCost, _NumberFormat($g_iWallCost))
For $i = 4 To $g_iCmbUpgradeWallsLevel+5
GUICtrlSetState($g_ahWallsCurrentCount[$i], $GUI_SHOW)
GUICtrlSetState($g_ahPicWallsLevel[$i], $GUI_SHOW)
Next
For $i = $g_iCmbUpgradeWallsLevel+6 To 12
GUICtrlSetState($g_ahWallsCurrentCount[$i], $GUI_HIDE)
GUICtrlSetState($g_ahPicWallsLevel[$i], $GUI_HIDE)
Next
If $g_iCmbUpgradeWallsLevel <= 3 Then GUICtrlSetState($g_hRdoUseGold, $GUI_CHECKED)
GUICtrlSetState($g_hRdoUseElixir, $g_iCmbUpgradeWallsLevel <= 3 ? $GUI_DISABLE : $GUI_ENABLE)
GUICtrlSetState($g_hRdoUseElixirGold, $g_iCmbUpgradeWallsLevel <= 3 ? $GUI_DISABLE : $GUI_ENABLE)
GUICtrlSetState($g_hTxtWallMinElixir, $g_iCmbUpgradeWallsLevel <= 3 ? $GUI_DISABLE : $GUI_ENABLE)
EndFunc
Func btnWalls()
Local $wasRunState = $g_bRunState
$g_bRunState = True
Zoomout()
$g_iCmbUpgradeWallsLevel = _GUICtrlComboBox_GetCurSel($g_hCmbWalls)
If imglocCheckWall() Then Setlog("Hei Chef! We found the Wall!")
$g_bRunState = $wasRunState
AndroidShield("btnWalls")
EndFunc
Func btnDonateTroop()
For $i = 0 To $eTroopCount-1 + $g_iCustomDonateConfigs
If @GUI_CtrlId = $g_ahBtnDonateTroop[$i] Then
If GUICtrlGetState($g_ahGrpDonateTroop[$i]) = BitOR($GUI_HIDE, $GUI_ENABLE) Then
_DonateBtn($g_ahGrpDonateTroop[$i], $g_ahTxtBlacklistTroop[$i])
EndIf
ExitLoop
EndIf
Next
EndFunc
Func btnDonateSpell()
For $i = 0 To $eSpellCount - 1
If @GUI_CtrlId = $g_ahBtnDonateSpell[$i] Then
If GUICtrlGetState($g_ahGrpDonateSpell[$i]) = BitOR($GUI_HIDE, $GUI_ENABLE) Then
_DonateBtn($g_ahGrpDonateSpell[$i], $g_ahTxtBlacklistSpell[$i])
EndIf
ExitLoop
EndIf
Next
EndFunc
Func btnDonateBlacklist()
If GUICtrlGetState($g_hGrpDonateGeneralBlacklist) = BitOR($GUI_HIDE, $GUI_ENABLE) Then
_DonateBtn($g_hGrpDonateGeneralBlacklist, $g_hTxtGeneralBlacklist)
EndIf
EndFunc
Func chkDonateTroop()
For $i = 0 To $eTroopCount-1 + $g_iCustomDonateConfigs
If @GUI_CtrlId = $g_ahChkDonateTroop[$i] Then
If GUICtrlRead($g_ahChkDonateTroop[$i]) = $GUI_CHECKED Then
_DonateControls($i)
Else
GUICtrlSetBkColor($g_ahLblDonateTroop[$i], $GUI_BKCOLOR_TRANSPARENT)
EndIf
EndIf
Next
EndFunc
Func chkDonateAllTroop()
For $i = 0 To $eTroopCount-1 + $g_iCustomDonateConfigs
If @GUI_CtrlId = $g_ahChkDonateAllTroop[$i] Then
_DonateAllControls($i, GUICtrlRead($g_ahChkDonateAllTroop[$i]) = $GUI_CHECKED ? True : False)
ExitLoop
EndIf
Next
EndFunc
Func chkDonateSpell()
For $i = 0 To $eSpellCount - 1
If @GUI_CtrlId = $g_ahChkDonateSpell[$i] Then
If GUICtrlRead($g_ahChkDonateSpell[$i]) = $GUI_CHECKED Then
_DonateControlsSpell($i)
Else
GUICtrlSetBkColor($g_ahLblDonateSpell[$i], $GUI_BKCOLOR_TRANSPARENT)
EndIf
EndIf
Next
EndFunc
Func chkDonateAllSpell()
For $i = 0 To $eSpellCount - 1
If @GUI_CtrlId = $g_ahChkDonateAllSpell[$i] Then
_DonateAllControlsSpell($i, GUICtrlRead($g_ahChkDonateAllSpell[$i]) = $GUI_CHECKED ? True : False)
ExitLoop
EndIf
Next
EndFunc
Func cmbDonateCustomA()
Local $combo1 = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomA[0])
Local $combo2 = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomA[1])
Local $combo3 = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomA[2])
GUICtrlSetImage($g_ahPicDonateCustomA[0], $g_sLibIconPath, $aDonIcons[$combo1])
GUICtrlSetImage($g_ahPicDonateCustomA[1], $g_sLibIconPath, $aDonIcons[$combo2])
GUICtrlSetImage($g_ahPicDonateCustomA[2], $g_sLibIconPath, $aDonIcons[$combo3])
EndFunc
Func cmbDonateCustomB()
Local $combo1 = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomB[0])
Local $combo2 = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomB[1])
Local $combo3 = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomB[2])
GUICtrlSetImage($g_ahPicDonateCustomB[0], $g_sLibIconPath, $aDonIcons[$combo1])
GUICtrlSetImage($g_ahPicDonateCustomB[1], $g_sLibIconPath, $aDonIcons[$combo2])
GUICtrlSetImage($g_ahPicDonateCustomB[2], $g_sLibIconPath, $aDonIcons[$combo3])
EndFunc
Func _DonateBtn($hFirstControl, $hLastControl)
Static $hLastDonateBtn1 = -1, $hLastDonateBtn2 = -1
If $hLastDonateBtn1 = -1 Then
For $i = $g_ahGrpDonateTroop[$eTroopBarbarian] To $g_ahTxtBlacklistTroop[$eTroopBarbarian]
GUICtrlSetState($i, $GUI_HIDE)
Next
Else
For $i = $hLastDonateBtn1 To $hLastDonateBtn2
GUICtrlSetState($i, $GUI_HIDE)
Next
EndIf
$hLastDonateBtn1 = $hFirstControl
$hLastDonateBtn2 = $hLastControl
For $i = $hFirstControl To $hLastControl
GUICtrlSetState($i, $GUI_SHOW)
Next
EndFunc
Func _DonateControls($iTroopIndex)
Local $bWasRedraw = SetRedrawBotWindow(False, Default, Default, Default, "_DonateControls")
For $i = 0 To $eTroopCount-1 + $g_iCustomDonateConfigs
If $i = $iTroopIndex Then
GUICtrlSetBkColor($g_ahLblDonateTroop[$i], $COLOR_ORANGE)
Else
If GUICtrlGetBkColor($g_ahLblDonateTroop[$i]) = $COLOR_NAVY Then GUICtrlSetBkColor($g_ahLblDonateTroop[$i], $GUI_BKCOLOR_TRANSPARENT)
EndIf
GUICtrlSetState($g_ahChkDonateAllTroop[$i], $GUI_UNCHECKED)
If BitAND(GUICtrlGetState($g_ahTxtDonateTroop[$i]), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($g_ahTxtDonateTroop[$i], $GUI_ENABLE)
If BitAND(GUICtrlGetState($g_ahTxtBlacklistTroop[$i]), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($g_ahTxtBlacklistTroop[$i], $GUI_ENABLE)
Next
SetRedrawBotWindowControls($bWasRedraw, $g_hGUI_DONATE_TAB, "_DonateControls")
EndFunc
Func _DonateAllControls($iTroopIndex, $Set)
Local $bWasRedraw = SetRedrawBotWindow(False, Default, Default, Default, "_DonateAllControls")
If $Set = True Then
For $i = 0 To $eTroopCount-1 + $g_iCustomDonateConfigs
GUICtrlSetBkColor($g_ahLblDonateTroop[$i], $i = $iTroopIndex ? $COLOR_NAVY : $GUI_BKCOLOR_TRANSPARENT)
If $i <> $iTroopIndex Then
GUICtrlSetState($g_ahChkDonateAllTroop[$i], $GUI_UNCHECKED)
EndIf
GUICtrlSetState($g_ahChkDonateTroop[$i], $GUI_UNCHECKED)
If BitAND(GUICtrlGetState($g_ahTxtDonateTroop[$i]), $GUI_ENABLE) = $GUI_ENABLE Then GUICtrlSetState($g_ahTxtDonateTroop[$i], $GUI_DISABLE)
If BitAND(GUICtrlGetState($g_ahTxtBlacklistTroop[$i]), $GUI_ENABLE) = $GUI_ENABLE Then GUICtrlSetState($g_ahTxtBlacklistTroop[$i], $GUI_DISABLE)
Next
If BitAND(GUICtrlGetState($g_hTxtGeneralBlacklist), $GUI_ENABLE) = $GUI_ENABLE Then GUICtrlSetState($g_hTxtGeneralBlacklist, $GUI_DISABLE)
Else
GUICtrlSetBkColor($g_ahLblDonateTroop[$iTroopIndex], $GUI_BKCOLOR_TRANSPARENT)
For $i = 0 To $eTroopCount - 1
If BitAND(GUICtrlGetState($g_ahTxtDonateTroop[$i]), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($g_ahTxtDonateTroop[$i], $GUI_ENABLE)
If BitAND(GUICtrlGetState($g_ahTxtBlacklistTroop[$i]), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($g_ahTxtBlacklistTroop[$i], $GUI_ENABLE)
Next
If BitAND(GUICtrlGetState($g_hTxtGeneralBlacklist), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($g_hTxtGeneralBlacklist, $GUI_ENABLE)
EndIf
SetRedrawBotWindowControls($bWasRedraw, $g_hGUI_DONATE_TAB, "_DonateAllControls")
EndFunc
Func _DonateControlsSpell($iSpellIndex)
For $i = 0 To $eSpellCount - 1
If $i = $iSpellIndex Then
GUICtrlSetBkColor($g_ahLblDonateSpell[$i], $COLOR_ORANGE)
Else
If GUICtrlGetBkColor($g_ahLblDonateSpell[$i]) = $COLOR_NAVY Then GUICtrlSetBkColor($g_ahLblDonateSpell[$i], $GUI_BKCOLOR_TRANSPARENT)
EndIf
GUICtrlSetState($g_ahChkDonateAllSpell[$i], $GUI_UNCHECKED)
If BitAND(GUICtrlGetState($g_ahTxtDonateSpell[$i]), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($g_ahTxtDonateSpell[$i], $GUI_ENABLE)
If BitAND(GUICtrlGetState($g_ahTxtBlacklistSpell[$i]), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($g_ahTxtBlacklistSpell[$i], $GUI_ENABLE)
Next
EndFunc
Func _DonateAllControlsSpell($iSpellIndex, $Set)
Local $bWasRedraw = SetRedrawBotWindow(False, Default, Default, Default, "_DonateAllControlsSpell")
If $Set = True Then
For $i = 0 To $eSpellCount - 1
If $i = $iSpellIndex Then
GUICtrlSetBkColor($g_ahLblDonateSpell[$i], $COLOR_NAVY)
Else
GUICtrlSetBkColor($g_ahLblDonateSpell[$i], $GUI_BKCOLOR_TRANSPARENT)
EndIf
If $i <> $iSpellIndex Then GUICtrlSetState($g_ahChkDonateAllSpell[$i], $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkDonateSpell[$i], $GUI_UNCHECKED)
If BitAND(GUICtrlGetState($g_ahTxtDonateSpell[$i]), $GUI_ENABLE) = $GUI_ENABLE Then GUICtrlSetState($g_ahTxtDonateSpell[$i], $GUI_DISABLE)
If BitAND(GUICtrlGetState($g_ahTxtBlacklistSpell[$i]), $GUI_ENABLE) = $GUI_ENABLE Then GUICtrlSetState($g_ahTxtBlacklistSpell[$i], $GUI_DISABLE)
Next
If BitAND(GUICtrlGetState($g_hTxtGeneralBlacklist), $GUI_ENABLE) = $GUI_ENABLE Then GUICtrlSetState($g_hTxtGeneralBlacklist, $GUI_DISABLE)
Else
GUICtrlSetBkColor($g_ahLblDonateSpell[$iSpellIndex], $GUI_BKCOLOR_TRANSPARENT)
For $i = 0 To $eSpellCount - 1
If BitAND(GUICtrlGetState($g_ahTxtDonateSpell[$i]), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($g_ahTxtDonateSpell[$i], $GUI_ENABLE)
If BitAND(GUICtrlGetState($g_ahTxtBlacklistSpell[$i]), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($g_ahTxtBlacklistSpell[$i], $GUI_ENABLE)
Next
If BitAND(GUICtrlGetState($g_hTxtGeneralBlacklist), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($g_hTxtGeneralBlacklist, $GUI_ENABLE)
EndIf
SetRedrawBotWindowControls($bWasRedraw, $g_hGUI_DONATE_TAB, "_DonateAllControlsSpell")
EndFunc
Func btnFilterDonationsCC()
setlog("open folder " & $g_sProfileDonateCapturePath,$color_aqua)
ShellExecute("explorer",$g_sProfileDonateCapturePath)
EndFunc
Func chkskipDonateNearFulLTroopsEnable()
If GUICtrlRead($g_hChkSkipDonateNearFullTroopsEnable) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtSkipDonateNearFullTroopsPercentage, $GUI_ENABLE)
GUICtrlSetState($g_hLblSkipDonateNearFullTroopsText, $GUI_ENABLE)
GUICtrlSetState($g_hLblSkipDonateNearFullTroopsText1, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtSkipDonateNearFullTroopsPercentage, $GUI_DISABLE)
GUICtrlSetState($g_hLblSkipDonateNearFullTroopsText, $GUI_DISABLE)
GUICtrlSetState($g_hLblSkipDonateNearFullTroopsText1, $GUI_DISABLE)
EndIf
EndFunc
Global $aLanguageFile[1][2]
Global $hLangIcons = 0
Func LoadLanguagesComboBox()
Local $hFileSearch = FileFindFirstFile($dirLanguages & "*.ini")
Local $sFilename, $sLangDisplayName = "", $iFileIndex = 0
If $hLangIcons Then _GUIImageList_Destroy($hLangIcons)
$hLangIcons = _GUIImageList_Create(16, 16, 5)
While 1
$sFilename = FileFindNextFile($hFileSearch)
If @error Then ExitLoop
ReDim $aLanguageFile[$iFileIndex + 1][3]
$aLanguageFile[$iFileIndex][0] = StringLeft($sFilename, StringLen($sFilename) - 4)
$aLanguageFile[$iFileIndex][2] = _GUIImageList_AddIcon($hLangIcons, @ScriptDir & "\lib\MBRBot.dll", Eval("e" & $aLanguageFile[$iFileIndex][0]) - 1 )
$sLangDisplayName = IniRead($dirLanguages & $sFilename, "Language", "DisplayName", "Unknown")
$aLanguageFile[$iFileIndex][1] = $sLangDisplayName
If $sLangDisplayName = "Unknown" Then
IniWrite($dirLanguages & $sFilename, "Language", "DisplayName", StringLeft($sFilename, StringLen($sFilename) - 4))
$sLangDisplayName = IniRead($dirLanguages & $sFilename, "Language", "DisplayName", "Unknown")
$aLanguageFile[$iFileIndex][1] = $sLangDisplayName
EndIf
$iFileIndex += 1
WEnd
FileClose($hFileSearch)
_GUICtrlComboBox_ResetContent($g_hCmbGUILanguage)
_GUICtrlComboBoxEx_SetImageList($g_hCmbGUILanguage, $hLangIcons)
For $i = 0 to UBound($aLanguageFile) - 1
If $aLanguageFile[$i][2] <> -1 Then
_GUICtrlComboBoxEx_AddString($g_hCmbGUILanguage, $aLanguageFile[$i][1], $aLanguageFile[$i][2], $aLanguageFile[$i][2])
Else
_GUICtrlComboBoxEx_AddString($g_hCmbGUILanguage, $aLanguageFile[$i][1], $eMissingLangIcon, $eMissingLangIcon)
EndIf
Next
_GUICtrlComboBoxEx_SetCurSel($g_hCmbGUILanguage, _GUICtrlComboBoxEx_FindStringExact($g_hCmbGUILanguage, $aLanguageFile[_ArraySearch($aLanguageFile, $sLanguage)][1]))
EndFunc
Func cmbLanguage()
Local $aLanguage = _GUICtrlComboBox_GetListArray($g_hCmbGUILanguage)
Local $sLanguageIndex = _ArraySearch($aLanguageFile, $aLanguage[_GUICtrlComboBox_GetCurSel($g_hCmbGUILanguage) + 1])
$sLanguage = $aLanguageFile[$sLanguageIndex][0]
MsgBox("", "", GetTranslated(636, 71, "Restart Bot to load program with new language:") & " " & $aLanguageFile[$sLanguageIndex][1] & " (" & $sLanguage & ")")
IniWriteS($g_sProfileConfigPath, "other", "language", $sLanguage)
ShellExecute(@ScriptFullPath,$g_sProfileCurrentName & " " & $g_sAndroidEmulator & " " & $g_sAndroidInstance & " /r")
EndFunc
Func chkUseRandomClick()
$iUseRandomClick =(GUICtrlRead($g_hChkUseRandomClick) = $GUI_CHECKED ? 1 : 0)
EndFunc
Func chkUpdatingWhenMinimized()
$iUpdatingWhenMinimized =(GUICtrlRead($g_hChkUpdatingWhenMinimized) = $GUI_CHECKED ? 1 : 0)
EndFunc
Func chkHideWhenMinimized()
$iHideWhenMinimized =(GUICtrlRead($g_hChkHideWhenMinimized) = $GUI_CHECKED ? 1 : 0)
TrayItemSetState($g_hTiHide,($iHideWhenMinimized = 1 ? $TRAY_CHECKED : $TRAY_UNCHECKED))
EndFunc
Func chkScreenshotType()
$iScreenshotType =(GUICtrlRead($g_hChkScreenshotType) = $GUI_CHECKED ? 1 : 0)
EndFunc
Func chkScreenshotHideName()
$ichkScreenshotHideName =(GUICtrlRead($g_hChkScreenshotHideName) = $GUI_CHECKED ? 1 : 0)
EndFunc
Func chkDeleteLogs()
GUICtrlSetState($g_hTxtDeleteLogsDays, GUICtrlRead($g_hChkDeleteLogs) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func chkDeleteTemp()
GUICtrlSetState($g_hTxtDeleteTempDays, GUICtrlRead($g_hChkDeleteTemp) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func chkDeleteLoots()
GUICtrlSetState($g_hTxtDeleteLootsDays, GUICtrlRead($g_hChkDeleteLoots) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func chkAutoStart()
GUICtrlSetState($g_hTxtAutostartDelay, GUICtrlRead($g_hChkAutoStart) = $GUI_CHECKED ? $GUI_ENABLE : $GUI_DISABLE)
EndFunc
Func chkDisposeWindows()
If GUICtrlRead($g_hChkAutoAlign) = $GUI_CHECKED Then
GUICtrlSetState($g_hCmbAlignmentOptions, $GUI_ENABLE)
GUICtrlSetState($g_hTxtAlignOffsetX, $GUI_ENABLE)
GUICtrlSetState($g_hTxtAlignOffsetY, $GUI_ENABLE)
Else
GUICtrlSetState($g_hCmbAlignmentOptions, $GUI_DISABLE)
GUICtrlSetState($g_hTxtAlignOffsetX, $GUI_DISABLE)
GUICtrlSetState($g_hTxtAlignOffsetY, $GUI_DISABLE)
EndIf
EndFunc
Func chkSinglePBTForced()
If GUICtrlRead($g_hChkSinglePBTForced) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtSinglePBTimeForced, $GUI_ENABLE)
GUICtrlSetState($g_hTxtPBTimeForcedExit, $GUI_ENABLE)
Else
GUICtrlSetState($g_hTxtSinglePBTimeForced, $GUI_DISABLE)
GUICtrlSetState($g_hTxtPBTimeForcedExit, $GUI_DISABLE)
EndIf
txtSinglePBTimeForced()
EndFunc
Func txtSinglePBTimeForced()
Switch Int(GUICtrlRead($g_hTxtSinglePBTimeForced))
Case 0 To 15
GUICtrlSetBkColor($g_hTxtSinglePBTimeForced, $COLOR_ERROR)
Case 16
GUICtrlSetBkColor($g_hTxtSinglePBTimeForced, $COLOR_YELLOW)
Case 17 To 999
GUICtrlSetBkColor($g_hTxtSinglePBTimeForced, $COLOR_MONEYGREEN)
EndSwitch
Switch Int(GUICtrlRead($g_hTxtPBTimeForcedExit))
Case 0 To 11
GUICtrlSetBkColor($g_hTxtPBTimeForcedExit, $COLOR_ERROR)
Case 12 To 14
GUICtrlSetBkColor($g_hTxtPBTimeForcedExit, $COLOR_YELLOW)
Case 15 To 999
GUICtrlSetBkColor($g_hTxtPBTimeForcedExit, $COLOR_MONEYGREEN)
EndSwitch
EndFunc
Func chkAutoResume()
$iChkAutoResume =(GUICtrlRead($g_hChkAutoResume) = $GUI_CHECKED ? 1 : 0)
EndFunc
Func chkDebugClick()
$g_iDebugClick =(GUICtrlRead($g_hChkDebugClick) = $GUI_CHECKED ? 1 : 0)
SetDebugLog("DebugClick " &($g_iDebugClick = 1 ? "enabled" : "disabled"))
EndFunc
Func chkDebugSetlog()
$g_iDebugSetlog =(GUICtrlRead($g_hChkDebugSetlog) = $GUI_CHECKED ? 1 : 0)
SetDebugLog("DebugSetlog " &($g_iDebugSetlog = 1 ? "enabled" : "disabled"))
EndFunc
Func chkDebugDisableZoomout()
$g_iDebugDisableZoomout =(GUICtrlRead($g_hChkDebugDisableZoomout) = $GUI_CHECKED ? 1 : 0)
SetDebugLog("DebugDisableZoomout " &($g_iDebugDisableZoomout = 1 ? "enabled" : "disabled"))
EndFunc
Func chkDebugDisableVillageCentering()
$g_iDebugDisableVillageCentering =(GUICtrlRead($g_hChkDebugDisableVillageCentering) = $GUI_CHECKED ? 1 : 0)
SetDebugLog("DebugDisableVillageCentering " &($g_iDebugDisableVillageCentering = 1 ? "enabled" : "disabled"))
EndFunc
Func chkDebugDeadbaseImage()
$g_iDebugDeadBaseImage =(GUICtrlRead($g_hChkDebugDeadbaseImage) = $GUI_CHECKED ? 1 : 0)
SetDebugLog("DebugDeadbaseImage " &($g_iDebugDeadBaseImage = 1 ? "enabled" : "disabled"))
EndFunc
Func chkDebugOcr()
$g_iDebugOcr =(GUICtrlRead($g_hChkDebugOCR) = $GUI_CHECKED ? 1 : 0)
SetDebugLog("DebugOcr " &($g_iDebugOcr = 1 ? "enabled" : "disabled"))
EndFunc
Func chkDebugImageSave()
$g_iDebugImageSave =(GUICtrlRead($g_hChkDebugImageSave) = $GUI_CHECKED ? 1 : 0)
SetDebugLog("DebugImageSave " &($g_iDebugImageSave = 1 ? "enabled" : "disabled"))
EndFunc
Func chkDebugBuildingPos()
$g_iDebugBuildingPos =(GUICtrlRead($g_hChkdebugBuildingPos) = $GUI_CHECKED ? 1 : 0)
SetDebugLog("DebugBuildingPos " &($g_iDebugBuildingPos = 1 ? "enabled" : "disabled"))
EndFunc
Func chkDebugTrain()
$g_iDebugSetlogTrain =(GUICtrlRead($g_hChkdebugTrain) = $GUI_CHECKED ? 1 : 0)
SetDebugLog("DebugTrain " &($g_iDebugSetlogTrain = 1 ? "enabled" : "disabled"))
EndFunc
Func chkdebugOCRDonate()
$g_iDebugOCRdonate =(GUICtrlRead($g_hChkDebugOCRDonate) = $GUI_CHECKED ? 1 : 0)
SetDebugLog("DebugOCRDonate " &($g_iDebugOCRdonate = 1 ? "enabled" : "disabled"))
EndFunc
Func chkdebugAttackCSV()
$g_iDebugAttackCSV =(GUICtrlRead($g_hChkdebugAttackCSV) = $GUI_CHECKED ? 1 : 0)
SetDebugLog("DebugAttackCSV " &($g_iDebugAttackCSV = 1 ? "enabled" : "disabled"))
EndFunc
Func chkmakeIMGCSV()
$g_iDebugMakeIMGCSV =(GUICtrlRead($g_hChkMakeIMGCSV) = $GUI_CHECKED ? 1 : 0)
SetDebugLog("MakeIMGCSV " &($g_iDebugMakeIMGCSV = 1 ? "enabled" : "disabled"))
EndFunc
Func btnTestTrain()
Local $currentOCR = $g_iDebugOcr
Local $currentRunState = $g_bRunState
$g_bRunState = True
$g_iDebugSetlog = 1
Setlog("VillageReport...")
VillageReport()
ZoomOut()
ApplyConfig_600_17("Read")
Setlog("UpgradeWall...")
UpgradeWall()
$g_iDebugSetlog = 0
$g_iDebugOcr = $currentOCR
$g_bRunState = $currentRunState
EndFunc
Func btnTestDonateCC()
Local $currentOCR = $g_iDebugOcr
Local $currentRunState = $g_bRunState
Local $currentSetlog = $g_iDebugSetlog
_GUICtrlTab_ClickTab($g_hTabMain, 0)
$g_bRunState = True
$g_iDebugSetlog = 1
ForceCaptureRegion()
DebugImageSave("donateCC_")
SetLog(_PadStringCenter(" Test DonateCC begin (" & $g_sBotVersion & ")", 54, "="), $COLOR_INFO)
$DonationWindowY = 0
Local $aDonWinOffColors[2][3] = [[0xFFFFFF, 0, 2], [0xc7c5bc, 0, 209]]
Local $aDonationWindow = _MultiPixelSearch(409, 0, 410, $g_iDEFAULT_HEIGHT, 1, 1, Hex(0xFFFFFF, 6), $aDonWinOffColors, 10)
If IsArray($aDonationWindow) Then
$DonationWindowY = $aDonationWindow[1]
_Sleep(250)
Setlog("$DonationWindowY: " & $DonationWindowY, $COLOR_DEBUG)
Else
SetLog("Could not find the Donate Window :(", $COLOR_ERROR)
Return False
EndIf
Setlog("Detecting Troops...")
DetectSlotTroop($eBowl)
Setlog("Detecting Spells...")
DetectSlotSpell($eSkSpell)
SetLog(_PadStringCenter(" Test DonateCC end ", 54, "="), $COLOR_INFO)
ShellExecute($g_sProfileTempDebugPath & "donateCC_")
$g_iDebugOcr = $currentOCR
$g_bRunState = $currentRunState
$g_iDebugSetlog = $currentSetlog
EndFunc
Func btnTestRequestCC()
Local $currentRunState = $g_bRunState
$g_bRunState = True
$canRequestCC = True
SetLog(_PadStringCenter(" Test RequestCC begin (" & $g_sBotVersion & ")", 54, "="), $COLOR_INFO)
RequestCC()
SetLog(_PadStringCenter(" Test RequestCC end ", 54, "="), $COLOR_INFO)
$g_bRunState = $currentRunState
EndFunc
Func btnTestAttackBar()
Local $currentOCR = $g_iDebugOcr
Local $currentRunState = $g_bRunState
_GUICtrlTab_ClickTab($g_hTabMain, 0)
$g_iDebugOcr = 1
$g_bRunState = True
ForceCaptureRegion()
SetLog(_PadStringCenter(" Test Attack Bar begin (" & $g_sBotVersion & ")", 54, "="), $COLOR_INFO)
_CaptureRegion2(0, 571 + $g_iBottomOffsetY, 859, 671 + $g_iBottomOffsetY)
Local $result = DllCall($g_hLibFunctions, "str", "searchIdentifyTroop", "ptr", $hHBitmap2)
Setlog("DLL Troopsbar list: " & $result[0], $COLOR_DEBUG)
If $ichkFixClanCastle = 1 Then $result[0] = FixClanCastle($result[0])
Local $aTroopDataList = StringSplit($result[0], "|")
If $result[0] <> "" Then
For $i = 1 To $aTroopDataList[0]
Local $troopData = StringSplit($aTroopDataList[$i], "#", $STR_NOCOUNT)
If $troopData[0] = 17 Or $troopData[0] = 18 Or $troopData[0] = 19 Or $troopData[0] = 20 Then $troopData[2] = 1
Setlog("position: " & $troopData[1] & " | troop code: " & $troopData[0] & " troop name:" & NameOfTroop($troopData[0]) & " | qty: " & $troopData[2])
Next
EndIf
_CaptureRegion(0, 630, $g_iDEFAULT_WIDTH)
Local $savefolder = $g_sProfileTempDebugPath
$savefolder = $g_sProfileTempDebugPath & "Test_Attack_Bar\"
DirCreate($savefolder)
Local $debugfile
Local $Date = @MDAY & "." & @MON & "." & @YEAR
Local $Time = @HOUR & "." & @MIN & "." & @SEC
$debugfile = "Test_Attack_Bar_" & $g_sBotVersion & "_" & $Date & "_" & $Time & ".png"
_GDIPlus_ImageSaveToFile($hBitmap, $savefolder & $debugfile)
SetLog(_PadStringCenter(" Test Attack Bar end ", 54, "="), $COLOR_INFO)
ShellExecute($savefolder)
$g_iDebugOcr = $currentOCR
$g_bRunState = $currentRunState
EndFunc
Func btnTestClickDrag()
Local $i
SetLog("Testing Click drag functionality...", $COLOR_INFO)
For $i = 0 To 4
SetLog("Click x1/y1=100/600 and drag to x2/y2=150/600", $COLOR_INFO)
ClickDrag(100, 600, 150, 600)
Next
SetDebugLog("Waiting 3 Seconds...")
_SleepStatus(3000, True, True, False)
For $i = 0 To 4
SetLog("Click x1/y1=150/600 and drag to x2/y2=100/600", $COLOR_INFO)
ClickDrag(150, 600, 100, 600)
Next
EndFunc
Func btnTestImage()
Local $hBMP = 0, $hHBMP = 0
Local $sImageFile = FileOpenDialog("Select CoC screenshot to test, cancel to use live screenshot", $g_sProfileTempPath, "Image (*.png)", $FD_FILEMUSTEXIST, "", $g_hFrmBot)
If @error <> 0 Then
SetLog("Testing image cancelled, taking screenshot from " & $g_sAndroidEmulator, $COLOR_INFO)
_CaptureRegion()
$hHBMP = $hHBitmap
TestCapture($hHBMP)
Else
SetLog("Testing image " & $sImageFile, $COLOR_INFO)
$hBMP = _GDIPlus_BitmapCreateFromFile($sImageFile)
$hHBMP = _GDIPlus_BitmapCreateDIBFromBitmap($hBMP)
_GDIPlus_BitmapDispose($hBMP)
TestCapture($hHBMP)
SetLog("Testing image hHBitmap = " & $hHBMP)
EndIf
Local $i
Local $result
Local $currentRunState = $g_bRunState
$g_bRunState = True
For $i = 0 To 0
SetLog("Testing image #" & $i & " " & $sImageFile, $COLOR_INFO)
_CaptureRegion()
SetLog("Testing checkObstacles...", $COLOR_SUCCESS)
$result = checkObstacles()
SetLog("Testing checkObstacles DONE, $Result=" & $result, $COLOR_SUCCESS)
SetLog("Testing waitMainScreen...", $COLOR_SUCCESS)
$result = waitMainScreen()
SetLog("Testing waitMainScreen DONE, $Result=" & $result, $COLOR_SUCCESS)
SetLog("Testing waitMainScreenMini...", $COLOR_SUCCESS)
$result = waitMainScreenMini()
SetLog("Testing waitMainScreenMini DONE, $Result=" & $result, $COLOR_SUCCESS)
SetLog("Testing WaitForClouds...", $COLOR_SUCCESS)
SetLog("$aNoCloudsAttack pixel check: " & _CheckPixel($aNoCloudsAttack, $g_bCapturePixel))
SetLog("Testing WaitForClouds DONE", $COLOR_SUCCESS)
SetLog("Testing checkAttackDisable...", $COLOR_SUCCESS)
SetLog("Testing checkAttackDisable($iTaBChkAttack)...", $COLOR_SUCCESS)
SetLog("checkAttackDisable($iTaBChkAttack) = " & checkAttackDisable($iTaBChkAttack))
SetLog("Testing checkAttackDisable($iTaBChkIdle)...", $COLOR_SUCCESS)
SetLog("checkAttackDisable($iTaBChkIdle) = " & checkAttackDisable($iTaBChkIdle))
SetLog("Testing checkAttackDisable($iTaBChkTime)...", $COLOR_SUCCESS)
SetLog("checkAttackDisable($iTaBChkTime) = " & checkAttackDisable($iTaBChkTime))
SetLog("Testing checkAttackDisable DONE", $COLOR_SUCCESS)
Next
SetLog("Testing finished", $COLOR_INFO)
_WinAPI_DeleteObject($hHBMP)
TestCapture(0)
$g_bRunState = $currentRunState
EndFunc
Func btnTestVillageSize()
BeginImageTest()
Local $currentRunState = $g_bRunState
$g_bRunState = True
_CaptureRegion()
_CaptureRegion2Sync()
SetLog("Testing GetVillageSize()", $COLOR_INFO)
Local $hTimer = TimerInit()
Local $village = GetVillageSize()
Local $ms = TimerDiff($hTimer)
If $village = 0 Then
SetLog("Village not found (" & Round($ms, 0) & " ms.)", $COLOR_WARNING)
Else
SetLog("Village found (" & Round($ms, 0) & " ms.)", $COLOR_WARNING)
SetLog("Village size: " & $village[0])
SetLog("Village zoom level: " & $village[1])
SetLog("Village offset x: " & $village[2])
SetLog("Village offset y: " & $village[3])
SetLog("Village stone " & $village[6] & ": " & $village[4] & ", " & $village[5])
SetLog("Village tree " & $village[9] & ": " & $village[7] & ", " & $village[8])
EndIf
EndImageTest()
$g_bRunState = $currentRunState
EndFunc
Func btnTestDeadBase()
Local $hBMP = 0, $hHBMP = 0
Local $sImageFile = FileOpenDialog("Select CoC screenshot to test, cancel to use live screenshot", $g_sProfileTempPath, "Image (*.png)", $FD_FILEMUSTEXIST, "", $g_hFrmBot)
If @error <> 0 Then
SetLog("Testing image cancelled, taking screenshot from " & $g_sAndroidEmulator, $COLOR_INFO)
_CaptureRegion()
$hHBMP = $hHBitmap
TestCapture($hHBMP)
Else
SetLog("Testing image " & $sImageFile, $COLOR_INFO)
$hBMP = _GDIPlus_BitmapCreateFromFile($sImageFile)
$hHBMP = _GDIPlus_BitmapCreateDIBFromBitmap($hBMP)
_GDIPlus_BitmapDispose($hBMP)
TestCapture($hHBMP)
SetLog("Testing image hHBitmap = " & $hHBMP)
EndIf
Local $currentRunState = $g_bRunState
$g_bRunState = True
SearchZoomOut($aCenterEnemyVillageClickDrag, True, "btnTestDeadBase")
ResetTHsearch()
SetLog("Testing FindTownhall()", $COLOR_INFO)
SetLog("FindTownhall() = " & FindTownhall(True), $COLOR_INFO)
SetLog("$IMGLOCREDLINE = " & $IMGLOCREDLINE, $COLOR_INFO)
SetLog("Testing checkDeadBase()", $COLOR_INFO)
SetLog("Result checkDeadBase() = " & checkDeadBase(), $COLOR_INFO)
SetLog("Testing checkDeadBase() DONE", $COLOR_INFO)
If $hHBMP <> 0 Then
_WinAPI_DeleteObject($hHBMP)
TestCapture(0)
EndIf
$g_bRunState = $currentRunState
EndFunc
Func btnTestDeadBaseFolder()
Local $directory = FileSelectFolder("Select folder of CoC village screenshot to test for dead base", "", $FSF_NEWDIALOG, @ScriptDir, $g_hFrmBot)
If @error <> 0 Then
SetLog("btnTestDeadBaseFolder cancelled", $COLOR_INFO)
EndIf
Local $oldFill = 'checkDeadBaseSuperNew(False, "' & @ScriptDir & "\imgxml\deadbase\elix\fill\old\" & '")'
Local $newFill = 'checkDeadBaseSuperNew(False, "' & @ScriptDir & "\imgxml\deadbase\elix\fill\new\" & '")'
checkDeadBaseFolder($directory, $oldFill, $newFill)
EndFunc
Func btnTestAttackCSV()
Local $hBMP = 0, $hHBMP = 0
Local $sImageFile = FileOpenDialog("Select CoC screenshot to test, cancel to use live screenshot", @ScriptDir & "\Zombies", "Image (*.png)", $FD_FILEMUSTEXIST, "", $g_hFrmBot)
If @error <> 0 Then
SetLog("Testing image cancelled, taking screenshot from " & $g_sAndroidEmulator, $COLOR_INFO)
_CaptureRegion()
$hHBMP = $hHBitmap
TestCapture($hHBMP)
Else
SetLog("Testing image " & $sImageFile, $COLOR_INFO)
$hBMP = _GDIPlus_BitmapCreateFromFile($sImageFile)
$hHBMP = _GDIPlus_BitmapCreateDIBFromBitmap($hBMP)
_GDIPlus_BitmapDispose($hBMP)
TestCapture($hHBMP)
SetLog("Testing image hHBitmap = " & $hHBMP)
EndIf
Local $currentRunState = $g_bRunState
Local $currentDebugAttackCSV = $g_iDebugAttackCSV
Local $currentMakeIMGCSV = $g_iDebugMakeIMGCSV
$g_bRunState = True
$g_iDebugAttackCSV = 1
$g_iDebugMakeIMGCSV = 1
SearchZoomOut($aCenterEnemyVillageClickDrag, True, "btnTestAttackCSV")
ResetTHsearch()
SetLog("Testing FindTownhall()", $COLOR_INFO)
SetLog("FindTownhall() = " & FindTownhall(True), $COLOR_INFO)
SetLog("$IMGLOCREDLINE = " & $IMGLOCREDLINE, $COLOR_INFO)
SetLog("Testing Algorithm_AttackCSV()", $COLOR_INFO)
Algorithm_AttackCSV()
SetLog("Testing Algorithm_AttackCSV() DONE", $COLOR_INFO)
If $hHBMP <> 0 Then
_WinAPI_DeleteObject($hHBMP)
TestCapture(0)
EndIf
$g_bRunState = $currentRunState
$g_iDebugAttackCSV = $currentDebugAttackCSV
$g_iDebugMakeIMGCSV = $currentMakeIMGCSV
EndFunc
Func btnTestFindButton()
BeginImageTest()
Local $result
Local $sButton = GUICtrlRead($g_hTxtTestFindButton)
SetLog("Testing findButton(""" & $sButton & """)", $COLOR_INFO)
$result = findButton($sButton)
$result =((IsArray($result)) ?(_ArrayToString($result, ",")) :($result))
If @error Then $result = "Error " & @error & ", " & @extended & ", "
SetLog("Result findButton(""" & $sButton & """) = " & $result, $COLOR_INFO)
SetLog("Testing findButton(""" & $sButton & """) DONE" , $COLOR_INFO)
EndImageTest()
EndFunc
Func btnTestCleanYard()
Local $currentRunState = $g_bRunState
Local $iCurrFreeBuilderCount = $iFreeBuilderCount
$iTestFreeBuilderCount = 5
$g_bRunState = True
BeginImageTest()
Local $result
SetLog("Testing CleanYard", $COLOR_INFO)
SearchZoomOut($aCenterEnemyVillageClickDrag, True, "btnTestCleanYard")
$result = CleanYard()
$result =((IsArray($result)) ?(_ArrayToString($result, ",")) :($result))
If @error Then $result = "Error " & @error & ", " & @extended & ", "
SetLog("Result CleanYard", $COLOR_INFO)
SetLog("Testing CheckTombs", $COLOR_INFO)
$result = CheckTombs()
$result =((IsArray($result)) ?(_ArrayToString($result, ",")) :($result))
If @error Then $result = "Error " & @error & ", " & @extended & ", "
SetLog("Result CheckTombs", $COLOR_INFO)
SetLog("Testing CleanYard DONE" , $COLOR_INFO)
EndImageTest()
$iTestFreeBuilderCount = -1
$iFreeBuilderCount = $iCurrFreeBuilderCount
$g_bRunState = $currentRunState
EndFunc
Func BeginImageTest($directory = $g_sProfileTempPath)
Local $hBMP = 0, $hHBMP = 0
Local $sImageFile = FileOpenDialog("Select CoC screenshot to test, cancel to use live screenshot", $directory, "Image (*.png)", $FD_FILEMUSTEXIST, "", $g_hFrmBot)
If @error <> 0 Then
SetLog("Testing image cancelled, taking screenshot from " & $g_sAndroidEmulator, $COLOR_INFO)
ZoomOut()
_CaptureRegion()
$hHBMP = $hHBitmap
TestCapture($hHBMP)
Return False
EndIf
SetLog("Testing image " & $sImageFile, $COLOR_INFO)
$hBMP = _GDIPlus_BitmapCreateFromFile($sImageFile)
$hHBMP = _GDIPlus_BitmapCreateDIBFromBitmap($hBMP)
_GDIPlus_BitmapDispose($hBMP)
TestCapture($hHBMP)
SetLog("Testing image hHBitmap = " & $hHBMP)
Return True
EndFunc
Func EndImageTest()
TestCapture(0)
EndFunc
Func FixClanCastle($inputString)
Local $OutputFinal = ""
Local $aTroopDataList = StringSplit($inputString, "|")
Local $counter = 0
If $inputString <> "" Then
For $i = 1 To $aTroopDataList[0]
If $counter > 0 Then $OutputFinal &= "|"
Local $troopData = StringSplit($aTroopDataList[$i], "#", $STR_NOCOUNT)
If $troopData[0] = 17 Or $troopData[0] = 18 Or $troopData[0] = 19 Or $troopData[0] = 20 Then $troopData[2] = 1
If $counter <> Number($troopData[1]) Then
$OutputFinal &= $eCastle & "#" & $counter & "#" & "1" & "|"
$counter = $troopData[1]
Setlog("Clan castle Forced in slot " & $counter, $COLOR_INFO)
EndIf
$counter += 1
$OutputFinal &= $troopData[0] & "#" & $troopData[1] & "#" & $troopData[2]
Next
EndIf
Return $OutputFinal
EndFunc
Func PopulatePresetComboBox()
Dim $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($g_sProfilePresetPath & "\*.ini")
Dim $output = ""
While True
$NewFile = FileFindNextFile($FileSearch)
If @error Then ExitLoop
$output = $output & StringLeft($NewFile, StringLen($NewFile) - 4) & "|"
WEnd
FileClose($FileSearch)
$output = StringLeft($output, StringLen($output) - 1)
_GUICtrlComboBox_ResetContent($g_hCmbPresetList)
GUICtrlSetData($g_hCmbPresetList, $output)
EndFunc
Func PresetLoadConfigInfo()
Local $inputfilename = $g_sProfilePresetPath & "\" & GUICtrlRead($g_hCmbPresetList) & ".ini"
Local $message = IniRead($inputfilename, "Preset", "info", "")
If StringInStr($message, "\n") > 0 Then
GUICtrlSetData($g_hTxtPresetMessage, StringReplace($message, "\n", @CRLF))
Else
GUICtrlSetData($g_hTxtPresetMessage, $message)
EndIf
GUICtrlSetState($g_hLblLoadPresetMessage, $GUI_HIDE)
GUICtrlSetState($g_hTxtPresetMessage, $GUI_SHOW)
GUICtrlSetState($g_hBtnGUIPresetLoadConf, $GUI_SHOW)
GUICtrlSetState($g_hBtnGUIPresetDeleteConf, $GUI_SHOW + $GUI_DISABLE)
GUICtrlSetState($g_hChkDeleteConf, $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDeleteConf, $GUI_SHOW)
EndFunc
Func PresetLoadConf()
Local $filename = GUICtrlRead($g_hCmbPresetList)
$g_sProfileSecondaryInputFileName = $g_sProfilePresetPath & "\" & $filename & ".ini"
SaveConfig()
readConfig()
applyConfig(False)
_GUICtrlTab_ClickTab($g_hTabMain, 0)
SetRedrawBotWindow(True, Default, Default, Default, "PresetLoadConf")
Setlog("Config " & $filename & " LOADED!", $COLOR_SUCCESS)
$g_sProfileSecondaryInputFileName = ""
EndFunc
Func PresetSaveConf()
Local $filename = GUICtrlRead($g_hTxtPresetSaveFilename)
If StringRight($filename, 4) = ".ini" Then
$filename = StringLeft($filename, StringLen($filename) - 4)
GUICtrlSetData($g_hTxtPresetSaveFilename, $filename)
EndIf
If StringRegExp($filename, '\\|/|:|\*|\?|\"|\<|\>|\|') Then GUICtrlSetData($g_hTxtPresetSaveFilename, StringRegExpReplace($filename, '\\|/|:|\*|\?|\"|\<|\>|\|', "_"))
If FileExists($g_sProfilePresetPath & "\" & $filename & ".ini") Then
Local $i = 2
While $i > 0
If FileExists($g_sProfilePresetPath & "\" & $filename & " (" & $i & ").ini") Then
$i += 1
Else
$filename = $filename & " (" & $i & ")"
GUICtrlSetData($g_hTxtPresetSaveFilename, $filename)
$i = 0
EndIf
WEnd
EndIf
Local $msg = StringReplace(GUICtrlRead($g_hTxtSavePresetMessage), @CRLF, "\n")
$g_sProfileSecondaryOutputFileName = $g_sProfilePresetPath & "\" & $filename & ".ini"
IniWrite($g_sProfileSecondaryOutputFileName, "preset", "info", $msg)
saveConfig()
readconfig()
applyConfig()
_GUICtrlTab_ClickTab($g_hTabMain, 0)
Setlog("Config " & $filename & " SAVED!", $COLOR_SUCCESS)
$g_sProfileSecondaryOutputFileName = ""
EndFunc
Func PresetDeleteConf()
Local $button = MsgBox($MB_ICONWARNING + $MB_OKCANCEL, GetTranslated(640, 70, "Delete Configuration"), GetTranslated(640, 71, 'Are you sure you want to delete the configuration ?') & GUICtrlRead($g_hCmbPresetList) & '"?' & @CRLF & "This cannot be undone.")
If $button = $IDOK Then
FileDelete($g_sProfilePresetPath & "\" & GUICtrlRead($g_hCmbPresetList) & ".ini")
saveconfig()
readconfig()
applyConfig()
EndIf
EndFunc
Func chkCheckDeleteConf()
If GUICtrlRead($g_hChkDeleteConf) = $GUI_CHECKED Then
GUICtrlSetState($g_hBtnGUIPresetDeleteConf, $GUI_ENABLE)
Else
GUICtrlSetState($g_hBtnGUIPresetDeleteConf, $GUI_DISABLE)
EndIf
EndFunc
Func MakeSavePresetMessage()
Local $message = ""
$message &= "NOTES:" & @CRLF & @CRLF
If $iChkTrophyRange = 1 Then $message &= "TROPHIES RANGE: " & $itxtdropTrophy & " - " & $itxtMaxTrophy & @CRLF & @CRLF
$message &= "TRAIN ARMY SETTINGS:" & @CRLF
$message &= "- Custom Train Troops:" & @CRLF
For $i = 0 To $eTroopCount - 1
If $g_aiArmyCompTroops[$i] > 0 Then
$message &= "  " & $g_asTroopShortNames[$i] & " " & $g_aiArmyCompTroops[$i] & "x"
If Mod($i + 1, 4) = 0 Then $message &= @CRLF
EndIf
Next
$message &= @CRLF
$message &= "SEARCH SETTINGS:" & @CRLF
For $i = $DB To $TS
If IsSearchModeActive($i, True) Then
Switch $i
Case $DB
$message &= "- DB search: "
Case $LB
$message &= "- AS search: "
Case $TS
$message &= "- TH search: "
EndSwitch
If $g_abSearchSearchesEnable[$i] Then $message &= " " & "s. " & $g_aiSearchSearchesMin[$i] & "-" & $g_aiSearchSearchesMax[$i]
If $g_abSearchTropiesEnable[$i] Then $message &= "  " & "t. " & $g_aiSearchTrophiesMin[$i] & "-" & $g_aiSearchTrophiesMax[$i]
If $g_abSearchCampsEnable[$i] Then $message &= " " & "c. >" & $g_aiSearchCampsPct[$i] & "%"
$message &= @CRLF
Switch $i
Case $DB
$message &= "- DB filter: "
Case $LB
$message &= "- AS filter: "
Case $TS
$message &= "- TH filter: "
EndSwitch
Switch $g_aiFilterMeetGE[$i]
Case 0
$message &= " G >= " & $g_aiFilterMinGold[$i]
$message &= " & "
$message &= " E >= " & $g_aiFilterMinElixir[$i] & "  "
Case 1
$message &= " G >= " & $g_aiFilterMinGold[$i]
$message &= " or "
$message &= " E >= " & $g_aiFilterMinElixir[$i] & "  "
Case 2
$message &= " G+E >= " & $g_aiFilterMinGoldPlusElixir[$i] & "  "
EndSwitch
If $g_abFilterMeetDEEnable[$i] Then $message &= " D >= " & $g_aiFilterMeetDEMin[$i] & "  "
If $g_abFilterMeetTrophyEnable[$i] Then $message &= " TR >= " & $g_aiFilterMeetTrophyMin[$i] & "  "
If $g_abFilterMeetTH[$i] Then $message &= " TH >= " & $g_aiFilterMeetTHMin[$i] + 6 & "  "
If $g_abFilterMeetTHOutsideEnable[$i] Then $message &= " THO" & "  "
If IsWeakBaseActive($i) Then $message &= " WB" & "  "
If $g_abFilterMeetOneConditionEnable[$i] Then $message &= " MeetOne" & "  "
$message &= @CRLF
EndIf
Next
$message &= @CRLF & "ATTACK SETTINGS:" & @CRLF
For $i = $DB To $TS
If IsSearchModeActive($i, True) Then
Switch $i
Case $DB
$message &= "- DB: "
Case $LB
$message &= "- AS: "
Case $TS
$message &= "- TH: "
EndSwitch
If $i = $DB Or $i = $LB Then
Switch $g_aiAttackAlgorithm[$i]
Case "0"
$message &= "Standard Attack > "
Case "1"
$message &= "Scripted Attack > "
Case "2"
$message &= "Milking Attack   " & @CRLF
EndSwitch
EndIf
If $i = $TS Then $message &= $g_sAtkTSType & @CRLF
If($i = $DB Or $i = $LB) And $g_aiAttackAlgorithm[$i] = 0 Then
Local $tmp = StringSplit("one side|two sides|three sides|four sides|DE side|TH side", "|", 2)
$message &= $tmp[$g_aiAttackStdDropSides[$i]] & @CRLF
EndIf
EndIf
Next
$message &= @CRLF & "END BATTLE SETTINGS:" & @CRLF
For $i = $DB To $TS
If IsSearchModeActive($i, True) Then
Switch $i
Case $DB
$message &= "- DB: "
Case $LB
$message &= "- AS: "
Case $TS
$message &= "- TH: "
EndSwitch
If $g_abStopAtkNoLoot1Enable[$i] Then $message &= "wait " & $g_aiStopAtkNoLoot1Time[$i] & "  "
If $g_abStopAtkNoLoot2Enable[$i] Then $message &= "wait " & $g_aiStopAtkNoLoot2Time[$i] & " ->(" & $g_aiStopAtkNoLoot2MinGold[$i] & "," & $g_aiStopAtkNoLoot2MinElixir[$i] & "," & $g_aiStopAtkNoLoot2MinDark[$i] & ")  "
If $g_abStopAtkNoResources[$i] Then $message &= "nores "
If $g_abStopAtkOneStar[$i] Then $message &= "1star  "
If $g_abStopAtkTwoStars[$i] Then $message &= "2stars  "
EndIf
$message &= @CRLF
Next
GUICtrlSetData($g_hTxtSavePresetMessage, $message)
EndFunc
Func btnStrategyFolder()
ShellExecute("explorer",$g_sProfilePresetPath)
EndFunc
Func cmbProfile()
saveConfig()
If $ichkSwitchAccount = 1 Then
If $ichkDeleteLogs = 1 Then DeleteFiles($g_sProfileLogsPath, "*.*", $iDeleteLogsDays, 0)
If $ichkDeleteLoots = 1 Then DeleteFiles($g_sProfileLootsPath, "*.*", $iDeleteLootsDays, 0)
If $ichkDeleteTemp = 1 Then DeleteFiles($g_sProfileTempPath, "*.*", $iDeleteTempDays, 0)
If $ichkDeleteTemp = 1 Then DeleteFiles($g_sProfileTempDebugPath, "*.*", $iDeleteTempDays, 0)
EndIf
If $g_hLogFile <> 0 Then
FileClose($g_hLogFile)
$g_hLogFile = 0
EndIf
If $g_hAttackLogFile <> 0 Then
FileClose($g_hAttackLogFile)
$g_hAttackLogFile = 0
EndIf
setupProfile()
readConfig()
applyConfig()
saveConfig()
SetLog("Profile " & $g_sProfileCurrentName & " loaded from " & $g_sProfileConfigPath, $COLOR_SUCCESS)
EndFunc
Func btnAddConfirm()
Switch @GUI_CtrlId
Case $g_hBtnAddProfile
GUICtrlSetState($g_hCmbProfile, $GUI_HIDE)
GUICtrlSetState($g_hTxtVillageName, $GUI_SHOW)
GUICtrlSetState($g_hBtnAddProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnConfirmAddProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnDeleteProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnCancelProfileChange, $GUI_SHOW)
GUICtrlSetState($g_hBtnConfirmRenameProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnRenameProfile, $GUI_HIDE)
Case $g_hBtnConfirmAddProfile
Local $newProfileName = StringRegExpReplace(GUICtrlRead($g_hTxtVillageName), '[/:*?"<>|]', '_')
If FileExists($g_sProfilePath & "\" & $newProfileName) Then
MsgBox($MB_ICONWARNING, GetTranslated(637, 11, "Profile Already Exists"), GetTranslated(637, 12, "%s already exists.\r\nPlease choose another name for your profile.", $newProfileName))
Return
EndIf
$g_sProfileCurrentName = $newProfileName
createProfile()
setupProfileComboBox()
selectProfile()
GUICtrlSetState($g_hTxtVillageName, $GUI_HIDE)
GUICtrlSetState($g_hCmbProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnAddProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnConfirmAddProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnDeleteProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnCancelProfileChange, $GUI_HIDE)
GUICtrlSetState($g_hBtnConfirmRenameProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnRenameProfile, $GUI_SHOW)
If GUICtrlGetState($g_hBtnDeleteProfile) <> $GUI_ENABLE Then GUICtrlSetState($g_hBtnDeleteProfile, $GUI_ENABLE)
If GUICtrlGetState($g_hBtnRenameProfile) <> $GUI_ENABLE Then GUICtrlSetState($g_hBtnRenameProfile, $GUI_ENABLE)
Case Else
SetLog("If you are seeing this log message there is something wrong.", $COLOR_ERROR)
EndSwitch
EndFunc
Func btnDeleteCancel()
Switch @GUI_CtrlId
Case $g_hBtnDeleteProfile
Local $msgboxAnswer = MsgBox($MB_ICONWARNING + $MB_OKCANCEL, GetTranslated(637, 8, "Delete Profile"), GetTranslated(637, 14, "Are you sure you really want to delete the profile?\r\nThis action can not be undone."))
If $msgboxAnswer = $IDOK Then
deleteProfile()
GUICtrlSetData($g_hTxtVillageName, GetTranslated(637,4, "MyVillage"))
If _GUICtrlComboBox_GetCount($g_hCmbProfile) > 1 Then
setupProfileComboBox()
selectProfile()
Else
createProfile(True)
EndIf
EndIf
Case $g_hBtnCancelProfileChange
GUICtrlSetState($g_hTxtVillageName, $GUI_HIDE)
GUICtrlSetState($g_hCmbProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnConfirmAddProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnAddProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnCancelProfileChange, $GUI_HIDE)
GUICtrlSetState($g_hBtnDeleteProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnConfirmRenameProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnRenameProfile, $GUI_SHOW)
Case Else
SetLog("If you are seeing this log message there is something wrong.", $COLOR_ERROR)
EndSwitch
If GUICtrlRead($g_hCmbProfile) = "<No Profiles>" Then
GUICtrlSetState($g_hBtnDeleteProfile, $GUI_DISABLE)
GUICtrlSetState($g_hBtnRenameProfile, $GUI_DISABLE)
EndIf
EndFunc
Func btnRenameConfirm()
Switch @GUI_CtrlId
Case $g_hBtnRenameProfile
GUICtrlSetData($g_hTxtVillageName, GUICtrlRead($g_hCmbProfile))
GUICtrlSetState($g_hCmbProfile, $GUI_HIDE)
GUICtrlSetState($g_hTxtVillageName, $GUI_SHOW)
GUICtrlSetState($g_hBtnAddProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnConfirmAddProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnDeleteProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnCancelProfileChange, $GUI_SHOW)
GUICtrlSetState($g_hBtnRenameProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnConfirmRenameProfile, $GUI_SHOW)
Case $g_hBtnConfirmRenameProfile
Local $newProfileName = StringRegExpReplace(GUICtrlRead($g_hTxtVillageName), '[/:*?"<>|]', '_')
If FileExists($g_sProfilePath & "\" & $newProfileName) Then
MsgBox($MB_ICONWARNING, GetTranslated(7, 108, "Profile Already Exists"), $newProfileName & " " & GetTranslated(7, 109, "already exists.") & @CRLF & GetTranslated(7, 110, "Please choose another name for your profile"))
Return
EndIf
$g_sProfileCurrentName = $newProfileName
renameProfile()
setupProfileComboBox()
selectProfile()
GUICtrlSetState($g_hTxtVillageName, $GUI_HIDE)
GUICtrlSetState($g_hCmbProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnConfirmAddProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnAddProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnCancelProfileChange, $GUI_HIDE)
GUICtrlSetState($g_hBtnDeleteProfile, $GUI_SHOW)
GUICtrlSetState($g_hBtnConfirmRenameProfile, $GUI_HIDE)
GUICtrlSetState($g_hBtnRenameProfile, $GUI_SHOW)
Case Else
SetLog("If you are seeing this log message there is something wrong.", $COLOR_ERROR)
EndSwitch
EndFunc
Func cmbBotCond()
If _GUICtrlComboBox_GetCurSel($g_hCmbBotCond) = 15 Then
If _GUICtrlComboBox_GetCurSel($g_hCmbHoursStop) = 0 Then _GUICtrlComboBox_SetCurSel($g_hCmbHoursStop, 1)
GUICtrlSetState($g_hCmbHoursStop, $GUI_ENABLE)
Else
_GUICtrlComboBox_SetCurSel($g_hCmbHoursStop, 0)
GUICtrlSetState($g_hCmbHoursStop, $GUI_DISABLE)
EndIf
EndFunc
Func chkBotStop()
If GUICtrlRead($g_hChkBotStop) = $GUI_CHECKED Then
GUICtrlSetState($g_hCmbBotCommand, $GUI_ENABLE)
GUICtrlSetState($g_hCmbBotCond, $GUI_ENABLE)
Else
GUICtrlSetState($g_hCmbBotCommand, $GUI_DISABLE)
GUICtrlSetState($g_hCmbBotCond, $GUI_DISABLE)
EndIf
EndFunc
Func btnLocateClanCastle()
Local $wasRunState = $g_bRunState
$g_bRunState = True
ZoomOut()
LocateClanCastle()
$g_bRunState = $wasRunState
AndroidShield("btnLocateClanCastle")
EndFunc
Func btnLocateKingAltar()
LocateKingAltar()
EndFunc
Func btnLocateQueenAltar()
LocateQueenAltar()
EndFunc
Func btnLocateWardenAltar()
LocateWardenAltar()
EndFunc
Func btnLocateTownHall()
Local $wasRunState = $g_bRunState
$g_bRunState = True
ZoomOut()
LocateTownHall()
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 600)
Local $stext = @CRLF & GetTranslated(640, 72, "If you locating your TH because you upgraded,") & @CRLF & GetTranslated(640, 73, "then you must restart bot!!!") & @CRLF & @CRLF & GetTranslated(640, 74, "Click OK to restart bot, ") & @CRLF & @CRLF & GetTranslated(640, 65, "Or Click Cancel to exit") & @CRLF
Local $MsgBox = _ExtMsgBox(0, GetTranslated(640, 1, "Ok|Cancel"), GetTranslated(640, 76, "Close Bot Please!"), $stext, 120)
If $g_iDebugSetlog = 1 Then Setlog("$MsgBox= " & $MsgBox, $COLOR_DEBUG)
If $MsgBox = 1 Then
RestartBot(False, $wasRunState)
EndIf
$g_bRunState = $wasRunState
AndroidShield("btnLocateTownHall")
EndFunc
Func btnResetBuilding()
Local $wasRunState = $g_bRunState
$g_bRunState = True
While 1
If _Sleep(500) Then Return
If FileExists($g_sProfileBuildingPath) Then
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 600)
Local $stext = @CRLF & GetTranslated(640, 63, "Click OK to Delete and Reset all Building info,") & @CRLF & @CRLF & GetTranslated(640, 64, "NOTE =>> Bot will exit and need to be restarted when complete") & @CRLF & @CRLF & GetTranslated(640, 65, "Or Click Cancel to exit") & @CRLF
Local $MsgBox = _ExtMsgBox(0, GetTranslated(640, 1, "Ok|Cancel"), GetTranslated(640, 67, "Delete Building Infomation ?"), $stext, 120)
If $g_iDebugSetlog = 1 Then Setlog("$MsgBox= " & $MsgBox, $COLOR_DEBUG)
If $MsgBox = 1 Then
Local $stext = @CRLF & GetTranslated(640, 68, "Are you 100% sure you want to delete Building information ?") & @CRLF & @CRLF & GetTranslated(640, 69, "Click OK to Delete and then restart the bot (manually)") & @CRLF & @CRLF & GetTranslated(640, 65, -1) & @CRLF
Local $MsgBox = _ExtMsgBox(0, GetTranslated(640, 1, -1), GetTranslated(640, 67, -1), $stext, 120)
If $g_iDebugSetlog = 1 Then Setlog("$MsgBox= " & $MsgBox, $COLOR_DEBUG)
If $MsgBox = 1 Then
Local $Result = FileDelete($g_sProfileBuildingPath)
If $Result = 0 Then
Setlog("Unable to remove building.ini file, please use manual method", $COLOR_ERROR)
Else
BotClose(False)
EndIf
EndIf
EndIf
Else
Setlog("Building.ini file does not exist", $COLOR_INFO)
EndIf
ExitLoop
WEnd
$g_bRunState = $wasRunState
AndroidShield("btnResetBuilding")
EndFunc
Func btnLab()
Local $wasRunState = $g_bRunState
$g_bRunState = True
ZoomOut()
LocateLab()
$g_bRunState = $wasRunState
AndroidShield("btnLab")
EndFunc
Func chkTrophyAtkDead()
If GUICtrlRead($g_hChkTrophyAtkDead) = $GUI_CHECKED Then
$ichkTrophyAtkDead = 1
GUICtrlSetState($g_hTxtDropTrophyArmyMin, $GUI_ENABLE)
GUICtrlSetState($g_hLblDropTrophyArmyMin, $GUI_ENABLE)
GUICtrlSetState($g_hLblDropTrophyArmyPercent, $GUI_ENABLE)
Else
$ichkTrophyAtkDead = 0
GUICtrlSetState($g_hTxtDropTrophyArmyMin, $GUI_DISABLE)
GUICtrlSetState($g_hLblDropTrophyArmyMin, $GUI_DISABLE)
GUICtrlSetState($g_hLblDropTrophyArmyPercent, $GUI_DISABLE)
EndIf
EndFunc
Func chkTrophyRange()
If GUICtrlRead($g_hChkTrophyRange) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtDropTrophy, $GUI_ENABLE)
GUICtrlSetState($g_hTxtMaxTrophy, $GUI_ENABLE)
GUICtrlSetState($g_hChkTrophyHeroes, $GUI_ENABLE)
GUICtrlSetState($g_hChkTrophyAtkDead, $GUI_ENABLE)
chkTrophyAtkDead()
chkTrophyHeroes()
Else
GUICtrlSetState($g_hTxtDropTrophy, $GUI_DISABLE)
GUICtrlSetState($g_hTxtMaxTrophy, $GUI_DISABLE)
GUICtrlSetState($g_hChkTrophyHeroes, $GUI_DISABLE)
GUICtrlSetState($g_hChkTrophyAtkDead, $GUI_DISABLE)
GUICtrlSetState($g_hTxtDropTrophyArmyMin, $GUI_DISABLE)
GUICtrlSetState($g_hLblDropTrophyArmyMin, $GUI_DISABLE)
GUICtrlSetState($g_hLblDropTrophyArmyPercent, $GUI_DISABLE)
GUICtrlSetState($g_hLblTrophyHeroesPriority, $GUI_DISABLE)
GUICtrlSetState($g_hCmbTrophyHeroesPriority, $GUI_DISABLE)
EndIf
EndFunc
Func chkTrophyHeroes()
If GUICtrlRead($g_hChkTrophyHeroes) = $GUI_CHECKED Then
GUICtrlSetState($g_hLblTrophyHeroesPriority, $GUI_ENABLE)
GUICtrlSetState($g_hCmbTrophyHeroesPriority, $GUI_ENABLE)
Else
GUICtrlSetState($g_hLblTrophyHeroesPriority, $GUI_DISABLE)
GUICtrlSetState($g_hCmbTrophyHeroesPriority, $GUI_DISABLE)
EndIf
EndFunc
Func LoadCOCDistributorsComboBox()
Local $sDistributors = $NO_COC
Local $aDistributorsData = GetCOCDistributors()
If @error = 2 Then
$sDistributors = $UNKNOWN_COC
ElseIf IsArray($aDistributorsData) Then
$sDistributors = _ArrayToString($aDistributorsData, "|")
EndIf
GUICtrlSetData($g_hCmbCOCDistributors, "", "")
GUICtrlSetData($g_hCmbCOCDistributors, $sDistributors)
EndFunc
Func SetCurSelCmbCOCDistributors()
Local $sIniDistributor
Local $iIndex
If _GUICtrlComboBox_GetCount($g_hCmbCOCDistributors) = 1 Then
_GUICtrlComboBox_SetCurSel($g_hCmbCOCDistributors, 0)
GUICtrlSetState($g_hCmbCOCDistributors, $GUI_DISABLE)
Else
$sIniDistributor = GetCOCTranslated($g_sAndroidGameDistributor)
$iIndex = _GUICtrlComboBox_FindStringExact($g_hCmbCOCDistributors, $sIniDistributor)
If $iIndex = -1 Then
_GUICtrlComboBox_SetCurSel($g_hCmbCOCDistributors, 0)
Else
_GUICtrlComboBox_SetCurSel($g_hCmbCOCDistributors, $iIndex)
EndIf
GUICtrlSetState($g_hCmbCOCDistributors, $GUI_ENABLE)
EndIf
EndFunc
Func cmbCOCDistributors()
Local $sDistributor
_GUICtrlComboBox_GetLBText($g_hCmbCOCDistributors, _GUICtrlComboBox_GetCurSel($g_hCmbCOCDistributors), $sDistributor)
If $sDistributor = $g_sUserGameDistributor Then
$g_sAndroidGameDistributor = $g_sUserGameDistributor
$g_sAndroidGamePackage = $g_sUserGamePackage
$g_sAndroidGameClass = $g_sUserGameClass
Else
GetCOCUnTranslated($sDistributor)
If Not @error Then
$g_sAndroidGameDistributor = GetCOCUnTranslated($sDistributor)
$g_sAndroidGamePackage = GetCOCPackage($sDistributor)
$g_sAndroidGameClass = GetCOCClass($sDistributor)
EndIf
EndIf
EndFunc
Func DistributorsBotStopEvent()
LoadCOCDistributorsComboBox()
SetCurSelCmbCOCDistributors()
EndFunc
Func BotStart()
ResumeAndroid()
CalCostCamp()
CalCostSpell()
$g_bRunState = True
$g_bTogglePauseAllowed = True
$g_bSkipFirstZoomout = False
$Is_SearchLimit = False
$Is_ClientSyncError = False
EnableControls($g_hFrmBotBottom, False, $g_aFrmBotBottomCtrlState)
$bTrainEnabled = True
$bDonationEnabled = True
$g_bMeetCondStop = False
$Is_ClientSyncError = False
$bDisableBreakCheck = False
$bDisableDropTrophy = False
If Not $bSearchMode Then
CreateLogFile()
CreateAttackLogFile()
If $g_iFirstRun = -1 Then $g_iFirstRun = 1
EndIf
_GUICtrlEdit_SetText($g_hTxtLog, _PadStringCenter(" BOT LOG ", 71, "="))
_GUICtrlRichEdit_SetFont($g_hTxtLog, 6, "Lucida Console")
_GUICtrlRichEdit_AppendTextColor($g_hTxtLog, "" & @CRLF, _ColorConvert($Color_Black))
SaveConfig()
readConfig()
applyConfig(False)
NotifyGetLastMessageFromTelegram()
If BitAND($g_iAndroidSupportFeature, 1 + 2) = 0 And $g_bChkBackgroundMode = True Then
GUICtrlSetState($g_hChkBackgroundMode, $GUI_UNCHECKED)
chkBackground()
SetLog("Background Mode not supported for " & $g_sAndroidEmulator & " and has been disabled", $COLOR_ERROR)
EndIf
GUICtrlSetState($g_hBtnStart, $GUI_HIDE)
GUICtrlSetState($g_hBtnStop, $GUI_SHOW)
GUICtrlSetState($g_hBtnPause, $GUI_SHOW)
GUICtrlSetState($g_hBtnResume, $GUI_HIDE)
GUICtrlSetState($g_hBtnSearchMode, $GUI_HIDE)
GUICtrlSetState($g_hChkBackgroundMode, $GUI_DISABLE)
EnableControls($g_hFrmBotBottom, Default, $g_aFrmBotBottomCtrlState)
DisableGuiControls()
SetRedrawBotWindow(True, Default, Default, Default, "BotStart")
Local $Result = False
If WinGetAndroidHandle() = 0 Then
$Result = OpenAndroid(False)
EndIf
SetDebugLog("Android Window Handle: " & WinGetAndroidHandle())
If $HWnD <> 0 Then
If Not $g_bRunState Then Return
If $g_bAndroidBackgroundLaunched = True Or AndroidControlAvailable() Then
If Not $Result Then
$Result = InitiateLayout()
EndIf
Else
SetLog("Current " & $g_sAndroidEmulator & " Window not supported by MyBot", $COLOR_ERROR)
$Result = RebootAndroid(False)
EndIf
If Not $g_bRunState Then Return
Local $hWndActive = $HWnD
If $g_bNoFocusTampering = False And $g_bAndroidBackgroundLaunched = False And $g_bAndroidEmbedded = False Then
Local $hTimer = TimerInit()
$hWndActive = -1
Local $activeHWnD = WinGetHandle("")
While TimerDiff($hTimer) < 1000 And $hWndActive <> $HWnD And Not _Sleep(100)
$hWndActive = WinActivate($HWnD)
WEnd
WinActivate($activeHWnD)
EndIf
If Not $g_bRunState Then Return
If $hWndActive = $HWnD And($g_bAndroidBackgroundLaunched = True Or AndroidControlAvailable()) Then
Initiate()
Else
SetLog("Cannot use " & $g_sAndroidEmulator & ", please check log", $COLOR_ERROR)
btnStop()
EndIf
Else
SetLog("Cannot start " & $g_sAndroidEmulator & ", please check log", $COLOR_ERROR)
btnStop()
EndIf
EndFunc
Func BotStop()
ResumeAndroid()
$g_bRunState = False
$g_bBotPaused = False
$g_bTogglePauseAllowed = True
EnableControls($g_hFrmBotBottom, False, $g_aFrmBotBottomCtrlState)
EnableGuiControls()
DistributorsBotStopEvent()
AndroidBotStopEvent()
AndroidShield("btnStop", Default)
EnableControls($g_hFrmBotBottom, Default, $g_aFrmBotBottomCtrlState)
GUICtrlSetState($g_hChkBackgroundMode, $GUI_ENABLE)
GUICtrlSetState($g_hBtnStart, $GUI_SHOW)
GUICtrlSetState($g_hBtnStop, $GUI_HIDE)
GUICtrlSetState($g_hBtnPause, $GUI_HIDE)
GUICtrlSetState($g_hBtnResume, $GUI_HIDE)
If $iTownHallLevel > 2 Then GUICtrlSetState($g_hBtnSearchMode, $GUI_ENABLE)
GUICtrlSetState($g_hBtnSearchMode, $GUI_SHOW)
GUICtrlSetState($g_hBtnAttackNowDB, $GUI_HIDE)
GUICtrlSetState($g_hBtnAttackNowLB, $GUI_HIDE)
GUICtrlSetState($g_hBtnAttackNowTS, $GUI_HIDE)
GUICtrlSetState($g_hPicTwoArrowShield, $GUI_SHOW)
GUICtrlSetState($g_hLblVersion, $GUI_SHOW)
SetLog(_PadStringCenter(" Bot Stop ", 50, "="), $COLOR_ACTION)
If Not $bSearchMode Then
If Not $g_bBotPaused Then $g_iTimePassed += Int(TimerDiff($g_hTimerSinceStarted))
$g_bRestart = True
If $g_hLogFile <> 0 Then
FileClose($g_hLogFile)
$g_hLogFile = 0
EndIf
If $g_hAttackLogFile <> 0 Then
FileClose($g_hAttackLogFile)
$g_hAttackLogFile = 0
EndIf
Else
$bSearchMode = False
EndIf
EndFunc
Func BotSearchMode()
$bSearchMode = True
$g_bRestart = False
$Is_ClientSyncError = False
If $g_iFirstRun = 1 Then $g_iFirstRun = -1
btnStart()
checkMainScreen(False)
If _Sleep(100) Then Return
$iTrophyCurrent = getTrophyMainScreen($aTrophies[0], $aTrophies[1])
If _Sleep(100) Then Return
CheckArmySpellCastel()
ClickP($aAway, 2, 0, "")
If _Sleep(100) Then Return
If(IsSearchModeActive($DB) And checkCollectors(True, False)) Or IsSearchModeActive($LB) Or IsSearchModeActive($TS) Then
If _Sleep(100) Then Return
PrepareSearch()
If _Sleep(1000) Then Return
VillageSearch()
If _Sleep(100) Then Return
Else
Setlog("Your Army is not prepared, check the Attack/train options")
EndIf
btnStop()
EndFunc
Func DisableSX()
GUICtrlSetState($chkEnableSuperXP, $GUI_UNCHECKED)
$ichkEnableSuperXP = 0
For $i = $grpSuperXP To $lblXPSXWonHour
GUICtrlSetState($i, $GUI_DISABLE)
Next
GUICtrlSetState($lblLOCKEDSX, BitOR($GUI_SHOW, $GUI_ENABLE))
EndFunc
Func SXSetXP($toSet = "")
If $toSet = "S" Or $toSet = "" Then GUICtrlSetData($lblXPatStart, $iStartXP)
If $toSet = "C" Or $toSet = "" Then GUICtrlSetData($lblXPCurrent, $iCurrentXP)
If $toSet = "W" Or $toSet = "" Then GUICtrlSetData($lblXPSXWon, $iGainedXP)
$iGainedXPHour = Round($iGainedXP /(Int(TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600 * 1000)
If $toSet = "H" Or $toSet = "" Then GUICtrlSetData($lblXPSXWonHour, _NumberFormat($iGainedXPHour))
EndFunc
Func chkEnableSuperXP()
If GUICtrlRead($chkEnableSuperXP) = $GUI_CHECKED Then
GUICtrlSetState($rbSXTraining, $GUI_ENABLE)
GUICtrlSetState($rbSXIAttacking, $GUI_ENABLE)
GUICtrlSetState($chkSXBK, $GUI_ENABLE)
GUICtrlSetState($chkSXAQ, $GUI_ENABLE)
GUICtrlSetState($chkSXGW, $GUI_ENABLE)
GUICtrlSetState($txtMaxXPtoGain, $GUI_ENABLE)
Else
GUICtrlSetState($rbSXTraining, $GUI_DISABLE)
GUICtrlSetState($rbSXIAttacking, $GUI_DISABLE)
GUICtrlSetState($chkSXBK, $GUI_DISABLE)
GUICtrlSetState($chkSXAQ, $GUI_DISABLE)
GUICtrlSetState($chkSXGW, $GUI_DISABLE)
GUICtrlSetState($txtMaxXPtoGain, $GUI_DISABLE)
EndIf
EndFunc
Func chkEnableSuperXP2()
$ichkEnableSuperXP = GUICtrlRead($chkEnableSuperXP) = $GUI_CHECKED ? 1 : 0
$irbSXTraining = GUICtrlRead($rbSXTraining) = $GUI_CHECKED ? 1 : 2
$ichkSXBK =(GUICtrlRead($chkSXBK) = $GUI_CHECKED) ? $eHeroKing : $eHeroNone
$ichkSXAQ =(GUICtrlRead($chkSXAQ) = $GUI_CHECKED) ? $eHeroQueen : $eHeroNone
$ichkSXGW =(GUICtrlRead($chkSXGW) = $GUI_CHECKED) ? $eHeroWarden : $eHeroNone
$itxtMaxXPtoGain = Int(GUICtrlRead($txtMaxXPtoGain))
EndFunc
Func cmbDeployDB()
If _GUICtrlComboBox_GetCurSel($g_hCmbStandardDropSidesDB) = 4 Then
For $i = $g_hChkSmartAttackRedAreaDB To $g_hPicAttackNearDarkElixirDrillDB
GUICtrlSetState($g_hChkSmartAttackRedAreaDB, $GUI_UNCHECKED)
GUICtrlSetState($i, $GUI_DISABLE)
Next
Else
For $i = $g_hChkSmartAttackRedAreaDB To $g_hPicAttackNearDarkElixirDrillDB
GUICtrlSetState($i, $GUI_ENABLE)
Next
GUICtrlSetState($g_hChkSmartAttackRedAreaDB, $GUI_ENABLE)
EndIf
EndFunc
Func cmbDeployAB()
If _GUICtrlComboBox_GetCurSel($g_hCmbStandardDropSidesAB) = 4 Then
For $i = $g_hChkSmartAttackRedAreaAB To $g_hPicAttackNearDarkElixirDrillAB
GUICtrlSetState($g_hChkSmartAttackRedAreaAB, $GUI_UNCHECKED)
GUICtrlSetState($i, $GUI_DISABLE)
Next
Else
For $i = $g_hChkSmartAttackRedAreaAB To $g_hPicAttackNearDarkElixirDrillAB
GUICtrlSetState($i, $GUI_ENABLE)
Next
EndIf
EndFunc
Func Donatelang()
$ichkExtraPersian =(GUICtrlRead($chkExtraPersian) = $GUI_CHECKED) ? 1 : 0
EndFunc
Func CheckWardenTimer()
If GUICtrlRead($g_hChkUseWardenAbility) = $GUI_CHECKED Then
GUICtrlSetState($g_hTxtWardenAbility, $GUI_ENABLE)
$iActivateWardenCondition = 1
Else
GUICtrlSetState($g_hTxtWardenAbility, $GUI_DISABLE)
$iActivateWardenCondition = 0
EndIf
EndFunc
Func delayWardenTimer()
$delayActivateW = Int(GUICtrlRead($g_hTxtWardenAbility)) * 1000
EndFunc
Func InitializeMainGUI()
InitializeControlVariables()
AtkLogHead()
tabMain()
If FileExists($g_sProfileConfigPath) = 0 And $g_asCmdLine[0] > 0 Then
createProfile()
saveConfig()
setupProfileComboBox()
EndIf
selectProfile()
If FileExists($g_sProfileConfigPath) Or FileExists($g_sProfileBuildingPath) Then
readConfig()
applyConfig()
EndIf
If $g_bDevMode = True Then
GUICtrlSetState($g_hChkDebugSetlog, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($g_hChkDebugDisableZoomout, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($g_hChkDebugDisableVillageCentering, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($g_hChkDebugDeadbaseImage, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($g_hChkDebugOCR, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($g_hChkDebugImageSave, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($g_hChkdebugBuildingPos, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($g_hChkdebugTrain, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($g_hChkDebugOCRDonate, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($g_hChkMakeIMGCSV, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($g_hChkdebugAttackCSV, $GUI_SHOW + $GUI_ENABLE)
EndIf
GUISetOnEvent($GUI_EVENT_CLOSE, "GUIEvents", $g_hFrmBot)
GUISetOnEvent($GUI_EVENT_MINIMIZE, "GUIEvents", $g_hFrmBot)
GUISetOnEvent($GUI_EVENT_RESTORE, "GUIEvents", $g_hFrmBot)
GUIRegisterMsg($WM_COMMAND, "GUIControl_WM_COMMAND")
GUIRegisterMsg($WM_NOTIFY, "GUIControl_WM_NOTIFY")
For $i = $WM_MOUSEMOVE To $WM_MBUTTONDBLCLK
GUIRegisterMsg($i, "GUIControl_WM_MOUSE")
Next
GUIRegisterMsg($WM_CLOSE, "GUIControl_WM_CLOSE")
GUIRegisterMsg($WM_NCACTIVATE, "GUIControl_WM_NCACTIVATE")
GUIRegisterMsg($WM_SETFOCUS, "GUIControl_WM_FOCUS")
GUIRegisterMsg($WM_KILLFOCUS, "GUIControl_WM_FOCUS")
GUIRegisterMsg($WM_MOVE, "GUIControl_WM_MOVE")
$g_hFrmBot_WNDPROC_ptr = DllCallbackGetPtr(DllCallbackRegister("frmBot_WNDPROC", "ptr", "hwnd;uint;long;ptr"))
cmbDBAlgorithm()
cmbABAlgorithm()
SetAccelerators()
EndFunc
Func SetCriticalMessageProcessing($bEnterCritical = Default)
If $bEnterCritical = Default Then Return $g_bCriticalMessageProcessing
Local $wasCritical = $g_bCriticalMessageProcessing
$g_bCriticalMessageProcessing = $bEnterCritical
Return $wasCritical
EndFunc
Func UpdateFrmBotStyle()
Local $ShowMinimize = $g_bAndroidBackgroundLaunched = True Or $g_bAndroidEmbedded = False Or($g_bAndroidEmbedded = True And $g_bChkBackgroundMode = True)
Local $lStyle = $WS_MINIMIZEBOX
Local $lNewStyle =($ShowMinimize ? $lStyle : 0)
Local $lCurStyle = _WinAPI_GetWindowLong($g_hFrmBot, $GWL_STYLE)
If BitAND($lCurStyle, $lStyle) <> $lNewStyle Then
If $ShowMinimize Then
$lNewStyle = BitOR($lCurStyle, $lStyle)
SetDebugLog("Show Bot Minimize Button")
Else
$lNewStyle = BitAND($lCurStyle, BitNOT($lStyle))
SetDebugLog("Hide Bot Minimize Button")
EndIf
_WinAPI_SetWindowLong($g_hFrmBot, $GWL_STYLE, $lNewStyle)
Return True
EndIf
Return False
EndFunc
Func IsAlwaysEnabledControl($controlID)
Local $bAlwaysEnabled =(($oAlwaysEnabledControls.Item($controlID)) ?(True) :(False))
Return $bAlwaysEnabled
EndFunc
Func SetAccelerators($bDockedUnshieledFocus = False)
Local $aAccelKeys[2][2] = [["{ESC}", $g_hBtnStop], ["{PAUSE}", $g_hBtnPause]]
Local $aAccelKeys_DockedUnshieldedFocus[3][2] = [["{ESC}", $g_hFrmBotEmbeddedShieldInput], ["{ENTER}", $g_hFrmBotEmbeddedShieldInput], ["{PAUSE}", $g_hBtnPause]]
GUISetAccelerators(0, $g_hFrmBot)
If $bDockedUnshieledFocus = False Then
GUISetAccelerators($aAccelKeys, $g_hFrmBot)
Else
GUISetAccelerators($aAccelKeys_DockedUnshieldedFocus, $g_hFrmBot)
EndIf
EndFunc
Func AndroidToFront()
WinMove2(GetAndroidDisplayHWnD(), "", -1, -1, -1, -1, $HWND_TOPMOST, 0, False)
WinMove2(GetAndroidDisplayHWnD(), "", -1, -1, -1, -1, $HWND_NOTOPMOST, 0, False)
EndFunc
Func DisableProcessWindowsGhosting()
DllCall($g_hLibUser32DLL, "none", "DisableProcessWindowsGhosting")
EndFunc
Func GUIControl_WM_NCACTIVATE($hWin, $iMsg, $wParam, $lParam)
Local $wasCritical = SetCriticalMessageProcessing(True)
Local $wasAllowed = $g_bTogglePauseAllowed
$g_bTogglePauseAllowed = False
If $g_iDebugWindowMessages Then SetDebugLog("GUIControl_WM_NCACTIVATE: $hWin=" & $hWin & ", $iMsg=" & Hex($iMsg, 8) & ", $wParam=" & $wParam & ", $lParam=" & $lParam, Default, True)
Local $iActive = BitAND($wParam, 0x0000FFFF)
If $hWin = $g_hFrmBot Then
If $g_bAndroidEmbedded And AndroidShieldActiveDelay() = False Then
If $iActive = 0 Then
AndroidShield("GUIControl_WM_NCACTIVATE not active", Default, False, 0, False, False)
Else
AndroidShield("GUIControl_WM_NCACTIVATE active", Default, False)
EndIf
EndIf
If $iActive = 0 Then
SetDebugLog("GUIControl_WM_NCACTIVATE: Deactivate Bot", Default, True)
_WinAPI_SetFocus(0)
Else
If $iHideWhenMinimized = 0 Then BotRestore("GUIControl_WM_NCACTIVATE")
SetDebugLog("GUIControl_WM_NCACTIVATE: Activate Bot", Default, True)
EndIf
If $g_bAndroidEmbedded And $g_iAndroidEmbedMode = 1 And AndroidShieldActiveDelay() = False Then
AndroidEmbedCheck(False, $iActive <> 0, 1)
AndroidShield("GUIControl_WM_NCACTIVATE", Default, False)
EndIf
EndIf
$g_bTogglePauseAllowed = $wasAllowed
SetCriticalMessageProcessing($wasCritical)
Return $GUI_RUNDEFMSG
EndFunc
Func GUIControl_WM_FOCUS($hWin, $iMsg, $wParam, $lParam)
Local $wasCritical = SetCriticalMessageProcessing(True)
Local $wasAllowed = $g_bTogglePauseAllowed
$g_bTogglePauseAllowed = False
If $g_iDebugWindowMessages Then SetDebugLog("GUIControl_WM_FOCUS: $hWin=" & $hWin & ", $iMsg=" & Hex($iMsg, 8) & ", $wParam=" & $wParam & ", $lParam=" & $lParam, Default, True)
Local $iActive = BitAND($wParam, 0x0000FFFF)
Switch $hWin
Case $g_hFrmBot
If $g_bAndroidEmbedded And AndroidShieldActiveDelay() = False Then
AndroidShield("GUIControl_WM_FOCUS", Default, False)
If $g_iAndroidEmbedMode = 1 Then
AndroidEmbedCheck(False, Default, 1)
EndIf
EndIf
EndSwitch
$g_bTogglePauseAllowed = $wasAllowed
SetCriticalMessageProcessing($wasCritical)
Return $GUI_RUNDEFMSG
EndFunc
Func GetPixelFromWindow($x, $y, $hWin)
Local $hDC = _WinAPI_GetWindowDC($hWin)
Local $Result = DllCall("gdi32.dll", "int", "GetPixel", "int", $hDC, "int", $x, "int", $y)
_WinAPI_ReleaseDC($hWin, $hDC)
If UBound($Result) > 0 Then Return Hex($Result[0], 6)
Return ""
EndFunc
Func GUIControl_WM_MOUSE($hWin, $iMsg, $wParam, $lParam)
Local $wasCritical = SetCriticalMessageProcessing(True)
Local $wasAllowed = $g_bTogglePauseAllowed
$g_bTogglePauseAllowed = False
Local $hWinMouse = $g_hFrmBotEmbeddedMouse
If $g_hFrmBotEmbeddedMouse = 0 Then $hWinMouse =(($g_iAndroidEmbedMode = 0) ? $g_hFrmBotEmbeddedShield : $g_hFrmBot)
If $g_iDebugWindowMessages > 1 Then SetDebugLog("GUIControl_WM_MOUSE: $hWin=" & $hWin & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam & ",$hWinMouse=" & $hWinMouse, Default, True)
If $hWin <> $hWinMouse Or $g_bAndroidEmbedded = False Or $g_avAndroidShieldStatus[0] = True Then
$g_bTogglePauseAllowed = $wasAllowed
SetCriticalMessageProcessing($wasCritical)
Return $GUI_RUNDEFMSG
EndIf
Switch $iMsg
Case $WM_LBUTTONDOWN, $WM_LBUTTONUP, $WM_RBUTTONDOWN, $WM_RBUTTONUP
Local $hInput = GUICtrlGetHandle($g_hFrmBotEmbeddedShieldInput)
_WinAPI_SetFocus($hInput)
EndSwitch
Switch $iMsg
Case $WM_MOUSEMOVE
If $g_iDebugClick And AndroidShieldHasFocus() Then
Local $x = BitAND($lParam, 0xFFFF)
Local $y = BitAND($lParam, 0xFFFF0000) / 0x10000
Local $c = GetPixelFromWindow($x, $y, $HWnDCtrl)
_GUICtrlStatusBar_SetText($g_hStatusBar, StringFormat("Mouse %03i,%03i Color %s", $x, $y, $c))
EndIf
Case $WM_LBUTTONDOWN
If $g_iDebugClick And AndroidShieldHasFocus() Then
Local $x = BitAND($lParam, 0xFFFF)
Local $y = BitAND($lParam, 0xFFFF0000) / 0x10000
Local $c = GetPixelFromWindow($x, $y, $HWnDCtrl)
SetLog(StringFormat("Mouse LBUTTONDOWN %03i,%03i Color %s", $x, $y, $c), $COLOR_DEBUG)
EndIf
Case $WM_LBUTTONUP, $WM_RBUTTONUP
If $g_iDebugWindowMessages Then
Local $x = BitAND($lParam, 0xFFFF)
Local $y = BitAND($lParam, 0xFFFF0000) / 0x10000
SetDebugLog("GUIControl_WM_MOUSE: " &($iMsg = $WM_LBUTTONUP ? "$WM_LBUTTONUP" : "$WM_RBUTTONUP") & " $hWin=" & $hWin & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam & ", X=" & $x & ", Y=" & $y, Default, True)
EndIf
If AndroidShieldHasFocus() = False Then
Local $hInput = GUICtrlGetHandle($g_hFrmBotEmbeddedShieldInput)
_WinAPI_SetFocus($hInput)
AndroidShield("GUIControl_WM_MOUSE", Default, False, 0, True)
$g_bTogglePauseAllowed = $wasAllowed
SetCriticalMessageProcessing($wasCritical)
Return $GUI_RUNDEFMSG
EndIf
EndSwitch
If AndroidShieldHasFocus() = False Then
$g_bTogglePauseAllowed = $wasAllowed
SetCriticalMessageProcessing($wasCritical)
Return $GUI_RUNDEFMSG
EndIf
Local $hCtrlTarget = $g_aiAndroidEmbeddedCtrlTarget[0]
If $iMsg <> $WM_MOUSEMOVE Or $g_iAndroidEmbedMode <> 0 Then
Local $Result = _WinAPI_PostMessage($hCtrlTarget, $iMsg, $wParam, $lParam)
EndIf
$g_bTogglePauseAllowed = $wasAllowed
SetCriticalMessageProcessing($wasCritical)
Return $GUI_RUNDEFMSG
EndFunc
Global $GUIControl_AndroidEmbedded_Call = [0, 0, 0, 0]
Func GUIControl_AndroidEmbedded($hWin, $iMsg, $wParam, $lParam)
If $g_bAndroidEmbedded = False Or $g_avAndroidShieldStatus[0] = True Then
Return $GUI_RUNDEFMSG
EndIf
Local $wasCritical = SetCriticalMessageProcessing(True)
Local $wasAllowed = $g_bTogglePauseAllowed
$g_bTogglePauseAllowed = False
Switch $iMsg
Case $WM_KEYDOWN, $WM_KEYUP, $WM_SYSKEYDOWN, $WM_SYSKEYUP, $WM_MOUSEWHEEL
If $iMsg = $WM_KEYUP And $wParam = 27 Then
Local $wasSilentSetLog = $g_bSilentSetLog
$g_bSilentSetLog = True
AndroidBackButton(False)
$g_bSilentSetLog = $wasSilentSetLog
Else
Local $hCtrlTarget = $g_aiAndroidEmbeddedCtrlTarget[0]
If $GUIControl_AndroidEmbedded_Call[0] <> $hCtrlTarget Or $GUIControl_AndroidEmbedded_Call[1] <> $iMsg Or $GUIControl_AndroidEmbedded_Call[2] <> $wParam Or $GUIControl_AndroidEmbedded_Call[3] <> $lParam Then
If $g_iDebugAndroidEmbedded Then SetDebugLog("GUIControl_AndroidEmbedded: FORWARD $hWin=" & $hWin & ", $iMsg=" & Hex($iMsg) & ", $wParam=" & $wParam & ", $lParam=" & $lParam & ", $hCtrlTarget=" & $hCtrlTarget, Default, True)
_WinAPI_PostMessage($hCtrlTarget, $iMsg, $wParam, $lParam)
Global $GUIControl_AndroidEmbedded_Call = [$hCtrlTarget, $iMsg, $wParam, $lParam]
EndIf
EndIf
EndSwitch
$g_bTogglePauseAllowed = $wasAllowed
SetCriticalMessageProcessing($wasCritical)
Return $GUI_RUNDEFMSG
EndFunc
Func GUIControl_WM_COMMAND($hWind, $iMsg, $wParam, $lParam)
If $GUIControl_Disabled = True Then Return $GUI_RUNDEFMSG
Local $wasAllowed = $g_bTogglePauseAllowed
$g_bTogglePauseAllowed = False
If $g_iDebugWindowMessages > 1 Then SetDebugLog("GUIControl_WM_COMMAND: $hWind=" & $hWind & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam, Default, True)
Local $nNotifyCode = BitShift($wParam, 16)
Local $nID = BitAND($wParam, 0x0000FFFF)
If $hWind <> $g_hFrmBotEmbeddedShield And $hWind <> $g_hFrmBotEmbeddedGraphics And $hWind <> $g_hFrmBotEmbeddedMouse And $nID <> $g_hFrmBotEmbeddedShieldInput Then
If AndroidShieldHasFocus() = True Then
If $g_iDebugWindowMessages Then SetDebugLog("GUIControl_WM_COMMAND: $hWind=" & $hWind & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam, Default, True)
AndroidShield("GUIControl_WM_COMMAND", Default, False, 150, False)
EndIf
EndIf
CheckRedrawBotWindow(Default, Default, "GUIControl_WM_COMMAND")
Switch $nID
Case $g_hDivider
$g_bMoveDivider = True
SetDebugLog("MoveDivider active", Default, True)
Case $GUI_EVENT_CLOSE
BotCloseRequest()
Case $g_hLblCreditsBckGrnd, $g_hLblUnbreakableHelp
Local $CursorInfo = GUIGetCursorInfo($g_hFrmBot)
If IsArray($CursorInfo) = 1 Then
Switch $CursorInfo[4]
Case $g_hLblMyBotURL, $g_hLblForumURL, $g_hLblUnbreakableLink
OpenURL_Label($CursorInfo[4])
EndSwitch
EndIf
Case $g_hLblMyBotURL, $g_hLblForumURL, $g_hLblUnbreakableLink
OpenURL_Label($nID)
Case $g_hFrmBot_URL_PIC
OpenURL_Label($g_hLblMyBotURL)
Case $g_hLblDonate
ShellExecute("https://mybot.run/forums/index.php?/donate/make-donation/")
Case $g_hBtnStop
btnStop()
Case $g_hBtnPause
btnPause()
Case $g_hBtnResume
btnResume()
Case $g_hBtnHide
btnHide()
Case $g_hBtnEmbed
btnEmbed()
Case $btnResetStats
btnResetStats()
Case $g_hBtnAttackNowDB
btnAttackNowDB()
Case $g_hBtnAttackNowLB
btnAttackNowLB()
Case $g_hBtnAttackNowTS
btnAttackNowTS()
Case $g_hBtnNotifyDeleteMessages
If $g_bRunState Then
btnDeletePBMessages()
Else
PushMsg("DeleteAllPBMessages")
EndIf
Case $g_hBtnMakeScreenshot
If $g_bRunState Then
btnMakeScreenshot()
Else
If $iScreenshotType = 0 Then
MakeScreenshot($g_sProfileTempPath, "jpg")
Else
MakeScreenshot($g_sProfileTempPath, "png")
EndIf
EndIf
Case $g_hPicTwoArrowShield
btnVillageStat()
Case $g_hPicArrowLeft, $g_hPicArrowRight
btnVillageStat()
Case $g_hChkDebugClick
chkDebugClick()
Case $g_hChkDebugSetlog
chkDebugSetlog()
Case $g_hChkDebugDisableZoomout
chkDebugDisableZoomout()
Case $g_hChkDebugDisableVillageCentering
chkDebugDisableVillageCentering()
Case $g_hChkDebugDeadbaseImage
chkDebugDeadbaseImage()
Case $g_hChkDebugOCR
chkDebugOcr()
Case $g_hChkDebugImageSave
chkDebugImageSave()
Case $g_hChkdebugBuildingPos
chkDebugBuildingPos()
Case $g_hChkdebugTrain
chkDebugTrain()
Case $g_hChkDebugOCRDonate
chkdebugOCRDonate()
Case $g_hChkdebugAttackCSV
chkdebugAttackCSV()
Case $g_hChkMakeIMGCSV
chkmakeIMGCSV()
Case $g_hBtnTestTrain
btnTestTrain()
Case $g_hBtnTestDonateCC
btnTestDonateCC()
Case $g_hBtnTestRequestCC
btnTestRequestCC()
Case $g_hBtnTestAttackBar
btnTestAttackBar()
Case $g_hBtnTestClickDrag
btnTestClickDrag()
Case $g_hBtnTestImage
btnTestImage()
Case $g_hBtnTestVillageSize
btnTestVillageSize()
Case $g_hBtnTestDeadBase
btnTestDeadBase()
Case $g_hBtnTestDeadBaseFolder
btnTestDeadBaseFolder()
Case $g_hBtnTestTHimgloc
imglocTHSearch()
Case $g_hBtnTestQuickTrainsimgloc
imglocTestQuickTrain(1)
Case $g_hBtnTestimglocTroopBar
TestImglocTroopBar()
Case $g_hBtnTestAttackCSV
btnTestAttackCSV()
Case $g_hBtnTestFindButton
btnTestFindButton()
Case $g_hBtnTestCleanYard
btnTestCleanYard()
Case $g_hBtnTestConfigSave
saveConfig()
Case $g_hBtnTestConfigRead
readConfig()
Case $g_hBtnTestConfigApply
applyConfig()
EndSwitch
If $lParam = $g_hCmbGUILanguage Then
If $nNotifyCode = $CBN_SELCHANGE Then cmbLanguage()
EndIf
$g_bTogglePauseAllowed = $wasAllowed
Return $GUI_RUNDEFMSG
EndFunc
Func GUIControl_WM_MOVE($hWind, $iMsg, $wParam, $lParam)
Local $wasCritical = SetCriticalMessageProcessing(True)
Local $wasAllowed = $g_bTogglePauseAllowed
$g_bTogglePauseAllowed = False
If $g_iDebugWindowMessages Then SetDebugLog("GUIControl_WM_MOVE: $hWind=" & $hWind & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam, Default, True)
If $hWind = $g_hFrmBot Then
If $iUpdatingWhenMinimized = 1 And BotWindowCheck() = False And _WinAPI_IsIconic($g_hFrmBot) Then
BotMinimize("GUIControl_WM_MOVE")
$g_bTogglePauseAllowed = $wasAllowed
SetCriticalMessageProcessing($wasCritical)
Return $GUI_RUNDEFMSG
EndIf
Local $frmBotPos = WinGetPos($g_hFrmBot)
If $g_bAndroidEmbedded = False Then
$frmBotPosX =($frmBotPos[0] > -30000 ? $frmBotPos[0] : $frmBotPosX)
$frmBotPosY =($frmBotPos[1] > -30000 ? $frmBotPos[1] : $frmBotPosY)
Else
$frmBotDockedPosX =($frmBotPos[0] > -30000 ? $frmBotPos[0] : $frmBotDockedPosX)
$frmBotDockedPosY =($frmBotPos[1] > -30000 ? $frmBotPos[1] : $frmBotDockedPosY)
EndIf
If $g_bAndroidEmbedded And AndroidEmbedArrangeActive() = False Then
Local $iAction = AndroidEmbedCheck(True)
If $iAction > 0 Then
AndroidEmbedCheck(False, Default, $iAction)
EndIf
If $g_iDebugWindowMessages Then
Local $a = $frmBotPos
SetDebugLog("Bot Position: " & $a[0] & "," & $a[1] & " " & $a[2] & "x" & $a[3])
$a = WinGetPos($HWnD)
SetDebugLog("Android Position: " & $a[0] & "," & $a[1] & " " & $a[2] & "x" & $a[3])
If $g_hFrmBotEmbeddedMouse <> 0 Then
$a = WinGetPos($g_hFrmBotEmbeddedMouse)
SetDebugLog("Mouse Window Position: " & $a[0] & "," & $a[1] & " " & $a[2] & "x" & $a[3])
EndIf
EndIf
EndIf
EndIf
$g_bTogglePauseAllowed = $wasAllowed
SetCriticalMessageProcessing($wasCritical)
Return $GUI_RUNDEFMSG
EndFunc
Func GUIControl_WM_SYSCOMMAND($hWind, $iMsg, $wParam, $lParam)
Local $wasCritical = SetCriticalMessageProcessing(True)
Local $wasAllowed = $g_bTogglePauseAllowed
$g_bTogglePauseAllowed = False
If $g_iDebugWindowMessages Then SetDebugLog("GUIControl_WM_SYSCOMMAND: $hWind=" & $hWind & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam, Default, True)
If $hWind = $g_hFrmBot Then
Switch $wParam
Case $SC_MINIMIZE
BotMinimize("GUIControl_WM_SYSCOMMAND")
Case $SC_RESTORE
BotRestore("GUIControl_WM_SYSCOMMAND")
Case $SC_CLOSE
BotCloseRequest()
EndSwitch
EndIf
$g_bTogglePauseAllowed = $wasAllowed
SetCriticalMessageProcessing($wasCritical)
Return $GUI_RUNDEFMSG
EndFunc
Func GUIControl_WM_NOTIFY($hWind, $iMsg, $wParam, $lParam)
Local $wasCritical = SetCriticalMessageProcessing(True)
Local $wasAllowed = $g_bTogglePauseAllowed
$g_bTogglePauseAllowed = False
If $g_iDebugWindowMessages > 1 Then SetDebugLog("GUIControl_WM_NOTIFY: $hWind=" & $hWind & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam, Default, True)
Local $nNotifyCode = BitShift($wParam, 16)
Local $nID = BitAND($wParam, 0x0000FFFF)
Local $bCheckEmbeddedShield = True
Switch $nID
Case $g_hTabMain
tabMain()
Case $g_hGUI_VILLAGE_TAB
tabVillage()
Case $g_hGUI_DONATE_TAB
tabDONATE()
Case $g_hGUI_ATTACK_TAB
tabAttack()
Case $g_hGUI_SEARCH_TAB
tabSEARCH()
Case $g_hGUI_DEADBASE_TAB
tabDeadbase()
Case $g_hGUI_ACTIVEBASE_TAB
tabActivebase()
Case $g_hGUI_THSNIPE_TAB
tabTHSnipe()
Case $g_hGUI_BOT_TAB
tabBot()
Case Else
$bCheckEmbeddedShield = False
EndSwitch
If $bCheckEmbeddedShield Then
If $hWind <> $g_hFrmBotEmbeddedShield And $hWind <> $g_hFrmBotEmbeddedGraphics And $hWind <> $g_hFrmBotEmbeddedMouse Then
If AndroidShieldHasFocus() = True Then
If $g_iDebugWindowMessages Then SetDebugLog("GUIControl_WM_NOTIFY: $hWind=" & $hWind & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam, Default, True)
AndroidShield("GUIControl_WM_NOTIFY", Default, False, 150, False)
EndIf
EndIf
EndIf
$g_bTogglePauseAllowed = $wasAllowed
SetCriticalMessageProcessing($wasCritical)
Return $GUI_RUNDEFMSG
EndFunc
Func GUIControl_WM_CLOSE($hWind, $iMsg, $wParam, $lParam)
If $g_iDebugWindowMessages > 0 Then SetDebugLog("GUIControl_WM_CLOSE: $hWind=" & $hWind & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam, Default, True)
If $hWind = $g_hFrmBot Then
BotCloseRequest()
EndIf
EndFunc
Func GUIEvents()
Local $wasAllowed = $g_bTogglePauseAllowed
$g_bTogglePauseAllowed = False
Local $GUI_CtrlId = @GUI_CtrlId
If $g_bFrmBotMinimized And $GUI_CtrlId = $GUI_EVENT_MINIMIZE Then
If $g_iDebugWindowMessages Then SetDebugLog("$GUI_EVENT_MINIMIZE changed to $GUI_EVENT_RESTORE", Default, True)
$GUI_CtrlId = $GUI_EVENT_RESTORE
EndIf
Switch $GUI_CtrlId
Case $GUI_EVENT_CLOSE
If $g_iDebugWindowMessages Then SetDebugLog("$GUI_EVENT_CLOSE", Default, True)
BotCloseRequest()
Case $GUI_EVENT_MINIMIZE
If $g_iDebugWindowMessages Then SetDebugLog("$GUI_EVENT_MINIMIZE", Default, True)
BotMinimize("GUIEvents")
Case $GUI_EVENT_RESTORE
If $g_iDebugWindowMessages Then SetDebugLog("$GUI_EVENT_RESTORE", Default, True)
BotRestore("GUIEvents")
Case Else
If $g_iDebugWindowMessages Then SetDebugLog("$GUI_EVENT: " & @GUI_CtrlId, Default, True)
EndSwitch
$g_bTogglePauseAllowed = $wasAllowed
EndFunc
Func OpenURL_Label($LabelCtrlID)
Local $url = GUICtrlRead($LabelCtrlID)
If StringInStr($url, "http") <> 1 Then
$url = _GUIToolTip_GetText($hToolTip, 0, GUICtrlGetHandle($LabelCtrlID))
EndIf
If StringInStr($url, "http") = 1 Then
SetDebugLog("Open URL: " & $url)
ShellExecute($url)
Else
SetDebugLog("Cannot open URL for Control ID " & $LabelCtrlID, $COLOR_ERROR)
EndIf
EndFunc
Func BotCloseRequest()
If $g_iBotAction = $eBotClose Then
BotClose()
Else
SetLog("Closing " & $g_sBotTitle & ", please wait ...")
EndIf
$g_bRunState = False
$g_bBotPaused = False
$g_iBotAction = $eBotClose
EndFunc
Func BotClose($SaveConfig = Default, $bExit = True)
If $SaveConfig = Default Then $SaveConfig = $g_iBotLaunchTime > 0
$g_bRunState = False
$g_bBotPaused = False
ResumeAndroid()
SetLog("Closing " & $g_sBotTitle & " now ...")
AndroidEmbed(False)
AndroidShieldDestroy()
AndroidBotStopEvent()
If $SaveConfig = True Then
setupProfile()
SaveConfig()
EndIf
AndroidAdbTerminateShellInstance()
If $g_hMutex_BotTitle <> 0 Then _WinAPI_CloseHandle($g_hMutex_BotTitle)
If $g_hMutex_Profile <> 0 Then _WinAPI_CloseHandle($g_hMutex_Profile)
If $g_hMutex_MyBot <> 0 Then _WinAPI_CloseHandle($g_hMutex_MyBot)
__GDIPlus_Shutdown()
MBRFunc(False)
_GUICtrlRichEdit_Destroy($g_hTxtLog)
_GUICtrlRichEdit_Destroy($g_hTxtAtkLog)
DllCall("comctl32.dll", "int", "ImageList_Destroy", "hwnd", $hImageList)
If $HWnD <> 0 Then ControlFocus($HWnD, "", $HWnD)
GUIDelete($g_hFrmBot)
$g_aiAndroidAdbScreencapBuffer = 0
$hStruct_SleepMicro = 0
UnregisterManagedMyBotHost()
If $bExit = True Then Exit
EndFunc
Func BotMinimize($sCaller, $iForceUpdatingWhenMinimized = False)
Local $hMutex = AcquireMutex("MinimizeRestore")
SetDebugLog("Minimize bot window, caller: " & $sCaller, Default, True)
$g_bFrmBotMinimized = True
If $iUpdatingWhenMinimized = 1 Or $iForceUpdatingWhenMinimized = True Then
If $iHideWhenMinimized = 1 Then
WinMove2($g_hFrmBot, "", -32000, -32000, -1, -1, 0, $SWP_HIDEWINDOW, False)
_WinAPI_SetWindowLong($g_hFrmBot, $GWL_EXSTYLE, BitOR(_WinAPI_GetWindowLong($g_hFrmBot, $GWL_EXSTYLE), $WS_EX_TOOLWINDOW))
EndIf
If _WinAPI_IsIconic($g_hFrmBot) Then WinSetState($g_hFrmBot, "", @SW_RESTORE)
If _WinAPI_IsIconic($HWnD) Then WinSetState($HWnD, "", @SW_RESTORE)
WinMove2($g_hFrmBot, "", -32000, -32000, -1, -1, 0, $SWP_SHOWWINDOW, False)
Else
If $iHideWhenMinimized = 1 Then
WinMove2($g_hFrmBot, "", -1, -1, -1, -1, 0, $SWP_HIDEWINDOW, False)
_WinAPI_SetWindowLong($g_hFrmBot, $GWL_EXSTYLE, BitOR(_WinAPI_GetWindowLong($g_hFrmBot, $GWL_EXSTYLE), $WS_EX_TOOLWINDOW))
EndIf
WinSetState($g_hFrmBot, "", @SW_MINIMIZE)
EndIf
ReleaseMutex($hMutex)
EndFunc
Func BotRestore($sCaller)
Local $hMutex = AcquireMutex("MinimizeRestore")
$g_bFrmBotMinimized = False
Local $botPosX =($g_bAndroidEmbedded = False ? $frmBotPosX : $frmBotDockedPosX)
Local $botPosY =($g_bAndroidEmbedded = False ? $frmBotPosY : $frmBotDockedPosY)
Local $aPos = [$botPosX, $botPosY]
SetDebugLog("Restore bot window to " & $botPosX & ", " & $botPosY & ", caller: " & $sCaller, Default, True)
Local $iExStyle = _WinAPI_GetWindowLong($g_hFrmBot, $GWL_EXSTYLE)
If BitAND($iExStyle, $WS_EX_TOOLWINDOW) Then
WinMove2($g_hFrmBot, "", -1, -1, -1, -1, 0, $SWP_HIDEWINDOW, False)
_WinAPI_SetWindowLong($g_hFrmBot, $GWL_EXSTYLE, BitAND($iExStyle, BitNOT($WS_EX_TOOLWINDOW)))
EndIf
If _WinAPI_IsIconic($g_hFrmBot) Then WinSetState($g_hFrmBot, "", @SW_RESTORE)
If $g_bAndroidAdbScreencap = False And $g_bRunState = True And $g_bBotPaused = False And _WinAPI_IsIconic($HWnD) Then WinSetState($HWnD, "", @SW_RESTORE)
WinMove2($g_hFrmBot, "", $botPosX, $botPosY, -1, -1, $HWND_TOP, $SWP_SHOWWINDOW)
_WinAPI_SetActiveWindow($g_hFrmBot)
_WinAPI_SetFocus($g_hFrmBot)
If _CheckWindowVisibility($g_hFrmBot, $aPos) Then
SetDebugLog("Bot Window '" & $Title & "' not visible, moving to position: " & $aPos[0] & ", " & $aPos[1])
WinMove2($g_hFrmBot, "", $aPos[0], $aPos[1])
EndIf
WinSetTrans($g_hFrmBot, "", 255)
ReleaseMutex($hMutex)
EndFunc
Func BotWindowCheck()
If $g_bFrmBotMinimized Then
Local $aPos = WinGetPos($g_hFrmBot)
If IsArray($aPos) And $aPos[0] > -30000 Or $aPos[0] > -30000 Then
BotMinimize("BotWindowCheck")
Return True
EndIf
EndIf
Return False
EndFunc
Func tiShow()
BotRestore("tiShow")
EndFunc
Func tiHide()
$iHideWhenMinimized =($iHideWhenMinimized = 1 ? 0 : 1)
TrayItemSetState($g_hTiHide,($iHideWhenMinimized = 1 ? $TRAY_CHECKED : $TRAY_UNCHECKED))
GUICtrlSetState($g_hChkHideWhenMinimized,($iHideWhenMinimized = 1 ? $GUI_CHECKED : $GUI_UNCHECKED))
If $g_bFrmBotMinimized = True Then
If $iHideWhenMinimized = 0 Then
BotRestore("tiHide")
Else
BotMinimize("tiHide")
EndIf
EndIf
EndFunc
Func tiAbout()
Local $sMsg = "Clash of Clans Bot" & @CRLF & @CRLF & "Version: " & $g_sBotVersion & @CRLF & "Released under the GNU GPLv3 license." & @CRLF & "Visit www.MyBot.run"
MsgBox(64 + $MB_APPLMODAL + $MB_TOPMOST, $g_sBotTitle, $sMsg, 0, $g_hFrmBot)
EndFunc
Func tiDonate()
ShellExecute("https://mybot.run/forums/index.php?/donate/make-donation/")
EndFunc
Func tiExit()
BotCloseRequest()
EndFunc
Func SetRedrawBotWindow($bEnableRedraw, $bCheckRedrawBotWindow = Default, $bForceRedraw = Default, $RedrawControlIDs = Default, $sSource = "")
If $g_iRedrawBotWindowMode = 0 Then Return False
If $g_iRedrawBotWindowMode = 1 Then $RedrawControlIDs = Default
If $bCheckRedrawBotWindow = Default Then $bCheckRedrawBotWindow = True
If $bForceRedraw = Default Then $bForceRedraw = False
Local $bWasRedraw = $g_bRedrawBotWindow[0]
If $g_bRedrawBotWindow[0] = $bEnableRedraw Then
Return $bWasRedraw
EndIf
_SendMessage($g_hFrmBotEx, $WM_SETREDRAW, $bEnableRedraw, 0)
$g_bRedrawBotWindow[0] = $bEnableRedraw
If $bEnableRedraw Then
If $bCheckRedrawBotWindow Then
CheckRedrawBotWindow($bForceRedraw, $RedrawControlIDs, $sSource)
EndIf
Else
SetDebugLog("Disable MyBot Window Redraw" &(($sSource <> "") ?(": " & $sSource) :("")))
$g_bRedrawBotWindow[1] = True
EndIf
Return $bWasRedraw
EndFunc
Func SetRedrawBotWindowControls($bEnableRedraw, $RedrawControlIDs, $sSource = "")
Return SetRedrawBotWindow($bEnableRedraw, True, False, $RedrawControlIDs, $sSource)
EndFunc
Func CheckRedrawBotWindow($bForceRedraw = Default, $RedrawControlIDs = Default, $sSource = "")
If $g_iRedrawBotWindowMode = 0 Then Return False
If $bForceRedraw = Default Then $bForceRedraw = False
If $g_iRedrawBotWindowMode = 1 Then $RedrawControlIDs = Default
If Not $g_bRedrawBotWindow[0] Then Return False
If $g_bRedrawBotWindow[1] Or $bForceRedraw Then
$g_bRedrawBotWindow[1] = False
$g_bRedrawBotWindow[2] = False
If $RedrawControlIDs = Default Then
SetDebugLog("Redraw MyBot Window" &($bForceRedraw ? " (forced)" : "") &(($sSource <> "") ?(": " & $sSource) :("")))
_WinAPI_RedrawWindow($g_hFrmBotEx, 0, 0, BitOR($RDW_INVALIDATE, $RDW_ALLCHILDREN, $RDW_ERASE))
Else
If IsArray($RedrawControlIDs) Then
SetDebugLog("Redraw MyBot ControlIds" &($bForceRedraw ? " (forced)" : "") & ": " & _ArrayToString($RedrawControlIDs, ", "))
Local $c
For $c In $RedrawControlIDs
If ControlRedraw($g_hFrmBot, $c) = 0 Then
_WinAPI_RedrawWindow($g_hFrmBotEx, 0, 0, BitOR($RDW_INVALIDATE, $RDW_ALLCHILDREN, $RDW_ERASE))
ExitLoop
EndIf
Next
Else
SetDebugLog("Redraw MyBot ControlId" &($bForceRedraw ? " (forced)" : "") & ": " & $RedrawControlIDs)
If ControlRedraw($g_hFrmBot, $RedrawControlIDs) = 0 Then
_WinAPI_RedrawWindow($g_hFrmBotEx, 0, 0, BitOR($RDW_INVALIDATE, $RDW_ALLCHILDREN, $RDW_ERASE))
EndIf
EndIf
EndIf
_WinAPI_UpdateWindow($g_hFrmBotEx)
Return True
Else
Return CheckRedrawControls(Default, $sSource)
EndIf
Return False
EndFunc
Func CheckRedrawControls($ForceCheck = Default, $sSource = "")
If $g_iRedrawBotWindowMode = 0 Then Return False
If $ForceCheck = Default Then $ForceCheck = False
If Not $g_bRedrawBotWindow[2] And Not $ForceCheck Then Return False
If GUICtrlRead($g_hTabMain, 1) = $g_hTabLog Then
Local $a = [$g_hTxtLog, $g_hTxtAtkLog]
Return CheckRedrawBotWindow(True, $a, $sSource)
EndIf
$g_bRedrawBotWindow[2] = False
Return False
EndFunc
Func RedrawBotWindowNow()
SetDebugLog("Redraw MyBot Window Now")
_WinAPI_RedrawWindow($g_hFrmBot, 0, 0, BitOR($RDW_INVALIDATE, $RDW_ALLCHILDREN, $RDW_ERASE))
_WinAPI_UpdateWindow($g_hFrmBot)
EndFunc
Func ControlRedraw($hWin, $ConrolId)
Local $a = ControlGetPos($hWin, "", $ConrolId)
If IsArray($a) = 0 Then
SetDebugLog("ControlRedraw: Invalid ControlId: " & $ConrolId)
Return 0
EndIf
Local $hCtrl =(IsHWnd($ConrolId) ? $ConrolId : GUICtrlGetHandle($ConrolId))
Local $hWinParent = _WinAPI_GetParent($hCtrl)
SetDebugLog("Control ID " & $ConrolId & " handle: " & $hCtrl & " parent: " & $hWinParent & " $g_hFrmBot: " & $g_hFrmBot & " $g_hFrmBotEx: " & $g_hFrmBotEx & " Pos: " & $a[0] & ", " & $a[1] & ", " & $a[2] & ", " & $a[3], Default, True)
Local $left = $a[0]
Local $top = $a[1]
Local $width = $a[2]
Local $height = $a[3]
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Left", $left)
DllStructSetData($tRECT, "Top", $top)
DllStructSetData($tRECT, "Right", $left + $width)
DllStructSetData($tRECT, "Bottom", $top + $height)
SetDebugLog("Control ID " & $ConrolId & " RedrawWindow Pos: " & $left & ", " & $top & ", " & $left + $width & ", " & $top + $height, Default, True)
_WinAPI_RedrawWindow($hWin, $tRECT, 0, BitOR($RDW_INVALIDATE, $RDW_ALLCHILDREN))
$tRECT = 0
Return 1
EndFunc
Func SetTime($bForceUpdate = False)
If $g_hTimerSinceStarted = 0 Then Return
Local $day = 0, $hour = 0, $min = 0, $sec = 0
Local Static $DisplayLoop = 0
If GUICtrlRead($g_hGUI_STATS_TAB, 1) = $g_hGUI_STATS_TAB_ITEM2 Or $bForceUpdate = True Then
_TicksToDay(Int(TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed), $day, $hour, $min, $sec)
GUICtrlSetData($g_hLblResultRuntime, $day > 0 ? StringFormat("%2u Day(s) %02i:%02i:%02i", $day, $hour, $min, $sec) : StringFormat("%02i:%02i:%02i", $hour, $min, $sec))
EndIf
If GUICtrlGetState($g_hLblResultGoldNow) <> $GUI_ENABLE + $GUI_SHOW Or $bForceUpdate = True Then
_TicksToTime(Int(TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed), $hour, $min, $sec)
GUICtrlSetData($g_hLblResultRuntimeNow, StringFormat("%02i:%02i:%02i", $hour, $min, $sec))
EndIf
If $DisplayLoop >= 10 Then
$DisplayLoop = 0
If GUICtrlRead($g_hGUI_MOD_TAB, 1) = $g_hGUI_MOD_TAB_ITEM5 And $CurrentAccount <> 0 Then
For $i = 1 To 8
If $ichkCanUse[$i] = 1 And $ichkDonateAccount[$i] <> 1 And $i <> $CurrentAccount And $TimerDiffStart[$i] <> 0 And(GUICtrlRead($g_lblTimeNowSW[$i]) <> "No Data" Or GUICtrlRead($g_lblTimeNowSW[$i]) <> "Looting") Then
$TimerDiffEnd[$i] = TimerDiff($TimerDiffStart[$i])
$AllAccountsWaitTimeDiff[$i] = Round($AllAccountsWaitTime[$i] * 60 * 1000 - $TimerDiffEnd[$i], 2)
If $AllAccountsWaitTimeDiff[$i] < 0 Then
GUICtrlSetData($g_lblTimeNowSW[$i], Round($AllAccountsWaitTimeDiff[$i] / 60 / 1000, 2))
GUICtrlSetBkColor($g_lblTimeNowSW[$i], $COLOR_RED)
GUICtrlSetColor($g_lblTimeNowSW[$i], $COLOR_BLACK)
Else
GUICtrlSetData($g_lblTimeNowSW[$i], Round($AllAccountsWaitTimeDiff[$i] / 60 / 1000, 2))
GUICtrlSetBkColor($g_lblTimeNowSW[$i], $COLOR_YELLOW)
GUICtrlSetColor($g_lblTimeNowSW[$i], $COLOR_BLACK)
EndIf
GUICtrlSetData($g_lblHrStatsGoldSW[$i], _NumberFormat(Round($g_iStatsTotalGain[$i][$eLootGold] /(Int(TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600)))
GUICtrlSetData($g_lblHrStatsElixirSW[$i], _NumberFormat(Round($g_iStatsTotalGain[$i][$eLootElixir] /(Int(TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600)))
If $g_iStatsStartedWith[$CurrentAccount][$eLootDarkElixir] <> "" Then
GUICtrlSetData($g_lblHrStatsDarkSW[$i], _NumberFormat(Round($g_iStatsTotalGain[$i][$eLootDarkElixir] /(Int(TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600 * 1000)))
EndIf
EndIf
Next
EndIf
For $i = 1 To 8
If WinGetState(Eval($hGuiPopOut & $i)) <> -1 Then
If $ichkCanUse[$i] = 1 And $ichkDonateAccount[$i] <> 1 And $i <> $CurrentAccount And $TimerDiffStart[$i] <> 0 And(GUICtrlRead($g_lblTimeNowPO[$i]) <> "No Data" Or GUICtrlRead($g_lblTimeNowPO[$i]) <> "Looting") Then
$TimerDiffEnd[$i] = TimerDiff($TimerDiffStart[$i])
$AllAccountsWaitTimeDiff[$i] = Round($AllAccountsWaitTime[$i] * 60 * 1000 - $TimerDiffEnd[$i], 2)
If $AllAccountsWaitTimeDiff[$i] < 0 Then
GUICtrlSetData($g_lblTimeNowPO[$i], Round($AllAccountsWaitTimeDiff[$i] / 60 / 1000, 2))
GUICtrlSetBkColor($g_lblTimeNowPO[$i], $COLOR_RED)
GUICtrlSetColor($g_lblTimeNowPO[$i], $COLOR_BLACK)
Else
GUICtrlSetData($g_lblTimeNowPO[$i], Round($AllAccountsWaitTimeDiff[$i] / 60 / 1000, 2))
GUICtrlSetBkColor($g_lblTimeNowPO[$i], $COLOR_YELLOW)
GUICtrlSetColor($g_lblTimeNowPO[$i], $COLOR_BLACK)
EndIf
GUICtrlSetData($g_lblHrStatsGoldPO[$i], _NumberFormat(Round($g_iStatsTotalGain[$i][$eLootGold] /(Int(TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600)))
GUICtrlSetData($g_lblHrStatsElixirPO[$i], _NumberFormat(Round($g_iStatsTotalGain[$i][$eLootElixir] /(Int(TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600)))
If $g_iStatsStartedWith[$CurrentAccount][$eLootDarkElixir] <> "" Then
GUICtrlSetData($g_lblHrStatsDarkPO[$i], _NumberFormat(Round($g_iStatsTotalGain[$i][$eLootDarkElixir] /(Int(TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600 * 1000)))
EndIf
EndIf
EndIf
Next
EndIf
If $CurrentAccount = 0 And WinGetState(Eval($hGuiPopOut0)) <> -1 Then
GUICtrlSetData($g_lblTimeNowPO[$CurrentAccount], "Looting")
GUICtrlSetBkColor($g_lblTimeNowPO[$CurrentAccount], $COLOR_GREEN)
GUICtrlSetColor($g_lblTimeNowPO[$CurrentAccount], $COLOR_BLACK)
GUICtrlSetData($g_lblHrStatsGoldPO[$CurrentAccount], _NumberFormat(Round($g_iStatsTotalGain[$CurrentAccount][$eLootGold] /(Int(TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600)))
GUICtrlSetData($g_lblHrStatsElixirPO[$CurrentAccount], _NumberFormat(Round($g_iStatsTotalGain[$CurrentAccount][$eLootElixir] /(Int(TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600)))
If $g_iStatsStartedWith[$CurrentAccount][$eLootDarkElixir] <> "" Then
GUICtrlSetData($g_lblHrStatsDarkPO[$CurrentAccount], _NumberFormat(Round($g_iStatsTotalGain[$CurrentAccount][$eLootDarkElixir] /(Int(TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600 * 1000)))
EndIf
EndIf
$DisplayLoop += 1
EndFunc
Func tabMain()
Local $tabidx = GUICtrlRead($g_hTabMain)
Select
Case $tabidx = 0
GUISetState(@SW_HIDE, $g_hGUI_VILLAGE)
GUISetState(@SW_HIDE, $g_hGUI_ATTACK)
GUISetState(@SW_HIDE, $g_hGUI_BOT)
GUISetState(@SW_HIDE, $g_hGUI_ABOUT)
GUISetState(@SW_HIDE, $g_hGUI_MOD)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_LOG)
Case $tabidx = 1
GUISetState(@SW_HIDE, $g_hGUI_LOG)
GUISetState(@SW_HIDE, $g_hGUI_ATTACK)
GUISetState(@SW_HIDE, $g_hGUI_BOT)
GUISetState(@SW_HIDE, $g_hGUI_ABOUT)
GUISetState(@SW_HIDE, $g_hGUI_MOD)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_VILLAGE)
tabVillage()
Case $tabidx = 2
GUISetState(@SW_HIDE, $g_hGUI_LOG)
GUISetState(@SW_HIDE, $g_hGUI_VILLAGE)
GUISetState(@SW_HIDE, $g_hGUI_BOT)
GUISetState(@SW_HIDE, $g_hGUI_ABOUT)
GUISetState(@SW_HIDE, $g_hGUI_MOD)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_ATTACK)
tabAttack()
Case $tabidx = 3
GUISetState(@SW_HIDE, $g_hGUI_LOG)
GUISetState(@SW_HIDE, $g_hGUI_VILLAGE)
GUISetState(@SW_HIDE, $g_hGUI_ATTACK)
GUISetState(@SW_HIDE, $g_hGUI_ABOUT)
GUISetState(@SW_HIDE, $g_hGUI_MOD)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_BOT)
tabBot()
Case $tabidx = 4
GUISetState(@SW_HIDE, $g_hGUI_LOG)
GUISetState(@SW_HIDE, $g_hGUI_VILLAGE)
GUISetState(@SW_HIDE, $g_hGUI_ATTACK)
GUISetState(@SW_HIDE, $g_hGUI_BOT)
GUISetState(@SW_HIDE, $g_hGUI_ABOUT)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_MOD)
Case $tabidx = 5
GUISetState(@SW_HIDE, $g_hGUI_LOG)
GUISetState(@SW_HIDE, $g_hGUI_VILLAGE)
GUISetState(@SW_HIDE, $g_hGUI_ATTACK)
GUISetState(@SW_HIDE, $g_hGUI_BOT)
GUISetState(@SW_HIDE, $g_hGUI_MOD)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_ABOUT)
Case Else
GUISetState(@SW_HIDE, $g_hGUI_LOG)
GUISetState(@SW_HIDE, $g_hGUI_VILLAGE)
GUISetState(@SW_HIDE, $g_hGUI_ATTACK)
GUISetState(@SW_HIDE, $g_hGUI_BOT)
EndSelect
EndFunc
Func tabVillage()
Local $tabidx = GUICtrlRead($g_hGUI_VILLAGE_TAB)
Select
Case $tabidx = 1
GUISetState(@SW_HIDE, $g_hGUI_UPGRADE)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_DONATE)
GUISetState(@SW_HIDE, $g_hGUI_NOTIFY)
Case $tabidx = 2
GUISetState(@SW_HIDE, $g_hGUI_DONATE)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_UPGRADE)
GUISetState(@SW_HIDE, $g_hGUI_NOTIFY)
Case $tabidx = 4
GUISetState(@SW_HIDE, $g_hGUI_DONATE)
GUISetState(@SW_HIDE, $g_hGUI_UPGRADE)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_NOTIFY)
Case Else
GUISetState(@SW_HIDE, $g_hGUI_DONATE)
GUISetState(@SW_HIDE, $g_hGUI_UPGRADE)
GUISetState(@SW_HIDE, $g_hGUI_NOTIFY)
EndSelect
EndFunc
Func tabAttack()
Local $tabidx = GUICtrlRead($g_hGUI_ATTACK_TAB)
Select
Case $tabidx = 0
GUISetState(@SW_HIDE, $g_hGUI_STRATEGIES)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_TRAINARMY)
GUISetState(@SW_HIDE, $g_hGUI_SEARCH)
Case $tabidx = 1
GUISetState(@SW_HIDE, $g_hGUI_STRATEGIES)
GUISetState(@SW_HIDE, $g_hGUI_TRAINARMY)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_SEARCH)
tabSEARCH()
Case $tabidx = 2
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_STRATEGIES)
GUISetState(@SW_HIDE, $g_hGUI_TRAINARMY)
GUISetState(@SW_HIDE, $g_hGUI_SEARCH)
EndSelect
EndFunc
Func tabSEARCH()
Local $tabidx = GUICtrlRead($g_hGUI_SEARCH_TAB)
Local $tabdbx = _GUICtrlTab_GetItemRect($g_hGUI_SEARCH_TAB, 0)
Local $tababx = _GUICtrlTab_GetItemRect($g_hGUI_SEARCH_TAB, 1)
Local $tabtsx = _GUICtrlTab_GetItemRect($g_hGUI_SEARCH_TAB, 2)
Local $tabblx = _GUICtrlTab_GetItemRect($g_hGUI_SEARCH_TAB, 3)
Select
Case $tabidx = 0
GUISetState(@SW_HIDE, $g_hGUI_ACTIVEBASE)
GUISetState(@SW_HIDE, $g_hGUI_THSNIPE)
GUISetState(@SW_HIDE, $g_hGUI_BULLY)
GUISetState(@SW_HIDE, $g_hGUI_ATTACKOPTION)
If GUICtrlRead($g_hChkDeadbase) = $GUI_CHECKED Then
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_DEADBASE)
GUICtrlSetState($g_hLblDeadbaseDisabled, $GUI_HIDE)
Else
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE)
GUICtrlSetState($g_hLblDeadbaseDisabled, $GUI_SHOW)
EndIf
GUICtrlSetPos($g_hChkActivebase, $tababx[2] - 15, $tababx[3] - 15)
GUICtrlSetPos($g_hChkTHSnipe, $tabtsx[2] - 15, $tabtsx[3] - 15)
GUICtrlSetPos($g_hChkBully, $tabblx[2] - 15, $tabblx[3] - 15)
GUICtrlSetPos($g_hChkDeadbase, $tabdbx[2] - 15, $tabdbx[3] - 17)
tabDeadbase()
Case $tabidx = 1
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE)
GUISetState(@SW_HIDE, $g_hGUI_THSNIPE)
GUISetState(@SW_HIDE, $g_hGUI_BULLY)
GUISetState(@SW_HIDE, $g_hGUI_ATTACKOPTION)
If GUICtrlRead($g_hChkActivebase) = $GUI_CHECKED Then
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_ACTIVEBASE)
GUICtrlSetState($g_hLblActivebaseDisabled, $GUI_HIDE)
Else
GUISetState(@SW_HIDE, $g_hGUI_ACTIVEBASE)
GUICtrlSetState($g_hLblActivebaseDisabled, $GUI_SHOW)
EndIf
GUICtrlSetPos($g_hChkDeadbase, $tabdbx[2] - 15, $tabdbx[3] - 15)
GUICtrlSetPos($g_hChkTHSnipe, $tabtsx[2] - 15, $tabtsx[3] - 15)
GUICtrlSetPos($g_hChkBully, $tabblx[2] - 15, $tabblx[3] - 15)
GUICtrlSetPos($g_hChkActivebase, $tababx[2] - 15, $tababx[3] - 17)
tabActivebase()
Case $tabidx = 2
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE)
GUISetState(@SW_HIDE, $g_hGUI_ACTIVEBASE)
GUISetState(@SW_HIDE, $g_hGUI_BULLY)
GUISetState(@SW_HIDE, $g_hGUI_ATTACKOPTION)
If GUICtrlRead($g_hChkTHSnipe) = $GUI_CHECKED Then
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_THSNIPE)
GUICtrlSetState($g_hLblTHSnipeDisabled, $GUI_HIDE)
Else
GUISetState(@SW_HIDE, $g_hGUI_THSNIPE)
GUICtrlSetState($g_hLblTHSnipeDisabled, $GUI_SHOW)
EndIf
GUICtrlSetPos($g_hChkDeadbase, $tabdbx[2] - 15, $tabdbx[3] - 15)
GUICtrlSetPos($g_hChkActivebase, $tababx[2] - 15, $tababx[3] - 15)
GUICtrlSetPos($g_hChkBully, $tabblx[2] - 15, $tabblx[3] - 15)
GUICtrlSetPos($g_hChkTHSnipe, $tabtsx[2] - 15, $tabtsx[3] - 17)
tabTHSnipe()
Case $tabidx = 3
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE)
GUISetState(@SW_HIDE, $g_hGUI_ACTIVEBASE)
GUISetState(@SW_HIDE, $g_hGUI_THSNIPE)
GUISetState(@SW_HIDE, $g_hGUI_ATTACKOPTION)
If GUICtrlRead($g_hChkBully) = $GUI_CHECKED Then
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_BULLY)
GUICtrlSetState($g_hLblBullyDisabled, $GUI_HIDE)
Else
GUISetState(@SW_HIDE, $g_hGUI_BULLY)
GUICtrlSetState($g_hLblBullyDisabled, $GUI_SHOW)
EndIf
GUICtrlSetPos($g_hChkDeadbase, $tabdbx[2] - 15, $tabdbx[3] - 15)
GUICtrlSetPos($g_hChkActivebase, $tababx[2] - 15, $tababx[3] - 15)
GUICtrlSetPos($g_hChkTHSnipe, $tabtsx[2] - 15, $tabtsx[3] - 15)
GUICtrlSetPos($g_hChkBully, $tabblx[2] - 15, $tabblx[3] - 17)
Case $tabidx = 4
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE)
GUISetState(@SW_HIDE, $g_hGUI_ACTIVEBASE)
GUISetState(@SW_HIDE, $g_hGUI_THSNIPE)
GUISetState(@SW_HIDE, $g_hGUI_BULLY)
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_ATTACKOPTION)
GUICtrlSetPos($g_hChkDeadbase, $tabdbx[2] - 15, $tabdbx[3] - 15)
GUICtrlSetPos($g_hChkActivebase, $tababx[2] - 15, $tababx[3] - 15)
GUICtrlSetPos($g_hChkTHSnipe, $tabtsx[2] - 15, $tabtsx[3] - 15)
GUICtrlSetPos($g_hChkBully, $tabblx[2] - 15, $tabblx[3] - 15)
EndSelect
EndFunc
Func tabDONATE()
Local $tabidx = GUICtrlRead($g_hGUI_DONATE_TAB)
Local $tabdonx = _GUICtrlTab_GetItemRect($g_hGUI_DONATE_TAB, 1)
Select
Case $tabidx = 0
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_RequestCC)
GUISetState(@SW_HIDE, $g_hGUI_DONATECC)
GUISetState(@SW_HIDE, $g_hGUI_ScheduleCC)
GUICtrlSetPos($g_hChkDonate, $tabdonx[2] - 15, $tabdonx[3] - 15)
Case $tabidx = 1
GUISetState(@SW_HIDE, $g_hGUI_RequestCC)
GUISetState(@SW_HIDE, $g_hGUI_ScheduleCC)
If GUICtrlRead($g_hChkDonate) = $GUI_CHECKED Then
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_DONATECC)
GUICtrlSetState($g_hLblDonateDisabled, $GUI_HIDE)
Else
GUISetState(@SW_HIDE, $g_hGUI_DONATECC)
GUICtrlSetState($g_hLblDonateDisabled, $GUI_SHOW)
EndIf
GUICtrlSetPos($g_hChkDonate, $tabdonx[2] - 15, $tabdonx[3] - 15)
Case $tabidx = 2
GUISetState(@SW_HIDE, $g_hGUI_RequestCC)
GUISetState(@SW_HIDE, $g_hGUI_DONATECC)
If GUICtrlRead($g_hChkDonate) = $GUI_CHECKED Then
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_ScheduleCC)
GUICtrlSetState($g_hLblScheduleDisabled, $GUI_HIDE)
Else
GUISetState(@SW_HIDE, $g_hGUI_ScheduleCC)
GUICtrlSetState($g_hLblScheduleDisabled, $GUI_SHOW)
EndIf
GUICtrlSetPos($g_hChkDonate, $tabdonx[2] - 15, $tabdonx[3] - 15)
EndSelect
EndFunc
Func tabBot()
Local $tabidx = GUICtrlRead($g_hGUI_BOT_TAB)
Select
Case $tabidx = 0
GUISetState(@SW_HIDE, $g_hGUI_STATS)
ControlShow("", "", $g_hCmbGUILanguage)
Case $tabidx = 1
GUISetState(@SW_HIDE, $g_hGUI_STATS)
ControlHide("", "", $g_hCmbGUILanguage)
Case $tabidx = 2
GUISetState(@SW_HIDE, $g_hGUI_STATS)
ControlHide("", "", $g_hCmbGUILanguage)
Case $tabidx = 3
GUISetState(@SW_SHOWNOACTIVATE, $g_hGUI_STATS)
ControlHide("", "", $g_hCmbGUILanguage)
EndSelect
EndFunc
Func tabDeadbase()
Local $tabidx = GUICtrlRead($g_hGUI_DEADBASE_TAB)
Select
Case $tabidx = 1
cmbDBAlgorithm()
Case Else
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE_ATTACK_STANDARD)
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE_ATTACK_SCRIPTED)
GUISetState(@SW_HIDE, $g_hGUI_DEADBASE_ATTACK_MILKING)
EndSelect
EndFunc
Func tabActivebase()
Local $tabidx = GUICtrlRead($g_hGUI_ACTIVEBASE_TAB)
Select
Case $tabidx = 1
cmbABAlgorithm()
Case Else
GUISetState(@SW_HIDE, $g_hGUI_ACTIVEBASE_ATTACK_STANDARD)
GUISetState(@SW_HIDE, $g_hGUI_ACTIVEBASE_ATTACK_SCRIPTED)
EndSelect
EndFunc
Func tabTHSnipe()
Local $tabidx = GUICtrlRead($g_hGUI_THSNIPE_TAB)
Select
Case $tabidx = 1
Case Else
EndSelect
EndFunc
Func Doncheck()
tabDONATE()
EndFunc
Func dbCheck()
$g_abAttackTypeEnable[$DB] =(GUICtrlRead($g_hChkDeadbase) = $GUI_CHECKED)
If $g_iBotLaunchTime > 0 Then _GUICtrlTab_SetCurFocus($g_hGUI_SEARCH_TAB, 0)
If BitAND(GUICtrlRead($g_hChkDBActivateSearches), GUICtrlRead($g_hChkDBActivateTropies), GUICtrlRead($g_hChkDBActivateCamps), GUICtrlRead($g_hChkDBSpellsWait)) = $GUI_UNCHECKED Then
GUICtrlSetState($g_hChkDBActivateSearches, $GUI_CHECKED)
chkDBActivateSearches()
Else
tabSEARCH()
EndIf
EndFunc
Func dbCheckAll()
If BitAND(GUICtrlRead($g_hChkDBActivateSearches), GUICtrlRead($g_hChkDBActivateTropies), GUICtrlRead($g_hChkDBActivateCamps), GUICtrlRead($g_hChkDBSpellsWait)) = $GUI_UNCHECKED Then
GUICtrlSetState($g_hChkDeadbase, $GUI_UNCHECKED)
Else
GUICtrlSetState($g_hChkDeadbase, $GUI_CHECKED)
EndIf
tabSEARCH()
EndFunc
Func abCheck()
$g_abAttackTypeEnable[$LB] =(GUICtrlRead($g_hChkActivebase) = $GUI_CHECKED)
If $g_iBotLaunchTime > 0 Then _GUICtrlTab_SetCurFocus($g_hGUI_SEARCH_TAB, 1)
If BitAND(GUICtrlRead($g_hChkABActivateSearches), GUICtrlRead($g_hChkABActivateTropies), GUICtrlRead($g_hChkABActivateCamps), GUICtrlRead($g_hChkABSpellsWait)) = $GUI_UNCHECKED Then
GUICtrlSetState($g_hChkABActivateSearches, $GUI_CHECKED)
chkABActivateSearches()
Else
tabSEARCH()
EndIf
EndFunc
Func abCheckAll()
If BitAND(GUICtrlRead($g_hChkABActivateSearches), GUICtrlRead($g_hChkABActivateTropies), GUICtrlRead($g_hChkABActivateCamps), GUICtrlRead($g_hChkABSpellsWait)) = $GUI_UNCHECKED Then
GUICtrlSetState($g_hChkActivebase, $GUI_UNCHECKED)
Else
GUICtrlSetState($g_hChkActivebase, $GUI_CHECKED)
EndIf
tabSEARCH()
EndFunc
Func tsCheck()
$g_abAttackTypeEnable[$TS] =(GUICtrlRead($g_hChkTHSnipe) = $GUI_CHECKED)
If $g_iBotLaunchTime > 0 Then _GUICtrlTab_SetCurFocus($g_hGUI_SEARCH_TAB, 2)
If BitAND(GUICtrlRead($g_hChkTSActivateSearches), GUICtrlRead($g_hChkTSActivateTropies), GUICtrlRead($g_hChkTSActivateCamps)) = $GUI_UNCHECKED Then
GUICtrlSetState($g_hChkTSActivateSearches, $GUI_CHECKED)
chkTSActivateSearches()
Else
tabSEARCH()
EndIf
EndFunc
Func tsCheckAll()
If BitAND(GUICtrlRead($g_hChkTSActivateSearches), GUICtrlRead($g_hChkTSActivateTropies), GUICtrlRead($g_hChkTSActivateCamps)) = $GUI_UNCHECKED Then
GUICtrlSetState($g_hChkTHSnipe, $GUI_UNCHECKED)
Else
GUICtrlSetState($g_hChkTHSnipe, $GUI_CHECKED)
EndIf
tabSEARCH()
EndFunc
Func bullyCheck()
$g_abAttackTypeEnable[$TB] =(GUICtrlRead($g_hChkBully) = $GUI_CHECKED)
If $g_iBotLaunchTime > 0 Then _GUICtrlTab_SetCurFocus($g_hGUI_SEARCH_TAB, 3)
tabSEARCH()
EndFunc
Func ImageList_Create()
$hImageList = DllCall("comctl32.dll", "hwnd", "ImageList_Create", "int", 16, "int", 16, "int", 0x0021, "int", 0, "int", 1)
$hImageList = $hImageList[0]
Return $hImageList
EndFunc
Func Bind_ImageList($nCtrl)
Local $aIconIndex = 0
$hImageList = ImageList_Create()
GUICtrlSendMsg($nCtrl, $TCM_SETIMAGELIST, 0, $hImageList)
Local $tTcItem = DllStructCreate("uint;dword;dword;ptr;int;int;int")
DllStructSetData($tTcItem, 1, 0x0002)
Switch $nCtrl
Case $g_hTabMain
Local $aIconIndex[6] = [$eIcnHourGlass, $eIcnTH11, $eIcnAttack, $eIcnGUI, $eModIcon, $eIcnInfo]
Case $g_hGUI_VILLAGE_TAB
Local $aIconIndex[5] = [$eIcnTH1, $eIcnCC, $eIcnLaboratory, $eIcnAchievements, $eIcnPBNotify]
Case $g_hGUI_TRAINARMY_TAB
Local $aIconIndex[4] = [$eIcnTrain, $eIcnGem, $eIcnReOrder, $eIcnOptions]
Case $g_hGUI_DONATE_TAB
Local $aIconIndex[3] = [$eIcnCCRequest, $eIcnCCDonate, $eIcnHourGlass]
Case $g_hGUI_UPGRADE_TAB
Local $aIconIndex[4] = [$eIcnLaboratory, $eIcnHeroes, $eIcnMortar, $eIcnWall]
Case $g_hGUI_NOTIFY_TAB
Local $aIconIndex[2] = [$eIcnPBNotify, $eIcnHourGlass]
Case $g_hGUI_ATTACK_TAB
Local $aIconIndex[3] = [$eIcnTrain, $eIcnMagnifier, $eIcnStrategies]
Case $g_hGUI_SEARCH_TAB
Local $aIconIndex[5] = [$eIcnCollector, $eIcnCC, $eIcnTH10, $eIcnTH1, $eIcnOptions]
Case $g_hGUI_DEADBASE_TAB
Local $aIconIndex[4] = [$eIcnMagnifier, $eIcnCamp, $eIcnSilverStar, $eIcnCollector]
Case $g_hGUI_ACTIVEBASE_TAB
Local $aIconIndex[3] = [$eIcnMagnifier, $eIcnCamp, $eIcnSilverStar]
Case $g_hGUI_THSNIPE_TAB
Local $aIconIndex[3] = [$eIcnMagnifier, $eIcnCamp, $eIcnSilverStar]
Case $g_hGUI_ATTACKOPTION_TAB
Local $aIconIndex[5] = [$eIcnMagnifier, $eIcnCamp, $eIcnLightSpell, $eIcnSilverStar, $eIcnTrophy]
Case $g_hGUI_BOT_TAB
Local $aIconIndex[4] = [$eIcnOptions, $eIcnAndroid, $eIcnBug, $eIcnStats]
Case $g_hGUI_STRATEGIES_TAB
Local $aIconIndex[2] = [$eIcnReload, $eIcnCopy]
Case $g_hGUI_STATS_TAB
Local $aIconIndex[4] = [$eIcnGoldElixir, $eIcnOptions, $eIcnCamp, $eIcnCCRequest]
Case $g_hGUI_MOD_TAB
Local $aIconIndex[5] = [$eIcnInfo, $eIcnBrain, $eIcnOptions, $eIcnProfile, $eIcnMultiStat]
Case Else
EndSwitch
If IsArray($aIconIndex) Then
For $i = 0 To UBound($aIconIndex) - 1
DllStructSetData($tTcItem, 6, $i)
AddImageToTab($nCtrl, $i, $tTcItem, $g_sLibIconPath, $aIconIndex[$i] - 1)
Next
$aIconIndex = 0
EndIf
$tTcItem = 0
EndFunc
Func AddImageToTab($nCtrl, $nTabIndex, $nItem, $g_sLibIconPath, $nIconID)
Local $hIcon = DllStructCreate("int")
Local $Result = DllCall("shell32.dll", "int", "ExtractIconEx", "str", $g_sLibIconPath, "int", $nIconID, "hwnd", 0, "ptr", DllStructGetPtr($hIcon), "int", 1)
$Result = $Result[0]
If $Result > 0 Then
DllCall("comctl32.dll", "int", "ImageList_AddIcon", "hwnd", $hImageList, "hwnd", DllStructGetData($hIcon, 1))
DllCall("user32.dll", "int", "SendMessage", "hwnd", ControlGetHandle($g_hFrmBot, "", $nCtrl), "int", $TCM_SETITEM, "int", $nTabIndex, "ptr", DllStructGetPtr($nItem))
DllCall("user32.dll", "int", "DestroyIcon", "hwnd", $hIcon)
EndIf
$hIcon = 0
EndFunc
Func _GUICtrlListView_SetItemHeightByFont($hListView, $iHeight)
Local $hDC = _WinAPI_GetDC($hListView), $hFont = _SendMessage($hListView, $WM_GETFONT)
Local $hObject = _WinAPI_SelectObject($hDC, $hFont), $lvLOGFONT = DllStructCreate($tagLOGFONT)
_WinAPI_GetObject($hFont, DllStructGetSize($lvLOGFONT), DllStructGetPtr($lvLOGFONT))
Local $hLVfont = _WinAPI_CreateFontIndirect($lvLOGFONT)
_WinAPI_SelectObject($hDC, $hObject)
_WinAPI_ReleaseDC($hListView, $hDC)
_WinAPI_DeleteObject($hFont)
$hFont = _WinAPI_CreateFont($iHeight, 0)
_WinAPI_SetFont($hListView, $hFont)
_WinAPI_DeleteObject($hFont)
Local $hHeader = _GUICtrlListView_GetHeader($hListView)
If $hHeader Then _WinAPI_SetFont($hHeader, $hLVfont)
$lvLOGFONT = 0
Return $hLVfont
EndFunc
Func _GUICtrlListView_GetHeightToFitRows($hListView, $iRows)
Local $tRECT = _WinAPI_GetClientRect($hListView)
Local $hHeader = _GUICtrlListView_GetHeader($hListView)
Local $tWindowPos = _GUICtrlHeader_Layout($hHeader, $tRECT)
Local $iHdrHeight = DllStructGetData($tWindowPos, "CY")
Local $aItemRect = _GUICtrlListView_GetItemRect($hListView, 0, 0)
Return($aItemRect[3] - $aItemRect[1]) * $iRows + $iHdrHeight + 8
EndFunc
Func EnableControls($hWin, $Enable, ByRef $avArr, $bGUIControl_Disabled = True, $i = 0)
Local $initalCall = $i = 0
If UBound($avArr, 0) <> 2 Then
Local $avTmp[1][2] = [[0]]
$avArr = $avTmp
EndIf
If $initalCall And $bGUIControl_Disabled Then
_SendMessage($hWin, $WM_SETREDRAW, False, 0)
Local $GUIControl_Disabled_ = $GUIControl_Disabled
$GUIControl_Disabled = True
EndIf
Local $hChild = _WinAPI_GetWindow($hWin, $GW_CHILD)
While $hChild
$i += 1
If $avArr[0][0] + 1 > UBound($avArr, 1) - 1 Then
ReDim $avArr[$avArr[0][0] + 2][2]
$avArr[$avArr[0][0] + 1][0] = $hChild
$avArr[$avArr[0][0] + 1][1] = BitAND(WinGetState($hChild), 4) > 0
EndIf
If $Enable = Default Then
WinSetState($hChild, "",($avArr[$i][1] = True ? @SW_ENABLE : @SW_DISABLE))
Else
WinSetState($hChild, "",($Enable ? @SW_ENABLE : @SW_DISABLE))
EndIf
$avArr[0][0] += 1
$i = EnableControls($hChild, $Enable, $avArr, $bGUIControl_Disabled, $i)
$hChild = _WinAPI_GetWindow($hChild, $GW_HWNDNEXT)
WEnd
If $initalCall And $Enable = Default Then $avArr = 0
If $initalCall And $bGUIControl_Disabled Then
_SendMessage($hWin, $WM_SETREDRAW, True, 0)
_WinAPI_RedrawWindow($hWin, 0, 0, BitOR($RDW_INVALIDATE, $RDW_ALLCHILDREN))
$GUIControl_Disabled = $GUIControl_Disabled_
EndIf
Return $i
EndFunc
Func frmBot_WNDPROC($hWin, $iMsg, $wParam, $lParam)
Local $wasCritical = SetCriticalMessageProcessing(True)
If $g_iDebugWindowMessages > 0 Then SetDebugLog("frmBot_WNDPROC: FORWARD $hWin=" & $hWin & ", $iMsg=" & Hex($iMsg) & ", $wParam=" & Hex($wParam) & ", $lParam=" & $lParam, Default, True)
Switch $iMsg
Case $WM_KEYDOWN, $WM_KEYUP, $WM_SYSKEYDOWN, $WM_SYSKEYUP, $WM_MOUSEWHEEL, $WM_MOUSEHWHEEL
GUIControl_AndroidEmbedded($hWin, $iMsg, $wParam, $lParam)
EndSwitch
Local $wndproc = $g_hFrmBot_WNDPROC
Local $Return = 1
If $wndproc <> 0 Then
_WinAPI_CallWindowProc($wndproc, $hWin, $iMsg, $wParam, $lParam)
$Return = 0
EndIf
SetCriticalMessageProcessing($wasCritical)
Return $Return
EndFunc
Func HandleWndProc($Enable = True)
If $g_hFrmBot_WNDPROC = 0 And $Enable = True Then
$g_hFrmBot_WNDPROC = _WinAPI_SetWindowLong(ControlGetHandle($g_hFrmBot, "", $g_hFrmBotEmbeddedShieldInput), $GWL_WNDPROC, $g_hFrmBot_WNDPROC_ptr)
ElseIf $g_hFrmBot_WNDPROC <> 0 And $Enable = False Then
_WinAPI_SetWindowLong(ControlGetHandle($g_hFrmBot, "", $g_hFrmBotEmbeddedShieldInput), $GWL_WNDPROC, $g_hFrmBot_WNDPROC)
$g_hFrmBot_WNDPROC = 0
EndIf
EndFunc
Func IsGUICtrlHidden($hGUICtrl)
If BitAND(WinGetState(GUICtrlGetHandle($hGUICtrl), ""), 2) = 0 Then Return True
Return False
EndFunc
Func AcquireMutex($mutexName, $scope = Default, $timeout = Default)
Local $timer = TimerInit()
Local $g_hMutex_MyBot = 0
If $scope = Default Then
$scope = @AutoItPID & "/"
ElseIf $scope <> "" Then
$scope &= "/"
EndIf
If $timeout = Default Then $timeout = 30000
While $g_hMutex_MyBot = 0 And($timeout = 0 Or TimerDiff($timer) < $timeout)
$g_hMutex_MyBot = _Singleton("MyBot.run/" & $scope & $mutexName, 1)
If $g_hMutex_MyBot <> 0 Then ExitLoop
If $timeout = 0 Then ExitLoop
Sleep($iDelaySleep)
WEnd
Return $g_hMutex_MyBot
EndFunc
Func ReleaseMutex($hMutex, $ReturnValue = Default)
_WinAPI_CloseHandle($hMutex)
If $ReturnValue = Default Then Return
Return $ReturnValue
EndFunc
Func WaitForSemaphore($sSemaphore, $iInitial = 4096, $iMaximum = 4096, $tSecurity = 0)
Local $bAquired = False
While $bAquired = False
Local $hSemaphore = _WinAPI_CreateSemaphore($sSemaphore, $iInitial, $iMaximum, $tSecurity)
$bAquired = _WinAPI_WaitForSingleObject($hSemaphore, 0) <> -1
If $bAquired = True Then
_WinAPI_ReleaseSemaphore($hSemaphore)
_WinAPI_CloseHandle($hSemaphore)
ExitLoop
EndIf
_Sleep($iDelaySleep, True, False)
WEnd
EndFunc
Func LockSemaphore($sSemaphore)
Local $bAquired = False
While $bAquired = False
Local $hSemaphore = _WinAPI_CreateSemaphore($sSemaphore, 0, 1)
$bAquired = _WinAPI_WaitForSingleObject($hSemaphore, 0) <> -1
If $bAquired = True And _WinAPI_WaitForSingleObject($hSemaphore, 0) = -1 Then
Return $hSemaphore
ExitLoop
EndIf
_WinAPI_ReleaseSemaphore($hSemaphore)
_WinAPI_CloseHandle($hSemaphore)
_Sleep($iDelaySleep, True, False)
WEnd
EndFunc
Func UnlockSemaphore($hSemaphore)
If $hSemaphore <> 0 And $hSemaphore <> -1 Then
_WinAPI_ReleaseSemaphore($hSemaphore)
Return _WinAPI_CloseHandle($hSemaphore)
EndIf
Return False
EndFunc
Global Enum $iOAER_bSet_ErrLine, $iOAER_bIn_Proc, $iOAER_bUse_StdOut, $iOAER_iPID, $iOAER_hErr_Callback, $iOAER_hErr_WinHook, $iOAER_sUserFunc, $iOAER_vUserParams, $iOAER_iCOMErrorNumber, $iOAER_sCOMErrorDesc, $iOAER_Total
Global $aOAER_DATA[$iOAER_Total]
Func _OnAutoItErrorRegister()
If $aOAER_DATA[$iOAER_hErr_WinHook] Then
Return
EndIf
$aOAER_DATA[$iOAER_hErr_CallBack] = DllCallbackRegister('__OAER_OnErrorCallback', 'int', 'int;int;int')
$aOAER_DATA[$iOAER_hErr_WinHook] = _WinAPI_SetWindowsHookEx($WH_CBT, DllCallbackGetPtr($aOAER_DATA[$iOAER_hErr_CallBack]), 0, _WinAPI_GetCurrentThreadId())
If Not $aOAER_DATA[$iOAER_hErr_WinHook] Then
DllCallbackFree($aOAER_DATA[$iOAER_hErr_CallBack])
Return 0
Else
Return 1
EndIf
EndFunc
Func _OnAutoItErrorUnRegister()
__OAER_OnExit()
EndFunc
Func __OAER_OnExit()
If $aOAER_DATA[$iOAER_hErr_WinHook] Then
_WinAPI_UnhookWindowsHookEx($aOAER_DATA[$iOAER_hErr_WinHook])
$aOAER_DATA[$iOAER_hErr_WinHook] = 0
EndIf
If $aOAER_DATA[$iOAER_hErr_CallBack] Then
DllCallbackFree($aOAER_DATA[$iOAER_hErr_CallBack])
$aOAER_DATA[$iOAER_hErr_CallBack] = 0
EndIf
EndFunc
Func __OAER_OnErrorCallback($nCode, $wParam, $lParam)
If $nCode < 0 Then
Return _WinAPI_CallNextHookEx($aOAER_DATA[$iOAER_hErr_WinHook], $nCode, $wParam, $lParam)
EndIf
Switch $nCode
Case 5
If Not _WinAPI_FindWindow('#32770', 'AutoIt Error') Then
Return _WinAPI_CallNextHookEx($aOAER_DATA[$iOAER_hErr_WinHook], $nCode, $wParam, $lParam)
EndIf
Local $hError_Wnd = HWnd($wParam)
Local $sError_Msg = StringRegExpReplace(ControlGetText($hError_Wnd, '', 'Static2'), '(?<!\r)\n', @CRLF)
If(_WinAPI_GetClassName($hError_Wnd) <> '#32770' And WinGetTitle($hError_Wnd) <> 'AutoIt Error') Or Not StringRegExp($sError_Msg, '(?is)^.*Line \d+\s+\(File "(.*?)"\):\s+.*Error: .*') Then
Return _WinAPI_CallNextHookEx($aOAER_DATA[$iOAER_hErr_WinHook], $nCode, $wParam, $lParam)
EndIf
SetDebugLog($g_sBotTitle & " AutoIt Error: " & $sError_Msg, Default, True)
BotClose(Default, False)
_WinAPI_FatalAppExit($sError_Msg)
EndSwitch
Return _WinAPI_CallNextHookEx($aOAER_DATA[$iOAER_hErr_WinHook], $nCode, $wParam, $lParam)
EndFunc
Func applyConfig($bRedrawAtExit = True, $TypeReadSave = "Read")
Static $iApplyConfigCount = 0
$iApplyConfigCount += 1
SetDebugLog("applyConfig(), call number " & $iApplyConfigCount)
setMaxDegreeOfParallelism($g_iThreads)
If $g_bAndroidEmbedded = False Then
If $frmBotPosX > -30000 And $frmBotPosY > -30000 And $g_bFrmBotMinimized = False Then WinMove2($g_hFrmBot, "", $frmBotPosX, $frmBotPosY)
If $AndroidPosX > -30000 And $AndroidPosY > -30000 And $Hide = False Then WinMove2($HWnD, "", $AndroidPosX, $AndroidPosY)
Else
If $frmBotDockedPosX > -30000 And $frmBotDockedPosY > -30000 And $g_bFrmBotMinimized = False Then WinMove2($g_hFrmBot, "", $frmBotDockedPosX, $frmBotDockedPosY)
EndIf
Local $bWasRdraw = SetRedrawBotWindow(False, Default, Default, Default, "applyConfig")
ApplyConfig_Android($TypeReadSave)
ApplyConfig_600_1($TypeReadSave)
ApplyConfig_600_6($TypeReadSave)
ApplyConfig_600_9($TypeReadSave)
ApplyConfig_600_11($TypeReadSave)
ApplyConfig_600_12($TypeReadSave)
ApplyConfig_600_13($TypeReadSave)
ApplyConfig_600_14($TypeReadSave)
ApplyConfig_600_15($TypeReadSave)
ApplyConfig_600_16($TypeReadSave)
ApplyConfig_600_17($TypeReadSave)
ApplyConfig_600_18($TypeReadSave)
ApplyConfig_600_19($TypeReadSave)
ApplyConfig_600_22($TypeReadSave)
ApplyConfig_600_26($TypeReadSave)
ApplyConfig_600_28($TypeReadSave)
ApplyConfig_600_28_DB($TypeReadSave)
ApplyConfig_600_28_LB($TypeReadSave)
ApplyConfig_600_28_TS($TypeReadSave)
ApplyConfig_600_29($TypeReadSave)
ApplyConfig_600_29_DB($TypeReadSave)
ApplyConfig_600_29_LB($TypeReadSave)
ApplyConfig_600_29_TS($TypeReadSave)
ApplyConfig_600_30($TypeReadSave)
ApplyConfig_600_30_DB($TypeReadSave)
ApplyConfig_600_30_LB($TypeReadSave)
ApplyConfig_600_30_TS($TypeReadSave)
ApplyConfig_600_31($TypeReadSave)
ApplyConfig_600_32($TypeReadSave)
ApplyConfig_600_35($TypeReadSave)
ApplyConfig_600_52_1($TypeReadSave)
ApplyConfig_600_52_2($TypeReadSave)
ApplyConfig_600_54($TypeReadSave)
ApplyConfig_600_56($TypeReadSave)
ApplyConfig_641_1($TypeReadSave)
PopulatePresetComboBox()
MakeSavePresetMessage()
GUICtrlSetState($g_hLblLoadPresetMessage, $GUI_SHOW)
GUICtrlSetState($g_hTxtPresetMessage, $GUI_HIDE)
GUICtrlSetState($g_hBtnGUIPresetLoadConf, $GUI_HIDE)
GUICtrlSetState($g_hBtnGUIPresetDeleteConf, $GUI_HIDE + $GUI_DISABLE)
GUICtrlSetState($g_hChkDeleteConf, $GUI_HIDE + $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDeleteConf, $GUI_HIDE)
ApplyConfig_DocOc($TypeReadSave)
ApplyConfig_Debug($TypeReadSave)
If $bRedrawAtExit Then SetRedrawBotWindow($bWasRdraw, Default, Default, Default, "applyConfig")
EndFunc
Func ApplyConfig_Android($TypeReadSave)
Switch $TypeReadSave
Case "Read"
SetCurSelCmbCOCDistributors()
UpdateBotTitle()
Case "Save"
cmbCOCDistributors()
EndSwitch
EndFunc
Func ApplyConfig_Debug($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkDebugClick, $g_iDebugClick = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDebugSetlog, $g_iDebugSetlog = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDebugDisableZoomout, $g_iDebugDisableZoomout = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDebugDisableVillageCentering, $g_iDebugDisableVillageCentering = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDebugDeadbaseImage, $g_iDebugDeadBaseImage = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDebugOCR, $g_iDebugOcr = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDebugImageSave, $g_iDebugImageSave = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkdebugBuildingPos, $g_iDebugBuildingPos = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkdebugTrain, $g_iDebugSetlogTrain = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDebugOCRDonate, $g_iDebugOCRdonate = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkdebugAttackCSV, $g_iDebugAttackCSV = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkMakeIMGCSV, $g_iDebugMakeIMGCSV = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
If $g_bDevMode = True Then
GUICtrlSetState($g_hChkDebugSetlog, $GUI_ENABLE)
GUICtrlSetState($g_hChkDebugOCR, $GUI_ENABLE)
GUICtrlSetState($g_hChkDebugImageSave, $GUI_ENABLE)
GUICtrlSetState($g_hChkdebugBuildingPos, $GUI_ENABLE)
GUICtrlSetState($g_hChkdebugTrain, $GUI_ENABLE)
GUICtrlSetState($g_hChkMakeIMGCSV, $GUI_ENABLE)
GUICtrlSetState($g_hChkdebugAttackCSV, $GUI_ENABLE)
EndIf
Case "Save"
$g_iDebugClick = GUICtrlRead($g_hChkDebugClick) = $GUI_CHECKED ? 1 : 0
If $g_bDevMode = True Then
$g_iDebugSetlog = GUICtrlRead($g_hChkDebugSetlog) = $GUI_CHECKED ? 1 : 0
$g_iDebugDisableZoomout = GUICtrlRead($g_hChkDebugDisableZoomout) = $GUI_CHECKED ? 1 : 0
$g_iDebugDisableVillageCentering = GUICtrlRead($g_hChkDebugDisableVillageCentering) = $GUI_CHECKED ? 1 : 0
$g_iDebugDeadBaseImage = GUICtrlRead($g_hChkDebugDeadbaseImage) = $GUI_CHECKED ? 1 : 0
$g_iDebugOcr = GUICtrlRead($g_hChkDebugOCR) = $GUI_CHECKED ? 1 : 0
$g_iDebugImageSave = GUICtrlRead($g_hChkDebugImageSave) = $GUI_CHECKED ? 1 : 0
$g_iDebugBuildingPos = GUICtrlRead($g_hChkdebugBuildingPos) = $GUI_CHECKED ? 1 : 0
$g_iDebugSetlogTrain = GUICtrlRead($g_hChkdebugTrain) = $GUI_CHECKED ? 1 : 0
$g_iDebugOCRdonate = GUICtrlRead($g_hChkDebugOCRDonate) = $GUI_CHECKED ? 1 : 0
$g_iDebugAttackCSV = GUICtrlRead($g_hChkdebugAttackCSV) = $GUI_CHECKED ? 1 : 0
$g_iDebugMakeIMGCSV = GUICtrlRead($g_hChkMakeIMGCSV ) = $GUI_CHECKED ? 1 : 0
EndIf
EndSwitch
EndFunc
Func ApplyConfig_600_1($TypeReadSave)
Switch $TypeReadSave
Case "Read"
_GUICtrlComboBox_SetCurSel($g_hCmbLogDividerOption, $g_iCmbLogDividerOption)
cmbLog()
GUICtrlSetState($g_hChkBackgroundMode, $g_bChkBackgroundMode = True ? $GUI_CHECKED : $GUI_UNCHECKED)
chkBackground()
Case "Save"
$g_iCmbLogDividerOption = _GUICtrlComboBox_GetCurSel($g_hCmbLogDividerOption)
$g_bChkBackgroundMode =(GUICtrlRead($g_hChkBackgroundMode) = $GUI_CHECKED)
EndSwitch
EndFunc
Func ApplyConfig_600_6($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkBotStop, $g_bChkBotStop ? $GUI_CHECKED : $GUI_UNCHECKED)
chkBotStop()
_GUICtrlComboBox_SetCurSel($g_hCmbBotCommand, $g_iCmbBotCommand)
_GUICtrlComboBox_SetCurSel($g_hCmbBotCond, $g_iCmbBotCond)
_GUICtrlComboBox_SetCurSel($g_hCmbHoursStop, $g_iCmbHoursStop)
cmbBotCond()
GUICtrlSetData($g_hTxtRestartGold, $g_iTxtRestartGold)
GUICtrlSetData($g_hTxtRestartElixir, $g_iTxtRestartElixir)
GUICtrlSetData($g_hTxtRestartDark, $g_iTxtRestartDark)
GUICtrlSetState($g_hChkTrap, $g_bChkTrap ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkCollect, $g_bChkCollect ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTombstones, $g_bChkTombstones ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkCleanYard, $g_bChkCleanYard ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkGemsBox, $g_bChkGemsBox ? $GUI_CHECKED : $GUI_UNCHECKED)
Case "Save"
$g_bChkBotStop =(GUICtrlRead($g_hChkBotStop) = $GUI_CHECKED)
$g_iCmbBotCommand = _GUICtrlComboBox_GetCurSel($g_hCmbBotCommand)
$g_iCmbBotCond = _GUICtrlComboBox_GetCurSel($g_hCmbBotCond)
$g_iCmbHoursStop = _GUICtrlComboBox_GetCurSel($g_hCmbHoursStop)
$g_iTxtRestartGold = GUICtrlRead($g_hTxtRestartGold)
$g_iTxtRestartElixir = GUICtrlRead($g_hTxtRestartElixir)
$g_iTxtRestartDark = GUICtrlRead($g_hTxtRestartDark)
$g_bChkTrap =(GUICtrlRead($g_hchkTrap) = $GUI_CHECKED)
$g_bChkCollect =(GUICtrlRead($g_hChkCollect) = $GUI_CHECKED)
$g_bChkTombstones =(GUICtrlRead($g_hChkTombstones) = $GUI_CHECKED)
$g_bChkCleanYard =(GUICtrlRead($g_hChkCleanYard) = $GUI_CHECKED)
$g_bChkGemsBox =(GUICtrlRead($g_hChkGemsBox) = $GUI_CHECKED)
EndSwitch
EndFunc
Func ApplyConfig_600_9($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkUnbreakable, $g_iUnbrkMode = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtUnbreakable, $g_iUnbrkWait)
GUICtrlSetData($g_hTxtUnBrkMinGold, $g_iUnbrkMinGold)
GUICtrlSetData($g_hTxtUnBrkMinElixir, $g_iUnbrkMinElixir)
GUICtrlSetData($g_hTxtUnBrkMinDark, $g_iUnbrkMinDark)
GUICtrlSetData($g_hTxtUnBrkMaxGold, $g_iUnbrkMaxGold)
GUICtrlSetData($g_hTxtUnBrkMaxElixir, $g_iUnbrkMaxElixir)
GUICtrlSetData($g_hTxtUnBrkMaxDark, $g_iUnbrkMaxDark)
chkUnbreakable()
Case "Save"
$g_iUnbrkMode = GUICtrlRead($g_hChkUnbreakable) = $GUI_CHECKED ? 1 : 0
$g_iUnbrkWait = GUICtrlRead($g_hTxtUnbreakable)
$g_iUnbrkMinGold = GUICtrlRead($g_hTxtUnBrkMinGold)
$g_iUnbrkMinElixir = GUICtrlRead($g_hTxtUnBrkMinElixir)
$g_iUnbrkMinDark = GUICtrlRead($g_hTxtUnBrkMinDark)
$g_iUnbrkMaxGold = GUICtrlRead($g_hTxtUnBrkMaxGold)
$g_iUnbrkMaxElixir = GUICtrlRead($g_hTxtUnBrkMaxElixir)
$g_iUnbrkMaxDark = GUICtrlRead($g_hTxtUnBrkMaxDark)
EndSwitch
EndFunc
Func ApplyConfig_600_11($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkRequestTroopsEnable, $g_bRequestTroopsEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkRequestCCHours()
GUICtrlSetData($g_hTxtRequestCC, $g_sRequestTroopsText)
For $i = 0 To 23
GUICtrlSetState($g_ahChkRequestCCHours[$i], $g_abRequestCCHours[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
Next
Case "Save"
$g_bRequestTroopsEnable =(GUICtrlRead($g_hChkRequestTroopsEnable) = $GUI_CHECKED)
$g_sRequestTroopsText = GUICtrlRead($g_hTxtRequestCC)
For $i = 0 To 23
$g_abRequestCCHours[$i] =(GUICtrlRead($g_ahChkRequestCCHours[$i]) = $GUI_CHECKED)
Next
EndSwitch
EndFunc
Func ApplyConfig_600_12($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkDonate, $g_bChkDonate ? $GUI_CHECKED : $GUI_UNCHECKED)
Doncheck()
For $i = 0 To $eTroopCount-1 + $g_iCustomDonateConfigs
GUICtrlSetState($g_ahChkDonateTroop[$i], $g_abChkDonateTroop[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
If $g_abChkDonateTroop[$i] Then
_DonateControls($i)
Else
GUICtrlSetBkColor($g_ahLblDonateTroop[$i], $GUI_BKCOLOR_TRANSPARENT)
EndIf
If $g_abChkDonateAllTroop[$i] Then
GUICtrlSetState($g_ahChkDonateAllTroop[$i], $GUI_CHECKED)
_DonateAllControls($i, True)
Else
GUICtrlSetState($g_ahChkDonateAllTroop[$i], $GUI_UNCHECKED)
EndIf
GUICtrlSetData($g_ahTxtDonateTroop[$i], $g_asTxtDonateTroop[$i])
GUICtrlSetData($g_ahTxtBlacklistTroop[$i], $g_asTxtBlacklistTroop[$i])
Next
For $i = 0 To $eSpellCount - 1
If $i <> $eSpellClone Then
GUICtrlSetState($g_ahChkDonateSpell[$i], $g_abChkDonateSpell[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
If $g_abChkDonateSpell[$i] Then
_DonateControlsSpell($i)
Else
GUICtrlSetBkColor($g_ahLblDonateSpell[$i], $GUI_BKCOLOR_TRANSPARENT)
EndIf
If $g_abChkDonateAllSpell[$i] Then
GUICtrlSetState($g_ahChkDonateAllSpell[$i], $GUI_CHECKED)
_DonateAllControlsSpell($i, True)
Else
GUICtrlSetState($g_ahChkDonateAllSpell[$i], $GUI_UNCHECKED)
EndIf
EndIf
If $i <> $eSpellClone Then
GUICtrlSetData($g_ahTxtDonateSpell[$i], $g_asTxtDonateSpell[$i])
GUICtrlSetData($g_ahTxtBlacklistSpell[$i], $g_asTxtBlacklistSpell[$i])
EndIf
Next
For $i = 0 To 2
_GUICtrlComboBox_SetCurSel($g_ahCmbDonateCustomA[$i], $g_aiDonateCustomTrpNumA[$i][0])
GUICtrlSetData($g_ahTxtDonateCustomA[$i], $g_aiDonateCustomTrpNumA[$i][1])
Next
cmbDonateCustomA()
For $i = 0 To 2
_GUICtrlComboBox_SetCurSel($g_ahCmbDonateCustomB[$i], $g_aiDonateCustomTrpNumB[$i][0])
GUICtrlSetData($g_ahTxtDonateCustomB[$i], $g_aiDonateCustomTrpNumB[$i][1])
Next
cmbDonateCustomB()
GUICtrlSetState($g_hChkExtraAlphabets, $g_bChkExtraAlphabets ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkExtraChinese, $g_bChkExtraChinese ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkExtraKorean, $g_bChkExtraKorean ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtGeneralBlacklist, $g_sTxtGeneralBlacklist)
Case "Save"
$g_bChkDonate =(GUICtrlRead($g_hChkDonate) = $GUI_CHECKED)
For $i = 0 To $eTroopCount-1 + $g_iCustomDonateConfigs
$g_abChkDonateTroop[$i] =(GUICtrlRead($g_ahChkDonateTroop[$i]) = $GUI_CHECKED)
$g_abChkDonateAllTroop[$i] =(GUICtrlRead($g_ahChkDonateAllTroop[$i]) = $GUI_CHECKED)
$g_asTxtDonateTroop[$i] = GUICtrlRead($g_ahTxtDonateTroop[$i])
$g_asTxtBlacklistTroop[$i] = GUICtrlRead($g_ahTxtBlacklistTroop[$i])
Next
For $i = 0 To $eSpellCount - 1
If $i <> $eSpellClone Then
$g_abChkDonateSpell[$i] =(GUICtrlRead($g_ahChkDonateSpell[$i]) = $GUI_CHECKED)
$g_abChkDonateAllSpell[$i] =(GUICtrlRead($g_ahChkDonateAllSpell[$i]) = $GUI_CHECKED)
$g_asTxtDonateSpell[$i] = GUICtrlRead($g_ahTxtDonateSpell[$i])
$g_asTxtBlacklistSpell[$i] = GUICtrlRead($g_ahTxtBlacklistSpell[$i])
EndIf
Next
For $i = 0 To 2
$g_aiDonateCustomTrpNumA[$i][0] = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomA[$i])
$g_aiDonateCustomTrpNumA[$i][1] = GUICtrlRead($g_ahTxtDonateCustomA[$i])
$g_aiDonateCustomTrpNumB[$i][0] = _GUICtrlComboBox_GetCurSel($g_ahCmbDonateCustomB[$i])
$g_aiDonateCustomTrpNumB[$i][1] = GUICtrlRead($g_ahTxtDonateCustomB[$i])
Next
$g_bChkExtraAlphabets =(GUICtrlRead($g_hChkExtraAlphabets) = $GUI_CHECKED)
$g_bChkExtraChinese =(GUICtrlRead($g_hChkExtraChinese) = $GUI_CHECKED)
$g_bChkExtraKorean =(GUICtrlRead($g_hChkExtraKorean) = $GUI_CHECKED)
$g_sTxtGeneralBlacklist = GUICtrlRead($g_hTxtGeneralBlacklist)
EndSwitch
EndFunc
Func ApplyConfig_600_13($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkDonateHoursEnable, $g_bDonateHoursEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkDonateHours()
For $i = 0 To 23
GUICtrlSetState($g_ahChkDonateHours[$i], $g_abDonateHours[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
Next
_GUICtrlComboBox_SetCurSel($g_hCmbFilterDonationsCC, $g_iCmbDonateFilter)
GUICtrlSetState($g_hChkSkipDonateNearFullTroopsEnable, $g_bDonateSkipNearFullEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtSkipDonateNearFullTroopsPercentage, $g_iDonateSkipNearFullPercent)
chkskipDonateNearFulLTroopsEnable()
Case "Save"
$g_bDonateHoursEnable =(GUICtrlRead($g_hChkDonateHoursEnable) = $GUI_CHECKED)
For $i = 0 To 23
$g_abDonateHours[$i] =(GUICtrlRead($g_ahChkDonateHours[$i]) = $GUI_CHECKED)
Next
$g_iCmbDonateFilter = _GUICtrlComboBox_GetCurSel($g_hCmbFilterDonationsCC)
$g_bDonateSkipNearFullEnable =(GUICtrlRead($g_hChkSkipDonateNearFullTroopsEnable) = $GUI_CHECKED)
$g_iDonateSkipNearFullPercent = Number(GUICtrlRead($g_hTxtSkipDonateNearFullTroopsPercentage))
EndSwitch
EndFunc
Func ApplyConfig_600_14($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkAutoLabUpgrades, $g_bAutoLabUpgradeEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbLaboratory, $g_iCmbLaboratory)
GUICtrlSetImage($g_hPicLabUpgrade, $g_sLibIconPath, $aLabTroops[$g_iCmbLaboratory][4])
chkLab()
Case "Save"
$g_bAutoLabUpgradeEnable =(GUICtrlRead($g_hChkAutoLabUpgrades) = $GUI_CHECKED)
$g_iCmbLaboratory = _GUICtrlComboBox_GetCurSel($g_hCmbLaboratory)
EndSwitch
EndFunc
Func ApplyConfig_600_15($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkUpgradeKing, $g_bUpgradeKingEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkUpgradeKing()
chkDBKingWait()
chkABKingWait()
GUICtrlSetState($g_hChkUpgradeQueen, $g_bUpgradeQueenEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkUpgradeQueen()
chkDBQueenWait()
chkABQueenWait()
GUICtrlSetState($g_hChkUpgradeWarden, $g_bUpgradeWardenEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkUpgradeWarden()
chkDBWardenWait()
chkABWardenWait()
Case "Save"
$g_bUpgradeKingEnable =(GUICtrlRead($g_hChkUpgradeKing) = $GUI_CHECKED)
$g_bUpgradeQueenEnable =(GUICtrlRead($g_hChkUpgradeQueen) = $GUI_CHECKED)
$g_bUpgradeWardenEnable =(GUICtrlRead($g_hChkUpgradeWarden) = $GUI_CHECKED)
EndSwitch
EndFunc
Func ApplyConfig_600_16($TypeReadSave)
Switch $TypeReadSave
Case "Read"
For $iz = 0 To UBound($g_avBuildingUpgrades, 1) - 1
GUICtrlSetImage($g_hPicUpgradeStatus[$iz], $g_sLibIconPath, $g_aiPicUpgradeStatus[$iz])
If $g_avBuildingUpgrades[$iz][2] > 0 Then
GUICtrlSetData($g_hTxtUpgradeValue[$iz], _NumberFormat($g_avBuildingUpgrades[$iz][2]))
Else
GUICtrlSetData($g_hTxtUpgradeValue[$iz], "")
EndIf
GUICtrlSetData($g_hTxtUpgradeName[$iz], $g_avBuildingUpgrades[$iz][4])
GUICtrlSetData($g_hTxtUpgradeLevel[$iz], $g_avBuildingUpgrades[$iz][5])
GUICtrlSetData($g_hTxtUpgradeTime[$iz], StringStripWS($g_avBuildingUpgrades[$iz][6], $STR_STRIPALL))
Switch $g_avBuildingUpgrades[$iz][3]
Case "Gold"
GUICtrlSetImage($g_hPicUpgradeType[$iz], $g_sLibIconPath, $eIcnGold)
Case "Elixir"
GUICtrlSetImage($g_hPicUpgradeType[$iz], $g_sLibIconPath, $eIcnElixir)
Case "Dark"
GUICtrlSetImage($g_hPicUpgradeType[$iz], $g_sLibIconPath, $eIcnDark)
Case Else
GUICtrlSetImage($g_hPicUpgradeType[$iz], $g_sLibIconPath, $eIcnBlank)
EndSwitch
GUICtrlSetState($g_hChkUpgrade[$iz], $g_abBuildingUpgradeEnable[$iz] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkUpgradeRepeat[$iz], $g_abUpgradeRepeatEnable[$iz] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtUpgradeEndTime[$iz], $g_avBuildingUpgrades[$iz][7])
Next
GUICtrlSetData($g_hTxtUpgrMinGold, $g_iUpgradeMinGold)
GUICtrlSetData($g_hTxtUpgrMinElixir, $g_iUpgradeMinElixir)
GUICtrlSetData($g_hTxtUpgrMinDark, $g_iUpgradeMinDark)
Case "Save"
For $iz = 0 To UBound($g_avBuildingUpgrades, 1) - 1
$g_abBuildingUpgradeEnable[$iz] =(GUICtrlRead($g_hChkUpgrade[$iz]) = $GUI_CHECKED)
$g_abUpgradeRepeatEnable[$iz] =(GUICtrlRead($g_hChkUpgradeRepeat[$iz]) = $GUI_CHECKED)
Next
$g_iUpgradeMinGold = Number(GUICtrlRead($g_hTxtUpgrMinGold))
$g_iUpgradeMinElixir = Number(GUICtrlRead($g_hTxtUpgrMinElixir))
$g_iUpgradeMinDark = Number(GUICtrlRead($g_hTxtUpgrMinDark))
EndSwitch
EndFunc
Func ApplyConfig_600_17($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkWalls, $g_bAutoUpgradeWallsEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtWallMinGold, $g_iUpgradeWallMinGold)
GUICtrlSetData($g_hTxtWallMinElixir, $g_iUpgradeWallMinElixir)
Switch $g_iUpgradeWallLootType
Case 0
GUICtrlSetState($g_hRdoUseGold, $GUI_CHECKED)
Case 1
GUICtrlSetState($g_hRdoUseElixir, $GUI_CHECKED)
Case 2
GUICtrlSetState($g_hRdoUseElixirGold, $GUI_CHECKED)
EndSwitch
GUICtrlSetState($g_hChkSaveWallBldr, $g_bUpgradeWallSaveBuilder ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbWalls, $g_iCmbUpgradeWallsLevel)
For $i = 4 To 12
GUICtrlSetData($g_ahWallsCurrentCount[$i], $g_aiWallsCurrentCount[$i])
Next
cmbWalls()
chkWalls()
Case "Save"
$g_bAutoUpgradeWallsEnable =(GUICtrlRead($g_hChkWalls) = $GUI_CHECKED)
$g_iUpgradeWallMinGold = Number(GUICtrlRead($g_hTxtWallMinGold))
$g_iUpgradeWallMinElixir = Number(GUICtrlRead($g_hTxtWallMinElixir))
If GUICtrlRead($g_hRdoUseGold) = $GUI_CHECKED Then
$g_iUpgradeWallLootType = 0
ElseIf GUICtrlRead($g_hRdoUseElixir) = $GUI_CHECKED Then
$g_iUpgradeWallLootType = 1
ElseIf GUICtrlRead($g_hRdoUseElixirGold) = $GUI_CHECKED Then
$g_iUpgradeWallLootType = 2
EndIf
$g_bUpgradeWallSaveBuilder =(GUICtrlRead($g_hChkSaveWallBldr) = $GUI_CHECKED)
$g_iCmbUpgradeWallsLevel = _GUICtrlComboBox_GetCurSel($g_hCmbWalls)
For $i = 4 To 12
$g_aiWallsCurrentCount[$i] = Number(GUICtrlRead($g_ahWallsCurrentCount[$i]))
Next
EndSwitch
EndFunc
Func ApplyConfig_600_18($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkNotifyPBEnable, $g_bNotifyPBEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyTGEnable, $g_bNotifyTGEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkPBTGenabled()
GUICtrlSetData($g_hTxtNotifyPBToken, $g_sNotifyPBToken)
GUICtrlSetData($g_hTxtNotifyTGToken, $g_sNotifyTGToken)
GUICtrlSetState($g_hChkNotifyRemote, $g_bNotifyRemoteEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyDeleteAllPBPushes, $g_bNotifyDeleteAllPushesOnStart ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyDeleteOldPBPushes, $g_bNotifyDeletePushesOlderThan ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbNotifyPushHours, $g_iNotifyDeletePushesOlderThanHours)
chkDeleteOldPBPushes()
GUICtrlSetData($g_hTxtNotifyOrigin, $g_sNotifyOrigin)
GUICtrlSetState($g_hChkNotifyAlertMatchFound, $g_bNotifyAlertMatchFound ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertLastRaidIMG, $g_bNotifyAlerLastRaidIMG ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertUpgradeWall, $g_bNotifyAlertUpgradeWalls ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertOutOfSync, $g_bNotifyAlertOutOfSync ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertTakeBreak, $g_bNotifyAlertTakeBreak ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertAnotherDevice, $g_bNotifyAlertAnotherDevice ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertLastRaidTXT, $g_bNotifyAlerLastRaidTXT ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertCampFull, $g_bNotifyAlertCampFull ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertVillageStats, $g_bNotifyAlertVillageReport ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertLastAttack, $g_bNotifyAlertLastAttack ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertBuilderIdle, $g_bNotifyAlertBulderIdle ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertMaintenance, $g_bNotifyAlertMaintenance ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyAlertBAN, $g_bNotifyAlertBAN ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNotifyBOTUpdate, $g_bNotifyAlertBOTUpdate ? $GUI_CHECKED : $GUI_UNCHECKED)
Case "Save"
$g_bNotifyPBEnable =(GUICtrlRead($g_hChkNotifyPBEnable) = $GUI_CHECKED)
$g_bNotifyTGEnable =(GUICtrlRead($g_hChkNotifyTGEnable) = $GUI_CHECKED)
$g_sNotifyPBToken = GUICtrlRead($g_hTxtNotifyPBToken)
$g_sNotifyTGToken = GUICtrlRead($g_hTxtNotifyTGToken)
$g_bNotifyRemoteEnable =(GUICtrlRead($g_hChkNotifyRemote) = $GUI_CHECKED)
$g_bNotifyDeleteAllPushesOnStart =(GUICtrlRead($g_hChkNotifyDeleteAllPBPushes) = $GUI_CHECKED)
$g_bNotifyDeletePushesOlderThan =(GUICtrlRead($g_hChkNotifyDeleteOldPBPushes) = $GUI_CHECKED)
$g_iNotifyDeletePushesOlderThanHours = _GUICtrlComboBox_GetCurSel($g_hCmbNotifyPushHours)
$g_sNotifyOrigin = GUICtrlRead($g_hTxtNotifyOrigin)
$g_bNotifyAlertMatchFound =(GUICtrlRead($g_hChkNotifyAlertMatchFound) = $GUI_CHECKED)
$g_bNotifyAlerLastRaidIMG =(GUICtrlRead($g_hChkNotifyAlertLastRaidIMG) = $GUI_CHECKED)
$g_bNotifyAlertUpgradeWalls =(GUICtrlRead($g_hChkNotifyAlertUpgradeWall) = $GUI_CHECKED)
$g_bNotifyAlertOutOfSync =(GUICtrlRead($g_hChkNotifyAlertOutOfSync) = $GUI_CHECKED)
$g_bNotifyAlertTakeBreak =(GUICtrlRead($g_hChkNotifyAlertTakeBreak) = $GUI_CHECKED)
$g_bNotifyAlertAnotherDevice =(GUICtrlRead($g_hChkNotifyAlertAnotherDevice) = $GUI_CHECKED)
$g_bNotifyAlerLastRaidTXT =(GUICtrlRead($g_hChkNotifyAlertLastRaidTXT) = $GUI_CHECKED)
$g_bNotifyAlertCampFull =(GUICtrlRead($g_hChkNotifyAlertCampFull) = $GUI_CHECKED)
$g_bNotifyAlertVillageReport =(GUICtrlRead($g_hChkNotifyAlertVillageStats) = $GUI_CHECKED)
$g_bNotifyAlertLastAttack =(GUICtrlRead($g_hChkNotifyAlertLastAttack) = $GUI_CHECKED)
$g_bNotifyAlertBulderIdle =(GUICtrlRead($g_hChkNotifyAlertBuilderIdle) = $GUI_CHECKED)
$g_bNotifyAlertMaintenance =(GUICtrlRead($g_hChkNotifyAlertMaintenance) = $GUI_CHECKED)
$g_bNotifyAlertBAN =(GUICtrlRead($g_hChkNotifyAlertBAN) = $GUI_CHECKED)
$g_bNotifyAlertBOTUpdate =(GUICtrlRead($g_hChkNotifyBOTUpdate) = $GUI_CHECKED)
EndSwitch
EndFunc
Func ApplyConfig_600_19($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkNotifyOnlyHours, $g_bNotifyScheduleHoursEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkNotifyHours()
For $i = 0 To 23
GUICtrlSetState($g_hChkNotifyhours[$i], $g_abNotifyScheduleHours[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
Next
GUICtrlSetState($g_hChkNotifyOnlyWeekDays, $g_bNotifyScheduleWeekDaysEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkNotifyWeekDays()
For $i = 0 To 6
GUICtrlSetState($g_hChkNotifyWeekdays[$i], $g_abNotifyScheduleWeekDays[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
Next
Case "Save"
$g_bNotifyScheduleHoursEnable =(GUICtrlRead($g_hChkNotifyOnlyHours) = $GUI_CHECKED)
For $i = 0 To 23
$g_abNotifyScheduleHours[$i] =(GUICtrlRead($g_hChkNotifyhours[$i]) = $GUI_CHECKED)
Next
$g_bNotifyScheduleWeekDaysEnable =(GUICtrlRead($g_hChkNotifyOnlyWeekDays) = $GUI_CHECKED)
For $i = 0 To 6
$g_abNotifyScheduleWeekDays[$i] =(GUICtrlRead($g_hChkNotifyWeekdays[$i]) = $GUI_CHECKED)
Next
EndSwitch
EndFunc
Func ApplyConfig_600_22($TypeReadSave)
Switch $TypeReadSave
Case "Read"
_GUICtrlComboBox_SetCurSel($g_hCmbBoostBarracks, $g_iCmbBoostBarracks)
_GUICtrlComboBox_SetCurSel($g_hCmbBoostSpellFactory, $g_iCmbBoostSpellFactory)
_GUICtrlComboBox_SetCurSel($g_hCmbBoostBarbarianKing, $g_iCmbBoostBarbarianKing)
_GUICtrlComboBox_SetCurSel($g_hCmbBoostArcherQueen, $g_iCmbBoostArcherQueen)
_GUICtrlComboBox_SetCurSel($g_hCmbBoostWarden, $g_iCmbBoostWarden)
For $i = 0 To 23
GUICtrlSetState($g_hChkBoostBarracksHours[$i], $g_abBoostBarracksHours[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
Next
Case "Save"
$g_iCmbBoostBarracks = GUICtrlRead($g_hCmbBoostBarracks)
$g_iCmbBoostSpellFactory = GUICtrlRead($g_hCmbBoostSpellFactory)
$g_iCmbBoostBarbarianKing = GUICtrlRead($g_hCmbBoostBarbarianKing)
$g_iCmbBoostArcherQueen = GUICtrlRead($g_hCmbBoostArcherQueen)
$g_iCmbBoostWarden = GUICtrlRead($g_hCmbBoostWarden)
For $i = 0 To 23
$g_abBoostBarracksHours[$i] =(GUICtrlRead($g_hChkBoostBarracksHours[$i]) = $GUI_CHECKED)
Next
EndSwitch
EndFunc
Func ApplyConfig_600_26($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkBully, $g_abAttackTypeEnable[$TB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtATBullyMode, $g_iAtkTBEnableCount)
_GUICtrlComboBox_SetCurSel($g_hCmbBullyMaxTH, $g_iAtkTBMaxTHLevel)
GUICtrlSetState($g_hRadBullyUseDBAttack, $g_iAtkTBMode = 0 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hRadBullyUseLBAttack, $g_iAtkTBMode = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
Case "Save"
$g_abAttackTypeEnable[$TB] =(GUICtrlRead($g_hChkBully) = $GUI_CHECKED)
$g_iAtkTBEnableCount = GUICtrlRead($g_hTxtATBullyMode)
$g_iAtkTBMaxTHLevel = _GUICtrlComboBox_GetCurSel($g_hCmbBullyMaxTH)
$g_iAtkTBMode =(GUICtrlRead($g_hRadBullyUseDBAttack) = $GUI_CHECKED ? 0 : 1)
EndSwitch
EndFunc
Func ApplyConfig_600_28($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkSearchReduction, $g_bSearchReductionEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkSearchReduction()
GUICtrlSetData($g_hTxtSearchReduceCount, $g_iSearchReductionCount)
GUICtrlSetData($g_hTxtSearchReduceGold, $g_iSearchReductionGold)
GUICtrlSetData($g_hTxtSearchReduceElixir, $g_iSearchReductionElixir)
GUICtrlSetData($g_hTxtSearchReduceGoldPlusElixir, $g_iSearchReductionGoldPlusElixir)
GUICtrlSetData($g_hTxtSearchReduceDark, $g_iSearchReductionDark)
GUICtrlSetData($g_hTxtSearchReduceTrophy, $g_iSearchReductionTrophy)
If $g_iSearchDelayMin > $g_iSearchDelayMax Then $g_iSearchDelayMax = $g_iSearchDelayMin
GUICtrlSetData($g_hSldVSDelay, $g_iSearchDelayMin)
GUICtrlSetData($g_hLblVSDelay, $g_iSearchDelayMin)
GUICtrlSetData($g_hSldMaxVSDelay, $g_iSearchDelayMax)
GUICtrlSetData($g_hLblMaxVSDelay, $g_iSearchDelayMax)
GUICtrlSetState($g_hChkAttackNow, $g_bSearchAttackNowEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkAttackNow()
_GUICtrlComboBox_SetCurSel($g_hCmbAttackNowDelay, $g_iSearchAttackNowDelay)
GUICtrlSetState($g_hChkRestartSearchLimit, $g_bSearchRestartEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtRestartSearchlimit, $g_iSearchRestartLimit)
ChkRestartSearchLimit()
GUICtrlSetState($g_hChkAlertSearch, $g_bSearchAlertMe ? $GUI_CHECKED : $GUI_UNCHECKED)
Case "Save"
$g_bSearchReductionEnable =(GUICtrlRead($g_hChkSearchReduction) = $GUI_CHECKED)
$g_iSearchReductionCount = GUICtrlRead($g_hTxtSearchReduceCount)
$g_iSearchReductionGold = GUICtrlRead($g_hTxtSearchReduceGold)
$g_iSearchReductionElixir = GUICtrlRead($g_hTxtSearchReduceElixir)
$g_iSearchReductionGoldPlusElixir = GUICtrlRead($g_hTxtSearchReduceGoldPlusElixir)
$g_iSearchReductionDark = GUICtrlRead($g_hTxtSearchReduceDark)
$g_iSearchReductionTrophy = GUICtrlRead($g_hTxtSearchReduceTrophy)
$g_iSearchDelayMin = GUICtrlRead($g_hSldVSDelay)
$g_iSearchDelayMax = GUICtrlRead($g_hSldMaxVSDelay)
$g_bSearchAttackNowEnable =(GUICtrlRead($g_hChkAttackNow) = $GUI_CHECKED)
$g_iSearchAttackNowDelay = _GUICtrlComboBox_GetCurSel($g_hCmbAttackNowDelay)
$g_bSearchRestartEnable =(GUICtrlRead($g_hChkRestartSearchLimit) = $GUI_CHECKED)
$g_iSearchRestartLimit = GUICtrlRead($g_hTxtRestartSearchlimit)
$g_bSearchAlertMe =(GUICtrlRead($g_hChkAlertSearch) = $GUI_CHECKED)
EndSwitch
EndFunc
Func ApplyConfig_600_28_DB($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkDBActivateSearches, $g_abSearchSearchesEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtDBSearchesMin, $g_aiSearchSearchesMin[$DB])
GUICtrlSetData($g_hTxtDBSearchesMax, $g_aiSearchSearchesMax[$DB])
GUICtrlSetState($g_hChkDBActivateTropies, $g_abSearchTropiesEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkDBActivateTropies()
GUICtrlSetData($g_hTxtDBTropiesMin, $g_aiSearchTrophiesMin[$DB])
GUICtrlSetData($g_hTxtDBTropiesMax, $g_aiSearchTrophiesMax[$DB])
GUICtrlSetState($g_hChkDBActivateCamps, $g_abSearchCampsEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkDBActivateCamps()
GUICtrlSetData($g_hTxtDBArmyCamps, $g_aiSearchCampsPct[$DB])
chkDBActivateSearches()
GUICtrlSetState($g_hChkDeadbase, $g_abAttackTypeEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBKingWait, BitAND($g_aiSearchHeroWaitEnable[$DB], $eHeroKing) = $eHeroKing ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBQueenWait, BitAND($g_aiSearchHeroWaitEnable[$DB], $eHeroQueen) = $eHeroQueen ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBWardenWait, BitAND($g_aiSearchHeroWaitEnable[$DB], $eHeroWarden) = $eHeroWarden ? $GUI_CHECKED : $GUI_UNCHECKED)
$iHeroWaitAttackNoBit[$DB][0] = GUICtrlRead($g_hChkDBKingWait) = $GUI_CHECKED ? $eHeroKing : $eHeroNone
$iHeroWaitAttackNoBit[$DB][1] = GUICtrlRead($g_hChkDBQueenWait) = $GUI_CHECKED ? $eHeroQueen : $eHeroNone
$iHeroWaitAttackNoBit[$DB][2] = GUICtrlRead($g_hChkDBWardenWait) = $GUI_CHECKED ? $eHeroWarden : $eHeroNone
GUICtrlSetState($g_hChkDBSpellsWait, $g_abSearchSpellsWaitEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkDBSpellsWait()
GUICtrlSetState($g_hChkDBWaitForCastleSpell, $g_abSearchCastleSpellsWaitEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbDBWaitForCastleSpell, $g_aiSearchCastleSpellsWaitRegular[$DB])
_GUICtrlComboBox_SetCurSel($g_hCmbDBWaitForCastleSpell2, $g_aiSearchCastleSpellsWaitDark[$DB])
cmbDBWaitForCCSpell()
chkDBWaitForCCSpell()
GUICtrlSetState($g_hChkDBWaitForCastleTroops, $g_abSearchCastleTroopsWaitEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbDBMeetGE, $g_aiFilterMeetGE[$DB])
GUICtrlSetData($g_hTxtDBMinGold, $g_aiFilterMinGold[$DB])
GUICtrlSetData($g_hTxtDBMinElixir, $g_aiFilterMinElixir[$DB])
GUICtrlSetData($g_hTxtDBMinGoldPlusElixir, $g_aiFilterMinGoldPlusElixir[$DB])
cmbDBGoldElixir()
GUICtrlSetState($g_hChkDBMeetDE, $g_abFilterMeetDEEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtDBMinDarkElixir, $g_aiFilterMeetDEMin[$DB])
chkDBMeetDE()
GUICtrlSetState($g_hChkDBMeetTrophy, $g_abFilterMeetTrophyEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtDBMinTrophy, $g_aiFilterMeetTrophyMin[$DB])
chkDBMeetTrophy()
GUICtrlSetState($g_hChkDBMeetTH, $g_abFilterMeetTH[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbDBTH, $g_aiFilterMeetTHMin[$DB])
$iMaxTH[$DB] = $THText[$g_aiFilterMeetTHMin[$DB]]
chkDBMeetTH()
GUICtrlSetState($g_hChkDBMeetTHO, $g_abFilterMeetTHOutsideEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkMaxMortar[$DB], $g_abFilterMaxMortarEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkMaxWizTower[$DB], $g_abFilterMaxWizTowerEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkMaxAirDefense[$DB], $g_abFilterMaxAirDefenseEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkMaxXBow[$DB], $g_abFilterMaxXBowEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkMaxInferno[$DB], $g_abFilterMaxInfernoEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkMaxEagle[$DB], $g_abFilterMaxEagleEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_ahCmbWeakMortar[$DB], $g_aiFilterMaxMortarLevel[$DB])
_GUICtrlComboBox_SetCurSel($g_ahCmbWeakWizTower[$DB], $g_aiFilterMaxWizTowerLevel[$DB])
_GUICtrlComboBox_SetCurSel($g_ahCmbWeakAirDefense[$DB], $g_aiFilterMaxAirDefenseLevel[$DB])
_GUICtrlComboBox_SetCurSel($g_ahCmbWeakXBow[$DB], $g_aiFilterMaxXBowLevel[$DB])
_GUICtrlComboBox_SetCurSel($g_ahCmbWeakInferno[$DB], $g_aiFilterMaxInfernoLevel[$DB])
_GUICtrlComboBox_SetCurSel($g_ahCmbWeakEagle[$DB], $g_aiFilterMaxEagleLevel[$DB])
chkDBWeakBase()
GUICtrlSetState($g_ahChkMeetOne[$DB], $g_abFilterMeetOneConditionEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
Case "Save"
$g_abAttackTypeEnable[$DB] =(GUICtrlRead($g_hChkDeadbase) = $GUI_CHECKED)
$g_abSearchSearchesEnable[$DB] =(GUICtrlRead($g_hChkDBActivateSearches) = $GUI_CHECKED)
$g_aiSearchSearchesMin[$DB] = GUICtrlRead($g_hTxtDBSearchesMin)
$g_aiSearchSearchesMax[$DB] = GUICtrlRead($g_hTxtDBSearchesMax)
$g_abSearchTropiesEnable[$DB] =(GUICtrlRead($g_hChkDBActivateTropies) = $GUI_CHECKED)
$g_aiSearchTrophiesMin[$DB] = GUICtrlRead($g_hTxtDBTropiesMin)
$g_aiSearchTrophiesMax[$DB] = GUICtrlRead($g_hTxtDBTropiesMax)
$g_abSearchCampsEnable[$DB] =(GUICtrlRead($g_hChkDBActivateCamps) = $GUI_CHECKED)
$g_aiSearchCampsPct[$DB] = Int(GUICtrlRead($g_hTxtDBArmyCamps))
$iHeroWaitAttackNoBit[$DB][0] = GUICtrlRead($g_hChkDBKingWait) = $GUI_CHECKED ? $eHeroKing : $eHeroNone
$iHeroWaitAttackNoBit[$DB][1] = GUICtrlRead($g_hChkDBQueenWait) = $GUI_CHECKED ? $eHeroQueen : $eHeroNone
$iHeroWaitAttackNoBit[$DB][2] = GUICtrlRead($g_hChkDBWardenWait) = $GUI_CHECKED ? $eHeroWarden : $eHeroNone
$g_abSearchSpellsWaitEnable[$DB] =(GUICtrlRead($g_hChkDBSpellsWait) = $GUI_CHECKED)
$g_abSearchCastleSpellsWaitEnable[$DB] =(GUICtrlRead($g_hChkDBWaitForCastleSpell) = $GUI_CHECKED)
$g_aiSearchCastleSpellsWaitRegular[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbDBWaitForCastleSpell)
$g_aiSearchCastleSpellsWaitDark[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbDBWaitForCastleSpell2)
$g_abSearchCastleTroopsWaitEnable[$DB] =(GUICtrlRead($g_hChkDBWaitForCastleTroops) = $GUI_CHECKED)
$g_aiFilterMeetGE[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbDBMeetGE)
$g_aiFilterMinGold[$DB] = GUICtrlRead($g_hTxtDBMinGold)
$g_aiFilterMinElixir[$DB] = GUICtrlRead($g_hTxtDBMinElixir)
$g_aiFilterMinGoldPlusElixir[$DB] = GUICtrlRead($g_hTxtDBMinGoldPlusElixir)
$g_abFilterMeetDEEnable[$DB] =(GUICtrlRead($g_hChkDBMeetDE) = $GUI_CHECKED)
$g_aiFilterMeetDEMin[$DB] = GUICtrlRead($g_hTxtDBMinDarkElixir)
$g_abFilterMeetTrophyEnable[$DB] =(GUICtrlRead($g_hChkDBMeetTrophy) = $GUI_CHECKED)
$g_aiFilterMeetTrophyMin[$DB] = GUICtrlRead($g_hTxtDBMinTrophy)
$g_abFilterMeetTH[$DB] =(GUICtrlRead($g_hChkDBMeetTH) = $GUI_CHECKED)
$g_aiFilterMeetTHMin[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbDBTH)
$iMaxTH[$DB] = $THText[$g_aiFilterMeetTHMin[$DB]]
$g_abFilterMeetTHOutsideEnable[$DB] =(GUICtrlRead($g_hChkDBMeetTHO) = $GUI_CHECKED)
$g_abFilterMaxMortarEnable[$DB] =(GUICtrlRead($g_ahChkMaxMortar[$DB]) = $GUI_CHECKED)
$g_abFilterMaxWizTowerEnable[$DB] =(GUICtrlRead($g_ahChkMaxWizTower[$DB]) = $GUI_CHECKED)
$g_abFilterMaxAirDefenseEnable[$DB] =(GUICtrlRead($g_ahChkMaxAirDefense[$DB]) = $GUI_CHECKED)
$g_abFilterMaxXBowEnable[$DB] =(GUICtrlRead($g_ahChkMaxXBow[$DB]) = $GUI_CHECKED)
$g_abFilterMaxInfernoEnable[$DB] =(GUICtrlRead($g_ahChkMaxInferno[$DB]) = $GUI_CHECKED)
$g_abFilterMaxEagleEnable[$DB] =(GUICtrlRead($g_ahChkMaxEagle[$DB]) = $GUI_CHECKED)
$g_aiFilterMaxMortarLevel[$DB] = _GUICtrlComboBox_GetCurSel($g_ahCmbWeakMortar[$DB])
$g_aiFilterMaxWizTowerLevel[$DB] = _GUICtrlComboBox_GetCurSel($g_ahCmbWeakWizTower[$DB])
$g_aiFilterMaxAirDefenseLevel[$DB] = _GUICtrlComboBox_GetCurSel($g_ahCmbWeakAirDefense[$DB])
$g_aiFilterMaxXBowLevel[$DB] = _GUICtrlComboBox_GetCurSel($g_ahCmbWeakXBow[$DB])
$g_aiFilterMaxInfernoLevel[$DB] = _GUICtrlComboBox_GetCurSel($g_ahCmbWeakInferno[$DB])
$g_aiFilterMaxEagleLevel[$DB] = _GUICtrlComboBox_GetCurSel($g_ahCmbWeakEagle[$DB])
$g_abFilterMeetOneConditionEnable[$DB] =(GUICtrlRead($g_ahChkMeetOne[$DB]) = $GUI_CHECKED)
EndSwitch
EndFunc
Func ApplyConfig_600_28_LB($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkABActivateSearches, $g_abSearchSearchesEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtABSearchesMin, $g_aiSearchSearchesMin[$LB])
GUICtrlSetData($g_hTxtABSearchesMax, $g_aiSearchSearchesMax[$LB])
GUICtrlSetState($g_hChkABActivateTropies, $g_abSearchTropiesEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkABActivateTropies()
GUICtrlSetData($g_hTxtABTropiesMin, $g_aiSearchTrophiesMin[$LB])
GUICtrlSetData($g_hTxtABTropiesMax, $g_aiSearchTrophiesMax[$LB])
GUICtrlSetState($g_hChkABActivateCamps, $g_abSearchCampsEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkABActivateCamps()
GUICtrlSetData($g_hTxtABArmyCamps, $g_aiSearchCampsPct[$LB])
chkABActivateSearches()
GUICtrlSetState($g_hChkActivebase, $g_abAttackTypeEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABKingWait, BitAND($g_aiSearchHeroWaitEnable[$LB], $eHeroKing) = $eHeroKing ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABQueenWait, BitAND($g_aiSearchHeroWaitEnable[$LB], $eHeroQueen) = $eHeroQueen ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABWardenWait, BitAND($g_aiSearchHeroWaitEnable[$LB], $eHeroWarden) = $eHeroWarden ? $GUI_CHECKED : $GUI_UNCHECKED)
$iHeroWaitAttackNoBit[$LB][0] = GUICtrlRead($g_hChkABKingWait) = $GUI_CHECKED ? $eHeroKing : $eHeroNone
$iHeroWaitAttackNoBit[$LB][1] = GUICtrlRead($g_hChkABQueenWait) = $GUI_CHECKED ? $eHeroQueen : $eHeroNone
$iHeroWaitAttackNoBit[$LB][2] = GUICtrlRead($g_hChkABWardenWait) = $GUI_CHECKED ? $eHeroWarden : $eHeroNone
GUICtrlSetState($g_hChkABSpellsWait, $g_abSearchSpellsWaitEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkABSpellsWait()
GUICtrlSetState($g_hChkABWaitForCastleSpell, $g_abSearchCastleSpellsWaitEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbABWaitForCastleSpell, $g_aiSearchCastleSpellsWaitRegular[$LB])
_GUICtrlComboBox_SetCurSel($g_hCmbABWaitForCastleSpell2, $g_aiSearchCastleSpellsWaitDark[$LB])
cmbABWaitForCCSpell()
chkABWaitForCCSpell()
GUICtrlSetState($g_hChkABWaitForCastleTroops, $g_abSearchCastleTroopsWaitEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbABMeetGE, $g_aiFilterMeetGE[$LB])
GUICtrlSetData($g_hTxtABMinGold, $g_aiFilterMinGold[$LB])
GUICtrlSetData($g_hTxtABMinElixir, $g_aiFilterMinElixir[$LB])
GUICtrlSetData($g_hTxtABMinGoldPlusElixir, $g_aiFilterMinGoldPlusElixir[$LB])
cmbABGoldElixir()
GUICtrlSetState($g_hChkABMeetDE, $g_abFilterMeetDEEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtABMinDarkElixir, $g_aiFilterMeetDEMin[$LB])
chkABMeetDE()
GUICtrlSetState($g_hChkABMeetTrophy, $g_abFilterMeetTrophyEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtABMinTrophy, $g_aiFilterMeetTrophyMin[$LB])
chkABMeetTrophy()
GUICtrlSetState($g_hChkABMeetTH, $g_abFilterMeetTH[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbABTH, $g_aiFilterMeetTHMin[$LB])
$iMaxTH[$LB] = $THText[$g_aiFilterMeetTHMin[$LB]]
chkABMeetTH()
GUICtrlSetState($g_hChkABMeetTHO, $g_abFilterMeetTHOutsideEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkMaxMortar[$LB], $g_abFilterMaxMortarEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkMaxWizTower[$LB], $g_abFilterMaxWizTowerEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkMaxAirDefense[$LB], $g_abFilterMaxAirDefenseEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkMaxXBow[$LB], $g_abFilterMaxXBowEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkMaxInferno[$LB], $g_abFilterMaxInfernoEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahChkMaxEagle[$LB], $g_abFilterMaxEagleEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_ahCmbWeakMortar[$LB], $g_aiFilterMaxMortarLevel[$LB])
_GUICtrlComboBox_SetCurSel($g_ahCmbWeakWizTower[$LB], $g_aiFilterMaxWizTowerLevel[$LB])
_GUICtrlComboBox_SetCurSel($g_ahCmbWeakAirDefense[$LB], $g_aiFilterMaxAirDefenseLevel[$LB])
_GUICtrlComboBox_SetCurSel($g_ahCmbWeakXBow[$LB], $g_aiFilterMaxXBowLevel[$LB])
_GUICtrlComboBox_SetCurSel($g_ahCmbWeakInferno[$LB], $g_aiFilterMaxInfernoLevel[$LB])
_GUICtrlComboBox_SetCurSel($g_ahCmbWeakEagle[$LB], $g_aiFilterMaxEagleLevel[$LB])
chkABWeakBase()
GUICtrlSetState($g_ahChkMeetOne[$LB], $g_abFilterMeetOneConditionEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
Case "Save"
$g_abAttackTypeEnable[$LB] =(GUICtrlRead($g_hChkActivebase) = $GUI_CHECKED)
$g_abSearchSearchesEnable[$LB] =(GUICtrlRead($g_hChkABActivateSearches) = $GUI_CHECKED)
$g_aiSearchSearchesMin[$LB] = GUICtrlRead($g_hTxtABSearchesMin)
$g_aiSearchSearchesMax[$LB] = GUICtrlRead($g_hTxtABSearchesMax)
$g_abSearchTropiesEnable[$LB] =(GUICtrlRead($g_hChkABActivateTropies) = $GUI_CHECKED)
$g_aiSearchTrophiesMin[$LB] = GUICtrlRead($g_hTxtABTropiesMin)
$g_aiSearchTrophiesMax[$LB] = GUICtrlRead($g_hTxtABTropiesMax)
$g_abSearchCampsEnable[$LB] =(GUICtrlRead($g_hChkABActivateCamps) = $GUI_CHECKED)
$g_aiSearchCampsPct[$LB] = Int(GUICtrlRead($g_hTxtABArmyCamps))
$iHeroWaitAttackNoBit[$LB][0] = GUICtrlRead($g_hChkABKingWait) = $GUI_CHECKED ? $eHeroKing : $eHeroNone
$iHeroWaitAttackNoBit[$LB][1] = GUICtrlRead($g_hChkABQueenWait) = $GUI_CHECKED ? $eHeroQueen : $eHeroNone
$iHeroWaitAttackNoBit[$LB][2] = GUICtrlRead($g_hChkABWardenWait) = $GUI_CHECKED ? $eHeroWarden : $eHeroNone
$g_abSearchSpellsWaitEnable[$LB] =(GUICtrlRead($g_hChkABSpellsWait) = $GUI_CHECKED)
$g_abSearchCastleSpellsWaitEnable[$LB] =(GUICtrlRead($g_hChkABWaitForCastleSpell) = $GUI_CHECKED)
$g_aiSearchCastleSpellsWaitRegular[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbABWaitForCastleSpell)
$g_aiSearchCastleSpellsWaitDark[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbABWaitForCastleSpell2)
$g_abSearchCastleTroopsWaitEnable[$LB] =(GUICtrlRead($g_hChkABWaitForCastleTroops) = $GUI_CHECKED)
$g_aiFilterMeetGE[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbABMeetGE)
$g_aiFilterMinGold[$LB] = GUICtrlRead($g_hTxtABMinGold)
$g_aiFilterMinElixir[$LB] = GUICtrlRead($g_hTxtABMinElixir)
$g_aiFilterMinGoldPlusElixir[$LB] = GUICtrlRead($g_hTxtABMinGoldPlusElixir)
$g_abFilterMeetDEEnable[$LB] =(GUICtrlRead($g_hChkABMeetDE) = $GUI_CHECKED)
$g_aiFilterMeetDEMin[$LB] = GUICtrlRead($g_hTxtABMinDarkElixir)
$g_abFilterMeetTrophyEnable[$LB] =(GUICtrlRead($g_hChkABMeetTrophy) = $GUI_CHECKED)
$g_aiFilterMeetTrophyMin[$LB] = GUICtrlRead($g_hTxtABMinTrophy)
$g_abFilterMeetTH[$LB] =(GUICtrlRead($g_hChkABMeetTH) = $GUI_CHECKED)
$g_aiFilterMeetTHMin[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbABTH)
$iMaxTH[$LB] = $THText[$g_aiFilterMeetTHMin[$LB]]
$g_abFilterMeetTHOutsideEnable[$LB] =(GUICtrlRead($g_hChkABMeetTHO) = $GUI_CHECKED)
$g_abFilterMaxMortarEnable[$LB] =(GUICtrlRead($g_ahChkMaxMortar[$LB]) = $GUI_CHECKED)
$g_abFilterMaxWizTowerEnable[$LB] =(GUICtrlRead($g_ahChkMaxWizTower[$LB]) = $GUI_CHECKED)
$g_abFilterMaxAirDefenseEnable[$LB] =(GUICtrlRead($g_ahChkMaxAirDefense[$LB]) = $GUI_CHECKED)
$g_abFilterMaxXBowEnable[$LB] =(GUICtrlRead($g_ahChkMaxXBow[$LB]) = $GUI_CHECKED)
$g_abFilterMaxInfernoEnable[$LB] =(GUICtrlRead($g_ahChkMaxInferno[$LB]) = $GUI_CHECKED)
$g_abFilterMaxEagleEnable[$LB] =(GUICtrlRead($g_ahChkMaxEagle[$LB]) = $GUI_CHECKED)
$g_aiFilterMaxMortarLevel[$LB] = _GUICtrlComboBox_GetCurSel($g_ahCmbWeakMortar[$LB])
$g_aiFilterMaxWizTowerLevel[$LB] = _GUICtrlComboBox_GetCurSel($g_ahCmbWeakWizTower[$LB])
$g_aiFilterMaxAirDefenseLevel[$LB] = _GUICtrlComboBox_GetCurSel($g_ahCmbWeakAirDefense[$LB])
$g_aiFilterMaxXBowLevel[$LB] = _GUICtrlComboBox_GetCurSel($g_ahCmbWeakXBow[$LB])
$g_aiFilterMaxInfernoLevel[$LB] = _GUICtrlComboBox_GetCurSel($g_ahCmbWeakInferno[$LB])
$g_aiFilterMaxEagleLevel[$LB] = _GUICtrlComboBox_GetCurSel($g_ahCmbWeakEagle[$LB])
$g_abFilterMeetOneConditionEnable[$LB] =(GUICtrlRead($g_ahChkMeetOne[$LB]) = $GUI_CHECKED)
EndSwitch
EndFunc
Func ApplyConfig_600_28_TS($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkTSActivateSearches, $g_abSearchSearchesEnable[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtTSSearchesMin, $g_aiSearchSearchesMin[$TS])
GUICtrlSetData($g_hTxtTSSearchesMax, $g_aiSearchSearchesMax[$TS])
GUICtrlSetState($g_hChkTSActivateTropies, $g_abSearchTropiesEnable[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkTSActivateTropies()
GUICtrlSetData($g_hTxtTSTropiesMin, $g_aiSearchTrophiesMin[$TS])
GUICtrlSetData($g_hTxtTSTropiesMax, $g_aiSearchTrophiesMax[$TS])
GUICtrlSetState($g_hChkTSActivateCamps, $g_abSearchCampsEnable[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkTSActivateCamps()
GUICtrlSetData($g_hTxtTSArmyCamps, $g_aiSearchCampsPct[$TS])
chkTSActivateSearches()
GUICtrlSetState($g_hChkTHSnipe, $g_abAttackTypeEnable[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbTSMeetGE, $g_aiFilterMeetGE[$TS])
GUICtrlSetData($g_hTxtTSMinGold, $g_aiFilterMinGold[$TS])
GUICtrlSetData($g_hTxtTSMinElixir, $g_aiFilterMinElixir[$TS])
GUICtrlSetData($g_hTxtTSMinGoldPlusElixir, $g_aiFilterMinGoldPlusElixir[$TS])
cmbTSGoldElixir()
GUICtrlSetState($g_hChkTSMeetDE, $g_abFilterMeetDEEnable[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtTSMinDarkElixir, $g_aiFilterMeetDEMin[$TS])
chkTSMeetDE()
GUICtrlSetData($g_hTxtSWTTiles, $g_iAtkTSAddTilesWhileTrain)
GUICtrlSetData($g_hTxtTHaddTiles, $g_iAtkTSAddTilesFullTroops)
Case "Save"
$g_abAttackTypeEnable[$TS] =(GUICtrlRead($g_hChkTHSnipe) = $GUI_CHECKED)
$g_abSearchSearchesEnable[$TS] =(GUICtrlRead($g_hChkTSActivateSearches) = $GUI_CHECKED)
$g_aiSearchSearchesMin[$TS] = GUICtrlRead($g_hTxtTSSearchesMin)
$g_aiSearchSearchesMax[$TS] = GUICtrlRead($g_hTxtTSSearchesMax)
$g_abSearchTropiesEnable[$TS] =(GUICtrlRead($g_hChkTSActivateTropies) = $GUI_CHECKED)
$g_aiSearchTrophiesMin[$TS] = GUICtrlRead($g_hTxtTSTropiesMin)
$g_aiSearchTrophiesMax[$TS] = GUICtrlRead($g_hTxtTSTropiesMax)
$g_abSearchCampsEnable[$TS] =(GUICtrlRead($g_hChkTSActivateCamps) = $GUI_CHECKED)
$g_aiSearchCampsPct[$TS] = Int(GUICtrlRead($g_hTxtTSArmyCamps))
$g_aiFilterMeetGE[$TS] = _GUICtrlComboBox_GetCurSel($g_hCmbTSMeetGE)
$g_aiFilterMinGold[$TS] = GUICtrlRead($g_hTxtTSMinGold)
$g_aiFilterMinElixir[$TS] = GUICtrlRead($g_hTxtTSMinElixir)
$g_aiFilterMinGoldPlusElixir[$TS] = GUICtrlRead($g_hTxtTSMinGoldPlusElixir)
$g_abFilterMeetDEEnable[$TS] =(GUICtrlRead($g_hChkTSMeetDE) = $GUI_CHECKED)
$g_aiFilterMeetDEMin[$TS] = GUICtrlRead($g_hTxtTSMinDarkElixir)
$g_iAtkTSAddTilesWhileTrain = GUICtrlRead($g_hTxtSWTTiles)
$g_iAtkTSAddTilesFullTroops = GUICtrlRead($g_hTxtTHaddTiles)
EndSwitch
EndFunc
Func ApplyConfig_600_29($TypeReadSave)
Switch $TypeReadSave
Case "Read"
Switch $iActivateKQCondition
Case "Manual"
GUICtrlSetState($g_hRadManAbilities, $GUI_CHECKED)
Case "Auto"
GUICtrlSetState($g_hRadAutoAbilities, $GUI_CHECKED)
EndSwitch
GUICtrlSetData($g_hTxtManAbilities,($delayActivateKQ / 1000))
GUICtrlSetState($g_hChkUseWardenAbility, $iActivateWardenCondition = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtWardenAbility,($delayActivateW / 1000))
GUICtrlSetState($g_hChkAttackPlannerEnable, $ichkAttackPlannerEnable = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkAttackPlannerCloseCoC, $ichkAttackPlannerCloseCoC = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkAttackPlannerCloseAll, $ichkAttackPlannerCloseAll = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkAttackPlannerRandom, $ichkAttackPlannerRandom = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbAttackPlannerRandom, $icmbAttackPlannerRandom)
GUICtrlSetState($g_hChkAttackPlannerDayLimit, $ichkAttackPlannerDayLimit = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
chkAttackPlannerEnable()
GUICtrlSetData($g_hCmbAttackPlannerDayMin, $icmbAttackPlannerDayMin)
GUICtrlSetData($g_hCmbAttackPlannerDayMax, $icmbAttackPlannerDayMax)
_cmbAttackPlannerDayLimit()
For $i = 0 To 6
GUICtrlSetState($g_ahChkAttackWeekdays[$i], $iPlannedAttackWeekDays[$i] = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
Next
For $i = 0 To 23
GUICtrlSetState($g_ahChkAttackHours[$i], $iPlannedattackHours[$i] = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
Next
GUICtrlSetState($g_hChkDropCCHoursEnable, $iPlannedDropCCHoursEnable = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
chkDropCCHoursEnable()
GUICtrlSetState($g_hChkUseCCBalanced, $iChkUseCCBalanced = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbCCDonated, $iCmbCCDonated - 1)
_GUICtrlComboBox_SetCurSel($g_hCmbCCReceived, $iCmbCCReceived - 1)
chkBalanceDR()
For $i = 0 To 23
GUICtrlSetState($g_ahChkDropCCHours[$i], $iPlannedDropCCHours[$i] = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
Next
Case "Save"
$iActivateKQCondition = GUICtrlRead($g_hRadManAbilities) = $GUI_CHECKED ? "Manual" : "Auto"
$delayActivateKQ = GUICtrlRead($g_hTxtManAbilities) * 1000
$iActivateWardenCondition = GUICtrlRead($g_hChkUseWardenAbility) = $GUI_CHECKED ? 1 : 0
$delayActivateW = GUICtrlRead($g_hTxtWardenAbility) * 1000
$ichkAttackPlannerEnable = GUICtrlRead($g_hChkAttackPlannerEnable) = $GUI_CHECKED ? 1 : 0
$ichkAttackPlannerCloseCoC = GUICtrlRead($g_hChkAttackPlannerCloseCoC) = $GUI_CHECKED ? 1 : 0
$ichkAttackPlannerCloseAll = GUICtrlRead($g_hChkAttackPlannerCloseAll) = $GUI_CHECKED ? 1 : 0
$ichkAttackPlannerRandom = GUICtrlRead($g_hChkAttackPlannerRandom) = $GUI_CHECKED ? 1 : 0
$icmbAttackPlannerRandom = _GUICtrlComboBox_GetCurSel($g_hCmbAttackPlannerRandom)
$ichkAttackPlannerDayLimit = GUICtrlRead($g_hChkAttackPlannerDayLimit) = $GUI_CHECKED ? 1 : 0
$icmbAttackPlannerDayMin = GUICtrlRead($g_hCmbAttackPlannerDayMin)
$icmbAttackPlannerDayMax = GUICtrlRead($g_hCmbAttackPlannerDayMax)
Local $string = ""
For $i = 0 To 6
$iPlannedAttackWeekDays[$i] = GUICtrlRead($g_ahChkAttackWeekdays[$i]) = $GUI_CHECKED ? 1 : 0
Next
Local $string = ""
For $i = 0 To 23
$iPlannedattackHours[$i] = GUICtrlRead($g_ahChkAttackHours[$i]) = $GUI_CHECKED ? 1 : 0
Next
$iPlannedDropCCHoursEnable = GUICtrlRead($g_hChkDropCCHoursEnable) = $GUI_CHECKED ? 1 : 0
$iChkUseCCBalanced = GUICtrlRead($g_hChkUseCCBalanced) = $GUI_CHECKED ? 1 : 0
$iCmbCCDonated = _GUICtrlComboBox_GetCurSel($g_hCmbCCDonated) + 1
$iCmbCCReceived = _GUICtrlComboBox_GetCurSel($g_hCmbCCReceived) + 1
Local $string = ""
For $i = 0 To 23
$iPlannedDropCCHours[$i] = GUICtrlRead($g_ahChkDropCCHours[$i]) = $GUI_CHECKED ? 1 : 0
Next
EndSwitch
EndFunc
Func ApplyConfig_600_29_DB($TypeReadSave)
Switch $TypeReadSave
Case "Read"
_GUICtrlComboBox_SetCurSel($g_hCmbDBAlgorithm, $g_aiAttackAlgorithm[$DB])
cmbDBAlgorithm()
_GUICtrlComboBox_SetCurSel($g_hCmbDBSelectTroop, $g_aiAttackTroopSelection[$DB])
GUICtrlSetState($g_hChkDBKingAttack, BitAND($g_aiAttackUseHeroes[$DB], $eHeroKing) = $eHeroKing ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBQueenAttack, BitAND($g_aiAttackUseHeroes[$DB], $eHeroQueen) = $eHeroQueen ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBWardenAttack, BitAND($g_aiAttackUseHeroes[$DB], $eHeroWarden) = $eHeroWarden ? $GUI_CHECKED : $GUI_UNCHECKED)
Local $temp1, $temp2, $temp3
$temp1 = GUICtrlRead($g_hChkDBKingAttack) = $GUI_CHECKED ? $eHeroKing : $eHeroNone
$temp2 = GUICtrlRead($g_hChkDBQueenAttack) = $GUI_CHECKED ? $eHeroQueen : $eHeroNone
$temp3 = GUICtrlRead($g_hChkDBWardenAttack) = $GUI_CHECKED ? $eHeroWarden : $eHeroNone
$g_aiAttackUseHeroes[$DB] = BitOR(Int($temp1), Int($temp2), Int($temp3))
GUICtrlSetState($g_hChkDBDropCC, $g_abAttackDropCC[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBLightSpell, $g_abAttackUseLightSpell[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBHealSpell, $g_abAttackUseHealSpell[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBRageSpell, $g_abAttackUseRageSpell[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBJumpSpell, $g_abAttackUseJumpSpell[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBFreezeSpell, $g_abAttackUseFreezeSpell[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBCloneSpell, $g_abAttackUseCloneSpell[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBPoisonSpell, $g_abAttackUsePoisonSpell[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBEarthquakeSpell, $g_abAttackUseEarthquakeSpell[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBHasteSpell, $g_abAttackUseHasteSpell[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBSkeletonSpell, $g_abAttackUseSkeletonSpell[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTHSnipeBeforeDBEnable, $g_bTHSnipeBeforeEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkTHSnipeBeforeDBEnable()
GUICtrlSetData($g_hTxtTHSnipeBeforeDBTiles, $g_iTHSnipeBeforeTiles[$DB])
LoadDBSnipeAttacks()
_GUICtrlComboBox_SetCurSel($g_hCmbTHSnipeBeforeDBScript, _GUICtrlComboBox_FindStringExact($g_hCmbTHSnipeBeforeDBScript, $g_iTHSnipeBeforeScript[$DB]))
Case "Save"
$g_aiAttackAlgorithm[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbDBAlgorithm)
$g_aiAttackTroopSelection[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbDBSelectTroop)
Local $temp1, $temp2, $temp3
$temp1 = GUICtrlRead($g_hChkDBKingAttack) = $GUI_CHECKED ? $eHeroKing : $eHeroNone
$temp2 = GUICtrlRead($g_hChkDBQueenAttack) = $GUI_CHECKED ? $eHeroQueen : $eHeroNone
$temp3 = GUICtrlRead($g_hChkDBWardenAttack) = $GUI_CHECKED ? $eHeroWarden : $eHeroNone
$g_aiAttackUseHeroes[$DB] = BitOR(Int($temp1), Int($temp2), Int($temp3))
$g_abAttackDropCC[$DB] =(GUICtrlRead($g_hChkDBDropCC) = $GUI_CHECKED)
$g_abAttackUseLightSpell[$DB] =(GUICtrlRead($g_hChkDBLightSpell) = $GUI_CHECKED)
$g_abAttackUseHealSpell[$DB] =(GUICtrlRead($g_hChkDBHealSpell) = $GUI_CHECKED)
$g_abAttackUseRageSpell[$DB] =(GUICtrlRead($g_hChkDBRageSpell) = $GUI_CHECKED)
$g_abAttackUseJumpSpell[$DB] =(GUICtrlRead($g_hChkDBJumpSpell) = $GUI_CHECKED)
$g_abAttackUseFreezeSpell[$DB] =(GUICtrlRead($g_hChkDBFreezeSpell) = $GUI_CHECKED)
$g_abAttackUsePoisonSpell[$DB] =(GUICtrlRead($g_hChkDBPoisonSpell) = $GUI_CHECKED)
$g_abAttackUseEarthquakeSpell[$DB] =(GUICtrlRead($g_hChkDBEarthquakeSpell) = $GUI_CHECKED)
$g_abAttackUseHasteSpell[$DB] =(GUICtrlRead($g_hChkDBHasteSpell) = $GUI_CHECKED)
$g_abAttackUseCloneSpell[$DB] =(GUICtrlRead($g_hChkDBCloneSpell) = $GUI_CHECKED)
$g_abAttackUseSkeletonSpell[$DB] =(GUICtrlRead($g_hChkDBSkeletonSpell) = $GUI_CHECKED)
$g_bTHSnipeBeforeEnable[$DB] =(GUICtrlRead($g_hChkTHSnipeBeforeDBEnable) = $GUI_CHECKED)
$g_iTHSnipeBeforeTiles[$DB] = GUICtrlRead($g_hTxtTHSnipeBeforeDBTiles)
$g_iTHSnipeBeforeScript[$DB] = GUICtrlRead($g_hCmbTHSnipeBeforeDBScript)
EndSwitch
ApplyConfig_600_29_DB_Standard($TypeReadSave)
ApplyConfig_600_29_DB_Scripted($TypeReadSave)
ApplyConfig_600_29_DB_Milking($TypeReadSave)
EndFunc
Func ApplyConfig_600_29_DB_Standard($TypeReadSave)
Switch $TypeReadSave
Case "Read"
_GUICtrlComboBox_SetCurSel($g_hCmbStandardDropOrderDB, $g_aiAttackStdDropOrder[$DB])
_GUICtrlComboBox_SetCurSel($g_hCmbStandardDropSidesDB, $g_aiAttackStdDropSides[$DB])
_GUICtrlComboBox_SetCurSel($g_hCmbStandardUnitDelayDB, $g_aiAttackStdUnitDelay[$DB])
_GUICtrlComboBox_SetCurSel($g_hCmbStandardWaveDelayDB, $g_aiAttackStdWaveDelay[$DB])
GUICtrlSetState($g_hChkRandomSpeedAtkDB, $g_abAttackStdRandomizeDelay[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkRandomSpeedAtkDB()
GUICtrlSetState($g_hChkSmartAttackRedAreaDB, $g_abAttackStdSmartAttack[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkSmartAttackRedAreaDB()
_GUICtrlComboBox_SetCurSel($g_hCmbSmartDeployDB, $g_aiAttackStdSmartDeploy[$DB])
GUICtrlSetState($g_hChkAttackNearGoldMineDB, $g_abAttackStdSmartNearCollectors[$DB][0] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkAttackNearElixirCollectorDB, $g_abAttackStdSmartNearCollectors[$DB][1] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkAttackNearDarkElixirDrillDB, $g_abAttackStdSmartNearCollectors[$DB][2] ? $GUI_CHECKED : $GUI_UNCHECKED)
Case "Save"
$g_aiAttackStdDropOrder[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbStandardDropOrderDB)
$g_aiAttackStdDropSides[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbStandardDropSidesDB)
$g_aiAttackStdUnitDelay[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbStandardUnitDelayDB)
$g_aiAttackStdWaveDelay[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbStandardWaveDelayDB)
$g_abAttackStdRandomizeDelay[$DB] =(GUICtrlRead($g_hChkRandomSpeedAtkDB) = $GUI_CHECKED)
$g_abAttackStdSmartAttack[$DB] =(GUICtrlRead($g_hChkSmartAttackRedAreaDB) = $GUI_CHECKED)
$g_aiAttackStdSmartDeploy[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbSmartDeployDB)
$g_abAttackStdSmartNearCollectors[$DB][0] =(GUICtrlRead($g_hChkAttackNearGoldMineDB) = $GUI_CHECKED)
$g_abAttackStdSmartNearCollectors[$DB][1] =(GUICtrlRead($g_hChkAttackNearElixirCollectorDB) = $GUI_CHECKED)
$g_abAttackStdSmartNearCollectors[$DB][2] =(GUICtrlRead($g_hChkAttackNearDarkElixirDrillDB) = $GUI_CHECKED)
EndSwitch
cmbDeployDB()
EndFunc
Func ApplyConfig_600_29_DB_Scripted($TypeReadSave)
Switch $TypeReadSave
Case "Read"
_GUICtrlComboBox_SetCurSel($g_hCmbScriptRedlineImplDB, $g_aiAttackScrRedlineRoutine[$DB])
_GUICtrlComboBox_SetCurSel($g_hCmbScriptDroplineDB, $g_aiAttackScrDroplineEdge[$DB])
PopulateComboScriptsFilesDB()
Local $tempindex = _GUICtrlComboBox_FindStringExact($g_hCmbScriptNameDB, $g_sAttackScrScriptName[$DB])
If $tempindex = -1 Then
$tempindex = 0
Setlog("Previous saved Scripted Attack not found (deleted, renamed?)", $COLOR_ERROR)
Setlog("Automatically setted a default script, please check your config", $COLOR_ERROR)
EndIf
_GUICtrlComboBox_SetCurSel($g_hCmbScriptNameDB, $tempindex)
cmbScriptNameDB()
cmbScriptRedlineImplDB()
Case "Save"
$g_aiAttackScrRedlineRoutine[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbScriptRedlineImplDB)
$g_aiAttackScrDroplineEdge[$DB] = _GUICtrlComboBox_GetCurSel($g_hCmbScriptDroplineDB)
Local $indexofscript = _GUICtrlComboBox_GetCurSel($g_hCmbScriptNameDB)
Local $scriptname
_GUICtrlComboBox_GetLBText($g_hCmbScriptNameDB, $indexofscript, $scriptname)
$g_sAttackScrScriptName[$DB] = $scriptname
IniWriteS($g_sProfileConfigPath, "attack", "ScriptDB", $g_sAttackScrScriptName[$LB])
EndSwitch
EndFunc
Func ApplyConfig_600_29_DB_Milking($TypeReadSave)
Switch $TypeReadSave
Case "Read"
_GUICtrlComboBox_SetCurSel($g_hCmbMilkAttackType, $g_iMilkAttackType = 1 ? 1 : 0)
For $i = 0 To 8
_GUICtrlComboBox_SetCurSel($g_hCmbMilkLvl[$i+4], $g_aiMilkFarmElixirParam[$i] + 1)
Next
GUICtrlSetState($g_hChkAtkElixirExtractors, $g_bMilkFarmLocateElixir ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkAtkGoldMines, $g_bMilkFarmLocateMine ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbAtkGoldMinesLevel, $g_iMilkFarmMineParam - 1)
GUICtrlSetState($g_hChkAtkDarkDrills, $g_bMilkFarmLocateDrill ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbAtkDarkDrillsLevel, $g_iMilkFarmDrillParam - 1)
_GUICtrlComboBox_SetCurSel($g_hCmbRedlineResDistance, $g_iMilkFarmResMaxTilesFromBorder)
GUICtrlSetState($g_hChkAttackMinesIfGold, $g_bMilkFarmAttackGoldMines ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkAttackMinesIfElixir, $g_bMilkFarmAttackElixirExtractors ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkAttackMinesIfDarkElixir, $g_bMilkFarmAttackDarkDrills ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtAttackMinesIfGold, $g_iMilkFarmLimitGold)
GUICtrlSetData($g_hTxtAttackMinesIfElixir, $g_iMilkFarmLimitElixir)
GUICtrlSetData($g_hTxtAttackMinesIfDarkElixir, $g_iMilkFarmLimitDark)
chkAttackMinesifGold()
chkAttackMinesifelixir()
chkAttackMinesifdarkElixir()
GUICtrlSetData($g_hTxtLowerXWave, $g_iMilkFarmTroopForWaveMin)
GUICtrlSetData($g_hTxtUpperXWave, $g_iMilkFarmTroopForWaveMax)
GUICtrlSetData($g_hTxtMaxWaves, $g_iMilkFarmTroopMaxWaves)
GUICtrlSetData($g_hTxtLowerDelayWaves, $g_iMilkFarmDelayFromWavesMin)
GUICtrlSetData($g_hTxtUpperDelayWaves, $g_iMilkFarmDelayFromWavesMax)
_GUICtrlComboBox_SetCurSel($g_hCmbMilkingAttackDropGoblinAlgorithm, $g_iMilkingAttackDropGoblinAlgorithm = 1 ? 1 : 0)
_GUICtrlComboBox_SetCurSel($g_hCmbStructureOrder, $g_iMilkingAttackStructureOrder)
GUICtrlSetState($g_hChkStructureDestroyedBeforeAttack, $g_bMilkingAttackCheckStructureDestroyedBeforeAttack ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkStructureDestroyedAfterAttack, $g_bMilkingAttackCheckStructureDestroyedAfterAttack ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkMilkAfterAttackTHSnipe, $g_bMilkAttackAfterTHSnipeEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkMilkAfterAttackTHSnipe()
GUICtrlSetData($g_hTxtMaxTilesMilk, $g_iMilkFarmTHMaxTilesFromBorder)
Local $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($g_sTHSnipeAttacksPath & "\*.csv")
Local $output = ""
While True
$NewFile = FileFindNextFile($FileSearch)
If @error Then ExitLoop
$output = $output & StringLeft($NewFile, StringLen($NewFile) - 4) & "|"
WEnd
FileClose($FileSearch)
$output = StringLeft($output, StringLen($output) - 1)
GUICtrlSetData($g_hCmbMilkSnipeAlgorithm, $output)
_GUICtrlComboBox_SetCurSel($g_hCmbMilkSnipeAlgorithm, _GUICtrlComboBox_FindStringExact($g_hCmbMilkSnipeAlgorithm, $g_sMilkFarmAlgorithmTh))
GUICtrlSetState($g_hChkSnipeIfNoElixir, $g_bMilkFarmSnipeEvenIfNoExtractorsFound ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkMilkAfterAttackScripted, $g_bMilkAttackAfterScriptedAtkEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
PopulateComboMilkingCSVScriptsFiles()
Local $tempindex = _GUICtrlComboBox_FindStringExact($g_hCmbMilkingCSVScriptName, $g_sMilkAttackCSVscript)
If $tempindex = -1 Then
$tempindex = 0
Setlog("Previous saved Milking Scripted Attack not found (deleted, renamed?)", $COLOR_ERROR)
Setlog("Automatically setted a default script, please check your config", $COLOR_ERROR)
EndIf
_GUICtrlComboBox_SetCurSel($g_hCmbMilkingCSVScriptName, $tempindex)
GUICtrlSetState($g_hChkMilkFarmForceTolerance, $g_bMilkFarmForceToleranceEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkMilkFarmForcetolerance()
GUICtrlSetData($g_hTxtMilkFarmForceToleranceNormal, $g_iMilkFarmForceToleranceNormal)
GUICtrlSetData($g_hTxtMilkFarmForceToleranceBoosted, $g_iMilkFarmForceToleranceBoosted)
GUICtrlSetData($g_hTxtMilkFarmForceToleranceDestroyed, $g_iMilkFarmForceToleranceDestroyed)
If $g_bDevMode = True Then
GUICtrlSetState($g_hGrpMilkingDebug, $GUI_SHOW)
GUICtrlSetState($g_hChkMilkingDebugIMG, $GUI_SHOW)
GUICtrlSetState($g_hChkMilkingDebugVillage, $GUI_SHOW)
GUICtrlSetState($g_hChkMilkingDebugFullSearch, $GUI_SHOW)
GUICtrlSetState($g_hChkMilkingDebugIMG, $g_iDebugResourcesOffset = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkMilkingDebugVillage, $g_iDebugMilkingIMGmake = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkMilkingDebugFullSearch, $g_iDebugContinueSearchElixir = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
EndIf
Case "Save"
$g_iMilkAttackType = _GUICtrlComboBox_GetCurSel($g_hCmbMilkAttackType)
For $i = 0 To 8
$g_aiMilkFarmElixirParam[$i] = _GUICtrlComboBox_GetCurSel($g_hCmbMilkLvl[$i+4]) - 1
Next
$g_bMilkFarmLocateElixir =(GUICtrlRead($g_hChkAtkElixirExtractors) = $GUI_CHECKED)
$g_bMilkFarmLocateMine =(GUICtrlRead($g_hChkAtkGoldMines) = $GUI_CHECKED)
$g_iMilkFarmMineParam = _GUICtrlComboBox_GetCurSel($g_hCmbAtkGoldMinesLevel) + 1
$g_bMilkFarmLocateDrill =(GUICtrlRead($g_hChkAtkDarkDrills) = $GUI_CHECKED)
$g_iMilkFarmDrillParam = _GUICtrlComboBox_GetCurSel($g_hCmbAtkDarkDrillsLevel) + 1
$g_iMilkFarmResMaxTilesFromBorder = _GUICtrlComboBox_GetCurSel($g_hCmbRedlineResDistance)
$g_bMilkFarmAttackGoldMines =(GUICtrlRead($g_hChkAttackMinesIfGold) = $GUI_CHECKED)
$g_bMilkFarmAttackElixirExtractors =(GUICtrlRead($g_hChkAttackMinesIfElixir) = $GUI_CHECKED)
$g_bMilkFarmAttackDarkDrills =(GUICtrlRead($g_hChkAttackMinesIfDarkElixir) = $GUI_CHECKED)
$g_iMilkFarmLimitGold = GUICtrlRead($g_hTxtAttackMinesIfGold)
$g_iMilkFarmLimitElixir = GUICtrlRead($g_hTxtAttackMinesIfElixir)
$g_iMilkFarmLimitDark = GUICtrlRead($g_hTxtAttackMinesIfDarkElixir)
$g_iMilkFarmTroopForWaveMin = GUICtrlRead($g_hTxtLowerXWave)
$g_iMilkFarmTroopForWaveMax = GUICtrlRead($g_hTxtUpperXWave)
$g_iMilkFarmTroopMaxWaves = GUICtrlRead($g_hTxtMaxWaves)
$g_iMilkFarmDelayFromWavesMin = GUICtrlRead($g_hTxtLowerDelayWaves)
$g_iMilkFarmDelayFromWavesMax = GUICtrlRead($g_hTxtUpperDelayWaves)
$g_iMilkingAttackDropGoblinAlgorithm = _GUICtrlComboBox_GetCurSel($g_hCmbMilkingAttackDropGoblinAlgorithm)
$g_iMilkingAttackStructureOrder = _GUICtrlComboBox_GetCurSel($g_hCmbStructureOrder)
$g_bMilkingAttackCheckStructureDestroyedBeforeAttack =(GUICtrlRead($g_hChkStructureDestroyedBeforeAttack) = $GUI_CHECKED)
$g_bMilkingAttackCheckStructureDestroyedAfterAttack =(GUICtrlRead($g_hChkStructureDestroyedAfterAttack) = $GUI_CHECKED)
$g_bMilkAttackAfterTHSnipeEnable =(GUICtrlRead($g_hChkMilkAfterAttackTHSnipe) = $GUI_CHECKED)
$g_iMilkFarmTHMaxTilesFromBorder = GUICtrlRead($g_hTxtMaxTilesMilk)
$g_sMilkFarmAlgorithmTh = GUICtrlRead($g_hCmbMilkSnipeAlgorithm)
$g_bMilkFarmSnipeEvenIfNoExtractorsFound =(GUICtrlRead($g_hChkSnipeIfNoElixir) = $GUI_CHECKED)
$g_bMilkAttackAfterScriptedAtkEnable =(GUICtrlRead($g_hChkMilkAfterAttackScripted) = $GUI_CHECKED)
Local $indexofscript = _GUICtrlComboBox_GetCurSel($g_hCmbMilkingCSVScriptName)
Local $scriptname
_GUICtrlComboBox_GetLBText($g_hCmbMilkingCSVScriptName, $indexofscript, $scriptname)
$g_sMilkAttackCSVscript = $scriptname
$g_bMilkFarmForceToleranceEnable =(GUICtrlRead($g_hChkMilkFarmForceTolerance) = $GUI_CHECKED)
$g_iMilkFarmForceToleranceNormal = GUICtrlRead($g_hTxtMilkFarmForceToleranceNormal)
$g_iMilkFarmForceToleranceBoosted = GUICtrlRead($g_hTxtMilkFarmForceToleranceBoosted)
$g_iMilkFarmForceToleranceDestroyed = GUICtrlRead($g_hTxtMilkFarmForceToleranceDestroyed)
If $g_bDevMode = True Then
$g_iDebugResourcesOffset = GUICtrlRead($g_hChkMilkingDebugIMG) = $GUI_CHECKED ? 1 : 0
$g_iDebugMilkingIMGmake = GUICtrlRead($g_hChkMilkingDebugVillage) = $GUI_CHECKED ? 1 : 0
$g_iDebugContinueSearchElixir = GUICtrlRead($g_hChkMilkingDebugFullSearch) = $GUI_CHECKED ? 1 : 0
EndIf
EndSwitch
EndFunc
Func ApplyConfig_600_29_LB($TypeReadSave)
Switch $TypeReadSave
Case "Read"
_GUICtrlComboBox_SetCurSel($g_hCmbABAlgorithm, $g_aiAttackAlgorithm[$LB])
cmbABAlgorithm()
_GUICtrlComboBox_SetCurSel($g_hCmbABSelectTroop, $g_aiAttackTroopSelection[$LB])
GUICtrlSetState($g_hChkABKingAttack, BitAND($g_aiAttackUseHeroes[$LB], $eHeroKing) = $eHeroKing ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABQueenAttack, BitAND($g_aiAttackUseHeroes[$LB], $eHeroQueen) = $eHeroQueen ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABWardenAttack, BitAND($g_aiAttackUseHeroes[$LB], $eHeroWarden) = $eHeroWarden ? $GUI_CHECKED : $GUI_UNCHECKED)
Local $temp1, $temp2, $temp3
$temp1 = GUICtrlRead($g_hChkABKingAttack) = $GUI_CHECKED ? $eHeroKing : $eHeroNone
$temp2 = GUICtrlRead($g_hChkABQueenAttack) = $GUI_CHECKED ? $eHeroQueen : $eHeroNone
$temp3 = GUICtrlRead($g_hChkABWardenAttack) = $GUI_CHECKED ? $eHeroWarden : $eHeroNone
$g_aiAttackUseHeroes[$LB] = BitOR(Int($temp1), Int($temp2), Int($temp3))
GUICtrlSetState($g_hChkABDropCC, $g_abAttackDropCC[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABLightSpell, $g_abAttackUseLightSpell[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABHealSpell, $g_abAttackUseHealSpell[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABRageSpell, $g_abAttackUseRageSpell[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABJumpSpell, $g_abAttackUseJumpSpell[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABFreezeSpell, $g_abAttackUseFreezeSpell[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABCloneSpell, $g_abAttackUseCloneSpell[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABPoisonSpell, $g_abAttackUsePoisonSpell[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABEarthquakeSpell, $g_abAttackUseEarthquakeSpell[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABHasteSpell, $g_abAttackUseHasteSpell[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABSkeletonSpell, $g_abAttackUseSkeletonSpell[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTHSnipeBeforeLBEnable, $g_bTHSnipeBeforeEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkTHSnipeBeforeLBEnable()
GUICtrlSetData($g_hTxtTHSnipeBeforeLBTiles, $g_iTHSnipeBeforeTiles[$LB])
LoadABSnipeAttacks()
_GUICtrlComboBox_SetCurSel($g_hCmbTHSnipeBeforeLBScript, _GUICtrlComboBox_FindStringExact($g_hCmbTHSnipeBeforeLBScript, $g_iTHSnipeBeforeScript[$LB]))
Case "Save"
$g_aiAttackAlgorithm[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbABAlgorithm)
$g_aiAttackTroopSelection[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbABSelectTroop)
Local $temp1, $temp2, $temp3
$temp1 = GUICtrlRead($g_hChkABKingAttack) = $GUI_CHECKED ? $eHeroKing : $eHeroNone
$temp2 = GUICtrlRead($g_hChkABQueenAttack) = $GUI_CHECKED ? $eHeroQueen : $eHeroNone
$temp3 = GUICtrlRead($g_hChkABWardenAttack) = $GUI_CHECKED ? $eHeroWarden : $eHeroNone
$g_aiAttackUseHeroes[$LB] = BitOR(Int($temp1), Int($temp2), Int($temp3))
$g_abAttackDropCC[$LB] =(GUICtrlRead($g_hChkABDropCC) = $GUI_CHECKED)
$g_abAttackUseLightSpell[$LB] =(GUICtrlRead($g_hChkABLightSpell) = $GUI_CHECKED)
$g_abAttackUseHealSpell[$LB] =(GUICtrlRead($g_hChkABHealSpell) = $GUI_CHECKED)
$g_abAttackUseRageSpell[$LB] =(GUICtrlRead($g_hChkABRageSpell) = $GUI_CHECKED)
$g_abAttackUseJumpSpell[$LB] =(GUICtrlRead($g_hChkABJumpSpell) = $GUI_CHECKED)
$g_abAttackUseFreezeSpell[$LB] =(GUICtrlRead($g_hChkABFreezeSpell) = $GUI_CHECKED)
$g_abAttackUseCloneSpell[$LB] =(GUICtrlRead($g_hChkABCloneSpell) = $GUI_CHECKED)
$g_abAttackUsePoisonSpell[$LB] =(GUICtrlRead($g_hChkABPoisonSpell) = $GUI_CHECKED)
$g_abAttackUseEarthquakeSpell[$LB] =(GUICtrlRead($g_hChkABEarthquakeSpell) = $GUI_CHECKED)
$g_abAttackUseHasteSpell[$LB] =(GUICtrlRead($g_hChkABHasteSpell) = $GUI_CHECKED)
$g_abAttackUseSkeletonSpell[$LB] =(GUICtrlRead($g_hChkABSkeletonSpell) = $GUI_CHECKED)
$g_bTHSnipeBeforeEnable[$LB] =(GUICtrlRead($g_hChkTHSnipeBeforeLBEnable) = $GUI_CHECKED)
$g_iTHSnipeBeforeTiles[$LB] = GUICtrlRead($g_hTxtTHSnipeBeforeLBTiles)
$g_iTHSnipeBeforeScript[$LB] = GUICtrlRead($g_hCmbTHSnipeBeforeLBScript)
EndSwitch
ApplyConfig_600_29_LB_Standard($TypeReadSave)
ApplyConfig_600_29_LB_Scripted($TypeReadSave)
EndFunc
Func ApplyConfig_600_29_LB_Standard($TypeReadSave)
Switch $TypeReadSave
Case "Read"
_GUICtrlComboBox_SetCurSel($g_hCmbStandardDropOrderAB, $g_aiAttackStdDropOrder[$LB])
_GUICtrlComboBox_SetCurSel($g_hCmbStandardDropSidesAB, $g_aiAttackStdDropSides[$LB])
_GUICtrlComboBox_SetCurSel($g_hCmbStandardUnitDelayAB, $g_aiAttackStdUnitDelay[$LB])
_GUICtrlComboBox_SetCurSel($g_hCmbStandardWaveDelayAB, $g_aiAttackStdWaveDelay[$LB])
GUICtrlSetState($g_hChkRandomSpeedAtkAB, $g_abAttackStdRandomizeDelay[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkRandomSpeedAtkAB()
GUICtrlSetState($g_hChkSmartAttackRedAreaAB, $g_abAttackStdSmartAttack[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
chkSmartAttackRedAreaAB()
_GUICtrlComboBox_SetCurSel($g_hCmbSmartDeployAB, $g_aiAttackStdSmartDeploy[$LB])
GUICtrlSetState($g_hChkAttackNearGoldMineAB, $g_abAttackStdSmartNearCollectors[$LB][0] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkAttackNearElixirCollectorAB, $g_abAttackStdSmartNearCollectors[$LB][1] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkAttackNearDarkElixirDrillAB, $g_abAttackStdSmartNearCollectors[$LB][2] ? $GUI_CHECKED : $GUI_UNCHECKED)
Case "Save"
$g_aiAttackStdDropOrder[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbStandardDropOrderAB)
$g_aiAttackStdDropSides[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbStandardDropSidesAB)
$g_aiAttackStdUnitDelay[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbStandardUnitDelayAB)
$g_aiAttackStdWaveDelay[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbStandardWaveDelayAB)
$g_abAttackStdRandomizeDelay[$LB] =(GUICtrlRead($g_hChkRandomSpeedAtkAB) = $GUI_CHECKED)
$g_abAttackStdSmartAttack[$LB] =(GUICtrlRead($g_hChkSmartAttackRedAreaAB) = $GUI_CHECKED)
$g_aiAttackStdSmartDeploy[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbSmartDeployAB)
$g_abAttackStdSmartNearCollectors[$LB][0] =(GUICtrlRead($g_hChkAttackNearGoldMineAB) = $GUI_CHECKED)
$g_abAttackStdSmartNearCollectors[$LB][1] =(GUICtrlRead($g_hChkAttackNearElixirCollectorAB) = $GUI_CHECKED)
$g_abAttackStdSmartNearCollectors[$LB][2] =(GUICtrlRead($g_hChkAttackNearDarkElixirDrillAB) = $GUI_CHECKED)
EndSwitch
cmbDeployAB()
EndFunc
Func ApplyConfig_600_29_LB_Scripted($TypeReadSave)
Switch $TypeReadSave
Case "Read"
_GUICtrlComboBox_SetCurSel($g_hCmbScriptRedlineImplAB, $g_aiAttackScrRedlineRoutine[$LB])
_GUICtrlComboBox_SetCurSel($g_hCmbScriptDroplineAB, $g_aiAttackScrDroplineEdge[$LB])
PopulateComboScriptsFilesAB()
Local $tempindex = _GUICtrlComboBox_FindStringExact($g_hCmbScriptNameAB, $g_sAttackScrScriptName[$LB])
If $tempindex = -1 Then
$tempindex = 0
Setlog("Previous saved Scripted Attack not found (deleted, renamed?)", $COLOR_ERROR)
Setlog("Automatically setted a default script, please check your config", $COLOR_ERROR)
EndIf
_GUICtrlComboBox_SetCurSel($g_hCmbScriptNameAB, $tempindex)
cmbScriptNameAB()
cmbScriptRedlineImplAB()
Case "Save"
$g_aiAttackScrRedlineRoutine[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbScriptRedlineImplAB)
$g_aiAttackScrDroplineEdge[$LB] = _GUICtrlComboBox_GetCurSel($g_hCmbScriptDroplineAB)
Local $indexofscript = _GUICtrlComboBox_GetCurSel($g_hCmbScriptNameAB)
Local $scriptname
_GUICtrlComboBox_GetLBText($g_hCmbScriptNameAB, $indexofscript, $scriptname)
$g_sAttackScrScriptName[$LB] = $scriptname
IniWriteS($g_sProfileConfigPath, "attack", "ScriptAB", $g_sAttackScrScriptName[$LB])
EndSwitch
EndFunc
Func ApplyConfig_600_29_TS($TypeReadSave)
Switch $TypeReadSave
Case "Read"
_GUICtrlComboBox_SetCurSel($g_hCmbTSSelectTroop, $g_aiAttackTroopSelection[$TS])
GUICtrlSetState($g_hChkTSKingAttack, BitAND($g_aiAttackUseHeroes[$TS], $eHeroKing) = $eHeroKing ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTSQueenAttack, BitAND($g_aiAttackUseHeroes[$TS], $eHeroQueen) = $eHeroQueen ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTSWardenAttack, BitAND($g_aiAttackUseHeroes[$TS], $eHeroWarden) = $eHeroWarden ? $GUI_CHECKED : $GUI_UNCHECKED)
Local $temp1, $temp2, $temp3
$temp1 = GUICtrlRead($g_hChkTSKingAttack) = $GUI_CHECKED ? $eHeroKing : $eHeroNone
$temp2 = GUICtrlRead($g_hChkTSQueenAttack) = $GUI_CHECKED ? $eHeroQueen : $eHeroNone
$temp3 = GUICtrlRead($g_hChkTSWardenAttack) = $GUI_CHECKED ? $eHeroWarden : $eHeroNone
$g_aiAttackUseHeroes[$TS] = BitOR(Int($temp1), Int($temp2), Int($temp3))
GUICtrlSetState($g_hChkTSDropCC, $g_abAttackDropCC[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTSLightSpell, $g_abAttackUseLightSpell[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTSHealSpell, $g_abAttackUseHealSpell[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTSRageSpell, $g_abAttackUseRageSpell[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTSJumpSpell, $g_abAttackUseJumpSpell[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTSFreezeSpell, $g_abAttackUseFreezeSpell[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTSPoisonSpell, $g_abAttackUsePoisonSpell[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTSEarthquakeSpell, $g_abAttackUseEarthquakeSpell[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkTSHasteSpell, $g_abAttackUseHasteSpell[$TS] ? $GUI_CHECKED : $GUI_UNCHECKED)
LoadThSnipeAttacks()
_GUICtrlComboBox_SetCurSel($g_hCmbAttackTHType, _GUICtrlComboBox_FindStringExact($g_hCmbAttackTHType, $g_sAtkTSType))
Case "Save"
$g_aiAttackTroopSelection[$TS] = _GUICtrlComboBox_GetCurSel($g_hCmbTSSelectTroop)
Local $temp1, $temp2, $temp3
$temp1 = GUICtrlRead($g_hChkTSKingAttack) = $GUI_CHECKED ? $eHeroKing : $eHeroNone
$temp2 = GUICtrlRead($g_hChkTSQueenAttack) = $GUI_CHECKED ? $eHeroQueen : $eHeroNone
$temp3 = GUICtrlRead($g_hChkTSWardenAttack) = $GUI_CHECKED ? $eHeroWarden : $eHeroNone
$g_aiAttackUseHeroes[$TS] = BitOR(Int($temp1), Int($temp2), Int($temp3))
$g_abAttackDropCC[$TS] =(GUICtrlRead($g_hChkTSDropCC) = $GUI_CHECKED)
$g_abAttackUseLightSpell[$TS] =(GUICtrlRead($g_hChkTSLightSpell) = $GUI_CHECKED)
$g_abAttackUseHealSpell[$TS] =(GUICtrlRead($g_hChkTSHealSpell) = $GUI_CHECKED)
$g_abAttackUseRageSpell[$TS] =(GUICtrlRead($g_hChkTSRageSpell) = $GUI_CHECKED)
$g_abAttackUseJumpSpell[$TS] =(GUICtrlRead($g_hChkTSJumpSpell) = $GUI_CHECKED)
$g_abAttackUseFreezeSpell[$TS] =(GUICtrlRead($g_hChkTSFreezeSpell) = $GUI_CHECKED)
$g_abAttackUsePoisonSpell[$TS] =(GUICtrlRead($g_hChkTSPoisonSpell) = $GUI_CHECKED)
$g_abAttackUseEarthquakeSpell[$TS] =(GUICtrlRead($g_hChkTSEarthquakeSpell) = $GUI_CHECKED)
$g_abAttackUseHasteSpell[$TS] =(GUICtrlRead($g_hChkTSHasteSpell) = $GUI_CHECKED)
$g_sAtkTSType = GUICtrlRead($g_hCmbAttackTHType)
EndSwitch
EndFunc
Func ApplyConfig_600_30($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkShareAttack, $iShareAttack = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtShareMinGold, $iShareminGold)
GUICtrlSetData($g_hTxtShareMinElixir, $iShareminElixir)
GUICtrlSetData($g_hTxtShareMinDark, $iShareminDark)
GUICtrlSetData($g_hTxtShareMessage, $sShareMessage)
GUICtrlSetState($g_hChkTakeLootSS, $TakeLootSnapShot = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkScreenshotLootInfo, $ScreenshotLootInfo = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
chkTakeLootSS()
Case "Save"
$iShareAttack = GUICtrlRead($g_hChkShareAttack) = $GUI_CHECKED ? 1 : 0
$iShareminGold = GUICtrlRead($g_hTxtShareMinGold)
$iShareminElixir = GUICtrlRead($g_hTxtShareMinElixir)
$iShareminDark = GUICtrlRead($g_hTxtShareMinDark)
$sShareMessage = GUICtrlRead($g_hTxtShareMessage)
$TakeLootSnapShot = GUICtrlRead($g_hChkTakeLootSS) = $GUI_CHECKED ? 1 : 0
$ScreenshotLootInfo = GUICtrlRead($g_hChkScreenshotLootInfo) = $GUI_CHECKED ? 1 : 0
EndSwitch
EndFunc
Func ApplyConfig_600_30_DB($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkStopAtkDBNoLoot1, $g_abStopAtkNoLoot1Enable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtStopAtkDBNoLoot1, $g_aiStopAtkNoLoot1Time[$DB])
chkStopAtkDBNoLoot1()
GUICtrlSetState($g_hChkStopAtkDBNoLoot2, $g_abStopAtkNoLoot2Enable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtStopAtkDBNoLoot2, $g_aiStopAtkNoLoot2Time[$DB])
chkStopAtkDBNoLoot2()
GUICtrlSetData($g_hTxtDBMinGoldStopAtk2, $g_aiStopAtkNoLoot2MinGold[$DB])
GUICtrlSetData($g_hTxtDBMinElixirStopAtk2, $g_aiStopAtkNoLoot2MinElixir[$DB])
GUICtrlSetData($g_hTxtDBMinDarkElixirStopAtk2, $g_aiStopAtkNoLoot2MinDark[$DB])
GUICtrlSetState($g_hChkDBEndNoResources, $g_abStopAtkNoResources[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBEndOneStar, $g_abStopAtkOneStar[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBEndTwoStars, $g_abStopAtkTwoStars[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDBEndPercentHigher, $g_abStopAtkPctHigherEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtDBPercentHigher, $g_aiStopAtkPctHigherAmt[$DB])
GUICtrlSetState($g_hChkDBEndPercentChange, $g_abStopAtkPctNoChangeEnable[$DB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtDBPercentChange, $g_aiStopAtkPctNoChangeTime[$DB])
Case "Save"
$g_abStopAtkNoLoot1Enable[$DB] =(GUICtrlRead($g_hChkStopAtkDBNoLoot1) = $GUI_CHECKED)
$g_aiStopAtkNoLoot1Time[$DB] = Int(GUICtrlRead($g_hTxtStopAtkDBNoLoot1))
$g_abStopAtkNoLoot2Enable[$DB] =(GUICtrlRead($g_hChkStopAtkDBNoLoot2) = $GUI_CHECKED)
$g_aiStopAtkNoLoot2Time[$DB] = Int(GUICtrlRead($g_hTxtStopAtkDBNoLoot2))
$g_aiStopAtkNoLoot2MinGold[$DB] = Int(GUICtrlRead($g_hTxtDBMinGoldStopAtk2))
$g_aiStopAtkNoLoot2MinElixir[$DB] = Int(GUICtrlRead($g_hTxtDBMinElixirStopAtk2))
$g_aiStopAtkNoLoot2MinDark[$DB] = Int(GUICtrlRead($g_hTxtDBMinDarkElixirStopAtk2))
$g_abStopAtkNoResources[$DB] =(GUICtrlRead($g_hChkDBEndNoResources) = $GUI_CHECKED)
$g_abStopAtkOneStar[$DB] =(GUICtrlRead($g_hChkDBEndOneStar) = $GUI_CHECKED)
$g_abStopAtkTwoStars[$DB] =(GUICtrlRead($g_hChkDBEndTwoStars) = $GUI_CHECKED)
$g_abStopAtkPctHigherEnable[$DB] =(GUICtrlRead($g_hChkDBEndPercentHigher) = $GUI_CHECKED)
$g_aiStopAtkPctHigherAmt[$DB] = GUICtrlRead($g_hTxtDBPercentHigher)
$g_abStopAtkPctNoChangeEnable[$DB] =(GUICtrlRead($g_hChkDBEndPercentChange) = $GUI_CHECKED)
$g_aiStopAtkPctNoChangeTime[$DB] = GUICtrlRead($g_hTxtDBPercentChange)
EndSwitch
EndFunc
Func ApplyConfig_600_30_LB($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkStopAtkABNoLoot1, $g_abStopAtkNoLoot1Enable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtStopAtkABNoLoot1, $g_aiStopAtkNoLoot1Time[$LB])
chkStopAtkABNoLoot1()
GUICtrlSetState($g_hChkStopAtkABNoLoot2, $g_abStopAtkNoLoot2Enable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtStopAtkABNoLoot2, $g_aiStopAtkNoLoot2Time[$LB])
chkStopAtkABNoLoot2()
GUICtrlSetData($g_hTxtABMinGoldStopAtk2, $g_aiStopAtkNoLoot2MinGold[$LB])
GUICtrlSetData($g_hTxtABMinElixirStopAtk2, $g_aiStopAtkNoLoot2MinElixir[$LB])
GUICtrlSetData($g_hTxtABMinDarkElixirStopAtk2, $g_aiStopAtkNoLoot2MinDark[$LB])
GUICtrlSetState($g_hChkABEndNoResources, $g_abStopAtkNoResources[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABEndOneStar, $g_abStopAtkOneStar[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABEndTwoStars, $g_abStopAtkTwoStars[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDESideEB, $g_bDESideEndEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkDESideEB()
GUICtrlSetData($g_hTxtDELowEndMin, $g_iDESideEndMin)
GUICtrlSetState($g_hChkDisableOtherEBO, $g_bDESideDisableOther ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDEEndBk, $g_bDESideEndBKWeak ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDEEndAq, $g_bDESideEndAQWeak ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDEEndOneStar, $g_bDESideEndOneStar ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkABEndPercentHigher, $g_abStopAtkPctHigherEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtABPercentHigher, $g_aiStopAtkPctHigherAmt[$LB])
GUICtrlSetState($g_hChkABEndPercentChange, $g_abStopAtkPctNoChangeEnable[$LB] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtABPercentChange, $g_aiStopAtkPctNoChangeTime[$LB])
Case "Save"
$g_abStopAtkNoLoot1Enable[$LB] =(GUICtrlRead($g_hChkStopAtkABNoLoot1) = $GUI_CHECKED)
$g_aiStopAtkNoLoot1Time[$LB] = Int(GUICtrlRead($g_hTxtStopAtkABNoLoot1))
$g_abStopAtkNoLoot2Enable[$LB] =(GUICtrlRead($g_hChkStopAtkABNoLoot2) = $GUI_CHECKED)
$g_aiStopAtkNoLoot2Time[$LB] =(GUICtrlRead($g_hTxtStopAtkABNoLoot2))
$g_aiStopAtkNoLoot2MinGold[$LB] = Int(GUICtrlRead($g_hTxtABMinGoldStopAtk2))
$g_aiStopAtkNoLoot2MinElixir[$LB] = Int(GUICtrlRead($g_hTxtABMinElixirStopAtk2))
$g_aiStopAtkNoLoot2MinDark[$LB] = Int(GUICtrlRead($g_hTxtABMinDarkElixirStopAtk2))
$g_abStopAtkNoResources[$LB] =(GUICtrlRead($g_hChkABEndNoResources) = $GUI_CHECKED)
$g_abStopAtkOneStar[$LB] =(GUICtrlRead($g_hChkABEndOneStar) = $GUI_CHECKED)
$g_abStopAtkTwoStars[$LB] =(GUICtrlRead($g_hChkABEndTwoStars) = $GUI_CHECKED)
$g_bDESideEndEnable =(GUICtrlRead($g_hChkDESideEB) = $GUI_CHECKED)
$g_iDESideEndMin = GUICtrlRead($g_hTxtDELowEndMin)
$g_bDESideDisableOther =(GUICtrlRead($g_hChkDisableOtherEBO) = $GUI_CHECKED)
$g_bDESideEndAQWeak =(GUICtrlRead($g_hChkDEEndAq) = $GUI_CHECKED)
$g_bDESideEndBKWeak =(GUICtrlRead($g_hChkDEEndBk) = $GUI_CHECKED)
$g_bDESideEndOneStar =(GUICtrlRead($g_hChkDEEndOneStar) = $GUI_CHECKED)
$g_abStopAtkPctHigherEnable[$LB] =(GUICtrlRead($g_hChkABEndPercentHigher) = $GUI_CHECKED)
$g_aiStopAtkPctHigherAmt[$LB] = GUICtrlRead($g_hTxtABPercentHigher)
$g_abStopAtkPctNoChangeEnable[$LB] =(GUICtrlRead($g_hChkABEndPercentChange) = $GUI_CHECKED)
$g_aiStopAtkPctNoChangeTime[$LB] = GUICtrlRead($g_hTxtABPercentChange)
EndSwitch
EndFunc
Func ApplyConfig_600_30_TS($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkTSActivateCamps2, $g_bEndTSCampsEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
chkTSActivateCamps2()
GUICtrlSetData($g_hTxtTSArmyCamps2, $g_iEndTSCampsPct)
Case "Save"
$g_bEndTSCampsEnable =(GUICtrlRead($g_hChkTSActivateCamps2) = $GUI_CHECKED)
$g_iEndTSCampsPct = GUICtrlRead($g_hTxtTSArmyCamps2)
EndSwitch
EndFunc
Func ApplyConfig_600_31($TypeReadSave)
Switch $TypeReadSave
Case "Read"
For $i = 6 To 12
GUICtrlSetState($g_ahChkDBCollectorLevel[$i], $g_abCollectorLevelEnabled[$i] ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_ahCmbDBCollectorLevel[$i], $g_abCollectorLevelEnabled[$i] ? $GUI_ENABLE : $GUI_DISABLE)
_GUICtrlComboBox_SetCurSel($g_ahCmbDBCollectorLevel[$i], $g_aiCollectorLevelFill[$i])
Next
GUICtrlSetState($g_hChkDBDisableCollectorsFilter, $g_bCollectorFilterDisable ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($g_hCmbMinCollectorMatches, $g_iCollectorMatchesMin - 1)
GUICtrlSetData($g_hSldCollectorTolerance, $g_iCollectorToleranceOffset)
checkCollectors()
Case "Save"
For $i = 6 To 12
$g_abCollectorLevelEnabled[$i] =(GUICtrlRead($g_ahChkDBCollectorLevel[$i]) = $GUI_CHECKED)
$g_aiCollectorLevelFill[$i] = _GUICtrlComboBox_GetCurSel($g_ahCmbDBCollectorLevel[$i])
Next
$g_bCollectorFilterDisable =(GUICtrlRead($g_hChkDBDisableCollectorsFilter) = $GUI_CHECKED)
$g_iCollectorMatchesMin = _GUICtrlComboBox_GetCurSel($g_hCmbMinCollectorMatches) + 1
$g_iCollectorToleranceOffset = GUICtrlRead($g_hSldCollectorTolerance)
EndSwitch
EndFunc
Func ApplyConfig_600_32($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkTrophyRange, $iChkTrophyRange = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtMaxTrophy, $itxtMaxTrophy)
GUICtrlSetData($g_hTxtDropTrophy, $itxtdropTrophy)
GUICtrlSetState($g_hChkTrophyHeroes, $iChkTrophyHeroes = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
chkTrophyHeroes()
_GUICtrlComboBox_SetCurSel($g_hCmbTrophyHeroesPriority, $iCmbTrophyHeroesPriority)
GUICtrlSetState($g_hChkTrophyAtkDead, $iChkTrophyAtkDead = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtDropTrophyArmyMin, $itxtDTArmyMin)
chkTrophyRange()
Case "Save"
$iChkTrophyRange = GUICtrlRead($g_hChkTrophyRange) = $GUI_CHECKED ? 1 : 0
$itxtMaxTrophy = GUICtrlRead($g_hTxtMaxTrophy)
$itxtdropTrophy = GUICtrlRead($g_hTxtDropTrophy)
$iChkTrophyHeroes = GUICtrlRead($g_hChkTrophyHeroes) = $GUI_CHECKED ? 1 : 0
$iCmbTrophyHeroesPriority = _GUICtrlComboBox_GetCurSel($g_hCmbTrophyHeroesPriority)
$iChkTrophyAtkDead = GUICtrlRead($g_hChkTrophyAtkDead) = $GUI_CHECKED ? 1 : 0
$itxtDTArmyMin = GUICtrlRead($g_hTxtDropTrophyArmyMin)
EndSwitch
EndFunc
Func ApplyConfig_600_35($TypeReadSave)
Switch $TypeReadSave
Case "Read"
LoadLanguagesComboBox()
GUICtrlSetState($g_hChkDisableSplash, $ichkDisableSplash = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkForMBRUpdates, $ichkVersion = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkDeleteLogs, $ichkDeleteLogs = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtDeleteLogsDays, $iDeleteLogsDays)
chkDeleteLogs()
GUICtrlSetState($g_hChkDeleteTemp, $ichkDeleteTemp = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtDeleteTempDays, $iDeleteTempDays)
chkDeleteTemp()
GUICtrlSetState($g_hChkDeleteLoots, $ichkDeleteLoots = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtDeleteLootsDays, $iDeleteLootsDays)
chkDeleteLoots()
GUICtrlSetState($g_hChkAutostart, $ichkAutoStart = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtAutostartDelay, $ichkAutoStartDelay)
chkAutoStart()
GUICtrlSetState($g_hChkCheckGameLanguage, $ichkLanguage = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkAutoAlign, $iDisposeWindows = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
chkDisposeWindows()
_GUICtrlComboBox_SetCurSel($g_hCmbAlignmentOptions, $icmbDisposeWindowsPos)
GUICtrlSetData($g_hTxtAlignOffsetX, $iWAOffsetX)
GUICtrlSetData($g_hTxtAlignOffsetY, $iWAOffsetY)
GUICtrlSetState($g_hChkUpdatingWhenMinimized, $iUpdatingWhenMinimized = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkHideWhenMinimized, $iHideWhenMinimized = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
TrayItemSetState($g_hTiHide, $iHideWhenMinimized = 1 ? $TRAY_CHECKED : $TRAY_UNCHECKED)
GUICtrlSetState($g_hChkUseRandomClick, $iUseRandomClick = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkScreenshotType, $iScreenshotType = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkScreenshotHideName, $ichkScreenshotHideName = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtTimeAnotherDevice, Int(Int($sTimeWakeUp) / 60))
GUICtrlSetState($g_hChkSinglePBTForced, $ichkSinglePBTForced = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtSinglePBTimeForced, $iValueSinglePBTimeForced)
GUICtrlSetData($g_hTxtPBTimeForcedExit, $iValuePBTimeForcedExit)
chkSinglePBTForced()
GUICtrlSetState($g_hChkAutoResume, $iChkAutoResume = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtAutoResumeTime, $iAutoResumeTime)
GUICtrlSetState($g_hChkFixClanCastle, $ichkFixClanCastle = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
Case "Save"
$ichkDisableSplash = GUICtrlRead($g_hChkDisableSplash) = $GUI_CHECKED ? 1 : 0
$ichkVersion = GUICtrlRead($g_hChkForMBRUpdates) = $GUI_CHECKED ? 1 : 0
$ichkDeleteLogs = GUICtrlRead($g_hChkDeleteLogs) = $GUI_CHECKED ? 1 : 0
$iDeleteLogsDays = GUICtrlRead($g_hTxtDeleteLogsDays)
$ichkDeleteTemp = GUICtrlRead($g_hChkDeleteTemp) = $GUI_CHECKED ? 1 : 0
$iDeleteTempDays = GUICtrlRead($g_hTxtDeleteTempDays)
$ichkDeleteLoots = GUICtrlRead($g_hChkDeleteLoots) = $GUI_CHECKED ? 1 : 0
$iDeleteLootsDays = GUICtrlRead($g_hTxtDeleteLootsDays)
$ichkAutoStart = GUICtrlRead($g_hChkAutostart) = $GUI_CHECKED ? 1 : 0
$ichkAutoStartDelay = GUICtrlRead($g_hTxtAutostartDelay)
$ichkLanguage = GUICtrlRead($g_hChkCheckGameLanguage) = $GUI_CHECKED ? 1 : 0
$iDisposeWindows = GUICtrlRead($g_hChkAutoAlign) = $GUI_CHECKED ? 1 : 0
$icmbDisposeWindowsPos = _GUICtrlComboBox_GetCurSel($g_hCmbAlignmentOptions)
$iWAOffsetX = GUICtrlRead($g_hTxtAlignOffsetX)
$iWAOffsetY = GUICtrlRead($g_hTxtAlignOffsetY)
$iHideWhenMinimized = GUICtrlRead($g_hChkHideWhenMinimized) = $GUI_CHECKED ? 1 : 0
$iUseRandomClick = GUICtrlRead($g_hChkUseRandomClick) = $GUI_CHECKED ? 1 : 0
$iScreenshotType = GUICtrlRead($g_hChkScreenshotType) = $GUI_CHECKED ? 1 : 0
$ichkScreenshotHideName = GUICtrlRead($g_hChkScreenshotHideName) = $GUI_CHECKED ? 1 : 0
$sTimeWakeUp = Int(GUICtrlRead($g_hTxtTimeAnotherDevice)) * 60
$ichkSinglePBTForced = GUICtrlRead($g_hChkSinglePBTForced) = $GUI_CHECKED ? 1 : 0
$iValueSinglePBTimeForced = GUICtrlRead($g_hTxtSinglePBTimeForced)
$iValuePBTimeForcedExit = GUICtrlRead($g_hTxtPBTimeForcedExit)
$iChkAutoResume = GUICtrlRead($g_hChkAutoResume) = $GUI_CHECKED ? 1 : 0
$iAutoResumeTime = GUICtrlRead($g_hTxtAutoResumeTime)
$ichkFixClanCastle = GUICtrlRead($g_hChkFixClanCastle) = $GUI_CHECKED ? 1 : 0
EndSwitch
EndFunc
Func ApplyConfig_600_52_1($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkUseQuickTrain, $g_bQuickTrainEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hRdoArmy1, $g_iQuickTrainArmyNum = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hRdoArmy2, $g_iQuickTrainArmyNum = 2 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hRdoArmy3, $g_iQuickTrainArmyNum = 3 ? $GUI_CHECKED : $GUI_UNCHECKED)
Case "Save"
$g_bQuickTrainEnable =(GUICtrlRead($g_hChkUseQuickTrain) = $GUI_CHECKED)
If GUICtrlRead($g_hRdoArmy1) = $GUI_CHECKED Then
$g_iQuickTrainArmyNum = 1
ElseIf GUICtrlRead($g_hRdoArmy2) = $GUI_CHECKED Then
$g_iQuickTrainArmyNum = 2
ElseIf GUICtrlRead($g_hRdoArmy3) = $GUI_CHECKED Then
$g_iQuickTrainArmyNum = 3
EndIf
EndSwitch
EndFunc
Func ApplyConfig_600_52_2($TypeReadSave)
Switch $TypeReadSave
Case "Read"
For $T = 0 To $eTroopCount - 1
Local $iCurrLevel = $g_aiTrainArmyTroopLevel[$T]
Local $iCurrCount = $g_aiArmyCompTroops[$T]
Local $iMaxLevel = $g_aiTroopCostPerLevel[$T][0]
Local $iColor =($iCurrLevel = $iMaxLevel ? $COLOR_YELLOW : $COLOR_WHITE)
GUICtrlSetData($g_ahTxtTrainArmyTroopCount[$T],($iCurrCount <> 0 And $iCurrLevel <> 0) ? $iCurrCount : 0)
GUICtrlSetState($g_ahTxtTrainArmyTroopCount[$T], $iCurrLevel <> 0 ? $GUI_SHOW : $GUI_HIDE)
GUICtrlSetData($g_ahLblTrainArmyTroopLevel[$T], $iCurrLevel)
If GUICtrlGetBkColor($g_ahLblTrainArmyTroopLevel[$T]) <> $iColor Then GUICtrlSetBkColor($g_ahLblTrainArmyTroopLevel[$T], $iColor)
Next
For $S = 0 To $eSpellCount - 1
Local $iCurrLevel = $g_aiTrainArmySpellLevel[$S]
Local $iCurrCount = $g_aiArmyCompSpells[$S]
Local $iMaxLevel = $g_aiSpellCostPerLevel[$S][0]
Local $iColor =($iCurrLevel = $iMaxLevel ? $COLOR_YELLOW : $COLOR_WHITE)
GUICtrlSetData($g_ahTxtTrainArmySpellCount[$S],($iCurrCount <> 0 And $iCurrLevel <> 0) ? $iCurrCount : 0)
GUICtrlSetState($g_ahTxtTrainArmySpellCount[$S], $iCurrLevel <> 0 ? $GUI_SHOW : $GUI_HIDE)
GUICtrlSetData($g_ahLblTrainArmySpellLevel[$S], $iCurrLevel)
If GUICtrlGetBkColor($g_ahLblTrainArmySpellLevel[$S]) <> $iColor Then GUICtrlSetBkColor($g_ahLblTrainArmySpellLevel[$S], $iColor)
Next
GUICtrlSetData($g_hTxtFullTroop, $g_iTrainArmyFullTroopPct)
GUICtrlSetState($g_hChkTotalCampForced, $g_bTotalCampForced ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtTotalCampForced, $g_iTotalCampForcedValue)
GUICtrlSetData($g_hTxtTotalCountSpell, $g_iTotalSpellValue)
GUICtrlSetState($g_hChkForceBrewBeforeAttack, $g_bForceBrewSpells ? $GUI_CHECKED : $GUI_UNCHECKED)
Case "Save"
For $T = 0 To $eTroopCount - 1
$g_aiArmyCompTroops[$T] = GUICtrlRead($g_ahTxtTrainArmyTroopCount[$T])
$g_aiTrainArmyTroopLevel[$T] = GUICtrlRead($g_ahLblTrainArmyTroopLevel[$T])
Next
For $S = 0 To $eSpellCount - 1
$g_aiArmyCompSpells[$S] = GUICtrlRead($g_ahTxtTrainArmySpellCount[$S])
$g_aiTrainArmySpellLevel[$S] = GUICtrlRead($g_ahLblTrainArmySpellLevel[$S])
Next
$g_iTrainArmyFullTroopPct = Int(GUICtrlRead($g_hTxtFullTroop))
$g_bTotalCampForced =(GUICtrlRead($g_hChkTotalCampForced) = $GUI_CHECKED)
$g_iTotalCampForcedValue = Int(GUICtrlRead($g_hTxtTotalCampForced))
$g_iTotalSpellValue = GUICtrlRead($g_hTxtTotalCountSpell)
$g_bForceBrewSpells =(GUICtrlRead($g_hChkForceBrewBeforeAttack) = $GUI_CHECKED)
EndSwitch
EndFunc
Func ApplyConfig_600_54($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkCustomTrainOrderEnable, $g_bCustomTrainOrderEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
For $z = 0 To UBound($g_ahCmbTroopOrder) -1
_GUICtrlComboBox_SetCurSel($g_ahCmbTroopOrder[$z], $g_aiCmbCustomTrainOrder[$z])
GUICtrlSetImage($g_ahImgTroopOrder[$z], $g_sLibIconPath, $g_aiTroopOrderIcon[$g_aiCmbCustomTrainOrder[$z]+1])
Next
If $g_bCustomTrainOrderEnable = True Then
If ChangeTroopTrainOrder() = False Then
SetDefaultTroopGroup()
GUICtrlSetState($g_hChkCustomTrainOrderEnable, $GUI_UNCHECKED)
$g_bCustomTrainOrderEnable = False
GUICtrlSetState($g_hBtnTroopOrderSet, $GUI_DISABLE)
For $i = 0 To UBound($g_ahCmbTroopOrder) - 1
GUICtrlSetState($g_ahCmbTroopOrder[$i], $GUI_DISABLE)
Next
EndIf
EndIf
chkTotalCampForced()
chkUseQTrain()
SetComboTroopComp()
Case "Save"
$g_bCustomTrainOrderEnable =(GUICtrlRead($g_hChkCustomTrainOrderEnable) = $GUI_CHECKED)
For $z = 0 To UBound($g_ahCmbTroopOrder) -1
$g_aiCmbCustomTrainOrder[$z] = _GUICtrlComboBox_GetCurSel($g_ahCmbTroopOrder[$z])
Next
EndSwitch
EndFunc
Func ApplyConfig_600_56($TypeReadSave)
Switch $TypeReadSave
Case "Read"
GUICtrlSetState($g_hChkSmartLightSpell, $ichkSmartZap = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkSmartEQSpell, $ichkEarthQuakeZap = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkNoobZap, $ichkNoobZap = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkSmartZapDB, $ichkSmartZapDB = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkSmartZapSaveHeroes, $ichkSmartZapSaveHeroes = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtSmartMinDark, $itxtMinDE)
GUICtrlSetData($g_hTxtSmartExpectedDE, $itxtExpectedDE)
GUICtrlSetState($g_hChkDebugSmartZap, $DebugSmartZap = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
chkSmartLightSpell()
Case "Save"
$ichkSmartZap = GUICtrlRead($g_hChkSmartLightSpell) = $GUI_CHECKED ? 1 : 0
$ichkEarthQuakeZap = GUICtrlRead($g_hChkSmartEQSpell) = $GUI_CHECKED ? 1 : 0
$ichkNoobZap = GUICtrlRead($g_hChkNoobZap) = $GUI_CHECKED ? 1 : 0
$ichkSmartZapDB = GUICtrlRead($g_hChkSmartZapDB) = $GUI_CHECKED ? 1 : 0
$ichkSmartZapSaveHeroes = GUICtrlRead($g_hChkSmartZapSaveHeroes) = $GUI_CHECKED ? 1 : 0
$itxtMinDE = GUICtrlRead($g_hTxtSmartMinDark)
$itxtExpectedDE = GUICtrlRead($g_hTxtSmartExpectedDE)
$DebugSmartZap = GUICtrlRead($g_hChkDebugSmartZap) = $GUI_CHECKED ? 1 : 0
EndSwitch
EndFunc
Func ApplyConfig_641_1($TypeReadSave)
Switch $TypeReadSave
Case "Read"
If $g_bCloseWhileTrainingEnable = True Then
GUICtrlSetState($g_hChkCloseWhileTraining, $GUI_CHECKED)
_GUI_Value_STATE("ENABLE", $groupCloseWhileTraining)
GUICtrlSetState($g_hLblCloseWaitingTroops, $GUI_ENABLE)
GUICtrlSetState($g_hCmbMinimumTimeClose, $GUI_ENABLE)
GUICtrlSetState($g_hLblSymbolWaiting, $GUI_ENABLE)
GUICtrlSetState($g_hLblWaitingInMinutes, $GUI_ENABLE)
Else
GUICtrlSetState($g_hChkCloseWhileTraining, $GUI_UNCHECKED)
_GUI_Value_STATE("DISABLE", $groupCloseWhileTraining)
GUICtrlSetState($g_hLblCloseWaitingTroops, $GUI_DISABLE)
GUICtrlSetState($g_hCmbMinimumTimeClose, $GUI_DISABLE)
GUICtrlSetState($g_hLblSymbolWaiting, $GUI_DISABLE)
GUICtrlSetState($g_hLblWaitingInMinutes, $GUI_DISABLE)
EndIf
GUICtrlSetState($g_hChkCloseWithoutShield, $g_bCloseWithoutShield ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkCloseEmulator, $g_bCloseEmulator ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($g_hChkRandomClose, $g_bCloseRandom ? $GUI_CHECKED : $GUI_UNCHECKED)
btnCloseWaitStopRandom()
If $g_bCloseExactTime = True Then
GUICtrlSetState($g_hRdoCloseWaitExact, $GUI_CHECKED)
GUICtrlSetState($g_hRdoCloseWaitRandom, $GUI_UNCHECKED)
EndIf
If $g_bCloseRandomTime = True Then
GUICtrlSetState($g_hRdoCloseWaitRandom, $GUI_CHECKED)
GUICtrlSetState($g_hRdoCloseWaitExact, $GUI_UNCHECKED)
EndIf
_GUICtrlComboBox_SetCurSel($g_hCmbCloseWaitRdmPercent, $g_iCloseRandomTimePercent)
btnCloseWaitRandom()
GUICtrlSetData($g_hCmbMinimumTimeClose, $g_iCloseMinimumTime)
GUICtrlSetData($g_hSldTrainITDelay, $g_iTrainClickDelay)
sldTrainITDelay()
GUICtrlSetData($g_hLblTrainITDelayTime, $g_iTrainClickDelay & " ms")
GUICtrlSetState($g_hChkTrainAddRandomDelayEnable, $g_bTrainAddRandomDelayEnable ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($g_hTxtAddRandomDelayMin, $g_iTrainAddRandomDelayMin)
GUICtrlSetData($g_hTxtAddRandomDelayMax, $g_iTrainAddRandomDelayMax)
chkAddDelayIdlePhaseEnable()
Case "Save"
$g_bCloseWhileTrainingEnable =(GUICtrlRead($g_hChkCloseWhileTraining) = $GUI_CHECKED)
$g_bCloseWithoutShield =(GUICtrlRead($g_hChkCloseWithoutShield) = $GUI_CHECKED)
$g_bCloseEmulator =(GUICtrlRead($g_hChkCloseEmulator) = $GUI_CHECKED)
$g_bCloseRandom =(GUICtrlRead($g_hChkRandomClose) = $GUI_CHECKED)
$g_bCloseExactTime =(GUICtrlRead($g_hRdoCloseWaitExact) = $GUI_CHECKED)
$g_bCloseRandomTime =(GUICtrlRead($g_hRdoCloseWaitRandom) = $GUI_CHECKED)
$g_iCloseRandomTimePercent = _GUICtrlComboBox_GetCurSel($g_hCmbCloseWaitRdmPercent)
$g_iCloseMinimumTime = GUICtrlRead($g_hCmbMinimumTimeClose)
$g_iTrainClickDelay = GUICtrlRead($g_hSldTrainITDelay)
$g_bTrainAddRandomDelayEnable =(GUICtrlRead($g_hChkTrainAddRandomDelayEnable) = $GUI_CHECKED)
$g_iTrainAddRandomDelayMin = GUICtrlRead($g_hTxtAddRandomDelayMin)
$g_iTrainAddRandomDelayMax = GUICtrlRead($g_hTxtAddRandomDelayMax)
EndSwitch
EndFunc
Func readConfig($inputfile = $g_sProfileConfigPath)
Static $iReadConfigCount = 0
$iReadConfigCount += 1
SetDebugLog("readConfig(), call number " & $iReadConfigCount)
$aWeakBaseStats = readWeakBaseStats()
If FileExists($g_sProfileBuildingPath) Then ReadBuildingConfig()
If FileExists($g_sProfileConfigPath) Then ReadRegularConfig()
EndFunc
Func ReadBuildingConfig()
SetDebugLog("Read Building Config " & $g_sProfileBuildingPath)
Local $locationsInvalid = False
Local $buildingVersion = "0.0.0"
IniReadS($buildingVersion, $g_sProfileBuildingPath, "general", "version", $buildingVersion)
Local $_ver630 = GetVersionNormalized("6.3.0")
Local $_ver63u = GetVersionNormalized("6.3.u")
Local $_ver63u3 = GetVersionNormalized("6.3.u3")
If $buildingVersion < $_ver630 Or($buildingVersion >= $_ver63u And $buildingVersion <= $_ver63u3) Then
SetLog("New MyBot.run version! Re-locate all buildings!", $COLOR_WARNING)
$locationsInvalid = True
EndIf
IniReadS($iTownHallLevel, $g_sProfileBuildingPath, "other", "LevelTownHall", 0, "int")
If $locationsInvalid = False Then
IniReadS($TownHallPos[0], $g_sProfileBuildingPath, "other", "xTownHall", -1, "int")
IniReadS($TownHallPos[1], $g_sProfileBuildingPath, "other", "yTownHall", -1, "int")
IniReadS($aCCPos[0], $g_sProfileBuildingPath, "other", "xCCPos", -1, "int")
IniReadS($aCCPos[1], $g_sProfileBuildingPath, "other", "yCCPos", -1, "int")
IniReadS($KingAltarPos[0], $g_sProfileBuildingPath, "other", "xKingAltarPos", -1, "int")
IniReadS($KingAltarPos[1], $g_sProfileBuildingPath, "other", "yKingAltarPos", -1, "int")
IniReadS($QueenAltarPos[0], $g_sProfileBuildingPath, "other", "xQueenAltarPos", -1, "int")
IniReadS($QueenAltarPos[1], $g_sProfileBuildingPath, "other", "yQueenAltarPos", -1, "int")
IniReadS($WardenAltarPos[0], $g_sProfileBuildingPath, "other", "xWardenAltarPos", -1, "int")
IniReadS($WardenAltarPos[1], $g_sProfileBuildingPath, "other", "yWardenAltarPos", -1, "int")
IniReadS($aLabPos[0], $g_sProfileBuildingPath, "upgrade", "LabPosX", -1, "int")
IniReadS($aLabPos[1], $g_sProfileBuildingPath, "upgrade", "LabPosY", -1, "int")
EndIf
IniReadS($TotalCamp, $g_sProfileBuildingPath, "other", "totalcamp", 0, "int")
For $iz = 0 To UBound($g_avBuildingUpgrades, 1) - 1
$g_avBuildingUpgrades[$iz][0] = IniRead($g_sProfileBuildingPath, "upgrade", "xupgrade" & $iz, "-1")
$g_avBuildingUpgrades[$iz][1] = IniRead($g_sProfileBuildingPath, "upgrade", "yupgrade" & $iz, "-1")
$g_avBuildingUpgrades[$iz][2] = IniRead($g_sProfileBuildingPath, "upgrade", "upgradevalue" & $iz, "-1")
$g_avBuildingUpgrades[$iz][3] = IniRead($g_sProfileBuildingPath, "upgrade", "upgradetype" & $iz, "")
$g_avBuildingUpgrades[$iz][4] = IniRead($g_sProfileBuildingPath, "upgrade", "upgradename" & $iz, "")
$g_avBuildingUpgrades[$iz][5] = IniRead($g_sProfileBuildingPath, "upgrade", "upgradelevel" & $iz, "")
$g_avBuildingUpgrades[$iz][6] = IniRead($g_sProfileBuildingPath, "upgrade", "upgradetime" & $iz, "")
$g_avBuildingUpgrades[$iz][7] = IniRead($g_sProfileBuildingPath, "upgrade", "upgradeend" & $iz, "-1")
$g_abBuildingUpgradeEnable[$iz] =(IniRead($g_sProfileBuildingPath, "upgrade", "upgradechk" & $iz, 0) = "1")
$g_abUpgradeRepeatEnable[$iz] =(IniRead($g_sProfileBuildingPath, "upgrade", "upgraderepeat" & $iz, 0) = "1")
$g_aiPicUpgradeStatus[$iz] = IniRead($g_sProfileBuildingPath, "upgrade", "upgradestatusicon" & $iz, $eIcnTroops)
If $locationsInvalid = True Then
$g_avBuildingUpgrades[$iz][0] = -1
$g_avBuildingUpgrades[$iz][1] = -1
$g_abBuildingUpgradeEnable[$iz] = False
$g_abUpgradeRepeatEnable[$iz] = False
EndIf
Next
EndFunc
Func ReadRegularConfig()
SetDebugLog("Read Config " & $g_sProfileConfigPath)
IniReadS($g_iThreads, $g_sProfileConfigPath, "general", "threads", $g_iThreads, "int")
IniReadS($iChkEnableAfter[$DB], $g_sProfileConfigPath, "search", "DBEnableAfter", 0, "int")
IniReadS($iChkEnableAfter[$LB], $g_sProfileConfigPath, "search", "ABEnableAfter", 0, "int")
IniReadS($frmBotPosX, $g_sProfileConfigPath, "general", "frmBotPosX", -1, "int")
IniReadS($frmBotPosY, $g_sProfileConfigPath, "general", "frmBotPosY", -1, "int")
If $frmBotPosX < -30000 Or $frmBotPosY < -30000 Then
$frmBotPosX = -1
$frmBotPosY = -1
EndIf
IniReadS($AndroidPosX, $g_sProfileConfigPath, "general", "AndroidPosX", -1, "int")
IniReadS($AndroidPosY, $g_sProfileConfigPath, "general", "AndroidPosY", -1, "int")
If $AndroidPosX < -30000 Or $AndroidPosY < -30000 Then
$AndroidPosX = -1
$AndroidPosY = -1
EndIf
IniReadS($frmBotDockedPosX, $g_sProfileConfigPath, "general", "frmBotDockedPosX", -1, "int")
IniReadS($frmBotDockedPosY, $g_sProfileConfigPath, "general", "frmBotDockedPosY", -1, "int")
If $frmBotDockedPosX < -30000 Or $frmBotDockedPosY < -30000 Then
$frmBotDockedPosX = -1
$frmBotDockedPosY = -1
EndIf
IniReadS($g_iRedrawBotWindowMode, $g_sProfileConfigPath, "general", "RedrawBotWindowMode", 2, "int")
ReadConfig_Android()
ReadConfig_Debug()
ReadConfig_600_1()
ReadConfig_600_6()
ReadConfig_600_9()
ReadConfig_600_11()
ReadConfig_600_12()
ReadConfig_600_13()
ReadConfig_600_14()
ReadConfig_600_15()
ReadConfig_600_16()
ReadConfig_600_17()
ReadConfig_600_18()
ReadConfig_600_19()
ReadConfig_600_22()
ReadConfig_600_26()
ReadConfig_600_28()
ReadConfig_600_28_DB()
ReadConfig_600_28_LB()
ReadConfig_600_28_TS()
ReadConfig_600_29()
ReadConfig_600_29_DB()
ReadConfig_600_29_LB()
ReadConfig_600_29_TS()
ReadConfig_600_30()
ReadConfig_600_30_DB()
ReadConfig_600_30_LB()
ReadConfig_600_30_TS()
ReadConfig_600_31()
ReadConfig_600_32()
ReadConfig_600_35()
ReadConfig_600_52_1()
ReadConfig_600_52_2()
ReadConfig_600_54()
ReadConfig_600_56()
ReadConfig_641_1()
ReadConfig_DocOc()
EndFunc
Func ReadConfig_Debug()
$g_iDebugClick = BitOR($g_iDebugClick, Int(IniRead($g_sProfileConfigPath, "debug", "debugsetclick", 0)))
If $g_bDevMode = True Then
$g_iDebugSetlog = BitOR($g_iDebugSetlog, Int(IniRead($g_sProfileConfigPath, "debug", "debugsetlog", 0)))
$g_iDebugDisableZoomout = BitOR($g_iDebugDisableZoomout, Int(IniRead($g_sProfileConfigPath, "debug", "disablezoomout", 0)))
$g_iDebugDisableVillageCentering = BitOR($g_iDebugDisableVillageCentering, Int(IniRead($g_sProfileConfigPath, "debug", "disablevillagecentering", 0)))
$g_iDebugDeadBaseImage = BitOR($g_iDebugDeadBaseImage, Int(IniRead($g_sProfileConfigPath, "debug", "debugdeadbaseimage", 0)))
$g_iDebugOcr = BitOR($g_iDebugOcr, Int(IniRead($g_sProfileConfigPath, "debug", "debugocr", 0)))
$g_iDebugImageSave = BitOR($g_iDebugImageSave, Int(IniRead($g_sProfileConfigPath, "debug", "debugimagesave", 0)))
$g_iDebugBuildingPos = BitOR($g_iDebugBuildingPos, Int(IniRead($g_sProfileConfigPath, "debug", "debugbuildingpos", 0)))
$g_iDebugSetlogTrain = BitOR($g_iDebugSetlogTrain, Int(IniRead($g_sProfileConfigPath, "debug", "debugtrain", 0)))
$g_iDebugResourcesOffset = BitOR($g_iDebugResourcesOffset, Int(IniRead($g_sProfileConfigPath, "debug", "debugresourcesoffset", 0)))
$g_iDebugContinueSearchElixir = BitOR($g_iDebugContinueSearchElixir, Int(IniRead($g_sProfileConfigPath, "debug", "continuesearchelixirdebug", 0)))
$g_iDebugMilkingIMGmake = BitOR($g_iDebugMilkingIMGmake, Int(IniRead($g_sProfileConfigPath, "debug", "debugMilkingIMGmake", 0)))
$g_iDebugOCRdonate = BitOR($g_iDebugOCRdonate, Int(IniRead($g_sProfileConfigPath, "debug", "debugOCRDonate", 0)))
$g_iDebugAttackCSV = BitOR($g_iDebugAttackCSV, Int(IniRead($g_sProfileConfigPath, "debug", "debugAttackCSV", 0)))
$g_iDebugMakeIMGCSV = BitOR($g_iDebugMakeIMGCSV, Int(IniRead($g_sProfileConfigPath, "debug", "debugmakeimgcsv", 0)))
EndIf
EndFunc
Func ReadConfig_Android()
$g_sAndroidGameDistributor = IniRead($g_sProfileConfigPath, "android", "game.distributor", $g_sAndroidGameDistributor)
$g_sAndroidGamePackage = IniRead($g_sProfileConfigPath, "android", "game.package", $g_sAndroidGamePackage)
$g_sAndroidGameClass = IniRead($g_sProfileConfigPath, "android", "game.class", $g_sAndroidGameClass)
$g_sUserGameDistributor = IniRead($g_sProfileConfigPath, "android", "user.distributor", $g_sUserGameDistributor)
$g_sUserGamePackage = IniRead($g_sProfileConfigPath, "android", "user.package", $g_sUserGamePackage)
$g_sUserGameClass = IniRead($g_sProfileConfigPath, "android", "user.class", $g_sUserGameClass)
$g_bAndroidCheckTimeLagEnabled = Int(IniRead($g_sProfileConfigPath, "android", "check.time.lag.enabled",($g_bAndroidCheckTimeLagEnabled ? 1 : 0))) = 1
$g_iAndroidAdbScreencapTimeoutMin = Int(IniRead($g_sProfileConfigPath, "android", "adb.screencap.timeout.min", $g_iAndroidAdbScreencapTimeoutMin))
$g_iAndroidAdbScreencapTimeoutMax = Int(IniRead($g_sProfileConfigPath, "android", "adb.screencap.timeout.max", $g_iAndroidAdbScreencapTimeoutMax))
$g_iAndroidAdbScreencapTimeoutDynamic = Int(IniRead($g_sProfileConfigPath, "android", "adb.screencap.timeout.dynamic", $g_iAndroidAdbScreencapTimeoutDynamic))
$g_bAndroidAdbInputEnabled = Int(IniRead($g_sProfileConfigPath, "android", "adb.input.enabled",($g_bAndroidAdbInputEnabled ? 1 : 0))) = 1
$g_bAndroidAdbClickEnabled = Int(IniRead($g_sProfileConfigPath, "android", "adb.click.enabled",($g_bAndroidAdbClickEnabled ? 1 : 0))) = 1
$g_iAndroidAdbClickGroup = Int(IniRead($g_sProfileConfigPath, "android", "adb.click.group", $g_iAndroidAdbClickGroup))
$g_bAndroidAdbClicksEnabled = Int(IniRead($g_sProfileConfigPath, "android", "adb.clicks.enabled",($g_bAndroidAdbClicksEnabled ? 1 : 0))) = 1
$g_iAndroidAdbClicksTroopDeploySize = Int(IniRead($g_sProfileConfigPath, "android", "adb.clicks.troop.deploy.size", $g_iAndroidAdbClicksTroopDeploySize))
$g_bNoFocusTampering = Int(IniRead($g_sProfileConfigPath, "android", "no.focus.tampering",($g_bNoFocusTampering ? 1 : 0))) = 1
$g_iAndroidShieldColor = Dec(IniRead($g_sProfileConfigPath, "android", "shield.color", Hex($g_iAndroidShieldColor, 6)))
$g_iAndroidShieldTransparency = Int(IniRead($g_sProfileConfigPath, "android", "shield.transparency", $g_iAndroidShieldTransparency))
$g_iAndroidActiveColor = Dec(IniRead($g_sProfileConfigPath, "android", "active.color", Hex($g_iAndroidActiveColor, 6)))
$g_iAndroidActiveTransparency = Int(IniRead($g_sProfileConfigPath, "android", "active.transparency", $g_iAndroidActiveTransparency))
$g_iAndroidInactiveColor = Dec(IniRead($g_sProfileConfigPath, "android", "inactive.color", Hex($g_iAndroidInactiveColor, 6)))
$g_iAndroidInactiveTransparency = Int(IniRead($g_sProfileConfigPath, "android", "inactive.transparency", $g_iAndroidInactiveTransparency))
If $g_bBotLaunchOption_Restart = True Then
Local $sAndroidEmulator = IniRead($g_sProfileConfigPath, "android", "emulator", "")
Local $sAndroidInstance = IniRead($g_sProfileConfigPath, "android", "instance", "")
If $sAndroidEmulator <> "" Then
If $sAndroidEmulator <> $g_sAndroidEmulator Or $sAndroidInstance <> $g_sAndroidInstance Then
UpdateHWnD(0)
UpdateAndroidConfig($sAndroidInstance, $sAndroidEmulator)
EndIf
Else
$g_bBotLaunchOption_Restart = False
EndIf
EndIf
EndFunc
Func ReadConfig_600_1()
IniReadS($g_iCmbLogDividerOption, $g_sProfileConfigPath, "general", "logstyle", 0, "int")
IniReadS($g_iLogDividerY, $g_sProfileConfigPath, "general", "LogDividerY", 243, "int")
IniReadS($g_bChkBackgroundMode, $g_sProfileConfigPath, "general", "Background", True, "Bool")
EndFunc
Func ReadConfig_600_6()
IniReadS($g_bChkBotStop, $g_sProfileConfigPath, "general", "BotStop", False, "Bool")
IniReadS($g_iCmbBotCommand, $g_sProfileConfigPath, "general", "Command", 0, "int")
IniReadS($g_iCmbBotCond, $g_sProfileConfigPath, "general", "Cond", 0, "int")
IniReadS($g_iCmbHoursStop, $g_sProfileConfigPath, "general", "Hour", 0, "int")
IniReadS($g_iTxtRestartGold, $g_sProfileConfigPath, "other", "minrestartgold", 50000, "int")
IniReadS($g_iTxtRestartElixir, $g_sProfileConfigPath, "other", "minrestartelixir", 50000, "int")
IniReadS($g_iTxtRestartDark, $g_sProfileConfigPath, "other", "minrestartdark", 500, "int")
IniReadS($g_bChkTrap, $g_sProfileConfigPath, "other", "chkTrap", True, "Bool")
IniReadS($g_bChkCollect, $g_sProfileConfigPath, "other", "chkCollect", True, "Bool")
IniReadS($g_bChkTombstones, $g_sProfileConfigPath, "other", "chkTombstones", True, "Bool")
IniReadS($g_bChkCleanYard, $g_sProfileConfigPath, "other", "chkCleanYard", False, "Bool")
IniReadS($g_bChkGemsBox, $g_sProfileConfigPath, "other", "chkGemsBox", False, "Bool")
EndFunc
Func ReadConfig_600_9()
IniReadS($g_iUnbrkMode, $g_sProfileConfigPath, "Unbreakable", "chkUnbreakable", 0, "int")
IniReadS($g_iUnbrkWait, $g_sProfileConfigPath, "Unbreakable", "UnbreakableWait", 5, "int")
IniReadS($g_iUnbrkMinGold, $g_sProfileConfigPath, "Unbreakable", "minUnBrkgold", 50000, "int")
IniReadS($g_iUnbrkMaxGold, $g_sProfileConfigPath, "Unbreakable", "maxUnBrkgold", 600000, "int")
IniReadS($g_iUnbrkMinElixir, $g_sProfileConfigPath, "Unbreakable", "minUnBrkelixir", 50000, "int")
IniReadS($g_iUnbrkMaxElixir, $g_sProfileConfigPath, "Unbreakable", "maxUnBrkelixir", 600000, "int")
IniReadS($g_iUnbrkMinDark, $g_sProfileConfigPath, "Unbreakable", "minUnBrkdark", 5000, "int")
IniReadS($g_iUnbrkMaxDark, $g_sProfileConfigPath, "Unbreakable", "maxUnBrkdark", 10000, "int")
EndFunc
Func ReadConfig_600_11()
$g_bRequestTroopsEnable =(IniRead($g_sProfileConfigPath, "planned", "RequestHoursEnable", 0) = "1")
$g_sRequestTroopsText = IniRead($g_sProfileConfigPath, "donate", "txtRequest", "")
$g_abRequestCCHours = StringSplit(IniRead($g_sProfileConfigPath, "planned", "RequestHours", "1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1"), "|", $STR_NOCOUNT)
For $i = 0 To 23
$g_abRequestCCHours[$i] =($g_abRequestCCHours[$i] = "1")
Next
EndFunc
Func ReadConfig_600_12()
$g_bChkDonate =(IniRead($g_sProfileConfigPath, "donate", "Doncheck", "1") = "1")
For $i = 0 To $eTroopCount-1 + $g_iCustomDonateConfigs
Local $sIniName = ""
If $i >= $eTroopBarbarian And $i <= $eTroopBowler Then
$sIniName = StringReplace($g_asTroopNamesPlural[$i], " ", "")
ElseIf $i = $eCustomA Then
$sIniName = "CustomA"
ElseIf $i = $eCustomB Then
$sIniName = "CustomB"
EndIf
$g_abChkDonateTroop[$i] =(IniRead($g_sProfileConfigPath, "donate", "chkDonate" & $sIniName, "0") = "1")
$g_abChkDonateAllTroop[$i] =(IniRead($g_sProfileConfigPath, "donate", "chkDonateAll" & $sIniName, "0") = "1")
Next
$g_asTxtDonateTroop[$eTroopBarbarian] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateBarbarians", "barbarians|barbarian|barb"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopBarbarian] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistBarbarians", "no barbarians|no barb|barbarian no|barb no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopArcher] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateArchers", "archers|archer|arch"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopArcher] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistArchers", "no archers|no arch|archer no|arch no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopGiant] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateGiants", "giants|giant|any"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopGiant] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistGiants", "no giants|giants no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopGoblin] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateGoblins", "goblins|goblin"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopGoblin] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistGoblins", "no goblins|goblins no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopWallBreaker] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateWallBreakers", "wall breakers|wb"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopWallBreaker] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistWallBreakers", "no wallbreakers|wb no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopBalloon] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateBalloons", "balloons|balloon"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopBalloon] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistBalloons", "no balloon|balloons no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopWizard] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateWizards", "wizards|wizard|wiz"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopWizard] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistWizards", "no wizards|wizards no|no wizard|wizard no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopHealer] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateHealers", "healer"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopHealer] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistHealers", "no healer|healer no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopDragon] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateDragons", "dragon"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopDragon] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistDragons", "no dragon|dragon no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopPekka] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonatePekkas", "PEKKA|pekka"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopPekka] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistPekkas", "no PEKKA|pekka no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopBabyDragon] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateBabyDragons", "baby dragon|baby"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopBabyDragon] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistBabyDragons", "no baby dragon|baby dragon no|no baby|baby no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopMiner] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateMiners", "miner|mine"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopMiner] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistMiners", "no miner|miner no|no mine|mine no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopMinion] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateMinions", "minions|minion"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopMinion] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistMinions", "no minion|minions no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopHogRider] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateHogRiders", "hogriders|hogs|hog"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopHogRider] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistHogRiders", "no hogriders|hogriders no|no hog|hogs no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopValkyrie] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateValkyries", "valkyries|valkyrie|valk"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopValkyrie] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistValkyries", "no valkyrie|valkyries no|no valk|valk no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopGolem] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateGolems", "golem"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopGolem] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistGolems", "no golem|golem no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopWitch] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateWitches", "witches|witch"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopWitch] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistWitches", "no witches|witches no|no witch|witch no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopLavaHound] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateLavaHounds", "lavahounds|lava|hound"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopLavaHound] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistLavaHounds", "no lavahound|lavahound no|no lava|lava no|nohound|hound no"), "|", @CRLF)
$g_asTxtDonateTroop[$eTroopBowler] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateBowlers", "bowler|bowl"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eTroopBowler] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistBowlers", "no bowler|bowl no"), "|", @CRLF)
$g_asTxtDonateTroop[$eCustomA] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomA", "ground support|ground"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eCustomA] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistCustomA", "no ground|ground no|nonly"), "|", @CRLF)
$g_asTxtDonateTroop[$eCustomB] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomB", "air support|any air"), "|", @CRLF)
$g_asTxtBlacklistTroop[$eCustomB] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistCustomB", "no air|air no|only|just"), "|", @CRLF)
For $i = 0 To $eSpellCount - 1
If $i <> $eSpellClone Then
Local $sIniName = $g_asSpellNames[$i] & "Spells"
$g_abChkDonateSpell[$i] =(IniRead($g_sProfileConfigPath, "donate", "chkDonate" & $sIniName, "0") = "1")
$g_abChkDonateAllSpell[$i] =(IniRead($g_sProfileConfigPath, "donate", "chkDonateAll" & $sIniName, "0") = "1")
EndIf
Next
$g_asTxtDonateSpell[$eSpellLightning] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateLightningSpells", "lightning"), "|", @CRLF)
$g_asTxtBlacklistSpell[$eSpellLightning] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistLightningSpells", "no lightning|lightning no"), "|", @CRLF)
$g_asTxtDonateSpell[$eSpellHeal] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateHealSpells", "heal"), "|", @CRLF)
$g_asTxtBlacklistSpell[$eSpellHeal] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistHealSpells", "no heal|heal no"), "|", @CRLF)
$g_asTxtDonateSpell[$eSpellRage] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateRageSpells", "rage"), "|", @CRLF)
$g_asTxtBlacklistSpell[$eSpellRage] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistRageSpells", "no rage|rage no"), "|", @CRLF)
$g_asTxtDonateSpell[$eSpellJump] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateJumpSpells", "jump"), "|", @CRLF)
$g_asTxtBlacklistSpell[$eSpellJump] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistJumpSpells", "no jump|jump no"), "|", @CRLF)
$g_asTxtDonateSpell[$eSpellFreeze] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateFreezeSpells", "freeze"), "|", @CRLF)
$g_asTxtBlacklistSpell[$eSpellFreeze] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistFreezeSpells", "no freeze|freeze no"), "|", @CRLF)
$g_asTxtDonateSpell[$eSpellPoison] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonatePoisonSpells", "poison"), "|", @CRLF)
$g_asTxtBlacklistSpell[$eSpellPoison] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistPoisonSpells", "no poison|poison no"), "|", @CRLF)
$g_asTxtDonateSpell[$eSpellEarthquake] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateEarthQuakeSpells", "earthquake|quake"), "|", @CRLF)
$g_asTxtBlacklistSpell[$eSpellEarthquake] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistEarthQuakeSpells", "no earthquake|quake no"), "|", @CRLF)
$g_asTxtDonateSpell[$eSpellHaste] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateHasteSpells", "haste"), "|", @CRLF)
$g_asTxtBlacklistSpell[$eSpellHaste] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistHasteSpells", "no haste|haste no"), "|", @CRLF)
$g_asTxtDonateSpell[$eSpellSkeleton] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtDonateSkeletonSpells", "skeleton"), "|", @CRLF)
$g_asTxtBlacklistSpell[$eSpellSkeleton] = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklistSkeletonSpells", "no skeleton|skeleton no"), "|", @CRLF)
$g_aiDonateCustomTrpNumA[0][0] = Int(IniRead($g_sProfileConfigPath, "donate", "cmbDonateCustomA1", 6))
$g_aiDonateCustomTrpNumA[1][0] = Int(IniRead($g_sProfileConfigPath, "donate", "cmbDonateCustomA2", 1))
$g_aiDonateCustomTrpNumA[2][0] = Int(IniRead($g_sProfileConfigPath, "donate", "cmbDonateCustomA3", 0))
$g_aiDonateCustomTrpNumA[0][1] = Int(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomA1", 2))
$g_aiDonateCustomTrpNumA[1][1] = Int(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomA2", 3))
$g_aiDonateCustomTrpNumA[2][1] = Int(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomA3", 1))
$g_aiDonateCustomTrpNumB[0][0] = Int(IniRead($g_sProfileConfigPath, "donate", "cmbDonateCustomB1", 11))
$g_aiDonateCustomTrpNumB[1][0] = Int(IniRead($g_sProfileConfigPath, "donate", "cmbDonateCustomB2", 1))
$g_aiDonateCustomTrpNumB[2][0] = Int(IniRead($g_sProfileConfigPath, "donate", "cmbDonateCustomB3", 6))
$g_aiDonateCustomTrpNumB[0][1] = Int(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomB1", 3))
$g_aiDonateCustomTrpNumB[1][1] = Int(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomB2", 13))
$g_aiDonateCustomTrpNumB[2][1] = Int(IniRead($g_sProfileConfigPath, "donate", "txtDonateCustomB3", 5))
$g_bChkExtraAlphabets =(IniRead($g_sProfileConfigPath, "donate", "chkExtraAlphabets", "0") = "1")
$g_bChkExtraChinese =(IniRead($g_sProfileConfigPath, "donate", "chkExtraChinese", "0") = "1")
$g_bChkExtraKorean =(IniRead($g_sProfileConfigPath, "donate", "chkExtraKorean", "0") = "1")
$g_sTxtGeneralBlacklist = StringReplace(IniRead($g_sProfileConfigPath, "donate", "txtBlacklist", "clan war|war|cw"), "|", @CRLF)
EndFunc
Func ReadConfig_600_13()
$g_bDonateHoursEnable =(IniRead($g_sProfileConfigPath, "planned", "DonateHoursEnable", "0") = "1")
$g_abDonateHours = StringSplit(IniRead($g_sProfileConfigPath, "planned", "DonateHours", "1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1"), "|", $STR_NOCOUNT)
For $i = 0 To 23
$g_abDonateHours[$i] =($g_abDonateHours[$i] = "1")
Next
$g_iCmbDonateFilter = Int(IniRead($g_sProfileConfigPath, "donate", "cmbFilterDonationsCC", 0))
$g_iDonateSkipNearFullPercent = Int(IniRead($g_sProfileConfigPath, "donate", "SkipDonateNearFulLTroopsPercentual", 90))
$g_bDonateSkipNearFullEnable =(IniRead($g_sProfileConfigPath, "donate", "SkipDonateNearFulLTroopsEnable", "1") = "1")
EndFunc
Func ReadConfig_600_14()
InireadS($g_bAutoLabUpgradeEnable, $g_sProfileBuildingPath, "upgrade", "upgradetroops", False, "Bool")
InireadS($g_iCmbLaboratory, $g_sProfileBuildingPath, "upgrade", "upgradetroopname", 0, "int")
$sLabUpgradeTime = IniRead($g_sProfileBuildingPath, "upgrade", "upgradelabtime", "")
EndFunc
Func ReadConfig_600_15()
IniReadS($g_bUpgradeKingEnable, $g_sProfileConfigPath, "upgrade", "UpgradeKing", False, "Bool")
IniReadS($g_bUpgradeQueenEnable, $g_sProfileConfigPath, "upgrade", "UpgradeQueen", False, "Bool")
IniReadS($g_bUpgradeWardenEnable, $g_sProfileConfigPath, "upgrade", "UpgradeWarden", False, "Bool")
EndFunc
Func ReadConfig_600_16()
IniReadS($g_iUpgradeMinGold, $g_sProfileConfigPath, "upgrade", "minupgrgold", 100000, "int")
IniReadS($g_iUpgradeMinElixir, $g_sProfileConfigPath, "upgrade", "minupgrelixir", 100000, "int")
IniReadS($g_iUpgradeMinDark, $g_sProfileConfigPath, "upgrade", "minupgrdark", 2000, "int")
EndFunc
Func ReadConfig_600_17()
IniReadS($g_bAutoUpgradeWallsEnable, $g_sProfileConfigPath, "upgrade", "auto-wall", False, "Bool")
IniReadS($g_iUpgradeWallMinGold, $g_sProfileConfigPath, "upgrade", "minwallgold", 0, "int")
IniReadS($g_iUpgradeWallMinElixir, $g_sProfileConfigPath, "upgrade", "minwallelixir", 0, "int")
IniReadS($g_iUpgradeWallLootType, $g_sProfileConfigPath, "upgrade", "use-storage", 0, "int")
IniReadS($g_bUpgradeWallSaveBuilder, $g_sProfileConfigPath, "upgrade", "savebldr", False, "Bool")
IniReadS($g_iCmbUpgradeWallsLevel, $g_sProfileConfigPath, "upgrade", "walllvl", 6, "int")
For $i = 4 To 12
IniReadS($g_aiWallsCurrentCount[$i], $g_sProfileConfigPath, "Walls", "Wall" & StringFormat("%02d", $i), 0, "int")
Next
IniReadS($g_iWallCost, $g_sProfileConfigPath, "upgrade", "WallCost", 0, "int")
EndFunc
Func ReadConfig_600_18()
IniReadS($g_bNotifyPBEnable, $g_sProfileConfigPath, "notify", "PBEnabled", False, "Bool")
IniReadS($g_bNotifyTGEnable, $g_sProfileConfigPath, "notify", "TGEnabled", False, "Bool")
IniReadS($g_sNotifyPBToken, $g_sProfileConfigPath, "notify", "PBToken", "")
IniReadS($g_sNotifyTGToken, $g_sProfileConfigPath, "notify", "TGToken", "")
IniReadS($g_bNotifyRemoteEnable, $g_sProfileConfigPath, "notify", "PBRemote", False, "Bool")
IniReadS($g_sNotifyOrigin, $g_sProfileConfigPath, "notify", "Origin", $g_sProfileCurrentName)
IniReadS($g_bNotifyDeleteAllPushesOnStart, $g_sProfileConfigPath, "notify", "DeleteAllPBPushes", False, "Bool")
IniReadS($g_bNotifyDeletePushesOlderThan, $g_sProfileConfigPath, "notify", "DeleteOldPBPushes", False, "Bool")
IniReadS($g_iNotifyDeletePushesOlderThanHours, $g_sProfileConfigPath, "notify", "HoursPushBullet", 4, "int")
IniReadS($g_bNotifyAlertMatchFound, $g_sProfileConfigPath, "notify", "AlertPBVMFound", False, "Bool")
IniReadS($g_bNotifyAlerLastRaidIMG, $g_sProfileConfigPath, "notify", "AlertPBLastRaid", False, "Bool")
IniReadS($g_bNotifyAlerLastRaidTXT, $g_sProfileConfigPath, "notify", "AlertPBLastRaidTxt", False, "Bool")
IniReadS($g_bNotifyAlertCampFull, $g_sProfileConfigPath, "notify", "AlertPBCampFull", False, "Bool")
IniReadS($g_bNotifyAlertUpgradeWalls, $g_sProfileConfigPath, "notify", "AlertPBWallUpgrade", False, "Bool")
IniReadS($g_bNotifyAlertOutOfSync, $g_sProfileConfigPath, "notify", "AlertPBOOS", False, "Bool")
IniReadS($g_bNotifyAlertTakeBreak, $g_sProfileConfigPath, "notify", "AlertPBVBreak", False, "Bool")
IniReadS($g_bNotifyAlertBulderIdle, $g_sProfileConfigPath, "notify", "AlertBuilderIdle", False, "Bool")
IniReadS($g_bNotifyAlertVillageReport, $g_sProfileConfigPath, "notify", "AlertPBVillage", False, "Bool")
IniReadS($g_bNotifyAlertLastAttack, $g_sProfileConfigPath, "notify", "AlertPBLastAttack", False, "Bool")
IniReadS($g_bNotifyAlertAnotherDevice, $g_sProfileConfigPath, "notify", "AlertPBOtherDevice", False, "Bool")
IniReadS($g_bNotifyAlertMaintenance, $g_sProfileConfigPath, "notify", "AlertPBMaintenance", False, "Bool")
IniReadS($g_bNotifyAlertBAN, $g_sProfileConfigPath, "notify", "AlertPBBAN", False, "Bool")
IniReadS($g_bNotifyAlertBOTUpdate, $g_sProfileConfigPath, "notify", "AlertPBUpdate", False, "Bool")
EndFunc
Func ReadConfig_600_19()
$g_bNotifyScheduleHoursEnable =(IniRead($g_sProfileConfigPath, "notify", "NotifyHoursEnable", "0") = "1")
$g_abNotifyScheduleHours = StringSplit(IniRead($g_sProfileConfigPath, "notify", "NotifyHours", "1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1"),"|", $STR_NOCOUNT)
For $i = 0 To 23
$g_abNotifyScheduleHours[$i] =($g_abNotifyScheduleHours[$i] = "1")
Next
$g_bNotifyScheduleWeekDaysEnable =(IniRead($g_sProfileConfigPath, "notify", "NotifyWeekDaysEnable", "0") = "1")
$g_abNotifyScheduleWeekDays = StringSplit(IniRead($g_sProfileConfigPath, "notify", "NotifyWeekDays", "1|1|1|1|1|1|1"),"|", $STR_NOCOUNT)
For $i = 0 To 6
$g_abNotifyScheduleWeekDays[$i] =($g_abNotifyScheduleWeekDays[$i] = "1")
Next
EndFunc
Func ReadConfig_600_22()
$g_abBoostBarracksHours = StringSplit(IniRead($g_sProfileConfigPath, "planned", "BoostBarracksHours", "1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1"), "|", $STR_NOCOUNT)
For $i = 0 To 23
$g_abBoostBarracksHours[$i] =($g_abBoostBarracksHours[$i] = "1")
Next
EndFunc
Func ReadConfig_600_26()
IniReadS($g_abAttackTypeEnable[$TB], $g_sProfileConfigPath, "search", "BullyMode", False, "Bool")
IniReadS($g_iAtkTBEnableCount, $g_sProfileConfigPath, "search", "ATBullyMode", 0, "int")
IniReadS($g_iAtkTBMaxTHLevel, $g_sProfileConfigPath, "search", "YourTH", 0, "int")
IniReadS($g_iAtkTBMode, $g_sProfileConfigPath, "search", "THBullyAttackMode", 0, "int")
EndFunc
Func ReadConfig_600_28()
IniReadS($g_bSearchReductionEnable, $g_sProfileConfigPath, "search", "reduction", False, "Bool")
IniReadS($g_iSearchReductionCount, $g_sProfileConfigPath, "search", "reduceCount", 20, "int")
IniReadS($g_iSearchReductionGold, $g_sProfileConfigPath, "search", "reduceGold", 2000, "int")
IniReadS($g_iSearchReductionElixir, $g_sProfileConfigPath, "search", "reduceElixir", 2000, "int")
IniReadS($g_iSearchReductionGoldPlusElixir, $g_sProfileConfigPath, "search", "reduceGoldPlusElixir", 4000, "int")
IniReadS($g_iSearchReductionDark, $g_sProfileConfigPath, "search", "reduceDark", 100, "int")
IniReadS($g_iSearchReductionTrophy, $g_sProfileConfigPath, "search", "reduceTrophy", 2, "int")
IniReadS($g_iSearchDelayMin, $g_sProfileConfigPath, "other", "VSDelay", 0, "Int")
IniReadS($g_iSearchDelayMax, $g_sProfileConfigPath, "other", "MaxVSDelay", 4, "Int")
IniReadS($g_bSearchAttackNowEnable, $g_sProfileConfigPath, "general", "AttackNow", False, "Bool")
IniReadS($g_iSearchAttackNowDelay, $g_sProfileConfigPath, "general", "attacknowdelay", 3, "int")
IniReadS($g_bSearchRestartEnable, $g_sProfileConfigPath, "search", "ChkRestartSearchLimit", True, "Bool")
IniReadS($g_iSearchRestartLimit, $g_sProfileConfigPath, "search", "RestartSearchLimit", 50, "int")
IniReadS($g_bSearchAlertMe, $g_sProfileConfigPath, "general", "AlertSearch", False, "Bool")
EndFunc
Func ReadConfig_600_28_DB()
IniReadS($g_abAttackTypeEnable[$DB], $g_sProfileConfigPath, "search", "DBcheck", True, "Bool")
IniReadS($g_abSearchSearchesEnable[$DB], $g_sProfileConfigPath, "search", "ChkDBSearchSearches", True, "Bool")
IniReadS($g_aiSearchSearchesMin[$DB], $g_sProfileConfigPath, "search", "DBEnableAfterCount", 1, "int")
IniReadS($g_aiSearchSearchesMax[$DB], $g_sProfileConfigPath, "search", "DBEnableBeforeCount", 9999, "int")
IniReadS($g_abSearchTropiesEnable[$DB], $g_sProfileConfigPath, "search", "ChkDBSearchTropies", False, "Bool")
IniReadS($g_aiSearchTrophiesMin[$DB], $g_sProfileConfigPath, "search", "DBEnableAfterTropies", 100, "int")
IniReadS($g_aiSearchTrophiesMax[$DB], $g_sProfileConfigPath, "search", "DBEnableBeforeTropies", 6000, "int")
IniReadS($g_abSearchCampsEnable[$DB], $g_sProfileConfigPath, "search", "ChkDBSearchCamps", False, "Bool")
IniReadS($g_aiSearchCampsPct[$DB], $g_sProfileConfigPath, "search", "DBEnableAfterArmyCamps", 100, "int")
Local $temp1, $temp2, $temp3
IniReadS($temp1, $g_sProfileConfigPath, "attack", "DBKingWait", $eHeroNone)
IniReadS($temp2, $g_sProfileConfigPath, "attack", "DBQueenWait", $eHeroNone)
IniReadS($temp3, $g_sProfileConfigPath, "attack", "DBWardenWait", $eHeroNone)
$g_aiSearchHeroWaitEnable[$DB] = BitOR(Int($temp1), Int($temp2), Int($temp3))
$iHeroWaitAttackNoBit[$DB][0] =($temp1 > $eHeroNone) ? 1 : 0
$iHeroWaitAttackNoBit[$DB][1] =($temp2 > $eHeroNone) ? 1 : 0
$iHeroWaitAttackNoBit[$DB][2] =($temp3 > $eHeroNone) ? 1 : 0
IniReadS($g_abSearchSpellsWaitEnable[$DB], $g_sProfileConfigPath, "search", "ChkDBSpellsWait", False, "Bool")
IniReadS($g_abSearchCastleSpellsWaitEnable[$DB], $g_sProfileConfigPath, "search", "ChkDBCastleSpellWait", False, "Bool")
IniReadS($g_abSearchCastleTroopsWaitEnable[$DB], $g_sProfileConfigPath, "search", "ChkDBCastleTroopsWait", False, "Bool")
IniReadS($g_aiSearchCastleSpellsWaitRegular[$DB], $g_sProfileConfigPath, "search", "cmbDBWaitForCastleSpell", 0, "int")
IniReadS($g_aiSearchCastleSpellsWaitDark[$DB], $g_sProfileConfigPath, "search", "cmbDBWaitForCastleSpell2", 0, "int")
IniReadS($g_aiFilterMeetGE[$DB], $g_sProfileConfigPath, "search", "DBMeetGE", 1, "int")
IniReadS($g_aiFilterMinGold[$DB], $g_sProfileConfigPath, "search", "DBsearchGold", 80000, "int")
IniReadS($g_aiFilterMinElixir[$DB], $g_sProfileConfigPath, "search", "DBsearchElixir", 80000, "int")
IniReadS($g_aiFilterMinGoldPlusElixir[$DB], $g_sProfileConfigPath, "search", "DBsearchGoldPlusElixir", 160000, "int")
IniReadS($g_abFilterMeetDEEnable[$DB], $g_sProfileConfigPath, "search", "DBMeetDE", False, "Bool")
IniReadS($g_aiFilterMeetDEMin[$DB], $g_sProfileConfigPath, "search", "DBsearchDark", 0, "int")
IniReadS($g_abFilterMeetTrophyEnable[$DB], $g_sProfileConfigPath, "search", "DBMeetTrophy", False, "Bool")
IniReadS($g_aiFilterMeetTrophyMin[$DB], $g_sProfileConfigPath, "search", "DBsearchTrophy", 0, "int")
IniReadS($g_abFilterMeetTH[$DB], $g_sProfileConfigPath, "search", "DBMeetTH", False, "Bool")
IniReadS($g_aiFilterMeetTHMin[$DB], $g_sProfileConfigPath, "search", "DBTHLevel", 0, "int")
IniReadS($g_abFilterMeetTHOutsideEnable[$DB], $g_sProfileConfigPath, "search", "DBMeetTHO", False, "Bool")
IniReadS($g_abFilterMaxMortarEnable[$DB], $g_sProfileConfigPath, "search", "DBCheckMortar", False, "Bool")
IniReadS($g_abFilterMaxWizTowerEnable[$DB], $g_sProfileConfigPath, "search", "DBCheckWizTower", False, "Bool")
IniReadS($g_abFilterMaxAirDefenseEnable[$DB], $g_sProfileConfigPath, "search", "DBCheckAirDefense", False, "Bool")
IniReadS($g_abFilterMaxXBowEnable[$DB], $g_sProfileConfigPath, "search", "DBCheckXBow",False, "Bool")
IniReadS($g_abFilterMaxInfernoEnable[$DB], $g_sProfileConfigPath, "search", "DBCheckInferno", False, "Bool")
IniReadS($g_abFilterMaxEagleEnable[$DB], $g_sProfileConfigPath, "search", "DBCheckEagle", False, "Bool")
IniReadS($g_aiFilterMaxMortarLevel[$DB], $g_sProfileConfigPath, "search", "DBWeakMortar", 5, "int")
IniReadS($g_aiFilterMaxWizTowerLevel[$DB], $g_sProfileConfigPath, "search", "DBWeakWizTower", 4, "int")
IniReadS($g_aiFilterMaxAirDefenseLevel[$DB], $g_sProfileConfigPath, "search", "DBWeakAirDefense", 7, "int")
IniReadS($g_aiFilterMaxXBowLevel[$DB], $g_sProfileConfigPath, "search", "DBWeakXBow", 4, "int")
IniReadS($g_aiFilterMaxInfernoLevel[$DB], $g_sProfileConfigPath, "search", "DBWeakInferno", 1, "int")
IniReadS($g_aiFilterMaxEagleLevel[$DB], $g_sProfileConfigPath, "search", "DBWeakEagle", 2, "int")
IniReadS($g_abFilterMeetOneConditionEnable[$DB], $g_sProfileConfigPath, "search", "DBMeetOne", False, "Bool")
EndFunc
Func ReadConfig_600_28_LB()
IniReadS($g_abAttackTypeEnable[$LB], $g_sProfileConfigPath, "search", "ABcheck", False, "Bool")
IniReadS($g_abSearchSearchesEnable[$LB], $g_sProfileConfigPath, "search", "ChkABSearchSearches", False, "Bool")
IniReadS($g_aiSearchSearchesMin[$LB], $g_sProfileConfigPath, "search", "ABEnableAfterCount", 1, "int")
IniReadS($g_aiSearchSearchesMax[$LB], $g_sProfileConfigPath, "search", "ABEnableBeforeCount", 9999, "int")
IniReadS($g_abSearchTropiesEnable[$LB], $g_sProfileConfigPath, "search", "ChkABSearchTropies", False, "Bool")
IniReadS($g_aiSearchTrophiesMin[$LB], $g_sProfileConfigPath, "search", "ABEnableAfterTropies", 100, "int")
IniReadS($g_aiSearchTrophiesMax[$LB], $g_sProfileConfigPath, "search", "ABEnableBeforeTropies", 6000, "int")
IniReadS($g_abSearchCampsEnable[$LB], $g_sProfileConfigPath, "search", "ChkABSearchCamps", False, "Bool")
IniReadS($g_aiSearchCampsPct[$LB], $g_sProfileConfigPath, "search", "ABEnableAfterArmyCamps", 100, "int")
Local $temp1, $temp2, $temp3
IniReadS($temp1, $g_sProfileConfigPath, "attack", "ABKingWait", $eHeroNone)
IniReadS($temp2, $g_sProfileConfigPath, "attack", "ABQueenWait", $eHeroNone)
IniReadS($temp3, $g_sProfileConfigPath, "attack", "ABWardenWait", $eHeroNone)
$g_aiSearchHeroWaitEnable[$LB] = BitOR(Int($temp1), Int($temp2), Int($temp3))
$iHeroWaitAttackNoBit[$LB][0] =($temp1 > $eHeroNone) ? 1 : 0
$iHeroWaitAttackNoBit[$LB][1] =($temp2 > $eHeroNone) ? 1 : 0
$iHeroWaitAttackNoBit[$LB][2] =($temp3 > $eHeroNone) ? 1 : 0
IniReadS($g_abSearchSpellsWaitEnable[$LB], $g_sProfileConfigPath, "search", "ChkABSpellsWait", False, "Bool")
IniReadS($g_abSearchCastleSpellsWaitEnable[$LB], $g_sProfileConfigPath, "search", "ChkABCastleSpellWait", False, "Bool")
IniReadS($g_abSearchCastleTroopsWaitEnable[$LB], $g_sProfileConfigPath, "search", "ChkABCastleTroopsWait", False, "Bool")
IniReadS($g_aiSearchCastleSpellsWaitRegular[$LB], $g_sProfileConfigPath, "search", "cmbABWaitForCastleSpell", 0, "int")
IniReadS($g_aiSearchCastleSpellsWaitDark[$LB], $g_sProfileConfigPath, "search", "cmbABWaitForCastleSpell2", 0, "int")
IniReadS($g_aiFilterMeetGE[$LB], $g_sProfileConfigPath, "search", "ABMeetGE", 2, "int")
IniReadS($g_aiFilterMinGold[$LB], $g_sProfileConfigPath, "search", "ABsearchGold", 80000, "int")
IniReadS($g_aiFilterMinElixir[$LB], $g_sProfileConfigPath, "search", "ABsearchElixir", 80000, "int")
IniReadS($g_aiFilterMinGoldPlusElixir[$LB], $g_sProfileConfigPath, "search", "ABsearchGoldPlusElixir", 160000, "int")
IniReadS($g_abFilterMeetDEEnable[$LB], $g_sProfileConfigPath, "search", "ABMeetDE", False, "Bool")
IniReadS($g_aiFilterMeetDEMin[$LB], $g_sProfileConfigPath, "search", "ABsearchDark", 0, "int")
IniReadS($g_abFilterMeetTrophyEnable[$LB], $g_sProfileConfigPath, "search", "ABMeetTrophy", False, "Bool")
IniReadS($g_aiFilterMeetTrophyMin[$LB], $g_sProfileConfigPath, "search", "ABsearchTrophy", 0, "int")
IniReadS($g_abFilterMeetTH[$LB], $g_sProfileConfigPath, "search", "ABMeetTH", False, "Bool")
IniReadS($g_aiFilterMeetTHMin[$LB], $g_sProfileConfigPath, "search", "ABTHLevel", 0, "int")
IniReadS($g_abFilterMeetTHOutsideEnable[$LB], $g_sProfileConfigPath, "search", "ABMeetTHO", False, "Bool")
IniReadS($g_abFilterMaxMortarEnable[$LB], $g_sProfileConfigPath, "search", "ABCheckMortar", False, "Bool")
IniReadS($g_abFilterMaxWizTowerEnable[$LB], $g_sProfileConfigPath, "search", "ABCheckWizTower", False, "Bool")
IniReadS($g_abFilterMaxAirDefenseEnable[$LB], $g_sProfileConfigPath, "search", "ABCheckAirDefense", False, "Bool")
IniReadS($g_abFilterMaxXBowEnable[$LB], $g_sProfileConfigPath, "search", "ABCheckXBow", False, "Bool")
IniReadS($g_abFilterMaxInfernoEnable[$LB], $g_sProfileConfigPath, "search", "ABCheckInferno", False, "Bool")
IniReadS($g_abFilterMaxEagleEnable[$LB], $g_sProfileConfigPath, "search", "ABCheckEagle", False, "Bool")
IniReadS($g_aiFilterMaxMortarLevel[$LB], $g_sProfileConfigPath, "search", "ABWeakMortar", 5, "int")
IniReadS($g_aiFilterMaxWizTowerLevel[$LB], $g_sProfileConfigPath, "search", "ABWeakWizTower", 4, "int")
IniReadS($g_aiFilterMaxAirDefenseLevel[$LB], $g_sProfileConfigPath, "search", "ABWeakAirDefense", 7, "int")
IniReadS($g_aiFilterMaxXBowLevel[$LB], $g_sProfileConfigPath, "search", "ABWeakXBow", 4, "int")
IniReadS($g_aiFilterMaxInfernoLevel[$LB], $g_sProfileConfigPath, "search", "ABWeakInferno", 1, "int")
IniReadS($g_aiFilterMaxEagleLevel[$LB], $g_sProfileConfigPath, "search", "ABWeakEagle", 2, "int")
IniReadS($g_abFilterMeetOneConditionEnable[$LB], $g_sProfileConfigPath, "search", "ABMeetOne", False, "Bool")
EndFunc
Func ReadConfig_600_28_TS()
IniReadS($g_abAttackTypeEnable[$TS], $g_sProfileConfigPath, "search", "TScheck", False, "Bool")
IniReadS($g_abSearchSearchesEnable[$TS], $g_sProfileConfigPath, "search", "ChkTSSearchSearches", False, "Bool")
IniReadS($g_aiSearchSearchesMin[$TS], $g_sProfileConfigPath, "search", "TSEnableAfterCount", 1, "int")
IniReadS($g_aiSearchSearchesMax[$TS], $g_sProfileConfigPath, "search", "TSEnableBeforeCount", 9999, "int")
IniReadS($g_abSearchTropiesEnable[$TS], $g_sProfileConfigPath, "search", "ChkTSSearchTropies", False, "Bool")
IniReadS($g_aiSearchTrophiesMin[$TS], $g_sProfileConfigPath, "search", "TSEnableAfterTropies", 100, "int")
IniReadS($g_aiSearchTrophiesMax[$TS], $g_sProfileConfigPath, "search", "TSEnableBeforeTropies", 6000, "int")
IniReadS($g_abSearchCampsEnable[$TS], $g_sProfileConfigPath, "search", "ChkTSSearchCamps", False, "Bool")
IniReadS($g_aiSearchCampsPct[$TS], $g_sProfileConfigPath, "search", "TSEnableAfterArmyCamps", 100, "int")
IniReadS($g_aiFilterMeetGE[$TS], $g_sProfileConfigPath, "search", "TSMeetGE", 1, "int")
IniReadS($g_aiFilterMinGold[$TS], $g_sProfileConfigPath, "search", "TSsearchGold", 80000, "int")
IniReadS($g_aiFilterMinElixir[$TS], $g_sProfileConfigPath, "search", "TSsearchElixir", 80000, "int")
IniReadS($g_aiFilterMinGoldPlusElixir[$TS], $g_sProfileConfigPath, "search", "TSsearchGoldPlusElixir", 160000, "int")
IniReadS($g_abFilterMeetDEEnable[$TS], $g_sProfileConfigPath, "search", "TSMeetDE", False, "Bool")
IniReadS($g_aiFilterMeetDEMin[$TS], $g_sProfileConfigPath, "search", "TSsearchDark", 600, "int")
IniReadS($g_iAtkTSAddTilesWhileTrain, $g_sProfileConfigPath, "search", "SWTtiles", 1, "int")
IniReadS($g_iAtkTSAddTilesFullTroops, $g_sProfileConfigPath, "search", "THaddTiles", 2, "int")
EndFunc
Func ReadConfig_600_29()
IniReadS($iActivateKQCondition, $g_sProfileConfigPath, "attack", "ActivateKQ", "Auto")
IniReadS($delayActivateKQ, $g_sProfileConfigPath, "attack", "delayActivateKQ", 9, "int")
IniReadS($iActivateWardenCondition, $g_sProfileConfigPath, "attack", "ActivateWarden", 1, "int")
IniReadS($delayActivateW, $g_sProfileConfigPath, "attack", "delayActivateW", 9, "int")
$ichkAttackPlannerEnable = Int(IniRead($g_sProfileConfigPath, "planned", "chkAttackPlannerEnable", 0))
$ichkAttackPlannerCloseCoC = Int(IniRead($g_sProfileConfigPath, "planned", "chkAttackPlannerCloseCoC", 0))
$ichkAttackPlannerCloseAll = Int(IniRead($g_sProfileConfigPath, "planned", "chkAttackPlannerCloseAll", 0))
$ichkAttackPlannerRandom = Int(IniRead($g_sProfileConfigPath, "planned", "chkAttackPlannerRandom", 0))
$icmbAttackPlannerRandom = Int(IniRead($g_sProfileConfigPath, "planned", "cmbAttackPlannerRandom", 4))
$ichkAttackPlannerDayLimit = Int(IniRead($g_sProfileConfigPath, "planned", "chkAttackPlannerDayLimit", 0))
$icmbAttackPlannerDayMin = Int(IniRead($g_sProfileConfigPath, "planned", "cmbAttackPlannerDayMin", 12))
$icmbAttackPlannerDayMax = Int(IniRead($g_sProfileConfigPath, "planned", "cmbAttackPlannerDayMax", 15))
$iPlannedAttackWeekDays = StringSplit(IniRead($g_sProfileConfigPath, "planned", "attackDays", "1|1|1|1|1|1|1"), "|", $STR_NOCOUNT)
$iPlannedattackHours = StringSplit(IniRead($g_sProfileConfigPath, "planned", "attackHours", "1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1"), "|", $STR_NOCOUNT)
$iPlannedDropCCHoursEnable = Int(IniRead($g_sProfileConfigPath, "planned", "DropCCEnable", 0))
$iPlannedDropCCHours = StringSplit(IniRead($g_sProfileConfigPath, "planned", "DropCCHours", "1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1"), "|", $STR_NOCOUNT)
IniReadS($iChkUseCCBalanced, $g_sProfileConfigPath, "ClanClastle", "BalanceCC", 0, "int")
IniReadS($iCmbCCDonated, $g_sProfileConfigPath, "ClanClastle", "BalanceCCDonated", 1, "int")
IniReadS($iCmbCCReceived, $g_sProfileConfigPath, "ClanClastle", "BalanceCCReceived", 1, "int")
EndFunc
Func ReadConfig_600_29_DB()
IniReadS($g_aiAttackAlgorithm[$DB], $g_sProfileConfigPath, "attack", "DBAtkAlgorithm", 0, "int")
IniReadS($g_aiAttackTroopSelection[$DB], $g_sProfileConfigPath, "attack", "DBSelectTroop", 0, "int")
Local $temp1, $temp2, $temp3
IniReadS($temp1, $g_sProfileConfigPath, "attack", "DBKingAtk", $eHeroNone)
IniReadS($temp2, $g_sProfileConfigPath, "attack", "DBQueenAtk", $eHeroNone)
IniReadS($temp3, $g_sProfileConfigPath, "attack", "DBWardenAtk", $eHeroNone)
$g_aiAttackUseHeroes[$DB] = BitOR(Int($temp1), Int($temp2), Int($temp3))
IniReadS($g_abAttackDropCC[$DB], $g_sProfileConfigPath, "attack", "DBDropCC", False, "Bool")
IniReadS($g_abAttackUseLightSpell[$DB], $g_sProfileConfigPath, "attack", "DBLightSpell", False, "Bool")
IniReadS($g_abAttackUseHealSpell[$DB], $g_sProfileConfigPath, "attack", "DBHealSpell", False, "Bool")
IniReadS($g_abAttackUseRageSpell[$DB], $g_sProfileConfigPath, "attack", "DBRageSpell", False, "Bool")
IniReadS($g_abAttackUseJumpSpell[$DB], $g_sProfileConfigPath, "attack", "DBJumpSpell", False, "Bool")
IniReadS($g_abAttackUseFreezeSpell[$DB], $g_sProfileConfigPath, "attack", "DBFreezeSpell", False, "Bool")
IniReadS($g_abAttackUsePoisonSpell[$DB], $g_sProfileConfigPath, "attack", "DBPoisonSpell", False, "Bool")
IniReadS($g_abAttackUseEarthquakeSpell[$DB], $g_sProfileConfigPath, "attack", "DBEarthquakeSpell", False, "Bool")
IniReadS($g_abAttackUseHasteSpell[$DB], $g_sProfileConfigPath, "attack", "DBHasteSpell", False, "Bool")
IniReadS($g_abAttackUseCloneSpell[$DB], $g_sProfileConfigPath, "attack", "DBCloneSpell", False, "Bool")
IniReadS($g_abAttackUseSkeletonSpell[$DB], $g_sProfileConfigPath, "attack", "DBSkeletonSpell", False, "Bool")
IniReadS($g_bTHSnipeBeforeEnable[$DB], $g_sProfileConfigPath, "attack", "THSnipeBeforeDBEnable", False, "Bool")
IniReadS($g_iTHSnipeBeforeTiles[$DB], $g_sProfileConfigPath, "attack", "THSnipeBeforeDBTiles", 0, "int")
IniReadS($g_iTHSnipeBeforeScript[$DB], $g_sProfileConfigPath, "attack", "THSnipeBeforeDBScript", "bam")
IniReadS($g_aiAttackStdDropOrder[$DB], $g_sProfileConfigPath, "attack", "DBStandardAlgorithm", 0, "int")
IniReadS($g_aiAttackStdDropSides[$DB], $g_sProfileConfigPath, "attack", "DBDeploy", 3, "int")
IniReadS($g_aiAttackStdUnitDelay[$DB], $g_sProfileConfigPath, "attack", "DBUnitD", 4, "int")
IniReadS($g_aiAttackStdWaveDelay[$DB], $g_sProfileConfigPath, "attack", "DBWaveD", 4, "int")
IniReadS($g_abAttackStdRandomizeDelay[$DB], $g_sProfileConfigPath, "attack", "DBRandomSpeedAtk", True, "Bool")
IniReadS($g_abAttackStdSmartAttack[$DB], $g_sProfileConfigPath, "attack", "DBSmartAttackRedArea", True, "Bool")
IniReadS($g_aiAttackStdSmartDeploy[$DB], $g_sProfileConfigPath, "attack", "DBSmartAttackDeploy", 0, "int")
IniReadS($g_abAttackStdSmartNearCollectors[$DB][0], $g_sProfileConfigPath, "attack", "DBSmartAttackGoldMine", False, "Bool")
IniReadS($g_abAttackStdSmartNearCollectors[$DB][1], $g_sProfileConfigPath, "attack", "DBSmartAttackElixirCollector", False, "Bool")
IniReadS($g_abAttackStdSmartNearCollectors[$DB][2], $g_sProfileConfigPath, "attack", "DBSmartAttackDarkElixirDrill", False, "Bool")
IniReadS($g_aiAttackScrRedlineRoutine[$DB], $g_sProfileConfigPath, "attack", "RedlineRoutineDB", $g_aiAttackScrRedlineRoutine[$DB], "Int")
IniReadS($g_aiAttackScrDroplineEdge[$DB], $g_sProfileConfigPath, "attack", "DroplineEdgeDB", $g_aiAttackScrDroplineEdge[$DB], "Int")
IniReadS($g_sAttackScrScriptName[$DB], $g_sProfileConfigPath, "attack", "ScriptDB", "Barch four fingers")
IniReadS($g_iMilkAttackType, $g_sProfileConfigPath, "MilkingAttack", "MilkAttackType", 0, "int")
IniReadS($g_aiMilkFarmElixirParam, $g_sProfileConfigPath, "MilkingAttack", "LocateElixirLevel", "-1|-1|-1|-1|-1|-1|2|2|2")
$g_aiMilkFarmElixirParam = StringSplit($g_aiMilkFarmElixirParam, "|", 2)
IniReadS($g_bMilkFarmLocateElixir, $g_sProfileConfigPath, "MilkingAttack", "LocateElixir", True, "Bool")
IniReadS($g_bMilkFarmLocateMine, $g_sProfileConfigPath, "MilkingAttack", "LocateMine", True, "Bool")
IniReadS($g_bMilkFarmLocateDrill, $g_sProfileConfigPath, "MilkingAttack", "LocateDrill", True, "Bool")
IniReadS($g_iMilkFarmMineParam, $g_sProfileConfigPath, "MilkingAttack", "MineParam", 5, "int")
IniReadS($g_iMilkFarmDrillParam, $g_sProfileConfigPath, "MilkingAttack", "DrillParam", 1, "int")
IniReadS($g_iMilkFarmResMaxTilesFromBorder, $g_sProfileConfigPath, "MilkingAttack", "MaxTiles", 1, "int")
IniReadS($g_bMilkFarmAttackGoldMines, $g_sProfileConfigPath, "MilkingAttack", "AttackMine", True, "Bool")
IniReadS($g_bMilkFarmAttackElixirExtractors, $g_sProfileConfigPath, "MilkingAttack", "AttackElixir", True, "Bool")
IniReadS($g_bMilkFarmAttackDarkDrills, $g_sProfileConfigPath, "MilkingAttack", "AttackDrill", True, "Bool")
IniReadS($g_iMilkFarmLimitGold, $g_sProfileConfigPath, "MilkingAttack", "LimitGold", 9950000, "int")
IniReadS($g_iMilkFarmLimitElixir, $g_sProfileConfigPath, "MilkingAttack", "LimitElixir", 9950000, "int")
IniReadS($g_iMilkFarmLimitDark, $g_sProfileConfigPath, "MilkingAttack", "LimitDark", 200000, "int")
IniReadS($g_iMilkFarmTroopForWaveMin, $g_sProfileConfigPath, "MilkingAttack", "TroopForWaveMin", 4, "int")
IniReadS($g_iMilkFarmTroopForWaveMax, $g_sProfileConfigPath, "MilkingAttack", "TroopForWaveMax", 6, "int")
IniReadS($g_iMilkFarmTroopMaxWaves, $g_sProfileConfigPath, "MilkingAttack", "MaxWaves", 4, "int")
IniReadS($g_iMilkFarmDelayFromWavesMin, $g_sProfileConfigPath, "MilkingAttack", "DelayBetweenWavesMin", 3000, "int")
IniReadS($g_iMilkFarmDelayFromWavesMax, $g_sProfileConfigPath, "MilkingAttack", "DelayBetweenWavesMax", 5000, "int")
IniReadS($g_iMilkingAttackDropGoblinAlgorithm, $g_sProfileConfigPath, "MilkingAttack", "DropRandomPlace", 0, "int")
IniReadS($g_iMilkingAttackStructureOrder, $g_sProfileConfigPath, "MilkingAttack", "StructureOrder", 1, "int")
IniReadS($g_bMilkingAttackCheckStructureDestroyedBeforeAttack, $g_sProfileConfigPath, "MilkingAttack", "CheckStructureDestroyedBeforeAttack", False, "Bool")
IniReadS($g_bMilkingAttackCheckStructureDestroyedAfterAttack, $g_sProfileConfigPath, "MilkingAttack", "CheckStructureDestroyedAfterAttack", False, "Bool")
IniReadS($g_bMilkAttackAfterTHSnipeEnable, $g_sProfileConfigPath, "MilkingAttack", "MilkAttackAfterTHSnipe", False, "Bool")
IniReadS($g_iMilkFarmTHMaxTilesFromBorder, $g_sProfileConfigPath, "MilkingAttack", "TownhallTiles", 0, "int")
IniReadS($g_sMilkFarmAlgorithmTh, $g_sProfileConfigPath, "MilkingAttack", "TownHallAlgorithm", "Bam")
IniReadS($g_bMilkFarmSnipeEvenIfNoExtractorsFound, $g_sProfileConfigPath, "MilkingAttack", "TownHallHitAnyway", False, "Bool")
IniReadS($g_bMilkAttackAfterScriptedAtkEnable, $g_sProfileConfigPath, "MilkingAttack", "MilkAttackAfterScriptedAtk", False, "Bool")
IniReadS($g_sMilkAttackCSVscript, $g_sProfileConfigPath, "MilkingAttack", "MilkAttackCSVscript", "0")
IniReadS($g_bMilkFarmForceToleranceEnable, $g_sProfileConfigPath, "MilkingAttack", "MilkFarmForceTolerance", False, "Bool")
IniReadS($g_iMilkFarmForceToleranceNormal, $g_sProfileConfigPath, "MilkingAttack", "MilkFarmForcetolerancenormal", 60, "int")
IniReadS($g_iMilkFarmForceToleranceBoosted, $g_sProfileConfigPath, "MilkingAttack", "MilkFarmForcetoleranceboosted", 60, "int")
IniReadS($g_iMilkFarmForceToleranceDestroyed, $g_sProfileConfigPath, "MilkingAttack", "MilkFarmForcetolerancedestroyed", 60, "int")
EndFunc
Func ReadConfig_600_29_LB()
IniReadS($g_aiAttackAlgorithm[$LB], $g_sProfileConfigPath, "attack", "ABAtkAlgorithm", 0, "int")
IniReadS($g_aiAttackTroopSelection[$LB], $g_sProfileConfigPath, "attack", "ABSelectTroop", 0, "int")
Local $temp1, $temp2, $temp3
IniReadS($temp1, $g_sProfileConfigPath, "attack", "ABKingAtk", $eHeroNone)
IniReadS($temp2, $g_sProfileConfigPath, "attack", "ABQueenAtk", $eHeroNone)
IniReadS($temp3, $g_sProfileConfigPath, "attack", "ABWardenAtk", $eHeroNone)
$g_aiAttackUseHeroes[$LB] = BitOR(Int($temp1), Int($temp2), Int($temp3))
IniReadS($g_abAttackDropCC[$LB], $g_sProfileConfigPath, "attack", "ABDropCC", False, "Bool")
IniReadS($g_abAttackUseLightSpell[$LB], $g_sProfileConfigPath, "attack", "ABLightSpell", False, "Bool")
IniReadS($g_abAttackUseHealSpell[$LB], $g_sProfileConfigPath, "attack", "ABHealSpell", False, "Bool")
IniReadS($g_abAttackUseRageSpell[$LB], $g_sProfileConfigPath, "attack", "ABRageSpell", False, "Bool")
IniReadS($g_abAttackUseJumpSpell[$LB], $g_sProfileConfigPath, "attack", "ABJumpSpell", False, "Bool")
IniReadS($g_abAttackUseFreezeSpell[$LB], $g_sProfileConfigPath, "attack", "ABFreezeSpell", False, "Bool")
IniReadS($g_abAttackUsePoisonSpell[$LB], $g_sProfileConfigPath, "attack", "ABPoisonSpell", False, "Bool")
IniReadS($g_abAttackUseEarthquakeSpell[$LB], $g_sProfileConfigPath, "attack", "ABEarthquakeSpell", False, "Bool")
IniReadS($g_abAttackUseHasteSpell[$LB], $g_sProfileConfigPath, "attack", "ABHasteSpell", False, "Bool")
IniReadS($g_abAttackUseCloneSpell[$LB], $g_sProfileConfigPath, "attack", "ABCloneSpell", False, "Bool")
IniReadS($g_abAttackUseSkeletonSpell[$LB], $g_sProfileConfigPath, "attack", "ABSkeletonSpell", False, "Bool")
IniReadS($g_bTHSnipeBeforeEnable[$LB], $g_sProfileConfigPath, "attack", "THSnipeBeforeLBEnable", False, "Bool")
IniReadS($g_iTHSnipeBeforeTiles[$LB], $g_sProfileConfigPath, "attack", "THSnipeBeforeLBTiles", 0, "int")
IniReadS($g_iTHSnipeBeforeScript[$LB], $g_sProfileConfigPath, "attack", "THSnipeBeforeLBScript", "bam")
IniReadS($g_aiAttackStdDropOrder[$LB], $g_sProfileConfigPath, "attack", "LBStandardAlgorithm", 0, "int")
IniReadS($g_aiAttackStdDropSides[$LB], $g_sProfileConfigPath, "attack", "ABDeploy", 0, "int")
IniReadS($g_aiAttackStdUnitDelay[$LB], $g_sProfileConfigPath, "attack", "ABUnitD", 4, "int")
IniReadS($g_aiAttackStdWaveDelay[$LB], $g_sProfileConfigPath, "attack", "ABWaveD", 4, "int")
IniReadS($g_abAttackStdRandomizeDelay[$LB], $g_sProfileConfigPath, "attack", "ABRandomSpeedAtk", True, "Bool")
IniReadS($g_abAttackStdSmartAttack[$LB], $g_sProfileConfigPath, "attack", "ABSmartAttackRedArea", True, "Bool")
IniReadS($g_aiAttackStdSmartDeploy[$LB], $g_sProfileConfigPath, "attack", "ABSmartAttackDeploy", 1, "int")
IniReadS($g_abAttackStdSmartNearCollectors[$LB][0], $g_sProfileConfigPath, "attack", "ABSmartAttackGoldMine", False, "Bool")
IniReadS($g_abAttackStdSmartNearCollectors[$LB][1], $g_sProfileConfigPath, "attack", "ABSmartAttackElixirCollector", False, "Bool")
IniReadS($g_abAttackStdSmartNearCollectors[$LB][2], $g_sProfileConfigPath, "attack", "ABSmartAttackDarkElixirDrill", False, "Bool")
IniReadS($g_aiAttackScrRedlineRoutine[$LB], $g_sProfileConfigPath, "attack", "RedlineRoutineAB", $g_aiAttackScrRedlineRoutine[$LB], "Int")
IniReadS($g_aiAttackScrDroplineEdge[$LB], $g_sProfileConfigPath, "attack", "DroplineEdgeAB", $g_aiAttackScrDroplineEdge[$LB], "Int")
IniReadS($g_sAttackScrScriptName[$LB], $g_sProfileConfigPath, "attack", "ScriptAB", "Barch four fingers")
EndFunc
Func ReadConfig_600_29_TS()
IniReadS($g_aiAttackTroopSelection[$TS], $g_sProfileConfigPath, "attack", "TSSelectTroop", 0, "int")
Local $temp1, $temp2, $temp3
IniReadS($temp1, $g_sProfileConfigPath, "attack", "TSKingAtk", $eHeroNone)
IniReadS($temp2, $g_sProfileConfigPath, "attack", "TSQueenAtk", $eHeroNone)
IniReadS($temp3, $g_sProfileConfigPath, "attack", "TSWardenAtk", $eHeroNone)
$g_aiAttackUseHeroes[$TS] = BitOR(Int($temp1), Int($temp2), Int($temp3))
IniReadS($g_abAttackDropCC[$TS], $g_sProfileConfigPath, "attack", "TSDropCC", False, "Bool")
IniReadS($g_abAttackUseHealSpell[$TS], $g_sProfileConfigPath, "attack", "TSHealSpell",False, "Bool")
IniReadS($g_abAttackUseLightSpell[$TS], $g_sProfileConfigPath, "attack", "TSLightSpell", False, "Bool")
IniReadS($g_abAttackUseRageSpell[$TS], $g_sProfileConfigPath, "attack", "TSRageSpell", False, "Bool")
IniReadS($g_abAttackUseJumpSpell[$TS], $g_sProfileConfigPath, "attack", "TSJumpSpell", False, "Bool")
IniReadS($g_abAttackUseFreezeSpell[$TS], $g_sProfileConfigPath, "attack", "TSFreezeSpell", False, "Bool")
IniReadS($g_abAttackUsePoisonSpell[$TS], $g_sProfileConfigPath, "attack", "TSPoisonSpell", False, "Bool")
IniReadS($g_abAttackUseEarthquakeSpell[$TS], $g_sProfileConfigPath, "attack", "TSEarthquakeSpell", False, "Bool")
IniReadS($g_abAttackUseHasteSpell[$TS], $g_sProfileConfigPath, "attack", "TSHasteSpell", False, "Bool")
IniReadS($g_sAtkTSType, $g_sProfileConfigPath, "attack", "AttackTHType", "bam")
EndFunc
Func ReadConfig_600_30()
$iShareAttack = Int(IniRead($g_sProfileConfigPath, "shareattack", "ShareAttack", 0))
$iShareminGold = Int(IniRead($g_sProfileConfigPath, "shareattack", "minGold", 200000))
$iShareminElixir = Int(IniRead($g_sProfileConfigPath, "shareattack", "minElixir", 200000))
$iSharemindark = Int(IniRead($g_sProfileConfigPath, "shareattack", "minDark", 100))
$sShareMessage = StringReplace(IniRead($g_sProfileConfigPath, "shareattack", "Message", "Nice|Good|Thanks|Wowwww"), "|", @CRLF)
IniReadS($TakeLootSnapShot, $g_sProfileConfigPath, "attack", "TakeLootSnapShot", 0, "int")
IniReadS($ScreenshotLootInfo, $g_sProfileConfigPath, "attack", "ScreenshotLootInfo", 0, "int")
EndFunc
Func ReadConfig_600_30_DB()
IniReadS($g_abStopAtkNoLoot1Enable[$DB], $g_sProfileConfigPath, "endbattle", "chkDBTimeStopAtk", True, "Bool")
IniReadS($g_aiStopAtkNoLoot1Time[$DB], $g_sProfileConfigPath, "endbattle", "txtDBTimeStopAtk", 15, "int")
IniReadS($g_abStopAtkNoLoot2Enable[$DB], $g_sProfileConfigPath, "endbattle", "chkDBTimeStopAtk2", False, "Bool")
IniReadS($g_aiStopAtkNoLoot2Time[$DB], $g_sProfileConfigPath, "endbattle", "txtDBTimeStopAtk2", 7, "int")
IniReadS($g_aiStopAtkNoLoot2MinGold[$DB], $g_sProfileConfigPath, "endbattle", "txtDBMinGoldStopAtk2", 1000, "int")
IniReadS($g_aiStopAtkNoLoot2MinElixir[$DB], $g_sProfileConfigPath, "endbattle", "txtDBMinElixirStopAtk2", 1000, "int")
IniReadS($g_aiStopAtkNoLoot2MinDark[$DB], $g_sProfileConfigPath, "endbattle", "txtDBMinDarkElixirStopAtk2", 50, "int")
IniReadS($g_abStopAtkNoResources[$DB], $g_sProfileConfigPath, "endbattle", "chkDBEndNoResources", False, "Bool")
IniReadS($g_abStopAtkOneStar[$DB], $g_sProfileConfigPath, "endbattle", "chkDBEndOneStar", False, "Bool")
IniReadS($g_abStopAtkTwoStars[$DB], $g_sProfileConfigPath, "endbattle", "chkDBEndTwoStars", False, "Bool")
IniReadS($g_abStopAtkPctHigherEnable[$DB], $g_sProfileConfigPath, "endbattle", "chkDBPercentageHigher", False, "Bool")
IniReadS($g_aiStopAtkPctHigherAmt[$DB], $g_sProfileConfigPath, "endbattle", "txtDBPercentageHigher", 50, "int")
IniReadS($g_abStopAtkPctNoChangeEnable[$DB], $g_sProfileConfigPath, "endbattle", "chkDBPercentageChange", False, "Bool")
IniReadS($g_aiStopAtkPctNoChangeTime[$DB], $g_sProfileConfigPath, "endbattle", "txtDBPercentageChange", 15, "int")
EndFunc
Func ReadConfig_600_30_LB()
IniReadS($g_abStopAtkNoLoot1Enable[$LB], $g_sProfileConfigPath, "endbattle", "chkABTimeStopAtk", True, "Bool")
IniReadS($g_aiStopAtkNoLoot1Time[$LB], $g_sProfileConfigPath, "endbattle", "txtABTimeStopAtk", 20, "int")
IniReadS($g_abStopAtkNoLoot2Enable[$LB], $g_sProfileConfigPath, "endbattle", "chkABTimeStopAtk2", False, "Bool")
IniReadS($g_aiStopAtkNoLoot2Time[$LB], $g_sProfileConfigPath, "endbattle", "txtABTimeStopAtk2", 7, "int")
IniReadS($g_aiStopAtkNoLoot2MinGold[$LB], $g_sProfileConfigPath, "endbattle", "txtABMinGoldStopAtk2", 1000, "int")
IniReadS($g_aiStopAtkNoLoot2MinElixir[$LB], $g_sProfileConfigPath, "endbattle", "txtABMinElixirStopAtk2", 1000, "int")
IniReadS($g_aiStopAtkNoLoot2MinDark[$LB], $g_sProfileConfigPath, "endbattle", "txtABMinDarkElixirStopAtk2", 50, "int")
IniReadS($g_abStopAtkNoResources[$LB], $g_sProfileConfigPath, "endbattle", "chkABEndNoResources", False, "Bool")
IniReadS($g_abStopAtkOneStar[$LB], $g_sProfileConfigPath, "endbattle", "chkABEndOneStar", False, "Bool")
IniReadS($g_abStopAtkTwoStars[$LB], $g_sProfileConfigPath, "endbattle", "chkABEndTwoStars", False, "Bool")
IniReadS($g_bDESideEndEnable, $g_sProfileConfigPath, "endbattle", "chkDESideEB", False, "Bool")
IniReadS($g_iDESideEndMin, $g_sProfileConfigPath, "endbattle", "txtDELowEndMin", 25, "int")
IniReadS($g_bDESideDisableOther, $g_sProfileConfigPath, "endbattle", "chkDisableOtherEBO", False, "Bool")
IniReadS($g_bDESideEndBKWeak, $g_sProfileConfigPath, "endbattle", "chkDEEndBk", False, "Bool")
IniReadS($g_bDESideEndAQWeak, $g_sProfileConfigPath, "endbattle", "chkDEEndAq", False, "Bool")
IniReadS($g_bDESideEndOneStar, $g_sProfileConfigPath, "endbattle", "chkDEEndOneStar", False, "Bool")
IniReadS($g_abStopAtkPctHigherEnable[$LB], $g_sProfileConfigPath, "endbattle", "chkABPercentageHigher", False, "Bool")
IniReadS($g_aiStopAtkPctHigherAmt[$LB], $g_sProfileConfigPath, "endbattle", "txtABPercentageHigher", 50, "int")
IniReadS($g_abStopAtkPctNoChangeEnable[$LB], $g_sProfileConfigPath, "endbattle", "chkABPercentageChange", False, "Bool")
IniReadS($g_aiStopAtkPctNoChangeTime[$LB], $g_sProfileConfigPath, "endbattle", "txtABPercentageChange", 15, "int")
EndFunc
Func ReadConfig_600_30_TS()
IniReadS($g_bEndTSCampsEnable, $g_sProfileConfigPath, "search", "ChkTSSearchCamps2", False, "Bool")
IniReadS($g_iEndTSCampsPct, $g_sProfileConfigPath, "search", "TSEnableAfterArmyCamps2", 100, "int")
EndFunc
Func ReadConfig_600_31()
$g_abCollectorLevelEnabled[6] = 0
For $i = 7 To 12
IniReadS($g_abCollectorLevelEnabled[$i], $g_sProfileConfigPath, "collectors", "lvl" & $i & "Enabled", True, "Bool")
Next
For $i = 6 To 12
IniReadS($g_aiCollectorLevelFill[$i], $g_sProfileConfigPath, "collectors", "lvl" & $i & "fill", 0, "int")
If $g_aiCollectorLevelFill[$i] > 1 Then $g_aiCollectorLevelFill[$i] = 1
Next
IniReadS($g_bCollectorFilterDisable, $g_sProfileConfigPath, "search", "chkDisableCollectorsFilter", False, "Bool")
InireadS($g_iCollectorMatchesMin, $g_sProfileConfigPath, "collectors", "minmatches", $g_iCollectorMatchesMin)
If $g_iCollectorMatchesMin < 1 Or $g_iCollectorMatchesMin > 6 Then $g_iCollectorMatchesMin = 3
IniReadS($g_iCollectorToleranceOffset, $g_sProfileConfigPath, "collectors", "tolerance", 0, "int")
EndFunc
Func ReadConfig_600_32()
IniReadS($iChkTrophyRange, $g_sProfileConfigPath, "search", "TrophyRange", 0, "int")
IniReadS($itxtdropTrophy, $g_sProfileConfigPath, "search", "MinTrophy", 5000, "int")
IniReadS($itxtMaxTrophy, $g_sProfileConfigPath, "search", "MaxTrophy", 5000, "int")
IniReadS($iChkTrophyHeroes, $g_sProfileConfigPath, "search", "chkTrophyHeroes", 0, "int")
IniReadS($iCmbTrophyHeroesPriority, $g_sProfileConfigPath, "search", "cmbTrophyHeroesPriority", 0, "int")
IniReadS($iChkTrophyAtkDead, $g_sProfileConfigPath, "search", "chkTrophyAtkDead", 0, "int")
IniReadS($itxtDTArmyMin, $g_sProfileConfigPath, "search", "DTArmyMin", 70, "int")
EndFunc
Func ReadConfig_600_35()
$ichkDisableSplash = IniRead($g_sProfileConfigPath, "General", "ChkDisableSplash", $ichkDisableSplash)
$ichkVersion = Int(IniRead($g_sProfileConfigPath, "General", "ChkVersion", 1))
IniReadS($ichkDeleteLogs, $g_sProfileConfigPath, "deletefiles", "DeleteLogs", 1, "int")
IniReadS($iDeleteLogsDays, $g_sProfileConfigPath, "deletefiles", "DeleteLogsDays", 2, "int")
IniReadS($ichkDeleteTemp, $g_sProfileConfigPath, "deletefiles", "DeleteTemp", 1, "int")
IniReadS($iDeleteTempDays, $g_sProfileConfigPath, "deletefiles", "DeleteTempDays", 2, "int")
IniReadS($ichkDeleteLoots, $g_sProfileConfigPath, "deletefiles", "DeleteLoots", 1, "int")
IniReadS($iDeleteLootsDays, $g_sProfileConfigPath, "deletefiles", "DeleteLootsDays", 2, "int")
IniReadS($ichkAutoStart, $g_sProfileConfigPath, "general", "AutoStart", 0, "int")
IniReadS($ichkAutoStartDelay, $g_sProfileConfigPath, "general", "AutoStartDelay", 10, "int")
IniReadS($g_bRestarted, $g_sProfileConfigPath, "general", "Restarted", $g_bRestarted, "int")
If $g_bBotLaunchOption_Autostart = True Then $g_bRestarted = True
$ichkLanguage = Int(IniRead($g_sProfileConfigPath, "General", "ChkLanguage", 1))
IniReadS($iDisposeWindows, $g_sProfileConfigPath, "general", "DisposeWindows", 0, "int")
IniReadS($icmbDisposeWindowsPos, $g_sProfileConfigPath, "general", "DisposeWindowsPos", "SNAP-TR")
IniReadS($iWAOffsetX, $g_sProfileConfigPath, "other", "WAOffsetX", "")
IniReadS($iWAOffsetY, $g_sProfileConfigPath, "other", "WAOffsetY", "")
IniReadS($iHideWhenMinimized, $g_sProfileConfigPath, "general", "HideWhenMinimized", $iHideWhenMinimized)
$iUseRandomClick = Int(IniRead($g_sProfileConfigPath, "other", "UseRandomClick", 0))
$iScreenshotType = Int(IniRead($g_sProfileConfigPath, "other", "ScreenshotType", 0))
$ichkScreenshotHideName = Int(IniRead($g_sProfileConfigPath, "other", "ScreenshotHideName", 1))
IniReadS($sTimeWakeUp, $g_sProfileConfigPath, "other", "txtTimeWakeUp", 0, "int")
$ichkSinglePBTForced = Int(IniRead($g_sProfileConfigPath, "other", "chkSinglePBTForced", 0))
$iValueSinglePBTimeForced = Int(IniRead($g_sProfileConfigPath, "other", "ValueSinglePBTimeForced", 18))
$iValuePBTimeForcedExit = Int(IniRead($g_sProfileConfigPath, "other", "ValuePBTimeForcedExit", 15))
$iChkAutoResume = Int(IniRead($g_sProfileConfigPath, "other", "ChkAutoResume", 0))
$iAutoResumeTime = Int(IniRead($g_sProfileConfigPath, "other", "AutoResumeTime", 5))
$ichkFixClanCastle = Int(IniRead($g_sProfileConfigPath, "other", "ChkFixClanCastle", 0))
EndFunc
Func ReadConfig_600_52_1()
$g_bQuickTrainEnable =(IniRead($g_sProfileConfigPath, "other", "ChkUseQTrain", "0") = "1")
IniReadS($g_iQuickTrainArmyNum, $g_sProfileConfigPath, "troop", "QuickTrainArmyNum", -1, "int")
If $g_iQuickTrainArmyNum = -1 Then
Local $iQTArmy[3] = [0,0,0]
IniReadS($iQTArmy[0], $g_sProfileConfigPath, "troop", "QuickTrain1", 1, "int")
IniReadS($iQTArmy[1], $g_sProfileConfigPath, "troop", "QuickTrain2", 0, "int")
IniReadS($iQTArmy[2], $g_sProfileConfigPath, "troop", "QuickTrain3", 0, "int")
$g_iQuickTrainArmyNum = 1
For $i = 0 To 2
If $iQTArmy[$i] = 1 Then
$g_iQuickTrainArmyNum = $i+1
ExitLoop
EndIf
Next
EndIf
EndFunc
Func ReadConfig_600_52_2()
For $T = 0 To $eTroopCount - 1
Local $tempTroopCount, $tempTroopLevel
Switch $T
Case $eTroopBarbarian
IniReadS($tempTroopCount, $g_sProfileConfigPath, "troop", $g_asTroopShortNames[$T], 58, "int")
IniReadS($tempTroopLevel, $g_sProfileConfigPath, "LevelTroop", $g_asTroopShortNames[$T], 1, "int")
Case $eTroopArcher
IniReadS($tempTroopCount, $g_sProfileConfigPath, "troop", $g_asTroopShortNames[$T], 115, "int")
IniReadS($tempTroopLevel, $g_sProfileConfigPath, "LevelTroop", $g_asTroopShortNames[$T], 1, "int")
Case $eTroopGoblin
IniReadS($tempTroopCount, $g_sProfileConfigPath, "troop", $g_asTroopShortNames[$T], 19, "int")
IniReadS($tempTroopLevel, $g_sProfileConfigPath, "LevelTroop", $g_asTroopShortNames[$T], 1, "int")
Case $eTroopGiant
IniReadS($tempTroopCount, $g_sProfileConfigPath, "troop", $g_asTroopShortNames[$T], 4, "int")
IniReadS($tempTroopLevel, $g_sProfileConfigPath, "LevelTroop", $g_asTroopShortNames[$T], 1, "int")
Case $eTroopWallBreaker
IniReadS($tempTroopCount, $g_sProfileConfigPath, "troop", $g_asTroopShortNames[$T], 4, "int")
IniReadS($tempTroopLevel, $g_sProfileConfigPath, "LevelTroop", $g_asTroopShortNames[$T], 1, "int")
Case Else
IniReadS($tempTroopCount, $g_sProfileConfigPath, "troop", $g_asTroopShortNames[$T], 0, "int")
IniReadS($tempTroopLevel, $g_sProfileConfigPath, "LevelTroop", $g_asTroopShortNames[$T], 0, "int")
EndSwitch
$g_aiArmyCompTroops[$T] = $tempTroopCount
$g_aiTrainArmyTroopLevel[$T] = $tempTroopLevel
Next
For $S = 0 To $eSpellCount - 1
IniReadS($g_aiArmyCompSpells[$S], $g_sProfileConfigPath, "Spells", $g_asSpellShortNames[$S], 0, "int")
IniReadS($g_aiTrainArmySpellLevel[$S], $g_sProfileConfigPath, "LevelSpell", $g_asSpellShortNames[$S], 0, "int")
Next
IniReadS($g_iTrainArmyFullTroopPct, $g_sProfileConfigPath, "troop", "fullTroop", 100, "int")
$g_bTotalCampForced =(IniRead($g_sProfileConfigPath, "other", "ChkTotalCampForced", "1") = "1")
$g_iTotalCampForcedValue = Int(IniRead($g_sProfileConfigPath, "other", "ValueTotalCampForced", 220))
$g_bForceBrewSpells =(IniRead($g_sProfileConfigPath, "other", "ChkForceBrewBeforeAttack", "0") = "1")
IniReadS($g_iTotalSpellValue, $g_sProfileConfigPath, "Spells", "SpellFactory", 0, "int")
$g_iTotalSpellValue = Int($g_iTotalSpellValue)
EndFunc
Func ReadConfig_600_54()
IniReadS($g_bCustomTrainOrderEnable, $g_sProfileConfigPath, "troop", "chkTroopOrder", False, "Bool")
For $z = 0 To UBound($g_aiCmbCustomTrainOrder) -1
IniReadS($g_aiCmbCustomTrainOrder[$z], $g_sProfileConfigPath, "troop", "cmbTroopOrder" & $z, -1)
Next
EndFunc
Func ReadConfig_600_56()
$ichkSmartZap = Int(IniRead($g_sProfileConfigPath, "SmartZap", "UseSmartZap", 0))
$ichkEarthQuakeZap = Int(IniRead($g_sProfileConfigPath, "SmartZap", "UseEarthQuakeZap", 0))
$ichkNoobZap = Int(IniRead($g_sProfileConfigPath, "SmartZap", "UseNoobZap", 0))
$ichkSmartZapDB = Int(IniRead($g_sProfileConfigPath, "SmartZap", "ZapDBOnly", 1))
$ichkSmartZapSaveHeroes = Int(IniRead($g_sProfileConfigPath, "SmartZap", "THSnipeSaveHeroes", 1))
$itxtMinDE = Int(IniRead($g_sProfileConfigPath, "SmartZap", "MinDE", 350))
$itxtExpectedDE = Int(IniRead($g_sProfileConfigPath, "SmartZap", "ExpectedDE", 320))
$DebugSmartZap = Int(IniRead($g_sProfileConfigPath, "SmartZap", "DebugSmartZap", 0))
EndFunc
Func ReadConfig_641_1()
IniReadS($g_bCloseWhileTrainingEnable, $g_sProfileConfigPath, "other", "chkCloseWaitEnable", True, "Bool")
IniReadS($g_bCloseWithoutShield, $g_sProfileConfigPath, "other", "chkCloseWaitTrain", False, "Bool")
IniReadS($g_bCloseEmulator, $g_sProfileConfigPath, "other", "btnCloseWaitStop", False, "Bool")
IniReadS($g_bCloseRandom, $g_sProfileConfigPath, "other", "btnCloseWaitStopRandom", False, "Bool")
IniReadS($g_bCloseExactTime, $g_sProfileConfigPath, "other", "btnCloseWaitExact", False, "Bool")
IniReadS($g_bCloseRandomTime, $g_sProfileConfigPath, "other", "btnCloseWaitRandom", True, "Bool")
IniReadS($g_iCloseRandomTimePercent, $g_sProfileConfigPath, "other", "CloseWaitRdmPercent", 10, "int")
IniReadS($g_iCloseMinimumTime, $g_sProfileConfigPath, "other", "MinimumTimeToClose", 2, "int")
IniReadS($g_iTrainClickDelay, $g_sProfileConfigPath, "other", "TrainITDelay", 40, "int")
IniReadS($g_bTrainAddRandomDelayEnable, $g_sProfileConfigPath, "other", "chkAddIdleTime", $g_bTrainAddRandomDelayEnable, "Bool")
IniReadS($g_iTrainAddRandomDelayMin, $g_sProfileConfigPath, "other", "txtAddDelayIdlePhaseTimeMin", $g_iTrainAddRandomDelayMin, "Int")
IniReadS($g_iTrainAddRandomDelayMax, $g_sProfileConfigPath, "other", "txtAddDelayIdlePhaseTimeMax", $g_iTrainAddRandomDelayMax, "Int")
EndFunc
Func IniReadS(ByRef $variable, $PrimaryInputFile, $section, $key, $defaultvalue, $valueType = Default)
Local $defaultvalueTest = "?"
Local $readValue = IniRead($g_sProfileSecondaryInputFileName, $section, $key, $defaultvalueTest)
If $readValue = $defaultvalueTest Then
$readValue = IniRead($PrimaryInputFile, $section, $key, $defaultvalue)
EndIf
Switch $valueType
Case Default
$variable = $readValue
Case "Int"
$variable = Int($readValue)
Case "Bool"
If $readValue = "True" Or $readValue = "1" Then
$variable = True
Else
$variable = False
EndIf
Case Else
$variable = $readValue
EndSwitch
EndFunc
Func saveConfig()
Static $iSaveConfigCount = 0
$iSaveConfigCount += 1
SetDebugLog("saveConfig(), call number " & $iSaveConfigCount)
saveWeakBaseStats()
SaveBuildingConfig()
SaveRegularConfig()
EndFunc
Func SaveBuildingConfig()
SetDebugLog("Save Building Config " & $g_sProfileBuildingPath)
IniWriteS($g_sProfileBuildingPath, "general", "version", GetVersionNormalized($g_sBotVersion))
IniWriteS($g_sProfileBuildingPath, "upgrade", "LabPosX", $aLabPos[0])
IniWriteS($g_sProfileBuildingPath, "upgrade", "LabPosY", $aLabPos[1])
IniWriteS($g_sProfileBuildingPath, "other", "xTownHall", $TownHallPos[0])
IniWriteS($g_sProfileBuildingPath, "other", "yTownHall", $TownHallPos[1])
IniWriteS($g_sProfileBuildingPath, "other", "LevelTownHall", $iTownHallLevel)
IniWriteS($g_sProfileBuildingPath, "other", "xCCPos", $aCCPos[0])
IniWriteS($g_sProfileBuildingPath, "other", "yCCPos", $aCCPos[1])
IniWriteS($g_sProfileBuildingPath, "other", "totalcamp", $TotalCamp)
IniWriteS($g_sProfileBuildingPath, "other", "xKingAltarPos", $KingAltarPos[0])
IniWriteS($g_sProfileBuildingPath, "other", "yKingAltarPos", $KingAltarPos[1])
IniWriteS($g_sProfileBuildingPath, "other", "xQueenAltarPos", $QueenAltarPos[0])
IniWriteS($g_sProfileBuildingPath, "other", "yQueenAltarPos", $QueenAltarPos[1])
IniWriteS($g_sProfileBuildingPath, "other", "xWardenAltarPos", $WardenAltarPos[0])
IniWriteS($g_sProfileBuildingPath, "other", "yWardenAltarPos", $WardenAltarPos[1])
EndFunc
Func SaveRegularConfig()
SetDebugLog("Save Config " & $g_sProfileConfigPath)
Local $hFile = -1
If $g_bChkExtraAlphabets Or $g_bChkExtraChinese Or $g_bChkExtraKorean Then $hFile = FileOpen($g_sProfileConfigPath, $FO_UTF16_LE + $FO_OVERWRITE)
IniWriteS($g_sProfileConfigPath, "general", "version", GetVersionNormalized($g_sBotVersion))
IniWriteS($g_sProfileConfigPath, "general", "threads", $g_iThreads)
IniWriteS($g_sProfileConfigPath, "general", "cmbProfile", _GUICtrlComboBox_GetCurSel($g_hCmbProfile))
IniWriteS($g_sProfileConfigPath, "general", "frmBotPosX", $frmBotPosX)
IniWriteS($g_sProfileConfigPath, "general", "frmBotPosY", $frmBotPosY)
If $HWnD <> 0 Then WinGetAndroidHandle()
IniWriteS($g_sProfileConfigPath, "general", "AndroidPosX", $AndroidPosX)
IniWriteS($g_sProfileConfigPath, "general", "AndroidPosY", $AndroidPosY)
IniWriteS($g_sProfileConfigPath, "general", "frmBotDockedPosX", $frmBotDockedPosX)
IniWriteS($g_sProfileConfigPath, "general", "frmBotDockedPosY", $frmBotDockedPosY)
IniWriteS($g_sProfileConfigPath, "general", "RedrawBotWindowMode", $g_iRedrawBotWindowMode)
SaveConfig_Android()
SaveConfig_600_1()
SaveConfig_600_6()
SaveConfig_600_9()
SaveConfig_600_11()
SaveConfig_600_12()
SaveConfig_600_13()
SaveConfig_600_14()
SaveConfig_600_15()
SaveConfig_600_16()
SaveConfig_600_17()
SaveConfig_600_18()
SaveConfig_600_19()
SaveConfig_600_22()
SaveConfig_600_26()
SaveConfig_600_28()
SaveConfig_600_28_DB()
SaveConfig_600_28_LB()
SaveConfig_600_28_TS()
SaveConfig_600_29()
SaveConfig_600_29_DB()
SaveConfig_600_29_LB()
SaveConfig_600_29_TS()
SaveConfig_600_30()
SaveConfig_600_30_DB()
SaveConfig_600_30_LB()
SaveConfig_600_30_TS()
SaveConfig_600_31()
SaveConfig_600_32()
SaveConfig_600_35()
SaveConfig_600_52_1()
SaveConfig_600_52_2()
SaveConfig_600_54()
SaveConfig_600_56()
SaveConfig_641_1()
SaveConfig_Debug()
SaveConfig_DocOc()
If $hFile <> -1 Then FileClose($hFile)
EndFunc
Func SaveConfig_Android()
ApplyConfig_Android("Save")
IniWriteS($g_sProfileConfigPath, "android", "game.distributor", $g_sAndroidGameDistributor)
IniWriteS($g_sProfileConfigPath, "android", "game.package", $g_sAndroidGamePackage)
IniWriteS($g_sProfileConfigPath, "android", "game.class", $g_sAndroidGameClass)
IniWriteS($g_sProfileConfigPath, "android", "user.distributor", $g_sUserGameDistributor)
IniWriteS($g_sProfileConfigPath, "android", "user.package", $g_sUserGamePackage)
IniWriteS($g_sProfileConfigPath, "android", "user.class", $g_sUserGameClass)
IniWriteS($g_sProfileConfigPath, "android", "check.time.lag.enabled",($g_bAndroidCheckTimeLagEnabled ? "1" : "0"))
IniWriteS($g_sProfileConfigPath, "android", "adb.screencap.timeout.min", $g_iAndroidAdbScreencapTimeoutMin)
IniWriteS($g_sProfileConfigPath, "android", "adb.screencap.timeout.max", $g_iAndroidAdbScreencapTimeoutMax)
IniWriteS($g_sProfileConfigPath, "android", "adb.screencap.timeout.dynamic", $g_iAndroidAdbScreencapTimeoutDynamic)
IniWriteS($g_sProfileConfigPath, "android", "adb.input.enabled",($g_bAndroidAdbInputEnabled ? "1" : "0"))
IniWriteS($g_sProfileConfigPath, "android", "adb.click.enabled",($g_bAndroidAdbClickEnabled ? "1" : "0"))
IniWriteS($g_sProfileConfigPath, "android", "adb.click.group", $g_iAndroidAdbClickGroup)
IniWriteS($g_sProfileConfigPath, "android", "adb.clicks.enabled",($g_bAndroidAdbClicksEnabled ? "1" : "0"))
IniWriteS($g_sProfileConfigPath, "android", "adb.clicks.troop.deploy.size", $g_iAndroidAdbClicksTroopDeploySize)
IniWriteS($g_sProfileConfigPath, "android", "no.focus.tampering",($g_bNoFocusTampering ? "1" : "0"))
IniWriteS($g_sProfileConfigPath, "android", "shield.color", Hex($g_iAndroidShieldColor, 6))
IniWriteS($g_sProfileConfigPath, "android", "shield.transparency", $g_iAndroidShieldTransparency)
IniWriteS($g_sProfileConfigPath, "android", "active.color", Hex($g_iAndroidActiveColor, 6))
IniWriteS($g_sProfileConfigPath, "android", "active.transparency", $g_iAndroidActiveTransparency)
IniWriteS($g_sProfileConfigPath, "android", "inactive.color", Hex($g_iAndroidInactiveColor, 6))
IniWriteS($g_sProfileConfigPath, "android", "inactive.transparency", $g_iAndroidInactiveTransparency)
IniWriteS($g_sProfileConfigPath, "android", "emulator", $g_sAndroidEmulator)
IniWriteS($g_sProfileConfigPath, "android", "instance", $g_sAndroidInstance)
EndFunc
Func SaveConfig_Debug()
ApplyConfig_Debug("Save")
If $g_bDevMode = True Then
IniWriteS($g_sProfileConfigPath, "debug", "debugsetlog", $g_iDebugSetlog)
IniWriteS($g_sProfileConfigPath, "debug", "debugsetclick", $g_iDebugClick)
IniWriteS($g_sProfileConfigPath, "debug", "disablezoomout", $g_iDebugDisableZoomout)
IniWriteS($g_sProfileConfigPath, "debug", "disablevillagecentering", $g_iDebugDisableVillageCentering)
IniWriteS($g_sProfileConfigPath, "debug", "debugdeadbaseimage", $g_iDebugDeadBaseImage)
IniWriteS($g_sProfileConfigPath, "debug", "debugocr", $g_iDebugOcr)
IniWriteS($g_sProfileConfigPath, "debug", "debugimagesave", $g_iDebugImageSave)
IniWriteS($g_sProfileConfigPath, "debug", "debugbuildingpos", $g_iDebugBuildingPos)
IniWriteS($g_sProfileConfigPath, "debug", "debugtrain", $g_iDebugSetlogTrain)
IniWriteS($g_sProfileConfigPath, "debug", "debugresourcesoffset", $g_iDebugResourcesOffset)
IniWriteS($g_sProfileConfigPath, "debug", "continuesearchelixirdebug", $g_iDebugContinueSearchElixir)
IniWriteS($g_sProfileConfigPath, "debug", "debugMilkingIMGmake", $g_iDebugMilkingIMGmake)
IniWriteS($g_sProfileConfigPath, "debug", "debugOCRDonate", $g_iDebugOCRdonate)
IniWriteS($g_sProfileConfigPath, "debug", "debugAttackCSV", $g_iDebugAttackCSV)
IniWriteS($g_sProfileConfigPath, "debug", "debugmakeimgcsv", $g_iDebugMakeIMGCSV)
Else
IniDelete($g_sProfileConfigPath, "debug", "debugsetlog")
IniDelete($g_sProfileConfigPath, "debug", "debugsetclick")
IniDelete($g_sProfileConfigPath, "debug", "disablezoomout")
IniDelete($g_sProfileConfigPath, "debug", "disablevillagecentering")
IniDelete($g_sProfileConfigPath, "debug", "debugdeadbaseimage")
IniDelete($g_sProfileConfigPath, "debug", "debugocr")
IniDelete($g_sProfileConfigPath, "debug", "debugimagesave")
IniDelete($g_sProfileConfigPath, "debug", "debugbuildingpos")
IniDelete($g_sProfileConfigPath, "debug", "debugtrain")
IniDelete($g_sProfileConfigPath, "debug", "debugresourcesoffset")
IniDelete($g_sProfileConfigPath, "debug", "continuesearchelixirdebug")
IniDelete($g_sProfileConfigPath, "debug", "debugMilkingIMGmake")
IniDelete($g_sProfileConfigPath, "debug", "debugOCRDonate")
IniDelete($g_sProfileConfigPath, "debug", "debugAttackCSV")
IniDelete($g_sProfileConfigPath, "debug", "debugmakeimgcsv")
EndIf
EndFunc
Func SaveConfig_600_1()
ApplyConfig_600_1("Save")
IniWriteS($g_sProfileConfigPath, "general", "logstyle", $g_iCmbLogDividerOption)
IniWriteS($g_sProfileConfigPath, "general", "LogDividerY", $g_iLogDividerY)
IniWriteS($g_sProfileConfigPath, "general", "Background", $g_bChkBackgroundMode ? 1 : 0)
EndFunc
Func SaveConfig_600_6()
ApplyConfig_600_6("Save")
IniWriteS($g_sProfileConfigPath, "general", "BotStop", $g_bChkBotStop ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "general", "Command", $g_iCmbBotCommand)
IniWriteS($g_sProfileConfigPath, "general", "Cond", $g_iCmbBotCond)
IniWriteS($g_sProfileConfigPath, "general", "Hour", $g_iCmbHoursStop)
IniWriteS($g_sProfileConfigPath, "other", "minrestartgold", $g_iTxtRestartGold)
IniWriteS($g_sProfileConfigPath, "other", "minrestartelixir", $g_iTxtRestartElixir)
IniWriteS($g_sProfileConfigPath, "other", "minrestartdark", $g_iTxtRestartDark)
IniWriteS($g_sProfileConfigPath, "other", "chkTrap", $g_bChkTrap ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "other", "chkCollect", $g_bChkCollect ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "other", "chkTombstones", $g_bChkTombstones ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "other", "chkCleanYard", $g_bChkCleanYard ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "other", "chkGemsBox", $g_bChkGemsBox ? 1 : 0)
EndFunc
Func SaveConfig_600_9()
ApplyConfig_600_9("Save")
IniWriteS($g_sProfileConfigPath, "Unbreakable", "chkUnbreakable", $g_iUnbrkMode)
IniWriteS($g_sProfileConfigPath, "Unbreakable", "UnbreakableWait", $g_iUnbrkWait)
IniWriteS($g_sProfileConfigPath, "Unbreakable", "minUnBrkgold", $g_iUnbrkMinGold)
IniWriteS($g_sProfileConfigPath, "Unbreakable", "minUnBrkelixir", $g_iUnbrkMinElixir)
IniWriteS($g_sProfileConfigPath, "Unbreakable", "minUnBrkdark", $g_iUnbrkMinDark)
IniWriteS($g_sProfileConfigPath, "Unbreakable", "maxUnBrkgold", $g_iUnbrkMaxGold)
IniWriteS($g_sProfileConfigPath, "Unbreakable", "maxUnBrkelixir", $g_iUnbrkMaxElixir)
IniWriteS($g_sProfileConfigPath, "Unbreakable", "maxUnBrkdark", $g_iUnbrkMaxDark)
EndFunc
Func SaveConfig_600_11()
ApplyConfig_600_11("Save")
IniWriteS($g_sProfileConfigPath, "planned", "RequestHoursEnable", $g_bRequestTroopsEnable ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "donate", "txtRequest", $g_sRequestTroopsText)
Local $string = ""
For $i = 0 To 23
$string &=($g_abRequestCCHours[$i] ? "1" : "0") & "|"
Next
IniWriteS($g_sProfileConfigPath, "planned", "RequestHours", $string)
EndFunc
Func SaveConfig_600_12()
ApplyConfig_600_12("Save")
IniWriteS($g_sProfileConfigPath, "donate", "Doncheck", $g_bChkDonate ? 1 : 0)
For $i = 0 To $eTroopCount-1 + $g_iCustomDonateConfigs
Local $sIniName = ""
If $i >= $eTroopBarbarian And $i <= $eTroopBowler Then
$sIniName = StringReplace($g_asTroopNamesPlural[$i], " ", "")
ElseIf $i = $eCustomA Then
$sIniName = "CustomA"
ElseIf $i = $eCustomB Then
$sIniName = "CustomB"
EndIf
IniWriteS($g_sProfileConfigPath, "donate", "chkDonate" & $sIniName, $g_abChkDonateTroop[$i] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "donate", "chkDonateAll" & $sIniName, $g_abChkDonateAllTroop[$i] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "donate", "txtDonate" & $sIniName, StringReplace($g_asTxtDonateTroop[$i], @CRLF, "|"))
IniWriteS($g_sProfileConfigPath, "donate", "txtBlacklist" & $sIniName, StringReplace($g_asTxtBlacklistTroop[$i], @CRLF, "|"))
Next
For $i = 0 To $eSpellCount - 1
If $i <> $eSpellClone Then
Local $sIniName = $g_asSpellNames[$i] & "Spells"
IniWriteS($g_sProfileConfigPath, "donate", "chkDonate" & $sIniName, $g_abChkDonateSpell[$i] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "donate", "chkDonateAll" & $sIniName, $g_abChkDonateAllSpell[$i] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "donate", "txtDonate" & $sIniName, StringReplace($g_asTxtDonateSpell[$i], @CRLF, "|"))
IniWriteS($g_sProfileConfigPath, "donate", "txtBlacklist" & $sIniName, StringReplace($g_asTxtBlacklistSpell[$i], @CRLF, "|"))
EndIf
Next
For $i = 0 To 2
IniWriteS($g_sProfileConfigPath, "donate", "cmbDonateCustomA" & $i+1, $g_aiDonateCustomTrpNumA[$i][0])
IniWriteS($g_sProfileConfigPath, "donate", "txtDonateCustomA" & $i+1, $g_aiDonateCustomTrpNumA[$i][1])
IniWriteS($g_sProfileConfigPath, "donate", "cmbDonateCustomB" & $i+1, $g_aiDonateCustomTrpNumB[$i][0])
IniWriteS($g_sProfileConfigPath, "donate", "txtDonateCustomB" & $i+1, $g_aiDonateCustomTrpNumB[$i][1])
Next
IniWriteS($g_sProfileConfigPath, "donate", "chkExtraAlphabets", $g_bChkExtraAlphabets ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "donate", "chkExtraChinese", $g_bChkExtraChinese ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "donate", "chkExtraKorean", $g_bChkExtraKorean ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "donate", "txtBlacklist", StringReplace($g_sTxtGeneralBlacklist, @CRLF, "|"))
EndFunc
Func SaveConfig_600_13()
ApplyConfig_600_13("Save")
IniWriteS($g_sProfileConfigPath, "planned", "DonateHoursEnable", $g_bDonateHoursEnable ? 1 : 0)
Local $string = ""
For $i = 0 To 23
$string &=($g_abDonateHours[$i] ? "1" : "0") & "|"
Next
IniWriteS($g_sProfileConfigPath, "planned", "DonateHours", $string)
IniWriteS($g_sProfileConfigPath, "donate", "cmbFilterDonationsCC", $g_iCmbDonateFilter)
IniWriteS($g_sProfileConfigPath, "donate", "SkipDonateNearFulLTroopsEnable", $g_bDonateSkipNearFullEnable ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "donate", "SkipDonateNearFulLTroopsPercentual", $g_iDonateSkipNearFullPercent)
EndFunc
Func SaveConfig_600_14()
ApplyConfig_600_14("Save")
IniWriteS($g_sProfileBuildingPath, "upgrade", "upgradetroops", $g_bAutoLabUpgradeEnable ? 1 : 0)
IniWriteS($g_sProfileBuildingPath, "upgrade", "upgradetroopname", $g_iCmbLaboratory)
IniWrite($g_sProfileBuildingPath, "upgrade", "upgradelabtime", $sLabUpgradeTime)
EndFunc
Func SaveConfig_600_15()
ApplyConfig_600_15("Save")
IniWriteS($g_sProfileConfigPath, "upgrade", "UpgradeKing", $g_bUpgradeKingEnable ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "upgrade", "UpgradeQueen", $g_bUpgradeQueenEnable ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "upgrade", "UpgradeWarden", $g_bUpgradeWardenEnable ? 1 : 0)
EndFunc
Func SaveConfig_600_16()
ApplyConfig_600_16("Save")
For $iz = 0 To UBound($g_avBuildingUpgrades, 1) - 1
IniWrite($g_sProfileBuildingPath, "upgrade", "xupgrade" & $iz, $g_avBuildingUpgrades[$iz][0])
IniWrite($g_sProfileBuildingPath, "upgrade", "yupgrade" & $iz, $g_avBuildingUpgrades[$iz][1])
IniWrite($g_sProfileBuildingPath, "upgrade", "upgradevalue" & $iz, $g_avBuildingUpgrades[$iz][2])
IniWrite($g_sProfileBuildingPath, "upgrade", "upgradetype" & $iz, $g_avBuildingUpgrades[$iz][3])
IniWrite($g_sProfileBuildingPath, "upgrade", "upgradename" & $iz, $g_avBuildingUpgrades[$iz][4])
IniWrite($g_sProfileBuildingPath, "upgrade", "upgradelevel" & $iz, $g_avBuildingUpgrades[$iz][5])
IniWrite($g_sProfileBuildingPath, "upgrade", "upgradetime" & $iz, $g_avBuildingUpgrades[$iz][6])
IniWrite($g_sProfileBuildingPath, "upgrade", "upgradeend" & $iz, $g_avBuildingUpgrades[$iz][7])
IniWrite($g_sProfileBuildingPath, "upgrade", "upgradechk" & $iz, $g_abBuildingUpgradeEnable[$iz] ? 1 : 0)
IniWrite($g_sProfileBuildingPath, "upgrade", "upgraderepeat" & $iz, $g_abUpgradeRepeatEnable[$iz] ? 1 : 0)
IniWrite($g_sProfileBuildingPath, "upgrade", "upgradestatusicon" & $iz, $g_aiPicUpgradeStatus[$iz])
Next
IniWriteS($g_sProfileConfigPath, "upgrade", "minupgrgold", $g_iUpgradeMinGold)
IniWriteS($g_sProfileConfigPath, "upgrade", "minupgrelixir", $g_iUpgradeMinElixir)
IniWriteS($g_sProfileConfigPath, "upgrade", "minupgrdark", $g_iUpgradeMinDark)
EndFunc
Func SaveConfig_600_17()
ApplyConfig_600_17("Save")
IniWriteS($g_sProfileConfigPath, "upgrade", "auto-wall", $g_bAutoUpgradeWallsEnable ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "upgrade", "minwallgold", $g_iUpgradeWallMinGold)
IniWriteS($g_sProfileConfigPath, "upgrade", "minwallelixir", $g_iUpgradeWallMinElixir)
IniWriteS($g_sProfileConfigPath, "upgrade", "use-storage", $g_iUpgradeWallLootType)
IniWriteS($g_sProfileConfigPath, "upgrade", "savebldr", $g_bUpgradeWallSaveBuilder ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "upgrade", "walllvl", $g_iCmbUpgradeWallsLevel)
For $i = 4 To 12
IniWriteS($g_sProfileConfigPath, "Walls", "Wall" & StringFormat("%02d", $i), $g_aiWallsCurrentCount[$i])
Next
IniWriteS($g_sProfileConfigPath, "upgrade", "WallCost", $g_iWallCost)
EndFunc
Func SaveConfig_600_18()
ApplyConfig_600_18("Save")
IniWriteS($g_sProfileConfigPath, "notify", "PBEnabled", $g_bNotifyPBEnable ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "notify", "TGEnabled", $g_bNotifyTGEnable ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "notify", "PBToken", $g_sNotifyPBToken)
IniWriteS($g_sProfileConfigPath, "notify", "TGToken", $g_sNotifyTGToken)
IniWriteS($g_sProfileConfigPath, "notify", "PBRemote", $g_bNotifyRemoteEnable ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "notify", "DeleteAllPBPushes", $g_bNotifyDeleteAllPushesOnStart ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "notify", "DeleteOldPBPushes", $g_bNotifyDeletePushesOlderThan ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "notify", "HoursPushBullet", $g_iNotifyDeletePushesOlderThanHours)
IniWriteS($g_sProfileConfigPath, "notify", "Origin", $g_sNotifyOrigin)
IniWriteS($g_sProfileConfigPath, "notify", "AlertPBVMFound", $g_bNotifyAlertMatchFound ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "notify", "AlertPBLastRaid", $g_bNotifyAlerLastRaidIMG ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "notify", "AlertPBWallUpgrade", $g_bNotifyAlertUpgradeWalls ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "notify", "AlertPBOOS", $g_bNotifyAlertOutOfSync ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "notify", "AlertPBVBreak", $g_bNotifyAlertTakeBreak ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "notify", "AlertPBOtherDevice", $g_bNotifyAlertAnotherDevice ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "notify", "AlertPBLastRaidTxt", $g_bNotifyAlerLastRaidTXT ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "notify", "AlertPBCampFull", $g_bNotifyAlertCampFull ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "notify", "AlertPBVillage", $g_bNotifyAlertVillageReport ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "notify", "AlertPBLastAttack", $g_bNotifyAlertLastAttack ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "notify", "AlertBuilderIdle", $g_bNotifyAlertBulderIdle ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "notify", "AlertPBMaintenance", $g_bNotifyAlertMaintenance ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "notify", "AlertPBBAN", $g_bNotifyAlertBAN ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "notify", "AlertPBUpdate", $g_bNotifyAlertBOTUpdate ? 1 : 0)
EndFunc
Func SaveConfig_600_19()
ApplyConfig_600_19("Save")
IniWrite($g_sProfileConfigPath, "notify", "NotifyHoursEnable", $g_bNotifyScheduleHoursEnable ? 1 : 0)
Local $string = ""
For $i = 0 To 23
$string &=($g_abNotifyScheduleHours[$i] ? "1" : "0") & "|"
Next
IniWrite($g_sProfileConfigPath, "notify", "NotifyHours", $string)
IniWrite($g_sProfileConfigPath, "notify", "NotifyWeekDaysEnable", $g_bNotifyScheduleWeekDaysEnable ? 1 : 0)
Local $string = ""
For $i = 0 To 6
$string &=($g_abNotifyScheduleWeekDays[$i] ? "1" : "0") & "|"
Next
IniWrite($g_sProfileConfigPath, "notify", "NotifyWeekDays", $string)
EndFunc
Func SaveConfig_600_22()
ApplyConfig_600_22("Save")
Local $string = ""
For $i = 0 To 23
$string &=($g_abBoostBarracksHours[$i] ? "1" : "0") & "|"
Next
IniWriteS($g_sProfileConfigPath, "planned", "BoostBarracksHours", $string)
EndFunc
Func SaveConfig_600_26()
ApplyConfig_600_26("Save")
IniWriteS($g_sProfileConfigPath, "search", "BullyMode", $g_abAttackTypeEnable[$TB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "ATBullyMode", $g_iAtkTBEnableCount)
IniWriteS($g_sProfileConfigPath, "search", "YourTH", $g_iAtkTBMaxTHLevel)
IniWriteS($g_sProfileConfigPath, "search", "THBullyAttackMode", $g_iAtkTBMode)
EndFunc
Func SaveConfig_600_28()
ApplyConfig_600_28("Save")
IniWriteS($g_sProfileConfigPath, "search", "reduction", $g_bSearchReductionEnable ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "reduceCount", $g_iSearchReductionCount)
IniWriteS($g_sProfileConfigPath, "search", "reduceGold", $g_iSearchReductionGold)
IniWriteS($g_sProfileConfigPath, "search", "reduceElixir", $g_iSearchReductionElixir)
IniWriteS($g_sProfileConfigPath, "search", "reduceGoldPlusElixir", $g_iSearchReductionGoldPlusElixir)
IniWriteS($g_sProfileConfigPath, "search", "reduceDark", $g_iSearchReductionDark)
IniWriteS($g_sProfileConfigPath, "search", "reduceTrophy", $g_iSearchReductionTrophy)
IniWriteS($g_sProfileConfigPath, "other", "VSDelay", $g_iSearchDelayMin)
IniWriteS($g_sProfileConfigPath, "other", "MaxVSDelay", $g_iSearchDelayMax)
IniWriteS($g_sProfileConfigPath, "general", "attacknow", $g_bSearchAttackNowEnable ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "general", "attacknowdelay", $g_iSearchAttackNowDelay)
IniWriteS($g_sProfileConfigPath, "search", "ChkRestartSearchLimit", $g_bSearchRestartEnable ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "RestartSearchLimit", $g_iSearchRestartLimit)
IniWriteS($g_sProfileConfigPath, "general", "AlertSearch", $g_bSearchAlertMe ? 1 : 0)
EndFunc
Func SaveConfig_600_28_DB()
ApplyConfig_600_28_DB("Save")
IniWriteS($g_sProfileConfigPath, "search", "DBcheck", $g_abAttackTypeEnable[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "ChkDBSearchSearches", $g_abSearchSearchesEnable[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "DBEnableAfterCount", $g_aiSearchSearchesMin[$DB])
IniWriteS($g_sProfileConfigPath, "search", "DBEnableBeforeCount", $g_aiSearchSearchesMax[$DB])
IniWriteS($g_sProfileConfigPath, "search", "ChkDBSearchTropies", $g_abSearchTropiesEnable[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "DBEnableAfterTropies", $g_aiSearchTrophiesMin[$DB])
IniWriteS($g_sProfileConfigPath, "search", "DBEnableBeforeTropies", $g_aiSearchTrophiesMax[$DB])
IniWriteS($g_sProfileConfigPath, "search", "ChkDBSearchCamps", $g_abSearchCampsEnable[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "DBEnableAfterArmyCamps", $g_aiSearchCampsPct[$DB])
IniWriteS($g_sProfileConfigPath, "attack", "DBKingWait", $iHeroWaitAttackNoBit[$DB][0])
IniWriteS($g_sProfileConfigPath, "attack", "DBQueenWait", $iHeroWaitAttackNoBit[$DB][1])
IniWriteS($g_sProfileConfigPath, "attack", "DBWardenWait", $iHeroWaitAttackNoBit[$DB][2])
IniWriteS($g_sProfileConfigPath, "search", "ChkDBSpellsWait", $g_abSearchSpellsWaitEnable[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "ChkDBCastleSpellWait", $g_abSearchCastleSpellsWaitEnable[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "cmbDBWaitForCastleSpell", $g_aiSearchCastleSpellsWaitRegular[$DB])
IniWriteS($g_sProfileConfigPath, "search", "cmbDBWaitForCastleSpell2", $g_aiSearchCastleSpellsWaitDark[$DB])
IniWriteS($g_sProfileConfigPath, "search", "ChkDBCastleTroopsWait", $g_abSearchCastleTroopsWaitEnable[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "DBMeetGE", $g_aiFilterMeetGE[$DB])
IniWriteS($g_sProfileConfigPath, "search", "DBsearchGold", $g_aiFilterMinGold[$DB])
IniWriteS($g_sProfileConfigPath, "search", "DBsearchElixir", $g_aiFilterMinElixir[$DB])
IniWriteS($g_sProfileConfigPath, "search", "DBsearchGoldPlusElixir", $g_aiFilterMinGoldPlusElixir[$DB])
IniWriteS($g_sProfileConfigPath, "search", "DBMeetDE", $g_abFilterMeetDEEnable[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "DBsearchDark", $g_aiFilterMeetDEMin[$DB])
IniWriteS($g_sProfileConfigPath, "search", "DBMeetTrophy", $g_abFilterMeetTrophyEnable[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "DBsearchTrophy", $g_aiFilterMeetTrophyMin[$DB])
IniWriteS($g_sProfileConfigPath, "search", "DBMeetTH", $g_abFilterMeetTH[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "DBTHLevel", $g_aiFilterMeetTHMin[$DB])
IniWriteS($g_sProfileConfigPath, "search", "DBMeetTHO", $g_abFilterMeetTHOutsideEnable[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "DBCheckMortar", $g_abFilterMaxMortarEnable[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "DBCheckWizTower", $g_abFilterMaxWizTowerEnable[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "DBCheckAirDefense", $g_abFilterMaxAirDefenseEnable[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "DBCheckXBow", $g_abFilterMaxXBowEnable[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "DBCheckInferno", $g_abFilterMaxInfernoEnable[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "DBCheckEagle", $g_abFilterMaxEagleEnable[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "DBWeakMortar", $g_aiFilterMaxMortarLevel[$DB])
IniWriteS($g_sProfileConfigPath, "search", "DBWeakWizTower", $g_aiFilterMaxWizTowerLevel[$DB])
IniWriteS($g_sProfileConfigPath, "search", "DBWeakAirDefense", $g_aiFilterMaxAirDefenseLevel[$DB])
IniWriteS($g_sProfileConfigPath, "search", "DBWeakXBow", $g_aiFilterMaxXBowLevel[$DB])
IniWriteS($g_sProfileConfigPath, "search", "DBWeakInferno", $g_aiFilterMaxInfernoLevel[$DB])
IniWriteS($g_sProfileConfigPath, "search", "DBWeakEagle", $g_aiFilterMaxEagleLevel[$DB])
IniWriteS($g_sProfileConfigPath, "search", "DBMeetOne", $g_abFilterMeetOneConditionEnable[$DB] ? 1 : 0)
EndFunc
Func SaveConfig_600_28_LB()
ApplyConfig_600_28_LB("Save")
IniWriteS($g_sProfileConfigPath, "search", "ABcheck", $g_abAttackTypeEnable[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "ChkABSearchSearches", $g_abSearchSearchesEnable[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "ABEnableAfterCount", $g_aiSearchSearchesMin[$LB])
IniWriteS($g_sProfileConfigPath, "search", "ABEnableBeforeCount", $g_aiSearchSearchesMax[$LB])
IniWriteS($g_sProfileConfigPath, "search", "ChkABSearchTropies", $g_abSearchTropiesEnable[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "ABEnableAfterTropies", $g_aiSearchTrophiesMin[$LB])
IniWriteS($g_sProfileConfigPath, "search", "ABEnableBeforeTropies", $g_aiSearchTrophiesMax[$LB])
IniWriteS($g_sProfileConfigPath, "search", "ChkABSearchCamps", $g_abSearchCampsEnable[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "ABEnableAfterArmyCamps", $g_aiSearchCampsPct[$LB])
IniWriteS($g_sProfileConfigPath, "attack", "ABKingWait", $iHeroWaitAttackNoBit[$LB][0])
IniWriteS($g_sProfileConfigPath, "attack", "ABQueenWait", $iHeroWaitAttackNoBit[$LB][1])
IniWriteS($g_sProfileConfigPath, "attack", "ABWardenWait", $iHeroWaitAttackNoBit[$LB][2])
IniWriteS($g_sProfileConfigPath, "search", "ChkABSpellsWait", $g_abSearchSpellsWaitEnable[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "ChkABCastleSpellWait", $g_abSearchCastleSpellsWaitEnable[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "cmbABWaitForCastleSpell", $g_aiSearchCastleSpellsWaitRegular[$LB])
IniWriteS($g_sProfileConfigPath, "search", "cmbABWaitForCastleSpell2", $g_aiSearchCastleSpellsWaitDark[$LB])
IniWriteS($g_sProfileConfigPath, "search", "ChkABCastleTroopsWait", $g_abSearchCastleTroopsWaitEnable[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "ABMeetGE", $g_aiFilterMeetGE[$LB])
IniWriteS($g_sProfileConfigPath, "search", "ABsearchGold", $g_aiFilterMinGold[$LB])
IniWriteS($g_sProfileConfigPath, "search", "ABsearchElixir", $g_aiFilterMinElixir[$LB])
IniWriteS($g_sProfileConfigPath, "search", "ABsearchGoldPlusElixir", $g_aiFilterMinGoldPlusElixir[$LB])
IniWriteS($g_sProfileConfigPath, "search", "ABMeetDE", $g_abFilterMeetDEEnable[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "ABsearchDark", $g_aiFilterMeetDEMin[$LB])
IniWriteS($g_sProfileConfigPath, "search", "ABMeetTrophy", $g_abFilterMeetTrophyEnable[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "ABsearchTrophy", $g_aiFilterMeetTrophyMin[$LB])
IniWriteS($g_sProfileConfigPath, "search", "ABMeetTH", $g_abFilterMeetTH[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "ABTHLevel", $g_aiFilterMeetTHMin[$LB])
IniWriteS($g_sProfileConfigPath, "search", "ABMeetTHO", $g_abFilterMeetTHOutsideEnable[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "ABCheckMortar", $g_abFilterMaxMortarEnable[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "ABCheckWizTower", $g_abFilterMaxWizTowerEnable[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "ABCheckAirDefense", $g_abFilterMaxAirDefenseEnable[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "ABCheckXBow", $g_abFilterMaxXBowEnable[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "ABCheckInferno", $g_abFilterMaxInfernoEnable[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "ABCheckEagle", $g_abFilterMaxEagleEnable[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "ABWeakMortar", $g_aiFilterMaxMortarLevel[$LB])
IniWriteS($g_sProfileConfigPath, "search", "ABWeakWizTower", $g_aiFilterMaxWizTowerLevel[$LB])
IniWriteS($g_sProfileConfigPath, "search", "ABWeakAirDefense", $g_aiFilterMaxAirDefenseLevel[$LB])
IniWriteS($g_sProfileConfigPath, "search", "ABWeakXBow", $g_aiFilterMaxXBowLevel[$LB])
IniWriteS($g_sProfileConfigPath, "search", "ABWeakInferno", $g_aiFilterMaxInfernoLevel[$LB])
IniWriteS($g_sProfileConfigPath, "search", "ABWeakEagle", $g_aiFilterMaxEagleLevel[$LB])
IniWriteS($g_sProfileConfigPath, "search", "ABMeetOne", $g_abFilterMeetOneConditionEnable[$LB] ? 1 : 0)
EndFunc
Func SaveConfig_600_28_TS()
ApplyConfig_600_28_TS("Save")
IniWriteS($g_sProfileConfigPath, "search", "TScheck", $g_abAttackTypeEnable[$TS] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "ChkTSSearchSearches", $g_abSearchSearchesEnable[$TS] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "TSEnableAfterCount", $g_aiSearchSearchesMin[$TS])
IniWriteS($g_sProfileConfigPath, "search", "TSEnableBeforeCount", $g_aiSearchSearchesMax[$TS])
IniWriteS($g_sProfileConfigPath, "search", "ChkTSSearchTropies", $g_abSearchTropiesEnable[$TS] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "TSEnableAfterTropies", $g_aiSearchTrophiesMin[$TS])
IniWriteS($g_sProfileConfigPath, "search", "TSEnableBeforeTropies", $g_aiSearchTrophiesMax[$TS])
IniWriteS($g_sProfileConfigPath, "search", "ChkTSSearchCamps", $g_abSearchCampsEnable[$TS] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "TSEnableAfterArmyCamps", $g_aiSearchCampsPct[$TS])
IniWriteS($g_sProfileConfigPath, "search", "TSMeetGE", $g_aiFilterMeetGE[$TS])
IniWriteS($g_sProfileConfigPath, "search", "TSsearchGold", $g_aiFilterMinGold[$TS])
IniWriteS($g_sProfileConfigPath, "search", "TSsearchElixir", $g_aiFilterMinElixir[$TS])
IniWriteS($g_sProfileConfigPath, "search", "TSsearchGoldPlusElixir", $g_aiFilterMinGoldPlusElixir[$TS])
IniWriteS($g_sProfileConfigPath, "search", "TSMeetDE", $g_abFilterMeetDEEnable[$TS] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "TSsearchDark", $g_aiFilterMeetDEMin[$TS])
IniWriteS($g_sProfileConfigPath, "search", "SWTtiles", $g_iAtkTSAddTilesWhileTrain)
IniWriteS($g_sProfileConfigPath, "search", "THaddTiles", $g_iAtkTSAddTilesFullTroops)
EndFunc
Func SaveConfig_600_29()
ApplyConfig_600_29("Save")
IniWriteS($g_sProfileConfigPath, "attack", "ActivateKQ", $iActivateKQCondition)
IniWriteS($g_sProfileConfigPath, "attack", "delayActivateKQ", $delayActivateKQ)
IniWriteS($g_sProfileConfigPath, "attack", "ActivateWarden", $iActivateWardenCondition)
IniWriteS($g_sProfileConfigPath, "attack", "delayActivateW", $delayActivateW)
IniWriteS($g_sProfileConfigPath, "planned", "chkAttackPlannerEnable", $ichkAttackPlannerEnable)
IniWriteS($g_sProfileConfigPath, "planned", "chkAttackPlannerCloseCoC", $ichkAttackPlannerCloseCoC)
IniWriteS($g_sProfileConfigPath, "planned", "chkAttackPlannerCloseAll", $ichkAttackPlannerCloseAll)
IniWriteS($g_sProfileConfigPath, "planned", "chkAttackPlannerRandom", $ichkAttackPlannerRandom)
IniWriteS($g_sProfileConfigPath, "planned", "cmbAttackPlannerRandom", $icmbAttackPlannerRandom)
IniWriteS($g_sProfileConfigPath, "planned", "chkAttackPlannerDayLimit", $ichkAttackPlannerDayLimit)
IniWriteS($g_sProfileConfigPath, "planned", "cmbAttackPlannerDayMin", $icmbAttackPlannerDayMin)
IniWriteS($g_sProfileConfigPath, "planned", "cmbAttackPlannerDayMax", $icmbAttackPlannerDayMax)
Local $string = ""
For $i = 0 To 6
$string &= $iPlannedAttackWeekDays[$i] & "|"
Next
IniWriteS($g_sProfileConfigPath, "planned", "attackDays", $string)
Local $string = ""
For $i = 0 To 23
$string &= $iPlannedattackHours[$i] & "|"
Next
IniWriteS($g_sProfileConfigPath, "planned", "attackHours", $string)
IniWriteS($g_sProfileConfigPath, "planned", "DropCCEnable", $iPlannedDropCCHoursEnable)
IniWriteS($g_sProfileConfigPath, "ClanClastle", "BalanceCC", $iChkUseCCBalanced)
IniWriteS($g_sProfileConfigPath, "ClanClastle", "BalanceCCDonated", $iCmbCCDonated)
IniWriteS($g_sProfileConfigPath, "ClanClastle", "BalanceCCReceived", $iCmbCCReceived)
Local $string = ""
For $i = 0 To 23
$string &= $iPlannedDropCCHours[$i] & "|"
Next
IniWriteS($g_sProfileConfigPath, "planned", "DropCCHours", $string)
EndFunc
Func SaveConfig_600_29_DB()
ApplyConfig_600_29_DB("Save")
IniWriteS($g_sProfileConfigPath, "attack", "DBAtkAlgorithm", $g_aiAttackAlgorithm[$DB])
IniWriteS($g_sProfileConfigPath, "attack", "DBSelectTroop", $g_aiAttackTroopSelection[$DB])
IniWriteS($g_sProfileConfigPath, "attack", "DBKingAtk", BitAND($g_aiAttackUseHeroes[$DB], $eHeroKing))
IniWriteS($g_sProfileConfigPath, "attack", "DBQueenAtk", BitAND($g_aiAttackUseHeroes[$DB], $eHeroQueen))
IniWriteS($g_sProfileConfigPath, "attack", "DBWardenAtk", BitAND($g_aiAttackUseHeroes[$DB], $eHeroWarden))
IniWriteS($g_sProfileConfigPath, "attack", "DBDropCC", $g_abAttackDropCC[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "DBLightSpell", $g_abAttackUseLightSpell[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "DBHealSpell", $g_abAttackUseHealSpell[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "DBRageSpell", $g_abAttackUseRageSpell[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "DBJumpSpell", $g_abAttackUseJumpSpell[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "DBFreezeSpell", $g_abAttackUseFreezeSpell[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "DBPoisonSpell", $g_abAttackUsePoisonSpell[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "DBEarthquakeSpell", $g_abAttackUseEarthquakeSpell[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "DBHasteSpell", $g_abAttackUseHasteSpell[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "DBCloneSpell", $g_abAttackUseCloneSpell[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "DBSkeletonSpell", $g_abAttackUseSkeletonSpell[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "THSnipeBeforeDBEnable", $g_bTHSnipeBeforeEnable[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "THSnipeBeforeDBTiles", $g_iTHSnipeBeforeTiles[$DB])
IniWriteS($g_sProfileConfigPath, "attack", "THSnipeBeforeDBScript", $g_iTHSnipeBeforeScript[$DB])
SaveConfig_600_29_DB_Standard()
SaveConfig_600_29_DB_Scripted()
SaveConfig_600_29_DB_Milking()
EndFunc
Func SaveConfig_600_29_DB_Standard()
ApplyConfig_600_29_DB_Standard("Save")
IniWriteS($g_sProfileConfigPath, "attack", "DBStandardAlgorithm", $g_aiAttackStdDropOrder[$DB])
IniWriteS($g_sProfileConfigPath, "attack", "DBDeploy", $g_aiAttackStdDropSides[$DB])
IniWriteS($g_sProfileConfigPath, "attack", "DBUnitD", $g_aiAttackStdUnitDelay[$DB])
IniWriteS($g_sProfileConfigPath, "attack", "DBWaveD", $g_aiAttackStdWaveDelay[$DB])
IniWriteS($g_sProfileConfigPath, "attack", "DBRandomSpeedAtk", $g_abAttackStdRandomizeDelay[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "DBSmartAttackRedArea", $g_abAttackStdSmartAttack[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "DBSmartAttackDeploy", $g_aiAttackStdSmartDeploy[$DB])
IniWriteS($g_sProfileConfigPath, "attack", "DBSmartAttackGoldMine", $g_abAttackStdSmartNearCollectors[$DB][0] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "DBSmartAttackElixirCollector", $g_abAttackStdSmartNearCollectors[$DB][1] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "DBSmartAttackDarkElixirDrill", $g_abAttackStdSmartNearCollectors[$DB][2] ? 1 : 0)
EndFunc
Func SaveConfig_600_29_DB_Scripted()
ApplyConfig_600_29_DB_Scripted("Save")
IniWriteS($g_sProfileConfigPath, "attack", "RedlineRoutineDB", $g_aiAttackScrRedlineRoutine[$DB])
IniWriteS($g_sProfileConfigPath, "attack", "DroplineEdgeDB", $g_aiAttackScrDroplineEdge[$DB])
IniWriteS($g_sProfileConfigPath, "attack", "ScriptDB", $g_sAttackScrScriptName[$DB])
EndFunc
Func SaveConfig_600_29_DB_Milking()
ApplyConfig_600_29_DB_Milking("Save")
IniWriteS($g_sProfileConfigPath, "MilkingAttack", "MilkAttackType", $g_iMilkAttackType)
Local $string = ""
For $i = 0 To 8
$string &= $g_aiMilkFarmElixirParam[$i] & "|"
Next
IniWriteS($g_sProfileConfigPath, "MilkingAttack", "LocateElixirLevel", $string)
IniWriteS($g_sProfileConfigPath, "MilkingAttack", "LocateElixir", $g_bMilkFarmLocateElixir ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "MilkingAttack", "LocateMine", $g_bMilkFarmLocateMine ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "MilkingAttack", "MineParam", $g_iMilkFarmMineParam)
IniWriteS($g_sProfileConfigPath, "MilkingAttack", "LocateDrill", $g_bMilkFarmLocateDrill ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "MilkingAttack", "DrillParam", $g_iMilkFarmDrillParam)
IniWriteS($g_sProfileConfigPath, "MilkingAttack", "MaxTiles", $g_iMilkFarmResMaxTilesFromBorder)
IniWriteS($g_sProfileConfigPath, "MilkingAttack", "AttackElixir", $g_bMilkFarmAttackElixirExtractors ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "MilkingAttack", "AttackMine", $g_bMilkFarmAttackGoldMines ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "MilkingAttack", "AttackDrill", $g_bMilkFarmAttackDarkDrills ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "MilkingAttack", "LimitGold", $g_iMilkFarmLimitGold)
IniWriteS($g_sProfileConfigPath, "MilkingAttack", "LimitElixir", $g_iMilkFarmLimitElixir)
IniWriteS($g_sProfileConfigPath, "MilkingAttack", "LimitDark", $g_iMilkFarmLimitDark)
IniWriteS($g_sProfileConfigPath, "MilkingAttack", "TroopForWaveMin", $g_iMilkFarmTroopForWaveMin)
IniWriteS($g_sProfileConfigPath, "MilkingAttack", "TroopForWaveMax", $g_iMilkFarmTroopForWaveMax)
IniWriteS($g_sProfileConfigPath, "MilkingAttack", "MaxWaves", $g_iMilkFarmTroopMaxWaves)
IniWriteS($g_sProfileConfigPath, "MilkingAttack", "DelayBetweenWavesMin", $g_iMilkFarmDelayFromWavesMin)
IniWriteS($g_sProfileConfigPath, "MilkingAttack", "DelayBetweenWavesMax", $g_iMilkFarmDelayFromWavesMax)
IniWriteS($g_sProfileConfigPath, "MilkingAttack", "DropRandomPlace", $g_iMilkingAttackDropGoblinAlgorithm)
IniWriteS($g_sProfileConfigPath, "MilkingAttack", "StructureOrder", $g_iMilkingAttackStructureOrder)
IniWriteS($g_sProfileConfigPath, "MilkingAttack", "CheckStructureDestroyedBeforeAttack", $g_bMilkingAttackCheckStructureDestroyedBeforeAttack ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "MilkingAttack", "CheckStructureDestroyedAfterAttack", $g_bMilkingAttackCheckStructureDestroyedAfterAttack ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "MilkingAttack", "MilkAttackAfterTHSnipe", $g_bMilkAttackAfterTHSnipeEnable ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "MilkingAttack", "TownhallTiles", $g_iMilkFarmTHMaxTilesFromBorder)
IniWriteS($g_sProfileConfigPath, "MilkingAttack", "TownHallAlgorithm", $g_sMilkFarmAlgorithmTh)
IniWriteS($g_sProfileConfigPath, "MilkingAttack", "TownHallHitAnyway", $g_bMilkFarmSnipeEvenIfNoExtractorsFound ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "MilkingAttack", "MilkAttackAfterScriptedAtk", $g_bMilkAttackAfterScriptedAtkEnable ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "MilkingAttack", "MilkAttackCSVscript", $g_sMilkAttackCSVscript)
IniWriteS($g_sProfileConfigPath, "MilkingAttack", "MilkFarmForceTolerance", $g_bMilkFarmForceToleranceEnable ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "MilkingAttack", "MilkFarmForcetolerancenormal", $g_iMilkFarmForceToleranceNormal)
IniWriteS($g_sProfileConfigPath, "MilkingAttack", "MilkFarmForcetoleranceboosted", $g_iMilkFarmForceToleranceBoosted)
IniWriteS($g_sProfileConfigPath, "MilkingAttack", "MilkFarmForcetolerancedestroyed", $g_iMilkFarmForceToleranceDestroyed)
EndFunc
Func SaveConfig_600_29_LB()
ApplyConfig_600_29_LB("Save")
IniWriteS($g_sProfileConfigPath, "attack", "ABAtkAlgorithm", $g_aiAttackAlgorithm[$LB])
IniWriteS($g_sProfileConfigPath, "attack", "ABSelectTroop", $g_aiAttackTroopSelection[$LB])
IniWriteS($g_sProfileConfigPath, "attack", "ABKingAtk", BitAND($g_aiAttackUseHeroes[$LB], $eHeroKing))
IniWriteS($g_sProfileConfigPath, "attack", "ABQueenAtk", BitAND($g_aiAttackUseHeroes[$LB], $eHeroQueen))
IniWriteS($g_sProfileConfigPath, "attack", "ABWardenAtk", BitAND($g_aiAttackUseHeroes[$LB], $eHeroWarden))
IniWriteS($g_sProfileConfigPath, "attack", "ABDropCC", $g_abAttackDropCC[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "ABLightSpell", $g_abAttackUseLightSpell[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "ABHealSpell", $g_abAttackUseHealSpell[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "ABRageSpell", $g_abAttackUseRageSpell[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "ABJumpSpell", $g_abAttackUseJumpSpell[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "ABFreezeSpell", $g_abAttackUseFreezeSpell[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "ABCloneSpell", $g_abAttackUseCloneSpell[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "ABPoisonSpell", $g_abAttackUsePoisonSpell[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "ABEarthquakeSpell", $g_abAttackUseEarthquakeSpell[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "ABHasteSpell", $g_abAttackUseHasteSpell[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "ABSkeletonSpell", $g_abAttackUseSkeletonSpell[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "THSnipeBeforeLBEnable", $g_bTHSnipeBeforeEnable[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "THSnipeBeforeLBTiles", $g_iTHSnipeBeforeTiles[$LB])
IniWriteS($g_sProfileConfigPath, "attack", "THSnipeBeforeLBScript", $g_iTHSnipeBeforeScript[$LB])
SaveConfig_600_29_LB_Standard()
SaveConfig_600_29_LB_Scripted()
EndFunc
Func SaveConfig_600_29_LB_Standard()
ApplyConfig_600_29_LB_Standard("Save")
IniWriteS($g_sProfileConfigPath, "attack", "LBStandardAlgorithm", $g_aiAttackStdDropOrder[$LB])
IniWriteS($g_sProfileConfigPath, "attack", "ABDeploy", $g_aiAttackStdDropSides[$LB])
IniWriteS($g_sProfileConfigPath, "attack", "ABUnitD", $g_aiAttackStdUnitDelay[$LB])
IniWriteS($g_sProfileConfigPath, "attack", "ABWaveD", $g_aiAttackStdWaveDelay[$LB])
IniWriteS($g_sProfileConfigPath, "attack", "ABRandomSpeedAtk", $g_abAttackStdRandomizeDelay[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "ABSmartAttackRedArea", $g_abAttackStdSmartAttack[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "ABSmartAttackDeploy", $g_aiAttackStdSmartDeploy[$LB])
IniWriteS($g_sProfileConfigPath, "attack", "ABSmartAttackGoldMine", $g_abAttackStdSmartNearCollectors[$LB][0] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "ABSmartAttackElixirCollector", $g_abAttackStdSmartNearCollectors[$LB][1] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "ABSmartAttackDarkElixirDrill", $g_abAttackStdSmartNearCollectors[$LB][2] ? 1 : 0)
EndFunc
Func SaveConfig_600_29_LB_Scripted()
ApplyConfig_600_29_LB_Scripted("Save")
IniWriteS($g_sProfileConfigPath, "attack", "RedlineRoutineAB", $g_aiAttackScrRedlineRoutine[$LB])
IniWriteS($g_sProfileConfigPath, "attack", "DroplineEdgeAB", $g_aiAttackScrDroplineEdge[$LB])
IniWriteS($g_sProfileConfigPath, "attack", "ScriptAB", $g_sAttackScrScriptName[$LB])
EndFunc
Func SaveConfig_600_29_TS()
ApplyConfig_600_29_TS("Save")
IniWriteS($g_sProfileConfigPath, "attack", "TSSelectTroop", $g_aiAttackTroopSelection[$TS])
IniWriteS($g_sProfileConfigPath, "attack", "TSKingAtk", BitAND($g_aiAttackUseHeroes[$TS], $eHeroKing))
IniWriteS($g_sProfileConfigPath, "attack", "TSQueenAtk", BitAND($g_aiAttackUseHeroes[$TS], $eHeroQueen))
IniWriteS($g_sProfileConfigPath, "attack", "TSWardenAtk", BitAND($g_aiAttackUseHeroes[$TS], $eHeroWarden))
IniWriteS($g_sProfileConfigPath, "attack", "TSDropCC", $g_abAttackDropCC[$TS] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "TSLightSpell", $g_abAttackUseLightSpell[$TS] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "TSHealSpell", $g_abAttackUseHealSpell[$TS] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "TSRageSpell", $g_abAttackUseRageSpell[$TS] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "TSJumpSpell", $g_abAttackUseJumpSpell[$TS] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "TSFreezeSpell", $g_abAttackUseFreezeSpell[$TS] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "TSPoisonSpell", $g_abAttackUsePoisonSpell[$TS] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "TSEarthquakeSpell", $g_abAttackUseEarthquakeSpell[$TS] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "TSHasteSpell", $g_abAttackUseHasteSpell[$TS] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "attack", "AttackTHType", $g_sAtkTSType)
EndFunc
Func SaveConfig_600_30()
ApplyConfig_600_30("Save")
IniWriteS($g_sProfileConfigPath, "shareattack", "ShareAttack", $iShareAttack)
IniWriteS($g_sProfileConfigPath, "shareattack", "minGold", $iShareminGold)
IniWriteS($g_sProfileConfigPath, "shareattack", "minElixir", $iShareminElixir)
IniWriteS($g_sProfileConfigPath, "shareattack", "minDark", $iShareminDark)
IniWriteS($g_sProfileConfigPath, "shareattack", "Message", StringReplace($sShareMessage, @CRLF, "|"))
IniWriteS($g_sProfileConfigPath, "attack", "TakeLootSnapShot", $TakeLootSnapShot)
IniWriteS($g_sProfileConfigPath, "attack", "ScreenshotLootInfo", $ScreenshotLootInfo)
EndFunc
Func SaveConfig_600_30_DB()
ApplyConfig_600_30_DB("Save")
IniWriteS($g_sProfileConfigPath, "endbattle", "chkDBTimeStopAtk", $g_abStopAtkNoLoot1Enable[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "endbattle", "txtDBTimeStopAtk", $g_aiStopAtkNoLoot1Time[$DB])
IniWriteS($g_sProfileConfigPath, "endbattle", "chkDBTimeStopAtk2", $g_abStopAtkNoLoot2Enable[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "endbattle", "txtDBTimeStopAtk2", $g_aiStopAtkNoLoot2Time[$DB])
IniWriteS($g_sProfileConfigPath, "endbattle", "txtDBMinGoldStopAtk2", $g_aiStopAtkNoLoot2MinGold[$DB])
IniWriteS($g_sProfileConfigPath, "endbattle", "txtDBMinElixirStopAtk2", $g_aiStopAtkNoLoot2MinElixir[$DB])
IniWriteS($g_sProfileConfigPath, "endbattle", "txtDBMinDarkElixirStopAtk2", $g_aiStopAtkNoLoot2MinDark[$DB])
IniWriteS($g_sProfileConfigPath, "endbattle", "chkDBEndNoResources", $g_abStopAtkNoResources[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "endbattle", "chkDBEndOneStar", $g_abStopAtkOneStar[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "endbattle", "chkDBEndTwoStars", $g_abStopAtkTwoStars[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "endbattle", "chkDBPercentageHigher", $g_abStopAtkPctHigherEnable[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "endbattle", "txtDBPercentageHigher", $g_aiStopAtkPctHigherAmt[$DB])
IniWriteS($g_sProfileConfigPath, "endbattle", "chkDBPercentageChange", $g_abStopAtkPctNoChangeEnable[$DB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "endbattle", "txtDBPercentageChange", $g_aiStopAtkPctNoChangeTime[$DB])
EndFunc
Func SaveConfig_600_30_LB()
ApplyConfig_600_30_LB("Save")
IniWriteS($g_sProfileConfigPath, "endbattle", "chkABTimeStopAtk", $g_abStopAtkNoLoot1Enable[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "endbattle", "txtABTimeStopAtk", $g_aiStopAtkNoLoot1Time[$LB])
IniWriteS($g_sProfileConfigPath, "endbattle", "chkABTimeStopAtk2", $g_abStopAtkNoLoot2Enable[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "endbattle", "txtABTimeStopAtk2", $g_aiStopAtkNoLoot2Time[$LB])
IniWriteS($g_sProfileConfigPath, "endbattle", "txtABMinGoldStopAtk2", $g_aiStopAtkNoLoot2MinGold[$LB])
IniWriteS($g_sProfileConfigPath, "endbattle", "txtABMinElixirStopAtk2", $g_aiStopAtkNoLoot2MinElixir[$LB])
IniWriteS($g_sProfileConfigPath, "endbattle", "txtABMinDarkElixirStopAtk2", $g_aiStopAtkNoLoot2MinDark[$LB])
IniWriteS($g_sProfileConfigPath, "endbattle", "chkABEndNoResources", $g_abStopAtkNoResources[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "endbattle", "chkABEndOneStar", $g_abStopAtkOneStar[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "endbattle", "chkABEndTwoStars", $g_abStopAtkTwoStars[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "endbattle", "chkDESideEB", $g_bDESideEndEnable ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "endbattle", "txtDELowEndMin", $g_iDESideEndMin)
IniWriteS($g_sProfileConfigPath, "endbattle", "chkDisableOtherEBO", $g_bDESideDisableOther ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "endbattle", "chkDEEndAq", $g_bDESideEndAQWeak ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "endbattle", "chkDEEndBk", $g_bDESideEndBKWeak ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "endbattle", "chkDEEndOneStar", $g_bDESideEndOneStar ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "endbattle", "chkABPercentageHigher", $g_abStopAtkPctHigherEnable[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "endbattle", "txtABPercentageHigher", $g_aiStopAtkPctHigherAmt[$LB])
IniWriteS($g_sProfileConfigPath, "endbattle", "chkABPercentageChange", $g_abStopAtkPctNoChangeEnable[$LB] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "endbattle", "txtABPercentageChange", $g_aiStopAtkPctNoChangeTime[$LB])
EndFunc
Func SaveConfig_600_30_TS()
ApplyConfig_600_30_TS("Save")
IniWriteS($g_sProfileConfigPath, "search", "ChkTSSearchCamps2", $g_bEndTSCampsEnable ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "search", "TSEnableAfterArmyCamps2", $g_iEndTSCampsPct)
EndFunc
Func SaveConfig_600_31()
ApplyConfig_600_31("Save")
For $i = 6 To 12
IniWriteS($g_sProfileConfigPath, "collectors", "lvl" & $i & "Enabled", $g_abCollectorLevelEnabled[$i] ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "collectors", "lvl" & $i & "fill", $g_aiCollectorLevelFill[$i])
Next
IniWriteS($g_sProfileConfigPath, "search", "chkDisableCollectorsFilter", $g_bCollectorFilterDisable ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "collectors", "minmatches", $g_iCollectorMatchesMin)
IniWriteS($g_sProfileConfigPath, "collectors", "tolerance", $g_iCollectorToleranceOffset)
EndFunc
Func SaveConfig_600_32()
ApplyConfig_600_32("Save")
IniWriteS($g_sProfileConfigPath, "search", "TrophyRange", $iChkTrophyRange)
IniWriteS($g_sProfileConfigPath, "search", "MaxTrophy", $itxtMaxTrophy)
IniWriteS($g_sProfileConfigPath, "search", "MinTrophy", $itxtdropTrophy)
IniWriteS($g_sProfileConfigPath, "search", "chkTrophyHeroes", $iChkTrophyHeroes)
IniWriteS($g_sProfileConfigPath, "search", "cmbTrophyHeroesPriority", $iCmbTrophyHeroesPriority)
IniWriteS($g_sProfileConfigPath, "search", "chkTrophyAtkDead", $iChkTrophyAtkDead)
IniWriteS($g_sProfileConfigPath, "search", "DTArmyMin", $itxtDTArmyMin)
EndFunc
Func SaveConfig_600_35()
ApplyConfig_600_35("Save")
IniWriteS($g_sProfileConfigPath, "other", "language", $sLanguage)
IniWriteS($g_sProfileConfigPath, "General", "ChkDisableSplash", $ichkDisableSplash)
IniWriteS($g_sProfileConfigPath, "General", "ChkVersion", $ichkVersion)
IniWriteS($g_sProfileConfigPath, "deletefiles", "DeleteLogs", $ichkDeleteLogs)
IniWriteS($g_sProfileConfigPath, "deletefiles", "DeleteLogsDays", $iDeleteLogsDays)
IniWriteS($g_sProfileConfigPath, "deletefiles", "DeleteTemp", $ichkDeleteTemp)
IniWriteS($g_sProfileConfigPath, "deletefiles", "DeleteTempDays", $iDeleteTempDays)
IniWriteS($g_sProfileConfigPath, "deletefiles", "DeleteLoots", $ichkDeleteLoots)
IniWriteS($g_sProfileConfigPath, "deletefiles", "DeleteLootsDays", $iDeleteLootsDays)
IniWriteS($g_sProfileConfigPath, "general", "AutoStart", $ichkAutoStart)
IniWriteS($g_sProfileConfigPath, "general", "AutoStartDelay", $ichkAutoStartDelay)
IniWriteS($g_sProfileConfigPath, "General", "ChkLanguage", $ichkLanguage)
IniWriteS($g_sProfileConfigPath, "general", "DisposeWindows", $iDisposeWindows)
IniWriteS($g_sProfileConfigPath, "general", "DisposeWindowsPos", $icmbDisposeWindowsPos)
IniWriteS($g_sProfileConfigPath, "other", "WAOffsetX", $iWAOffsetX)
IniWriteS($g_sProfileConfigPath, "other", "WAOffsetY", $iWAOffsetY)
IniWriteS($g_sProfileConfigPath, "general", "UpdatingWhenMinimized", $iUpdatingWhenMinimized)
IniWriteS($g_sProfileConfigPath, "general", "HideWhenMinimized", $iHideWhenMinimized)
IniWriteS($g_sProfileConfigPath, "other", "UseRandomClick", $iUseRandomClick)
IniWriteS($g_sProfileConfigPath, "other", "ScreenshotType", $iScreenshotType)
IniWriteS($g_sProfileConfigPath, "other", "ScreenshotHideName", $ichkScreenshotHideName)
IniWriteS($g_sProfileConfigPath, "other", "txtTimeWakeUp", $sTimeWakeUp)
IniWriteS($g_sProfileConfigPath, "other", "chkSinglePBTForced", $ichkSinglePBTForced)
IniWriteS($g_sProfileConfigPath, "other", "ValueSinglePBTimeForced", $iValueSinglePBTimeForced)
IniWriteS($g_sProfileConfigPath, "other", "ValuePBTimeForcedExit", $iValuePBTimeForcedExit)
IniWriteS($g_sProfileConfigPath, "other", "ChkAutoResume", $iChkAutoResume)
IniWriteS($g_sProfileConfigPath, "other", "AutoResumeTime", $iAutoResumeTime)
IniWriteS($g_sProfileConfigPath, "other", "ChkFixClanCastle", $ichkFixClanCastle)
EndFunc
Func SaveConfig_600_52_1()
ApplyConfig_600_52_1("Save")
IniWriteS($g_sProfileConfigPath, "other", "ChkUseQTrain", $g_bQuickTrainEnable ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "troop", "QuickTrainArmyNum", $g_iQuickTrainArmyNum)
EndFunc
Func SaveConfig_600_52_2()
ApplyConfig_600_52_2("Save")
For $T = 0 To $eTroopCount - 1
IniWriteS($g_sProfileConfigPath, "troop", $g_asTroopShortNames[$T], $g_aiArmyCompTroops[$T])
IniWriteS($g_sProfileConfigPath, "LevelTroop", $g_asTroopShortNames[$T], $g_aiTrainArmyTroopLevel[$T])
Next
For $S = 0 To $eSpellCount - 1
IniWriteS($g_sProfileConfigPath, "Spells", $g_asSpellShortNames[$S], $g_aiArmyCompSpells[$S])
IniWriteS($g_sProfileConfigPath, "LevelSpell", $g_asSpellShortNames[$S], $g_aiTrainArmySpellLevel[$S])
Next
IniWriteS($g_sProfileConfigPath, "troop", "fulltroop", $g_iTrainArmyFullTroopPct)
IniWriteS($g_sProfileConfigPath, "other", "ChkTotalCampForced", $g_bTotalCampForced ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "other", "ValueTotalCampForced", $g_iTotalCampForcedValue)
IniWriteS($g_sProfileConfigPath, "Spells", "SpellFactory", $g_iTotalSpellValue)
IniWriteS($g_sProfileConfigPath, "other", "ChkForceBrewBeforeAttack", $g_bForceBrewSpells ? 1 : 0)
EndFunc
Func SaveConfig_600_54()
ApplyConfig_600_54("Save")
IniWriteS($g_sProfileConfigPath, "troop", "chkTroopOrder", $g_bCustomTrainOrderEnable ? 1 : 0)
For $z = 0 To UBound($g_aiCmbCustomTrainOrder) -1
IniWriteS($g_sProfileConfigPath, "troop", "cmbTroopOrder" & $z, $g_aiCmbCustomTrainOrder[$z])
Next
EndFunc
Func SaveConfig_600_56()
ApplyConfig_600_56("Save")
IniWrite($g_sProfileConfigPath, "SmartZap", "UseSmartZap", $ichkSmartZap)
IniWrite($g_sProfileConfigPath, "SmartZap", "UseEarthQuakeZap", $ichkEarthQuakeZap)
IniWrite($g_sProfileConfigPath, "SmartZap", "UseNoobZap", $ichkNoobZap)
IniWrite($g_sProfileConfigPath, "SmartZap", "ZapDBOnly", $ichkSmartZapDB)
IniWrite($g_sProfileConfigPath, "SmartZap", "THSnipeSaveHeroes", $ichkSmartZapSaveHeroes)
IniWrite($g_sProfileConfigPath, "SmartZap", "MinDE", $itxtMinDE)
IniWrite($g_sProfileConfigPath, "SmartZap", "ExpectedDE", $itxtExpectedDE)
IniWrite($g_sProfileConfigPath, "SmartZap", "DebugSmartZap", $DebugSmartZap)
EndFunc
Func SaveConfig_641_1()
ApplyConfig_641_1("Save")
IniWriteS($g_sProfileConfigPath, "other", "chkCloseWaitEnable", $g_bCloseWhileTrainingEnable ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "other", "chkCloseWaitTrain", $g_bCloseWithoutShield ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "other", "btnCloseWaitStop", $g_bCloseEmulator ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "other", "btnCloseWaitStopRandom", $g_bCloseRandom ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "other", "btnCloseWaitExact", $g_bCloseExactTime ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "other", "btnCloseWaitRandom", $g_bCloseRandomTime ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "other", "CloseWaitRdmPercent", $g_iCloseRandomTimePercent)
IniWriteS($g_sProfileConfigPath, "other", "MinimumTimeToClose", $g_iCloseMinimumTime)
IniWriteS($g_sProfileConfigPath, "other", "TrainITDelay", $g_iTrainClickDelay)
IniWriteS($g_sProfileConfigPath, "other", "chkAddIdleTime", $g_bTrainAddRandomDelayEnable ? 1 : 0)
IniWriteS($g_sProfileConfigPath, "other", "txtAddDelayIdlePhaseTimeMin", $g_iTrainAddRandomDelayMin)
IniWriteS($g_sProfileConfigPath, "other", "txtAddDelayIdlePhaseTimeMax", $g_iTrainAddRandomDelayMax)
EndFunc
Func IniWriteS($filename, $section, $key, $value)
Local $s = $section
Local $k = $key
IniWrite($filename, $section, $key, $value)
If $g_sProfileSecondaryOutputFileName <> "" Then
If $s = "search" Or $s = "attack" Or $s = "troop" Or $s = "spells" Or $s = "milkingattack" Or $s = "endbattle" or $s = "collectors" or($s = "general" And $k = "version") Then
IniWrite($g_sProfileSecondaryOutputFileName, $section, $key, $value)
EndIf
EndIf
EndFunc
Global $saveiChkTimeStopAtk[$g_iModeCount], $saveiChkTimeStopAtk2[$g_iModeCount], $saveichkEndOneStar[$g_iModeCount], $saveichkEndTwoStars[$g_iModeCount]
Func GetBuildingEdge($TypeBuilding = $eSideBuildingDES)
Local $TypeBuildingName
BuildingXY($TypeBuilding)
Switch $TypeBuilding
Case $eSideBuildingDES
$TypeBuildingName = "DE Storage"
Case $eSideBuildingTH
$TypeBuildingName = "TownHall"
EndSwitch
If $BuildingLoc = 1 Then
If($BuildingLocx = 430) And($BuildingLocy = 313) Then
SetLog($TypeBuildingName & " Located in Middle... Attacking Random Side", $COLOR_INFO)
$BuildingEdge =(Random(Round(0, 3)))
ElseIf($BuildingLocx >= 430) And($BuildingLocy >= 313) Then
SetLog($TypeBuildingName & " Located Bottom Right... Attacking Bottom Right", $COLOR_INFO)
$BuildingEdge = 0
ElseIf($BuildingLocx > 430) And($BuildingLocy < 313) Then
SetLog($TypeBuildingName & " Located Top Right... Attacking Top Right", $COLOR_INFO)
$BuildingEdge = 3
ElseIf($BuildingLocx <= 430) And($BuildingLocy <= 313) Then
SetLog($TypeBuildingName & " Located Top Left... Attacking Top Left", $COLOR_INFO)
$BuildingEdge = 1
ElseIf($BuildingLocx < 430) And($BuildingLocy > 313) Then
SetLog($TypeBuildingName & " Located Bottom Left... Attacking Bottom Left", $COLOR_INFO)
$BuildingEdge = 2
EndIf
ElseIf $BuildingLoc = 0 Then
SetLog($TypeBuildingName & " Not Located... Attacking Random Side", $COLOR_INFO)
$BuildingEdge =(Random(Round(0, 3)))
EndIf
EndFunc
Func BuildingXY($TypeBuilding = $eSideBuildingDES)
Local $TypeBuildingName
_CaptureRegion2(230, 170, 630, 440)
Switch $TypeBuilding
Case $eSideBuildingDES
$TypeBuildingName = "DE Storage"
$BuildingToLoc = GetLocationDarkElixirStorage()
Case $eSideBuildingTH
$TypeBuildingName = "TownHall"
$BuildingToLoc = GetLocationTownHall()
EndSwitch
Local $pixel
If(UBound($BuildingToLoc) > 1) Then
Local $centerPixel[2] = [430, 313]
Local $arrPixelCloser = _FindPixelCloser($BuildingToLoc, $centerPixel, 1)
$pixel = $arrPixelCloser[0]
ElseIf(UBound($BuildingToLoc) > 0) Then
$pixel = $BuildingToLoc[0]
Else
$pixel = -1
EndIf
If $pixel = -1 Then
$BuildingLoc = 0
SetLog(" == " & $TypeBuildingName & " Not Found ==")
Else
$pixel[0] += 230
$pixel[1] += 170
SetLog("== " & $TypeBuildingName & " : [" & $pixel[0] & "," & $pixel[1] & "] ==", $COLOR_INFO)
If _Sleep(1000) Then Return False
$BuildingLocx = $pixel[0]
$BuildingLocy = $pixel[1]
$BuildingLoc = 1
EndIf
EndFunc
Func DELow()
Local $DarkE = ""
Local $Dchk = 0
While $DarkE = ""
$DarkE = getDarkElixirVillageSearch(48, 125)
$Dchk += 1
If _Sleep(50) Then Return
If $Dchk >= 10 Then
SetLog("Can't find De", $COLOR_ERROR)
Return False
EndIf
WEnd
If Number($DarkE) <(Number($searchDark) *(Number($g_iDESideEndMin) / 100)) Then
If _Sleep(50) Then Return
$DarkE = getDarkElixirVillageSearch(48, 125)
If _Sleep(50) Then Return
If Number($DarkE) <(Number($searchDark) *(Number($g_iDESideEndMin) / 100)) Then
If $g_bDESideEndAQWeak And $dropQueen And $checkQPower = False Then
If $iActivateKQCondition = "Auto" Then
$DarkLow = 1
SetLog("Low De. De = ( " & $DarkE & " ) and AQ health Low. Return to protect Royals.  Returning immediately", $COLOR_SUCCESS)
Return False
ElseIf Not _ColorCheck(_GetPixelColor(68 +(72 * $Queen), 572, True), Hex(0x72F50B, 6), 120, "Heroes") Then
$DarkLow = 1
SetLog("Low De. De = ( " & $DarkE & " ) and AQ health Low. Return to protect Royals.  Returning immediately", $COLOR_SUCCESS)
Return False
EndIf
EndIf
If $g_bDESideEndBKWeak And $dropKing And $checkKPower = False Then
If $iActivateKQCondition = "Auto" Then
$DarkLow = 1
SetLog("Low De. De = ( " & $DarkE & " ) and BK health Low. Return to protect Royals.  Returning immediately", $COLOR_SUCCESS)
Return False
ElseIf Not _ColorCheck(_GetPixelColor(68 +(72 * $King), 572, True), Hex(0x4FD404, 6), 120, "Heroes") Then
$DarkLow = 1
SetLog("Low De. De = ( " & $DarkE & " ) and BK health Low. Return to protect Royals.  Returning immediately", $COLOR_SUCCESS)
Return False
EndIf
EndIf
If $g_bDESideEndOneStar Then
If _ColorCheck(_GetPixelColor($aWonOneStar[0], $aWonOneStar[1], True), Hex($aWonOneStar[2], 6), $aWonOneStar[3]) Then
SetLog("Low De. De = ( " & $DarkE & " ) and 1 star achieved. Return to protect Royals.  Returning immediately", $COLOR_SUCCESS)
$DarkLow = 1
Return False
Else
SetLog("Low De. ( " & $DarkE & " ) Waiting for 1 star", $COLOR_SUCCESS)
$DarkLow = 2
Return False
EndIf
EndIf
If $g_bDESideEndAQWeak = False And $g_bDESideEndBKWeak = False And $g_bDESideEndOneStar = False Then
SetLog("Low De. De = ( " & $DarkE & " ). Return to protect Royals.  Returning immediately", $COLOR_SUCCESS)
Return False
EndIf
EndIf
Else
$DarkLow = 0
EndIf
EndFunc
Func SaveandDisableEBO()
$saveichkEndOneStar[$g_iMatchMode] = $g_abStopAtkOneStar[$g_iMatchMode]
$saveichkEndTwoStars[$g_iMatchMode] = $g_abStopAtkTwoStars[$g_iMatchMode]
$saveichkTimeStopAtk[$g_iMatchMode] = $g_abStopAtkNoLoot1Enable[$g_iMatchMode]
$saveiChkTimeStopAtk2[$g_iMatchMode] = $g_abStopAtkNoLoot2Enable[$g_iMatchMode]
$g_abStopAtkOneStar[$g_iMatchMode] = 0
$g_abStopAtkTwoStars[$g_iMatchMode] = 0
$g_abStopAtkNoLoot1Enable[$g_iMatchMode] = 0
$g_abStopAtkNoLoot2Enable[$g_iMatchMode] = 0
EndFunc
Func RevertEBO()
$g_abStopAtkOneStar[$g_iMatchMode] = $saveichkEndOneStar
$g_abStopAtkTwoStars[$g_iMatchMode] = $saveichkEndTwoStars
$g_abStopAtkNoLoot1Enable[$g_iMatchMode] = $saveichkTimeStopAtk
$g_abStopAtkNoLoot2Enable[$g_iMatchMode] = $saveiChkTimeStopAtk2
EndFunc
Func GoldElixirChangeThSnipes($x)
Local $Gold1, $Gold2
Local $GoldChange, $ElixirChange
Local $Elixir1, $Elixir2
SetLog("Checking if the Gold6Elixir are changing...", $COLOR_INFO)
For $y = 0 To $x
$Gold1 = getGoldVillageSearch(48, 69)
$Elixir1 = getElixirVillageSearch(48, 69 + 29)
Local $iBegin = TimerInit()
While TimerDiff($iBegin) < 2000
CheckHeroesHealth()
If $checkKPower Or $checkQPower Then
If _Sleep($iDelayGoldElixirChange1) Then Return
Else
If _Sleep($iDelayGoldElixirChange2) Then Return
EndIf
$Gold2 = getGoldVillageSearch(48, 69)
If $Gold2 = "" Then
If _Sleep($iDelayGoldElixirChange1) Then Return
$Gold2 = getGoldVillageSearch(48, 69)
EndIf
$Elixir2 = getElixirVillageSearch(48, 69 + 29)
If $Gold2 <> "" Or $Elixir2 <> "" Then
$GoldChange = $Gold2
$ElixirChange = $Elixir2
EndIf
If($Gold2 = "" And $Elixir2 = "") Then
If _Sleep($iDelayGoldElixirChange1) Then Return
If getGoldVillageSearch(48, 69) = "" And getElixirVillageSearch(48, 69 + 29) = "" Then
SetLog("Battle has finished", $COLOR_SUCCESS)
Return True
ExitLoop
EndIf
EndIf
WEnd
If($Gold1 = $Gold2 And $Elixir1 = $Elixir2) Or($Gold2 = "" And $Elixir2 = "") Then
ExitLoop
Else
SetLog("Gold & Elixir change detected, waiting...", $COLOR_SUCCESS)
ContinueLoop
EndIf
$x += 1
If Sleep(1000) Then Return
Return False
Next
EndFunc
Func GoldElixirChangeEBO()
Local $Gold1, $Gold2
Local $GoldChange, $ElixirChange
Local $Elixir1, $Elixir2
Local $DarkElixir1, $DarkElixir2
Local $DarkElixirChange
Local $Trophies
Local $txtDiff
Local $exitOneStar = 0, $exitTwoStars = 0
Local $Damage, $CurDamage
$DarkLow = 0
$Gold1 = getGoldVillageSearch(48, 69)
$Elixir1 = getElixirVillageSearch(48, 69 + 29)
$Trophies = getTrophyVillageSearch(48, 69 + 99)
$Damage = getOcrOverAllDamage(780, 527 + $g_iBottomOffsetY)
If $Trophies <> "" Then
If _Sleep($iDelayGoldElixirChangeEBO1) Then Return
$DarkElixir1 = getDarkElixirVillageSearch(48, 69 + 57)
Else
$DarkElixir1 = ""
$Trophies = getTrophyVillageSearch(48, 69 + 69)
EndIf
Local $x = $g_aiStopAtkNoLoot1Time[$g_iMatchMode] * 1000, $y = $g_aiStopAtkNoLoot2Time[$g_iMatchMode] * 1000, $z, $w = $g_aiStopAtkPctNoChangeTime[$g_iMatchMode] * 1000
If Number($Gold1) < $g_aiStopAtkNoLoot2MinGold[$g_iMatchMode] And Number($Elixir1) < $g_aiStopAtkNoLoot2MinElixir[$g_iMatchMode] And Number($DarkElixir1) < $g_aiStopAtkNoLoot2MinDark[$g_iMatchMode] And $g_abStopAtkNoLoot2Enable[$g_iMatchMode] Then
$z = $y
ElseIf $Damage <> "" And $g_abStopAtkPctNoChangeEnable[$g_iMatchMode] Then
$z = $w
Else
If $g_abStopAtkNoLoot1Enable[$g_iMatchMode] Then
$z = $x
Else
$z = 60 * 3 * 1000
EndIf
EndIf
If $g_abStopAtkTwoStars[$g_iMatchMode] And _CheckPixel($aWonTwoStar, True) Then
SetLog("Two Star Reach, exit", $COLOR_SUCCESS)
$exitTwoStars = 1
$z = 0
EndIf
If $g_abStopAtkOneStar[$g_iMatchMode] And _CheckPixel($aWonOneStar, True) Then
SetLog("One Star Reach, exit", $COLOR_SUCCESS)
$exitOneStar = 1
$z = 0
EndIf
If $g_abStopAtkPctHigherEnable[$g_iMatchMode] And Number(getOcrOverAllDamage(780, 527 + $g_iBottomOffsetY)) > Number($g_aiStopAtkPctHigherAmt[$g_iMatchMode]) Then
SetLog("Overall Damage above " & Number($g_aiStopAtkPctHigherAmt[$g_iMatchMode]), $COLOR_SUCCESS)
$z = 0
EndIf
Local $NoResourceOCR = False
Local $iBegin = TimerInit()
While TimerDiff($iBegin) < $z
CheckHeroesHealth()
If $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] = 4 And $g_bDESideEndEnable Then
If $dropQueen Or $dropKing Then DELow()
If $DarkLow = 1 Then ExitLoop
EndIf
If $checkKPower Or $checkQPower Or $DarkLow = 2 Then
If _Sleep($iDelayGoldElixirChangeEBO1) Then Return
Else
If _Sleep($iDelayGoldElixirChangeEBO2) Then Return
EndIf
$Gold2 = getGoldVillageSearch(48, 69)
If $Gold2 = "" Then
If _Sleep($iDelayGoldElixirChangeEBO1) Then Return
$Gold2 = getGoldVillageSearch(48, 69)
EndIf
CheckHeroesHealth()
$Elixir2 = getElixirVillageSearch(48, 69 + 29)
$Trophies = getTrophyVillageSearch(48, 69 + 99)
CheckHeroesHealth()
If $Trophies <> "" Then
If _Sleep($iDelayGoldElixirChangeEBO1) Then Return
$DarkElixir2 = getDarkElixirVillageSearch(48, 69 + 57)
Else
$DarkElixir2 = ""
$Trophies = getTrophyVillageSearch(48, 69 + 69)
EndIf
$CurDamage = getOcrOverAllDamage(780, 527 + $g_iBottomOffsetY)
CheckHeroesHealth()
$txtDiff = Round(($z - TimerDiff($iBegin)) / 1000, 1)
If Number($txtDiff) < 0 Then $txtDiff = 0
$NoResourceOCR = StringLen($Gold2) = 0 And StringLen($Elixir2) = 0 And StringLen($DarkElixir2) = 0
If $NoResourceOCR Then
SetLog("detected [G]: " & $Gold2 & " [E]: " & $Elixir2 & " [DE]: " & $DarkElixir2 & " [%]: " & $CurDamage & " |  Exit now ", $COLOR_INFO)
Else
SetLog("detected [G]: " & $Gold2 & " [E]: " & $Elixir2 & " [DE]: " & $DarkElixir2 & " [%]: " & $CurDamage & " |  Exit in " & StringReplace(StringFormat("%2i", $txtDiff), "-", "") & " sec.", $COLOR_INFO)
EndIf
If Number($CurDamage) >= 92 Then
If($checkKPower = True Or $checkQPower = True Or $checkWPower = True) And $iActivateKQCondition = "Auto" Then
If $checkKPower = True Then
SetLog("Activating King's power to restore some health before leaving with a 3 Star", $COLOR_INFO)
If IsAttackPage() Then SelectDropTroop($King)
$checkKPower = False
EndIf
If $checkQPower = True Then
SetLog("Activating Queen's power to restore some health before leaving with a 3 Star", $COLOR_INFO)
If IsAttackPage() Then SelectDropTroop($Queen)
$checkQPower = False
EndIf
If $checkWPower = True Then
SetLog("Activating Warden's power to restore some health before leaving with a 3 Star", $COLOR_INFO)
If IsAttackPage() Then SelectDropTroop($Warden)
$checkWPower = False
EndIf
EndIf
EndIf
If $Gold2 <> "" Or $Elixir2 <> "" Or $DarkElixir2 <> "" Then
$GoldChange = $Gold2
$ElixirChange = $Elixir2
$DarkElixirChange = $DarkElixir2
EndIf
If $g_abStopAtkNoResources[$g_iMatchMode] And Number($Gold2) = 0 And Number($Elixir2) = 0 And Number($DarkElixir2) = 0 Then
SetLog("Gold & Elixir & DE = 0, end battle ", $COLOR_SUCCESS)
If _Sleep($iDelayGoldElixirChangeEBO2) Then Return
ExitLoop
EndIf
If $g_abStopAtkTwoStars[$g_iMatchMode] And _CheckPixel($aWonTwoStar, True) Then
SetLog("Two Star Reach, exit", $COLOR_SUCCESS)
$exitTwoStars = 1
ExitLoop
EndIf
If $g_abStopAtkOneStar[$g_iMatchMode] And _CheckPixel($aWonOneStar, True) Then
SetLog("One Star Reach, exit", $COLOR_SUCCESS)
$exitOneStar = 1
ExitLoop
EndIf
If getGoldVillageSearch(48, 69) = "" And getElixirVillageSearch(48, 69 + 29) = "" And $DarkElixir2 = "" Then
ExitLoop
EndIf
If $g_abStopAtkPctHigherEnable[$g_iMatchMode] And Number(getOcrOverAllDamage(780, 527 + $g_iBottomOffsetY)) > Number($g_aiStopAtkPctHigherAmt[$g_iMatchMode]) Then
SetLog("Overall Damage above " & Number($g_aiStopAtkPctHigherAmt[$g_iMatchMode]) & ", exit", $COLOR_SUCCESS)
ExitLoop
EndIf
If($g_abStopAtkNoLoot1Enable[$g_iMatchMode] Or $g_abStopAtkNoLoot2Enable[$g_iMatchMode]) And($Gold1 <> $Gold2 Or $Elixir1 <> $Elixir2 Or $DarkElixir1 <> $DarkElixir2) Then
SetLog("Gold & Elixir & DE change detected, waiting...", $COLOR_SUCCESS)
Return True
EndIf
If $g_abStopAtkPctNoChangeEnable[$g_iMatchMode] And(Number($Damage) <> Number($CurDamage)) Then
SetLog("Overall Damage Percentage change detected, waiting...", $COLOR_SUCCESS)
Return True
EndIf
WEnd
If $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] = 4 And $g_bDESideEndEnable And $DarkLow = 1 Then
SetLog("Returning Now -DE-", $COLOR_SUCCESS)
Return False
EndIf
If $g_abStopAtkOneStar[$g_iMatchMode] And $exitOneStar = 1 Then
If _Sleep($iDelayGoldElixirChangeEBO2) Then Return
Return False
EndIf
If $g_abStopAtkTwoStars[$g_iMatchMode] And $exitTwoStars = 1 Then
If _Sleep($iDelayGoldElixirChangeEBO2) Then Return
Return False
EndIf
If($NoResourceOCR = True) Then
SetLog("Battle has finished", $COLOR_SUCCESS)
Return False
EndIf
If $g_abStopAtkPctHigherEnable[$g_iMatchMode] And Number(getOcrOverAllDamage(780, 527 + $g_iBottomOffsetY)) > Number($g_aiStopAtkPctHigherAmt[$g_iMatchMode]) Then
Return False
EndIf
If $g_abStopAtkNoResources[$g_iMatchMode] And $NoResourceOCR = False And Number($Gold2) = 0 And Number($Elixir2) = 0 And Number($DarkElixir2) = 0 Then
SetLog("Gold & Elixir & DE = 0, end battle ", $COLOR_SUCCESS)
If _Sleep($iDelayGoldElixirChangeEBO2) Then Return
Return False
EndIf
If $g_abStopAtkPctNoChangeEnable[$g_iMatchMode] And Number($Damage) = Number($CurDamage) Then
SetLog("No Overall Damage Percentage change detected, exit", $COLOR_SUCCESS)
Return False
EndIf
If(Number($Gold1) = Number($Gold2) And Number($Elixir1) = Number($Elixir2) And Number($DarkElixir1) = Number($DarkElixir2)) Then
If $g_abStopAtkNoLoot1Enable[$g_iMatchMode] Or $g_abStopAtkNoLoot2Enable[$g_iMatchMode] Then
SetLog("Gold & Elixir & DE no change detected, exit", $COLOR_SUCCESS)
Return False
Else
SetLog("Gold & Elixir & DE no change detected, waiting...", $COLOR_SUCCESS)
EndIf
Else
If $g_iDebugSetlog = 1 Then
Setlog("Gold1: " & Number($Gold1) & "  Gold2: " & Number($Gold2), $COLOR_DEBUG)
Setlog("Elixir1: " & Number($Elixir1) & "  Elixir2: " & Number($Elixir2), $COLOR_DEBUG)
Setlog("Dark Elixir1: " & Number($DarkElixir1) & "  Dark Elixir2: " & Number($DarkElixir2), $COLOR_DEBUG)
EndIf
EndIf
Return True
EndFunc
Func OverallDamage($OverallDamage = 30, $SetLog = True)
Local $Damage = Number(getOcrOverAllDamage(780, 527 + $g_iBottomOffsetY))
If $SetLog = True Then
SetLog("Overall Damage: " & $Damage & "%")
EndIf
If $Damage >= $OverallDamage Then
Return True
Else
Return False
EndIf
EndFunc
Func PrepareAttack($pMatchMode, $Remaining = False)
If($pMatchMode = $DB and $g_aiAttackAlgorithm[$DB] = 1) or($pMatchMode = $LB and $g_aiAttackAlgorithm[$LB] = 1) Then
If $g_iDebugMakeIMGCSV = 1 And $Remaining = False And TestCapture() = 0 Then DebugImageSave("clean", False)
EndIf
Local $troopsnumber = 0
If $g_iDebugSetlog = 1 Then SetLog("PrepareAttack for " & $pMatchMode & " " & $g_asModeText[$pMatchMode], $COLOR_DEBUG)
If $Remaining Then
SetLog("Checking remaining unused troops for: " & $g_asModeText[$pMatchMode], $COLOR_INFO)
Else
SetLog("Initiating attack for: " & $g_asModeText[$pMatchMode], $COLOR_ERROR)
EndIf
_CaptureRegion2(0, 571 + $g_iBottomOffsetY, 859, 671 + $g_iBottomOffsetY)
If _Sleep($iDelayPrepareAttack1) Then Return
For $i = 0 to UBound($atkTroops) -1
$atkTroops[$i][0] = -1
$atkTroops[$i][1] = 0
Next
Local $Plural = 0
Local $result = AttackBarCheck($Remaining)
If $g_iDebugSetlog = 1 Then Setlog("DLL Troopsbar list: " & $result, $COLOR_DEBUG)
Local $aTroopDataList = StringSplit($result, "|")
Local $aTemp[12][3]
If $result <> "" Then
For $i = 1 To $aTroopDataList[0]
Local $troopData = StringSplit($aTroopDataList[$i], "#", $STR_NOCOUNT)
$aTemp[Number($troopData[1])][0] = $troopData[0]
$aTemp[Number($troopData[1])][1] = Number($troopData[2])
$aTemp[Number($troopData[1])][2] = Number($troopData[1])
Next
EndIf
For $i = 0 To UBound($aTemp) - 1
If $aTemp[$i][0] = "" And $aTemp[$i][1] = "" Then
$atkTroops[$i][0] = -1
$atkTroops[$i][1] = 0
Else
Local $troopKind = $aTemp[$i][0]
If $troopKind < $eKing Then
If Not IsTroopToBeUsed($pMatchMode, $troopKind) Then
If $g_iDebugSetlog = 1 Then Setlog("Discard use of troop " & $troopKind & " " & NameOfTroop($troopKind), $COLOR_ERROR)
$atkTroops[$i][0] = -1
$atkTroops[$i][1] = 0
$troopKind = -1
Else
$atkTroops[$i][0] = $aTemp[$i][0]
$atkTroops[$i][1] = $aTemp[$i][1]
$troopsnumber += $aTemp[$i][1]
EndIf
Else
$atkTroops[$i][0] = $troopKind
If IsSpecialTroopToBeUsed($pMatchMode, $TroopKind) then
$troopsnumber += 1
$atkTroops[$i][0] = $aTemp[$i][0]
$atkTroops[$i][1] = $aTemp[$i][1]
If $atkTroops[$i][0] = $eKing or $atkTroops[$i][0] = $eQueen or $atkTroops[$i][0] = $eWarden then $atkTroops[$i][1] = 1
$troopKind = $atkTroops[$i][1]
$troopsnumber += 1
Else
If $g_iDebugSetlog = 1 Then Setlog($aTemp[$i][2] & " » Discard use hero/poison " & $troopKind & " " & NameOfTroop($troopKind), $COLOR_ERROR)
$troopKind = -1
EndIf
EndIf
$Plural = 0
If $aTemp[$i][1] > 1 then $Plural = 1
If $troopKind <> -1 Then SetLog($aTemp[$i][2] & " » " & $atkTroops[$i][1] & " " & NameOfTroop($atkTroops[$i][0], $Plural), $COLOR_SUCCESS)
EndIf
Next
If $g_iDebugSetlog=1 Then Setlog("troopsnumber  = " & $troopsnumber)
Return $troopsnumber
EndFunc
Func IsTroopToBeUsed($pMatchMode, $pTroopType)
If $pMatchMode = $DT Or $pMatchMode = $TB Then Return True
If $pMatchMode = $MA Then
Local $tempArr = $troopsToBeUsed[$g_aiAttackTroopSelection[$DB]]
Else
Local $tempArr = $troopsToBeUsed[$g_aiAttackTroopSelection[$pMatchMode]]
EndIf
For $x = 0 To UBound($tempArr) - 1
If $tempArr[$x] = $pTroopType Then
If $pMatchMode =$MA and $pTroopType = $eGobl Then
Return False
Else
Return True
EndIf
EndIf
Next
Return False
EndFunc
Func IsSpecialTroopToBeUsed($pMatchMode, $pTroopType)
Local $iTempMode =($pMatchMode = $MA ? $DB : $pMatchMode)
If $pMatchMode <> $DB and $pMatchMode <> $LB and $pMatchMode <> $TS and $pMatchMode <> $MA Then
Return True
Else
Switch $pTroopType
Case $eKing
If(BitAND($g_aiAttackUseHeroes[$iTempMode], $eHeroKing) = $eHeroKing) Then Return True
Case $eQueen
If(BitAND($g_aiAttackUseHeroes[$iTempMode], $eHeroQueen) = $eHeroQueen) Then Return True
Case $eWarden
If(BitAND($g_aiAttackUseHeroes[$iTempMode], $eHeroWarden) = $eHeroWarden) Then Return True
Case $eCastle
If $g_abAttackDropCC[$iTempMode] Then Return True
Case $eLSpell
If $g_abAttackUseLightSpell[$iTempMode] Or $ichkSmartZap = 1 Then Return True
Case $eHSpell
If $g_abAttackUseHealSpell[$iTempMode] Then Return True
Case $eRSpell
If $g_abAttackUseRageSpell[$iTempMode] Then Return True
Case $eJSpell
If $g_abAttackUseJumpSpell[$iTempMode] Then Return True
Case $eFSpell
If $g_abAttackUseFreezeSpell[$iTempMode] Then Return True
Case $ePSpell
If $g_abAttackUsePoisonSpell[$iTempMode] Then Return True
Case $eESpell
If $g_abAttackUseEarthquakeSpell[$iTempMode] = 1 Or $ichkSmartZap = 1 Then Return True
Case $eHaSpell
If $g_abAttackUseHasteSpell[$iTempMode] Then Return True
Case $eCSpell
If $g_abAttackUseCloneSpell[$iTempMode] Then Return True
Case $eSkSpell
If $g_abAttackUseSkeletonSpell[$iTempMode] Then Return True
Case Else
Return False
EndSwitch
Return False
EndIf
EndFunc
Func SnipeWhileTrain()
Local $tempSnipeWhileTrain[8] = [0, 0, 0, 0, 0, 0, 0, 0]
Local $isSnipeWhileTrain = False
Local $SnipeChangedSettings = False
If $g_iDebugSetlog = 1 Then Setlog("SnipeWhileTrain function ", $COLOR_DEBUG)
If $iChkSnipeWhileTrain = 1 And $g_iCommandStop <> 0 And $g_iCommandStop <> 3 Then
If($CurCamp <=($TotalCamp * $itxtminArmyCapacityTHSnipe / 100)) Then
SetLog("army Capacity below " & $itxtminArmyCapacityTHSnipe & "%, not enough for Snipe While Train")
Return False
EndIf
If $fullArmy = False And($CurCamp / $TotalCamp >=($itxtminArmyCapacityTHSnipe / 100)) = True Then
$tempSnipeWhileTrain[0] = $g_abFilterMeetTrophyEnable[$DB]
$tempSnipeWhileTrain[1] = $g_abFilterMeetTrophyEnable[$LB]
$tempSnipeWhileTrain[2] = $g_aiFilterMeetTrophyMin[$DB]
$tempSnipeWhileTrain[3] = $g_aiFilterMeetTrophyMin[$LB]
$tempSnipeWhileTrain[4] = $g_abFilterMeetOneConditionEnable[$LB]
$tempSnipeWhileTrain[5] = $g_abFilterMeetOneConditionEnable[$DB]
$tempSnipeWhileTrain[7] = $g_iAtkTSAddTilesFullTroops
$g_abFilterMeetTrophyEnable[$DB] = True
$g_abFilterMeetTrophyEnable[$LB] = True
$g_aiFilterMeetTrophyMin[$DB] = 99
$g_aiFilterMeetTrophyMin[$LB] = 99
$g_abFilterMeetOneConditionEnable[$LB] = False
$g_abFilterMeetOneConditionEnable[$DB] = False
$g_iAtkTSAddTilesFullTroops = $g_iAtkTSAddTilesWhileTrain
$SnipeChangedSettings = True
SetLog("***[Trying TH snipe while training army]***", 0x808000)
$isSnipeWhileTrain = True
$Is_ClientSyncError = False
AttackMain()
$g_bRestart = False
$Is_ClientSyncError = False
$isSnipeWhileTrain = False
SetLog("***[End trying TH snipe while training army]***", 0x808000)
If $SnipeChangedSettings = True Then
$g_abFilterMeetTrophyEnable[$DB] = $tempSnipeWhileTrain[0]
$g_abFilterMeetTrophyEnable[$LB] = $tempSnipeWhileTrain[1]
$g_aiFilterMeetTrophyMin[$DB] = $tempSnipeWhileTrain[2]
$g_aiFilterMeetTrophyMin[$LB] = $tempSnipeWhileTrain[3]
$g_abFilterMeetOneConditionEnable[$LB] = $tempSnipeWhileTrain[4]
$g_abFilterMeetOneConditionEnable[$DB] = $tempSnipeWhileTrain[5]
$g_iAtkTSAddTilesFullTroops = $tempSnipeWhileTrain[7]
$Is_ClientSyncError = False
EndIf
$SnipeChangedSettings = False
$isSnipeWhileTrain = False
Return True
EndIf
EndIf
EndFunc
Func Unbreakable()
Local $x, $y, $i, $iTime, $iCount
Switch $g_iUnbrkMode
Case 2
If(Number($iGoldCurrent) > Number($g_iUnbrkMaxGold)) And(Number($iElixirCurrent) > Number($g_iUnbrkMaxElixir)) And(Number($iDarkCurrent) > Number($g_iUnbrkMaxDark)) Then
SetLog(" ====== Unbreakable Mode restarted! ====== ", $COLOR_SUCCESS)
$g_iUnbrkMode = 1
Else
SetLog(" = Unbreakable Mode Paused, Farming to Refill Storages =", $COLOR_INFO)
Return False
EndIf
Case 1
SetLog(" ====== Unbreakable Mode enabled! ====== ", $COLOR_SUCCESS)
Case Else
SetLog(">>> Programmer Humor, You shouldn't ever see this message, RUN! <<<", $COLOR_DEBUG)
EndSwitch
Select
Case $iChkTrophyAtkDead = 1
If($CurCamp <=($TotalCamp * 70 / 100)) Then
SetLog("Oops, wait for 70% troops due attack dead base checked", $COLOR_ERROR)
Return True
EndIf
Case $iChkTrophyAtkDead = 0
If($CurCamp <=($TotalCamp * 20 / 100)) Then
SetLog("Oops, wait for 20% troops for use in trophy drop", $COLOR_ERROR)
Return True
EndIf
Case Else
SetLog("You should not see this, silly programmer made a mistake, RUN!", $COLOR_WARNING)
EndSelect
Local $sMissingLoot = ""
If((Number($iGoldCurrent) - Number($g_iUnbrkMinGold)) < 0) Then
$sMissingLoot &= "Gold, "
EndIf
If((Number($iElixirCurrent) - Number($g_iUnbrkMinElixir)) < 0) Then
$sMissingLoot &= "Elixir, "
EndIf
If((Number($iDarkCurrent) - Number($g_iUnbrkMinDark)) < 0) Then
$sMissingLoot &= "Dark Elixir"
EndIf
If $sMissingLoot <> "" Then
SetLog("Oops, Out of " & $sMissingLoot & " - back to farming", $COLOR_ERROR)
$g_iUnbrkMode = 2
Return False
EndIf
DropTrophy()
If _Sleep($iDelayUnbreakable2) Then Return True
ClickP($aAway, 1, $iDelayUnbreakable7, "#0112")
If _Sleep($iDelayUnbreakable1) Then Return True
If $g_bRestart = True Then Return True
$iCount = 0
Local $iTrophyCurrent = getTrophyMainScreen($aTrophies[0], $aTrophies[1])
If $g_iDebugSetlog = 1 Then Setlog("Trophy Count Read = " & $iTrophyCurrent, $COLOR_DEBUG)
While Number($iTrophyCurrent) > Number($itxtMaxTrophy)
If $g_iDebugSetlog = 1 Then Setlog("Drop Trophy Loop #" & $iCount + 1, $COLOR_DEBUG)
DropTrophy()
If _Sleep($iDelayUnbreakable2) Then Return
ClickP($aAway, 1, 0, "#0395")
If _Sleep($iDelayUnbreakable1) Then Return
$iTrophyCurrent = getTrophyMainScreen($aTrophies[0], $aTrophies[1])
If($iCount > 2) And(Number($iTrophyCurrent) > Number($itxtMaxTrophy)) Then
Setlog("Unable to drop trophy, trying again", $COLOR_ERROR)
If _Sleep(500) Then Return
Return True
EndIf
$iCount += 1
WEnd
If $g_bRestart = True Then Return True
BreakPersonalShield()
If @error Then
If @extended <> "" Then Setlog("PersonalShield button problem: " & @extended, $COLOR_ERROR)
Return True
EndIf
ClickP($aAway, 2, $iDelayUnbreakable8, "#0115")
If _Sleep($iDelayUnbreakable1) Then Return True
If CheckObstacles() = True Then Setlog("Window clean required, but no problem for MyBot!", $COLOR_INFO)
SetLog("Closing Clash Of Clans", $COLOR_INFO)
$i = 0
While 1
AndroidBackButton()
If _Sleep($iDelayUnbreakable1) Then Return True
Local $offColors[3][3] = [[0x000000, 144, 0], [0xFFFFFF, 54, 17], [0xCBE870, 54, 10]]
Global $ButtonPixel = _MultiPixelSearch(438, 372 + $g_iMidOffsetY, 590, 404 + $g_iMidOffsetY, 1, 1, Hex(0x000000, 6), $offColors, 20)
If $g_iDebugSetlog = 1 Then Setlog("Exit btn chk-#1: " & _GetPixelColor(441, 374, True) & ", #2: " & _GetPixelColor(441 + 144, 374, True) & ", #3: " & _GetPixelColor(441 + 54, 374 + 17, True) & ", #4: " & _GetPixelColor(441 + 54, 374 + 10, True), $COLOR_DEBUG)
If IsArray($ButtonPixel) Then
If $g_iDebugSetlog = 1 Then
Setlog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("Pixel color found #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 144, $ButtonPixel[1], True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 54, $ButtonPixel[1] + 17, True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 54, $ButtonPixel[1] + 27, True), $COLOR_DEBUG)
EndIf
PureClick($ButtonPixel[0] + 75, $ButtonPixel[1] + 25, 2, 50, "#0117")
ExitLoop
EndIf
If $i > 15 Then ExitLoop
$i += 1
WEnd
$iTime = Number($g_iUnbrkWait)
If $iTime < 1 Then $iTime = 1
Local Const $iGracePeriodTime = 5
$iTime =($iTime + $iGracePeriodTime) * 60 * 1000
WaitnOpenCoC($iTime, False)
$iCount = 0
While 1
If $g_iDebugSetlog = 1 Then Setlog("Under Attack Pixels = " & _GetPixelColor(841, 342 + $g_iMidOffsetY, True) & "/" & _GetPixelColor(842, 348 + $g_iMidOffsetY, True), $COLOR_DEBUG)
If _ColorCheck(_GetPixelColor(841, 342 + $g_iMidOffsetY, True), Hex(0x711C0A, 6), 20) And _ColorCheck(_GetPixelColor(842, 348 + $g_iMidOffsetY, True), Hex(0x721C0E, 6), 20) Then
Setlog("Base is under attack, waiting 30 seocnds for end", $COLOR_INFO)
Else
ExitLoop
EndIf
If _SleepStatus($iDelayUnbreakable6) Then Return True
If $iCount > 7 Then ExitLoop
$iCount += 1
WEnd
If _Sleep($iDelayUnbreakable4) Then Return True
Local $Message = _PixelSearch(20, 624, 105, 627, Hex(0xE1E3CB, 6), 15)
If IsArray($Message) Then
If $g_iDebugSetlog = 1 Then Setlog("Return Home Pixel = " & _GetPixelColor($Message[0], $Message[1], True) & ", Pos: " & $Message[0] & "/" & $Message[1], $COLOR_DEBUG)
PureClick(67, 602 + $g_iBottomOffsetY, 1, 0, "#0138")
If _Sleep($iDelayUnbreakable3) Then Return True
EndIf
If _ColorCheck(_GetPixelColor(235, 209 + $g_iMidOffsetY, True), Hex(0x9E3826, 6), 20) And _ColorCheck(_GetPixelColor(242, 140 + $g_iMidOffsetY, True), Hex(0xFFFFFF, 6), 20) Then
If $g_iDebugSetlog = 1 Then Setlog("Village Attacked Pixels = " & _GetPixelColor(235, 209 + $g_iMidOffsetY, True) & "/" & _GetPixelColor(242, 140 + $g_iMidOffsetY, True), $COLOR_DEBUG)
PureClick(429, 493 + $g_iMidOffsetY, 1, 0, "#0132")
If _Sleep($iDelayUnbreakable3) Then Return True
EndIf
If CheckObstacles() = True Then
If _Sleep($iDelayUnbreakable3) Then Return
If CheckObstacles() = True Then CheckMainScreen(False)
Return
EndIf
ZoomOut()
If _Sleep($iDelayUnbreakable1) Then Return True
Return True
EndFunc
Func Barch()
While 1
Local $Barb = -1, $Arch = -1, $CC = -1
Global $King = -1, $Queen = -1, $Warden = -1
For $i = 0 To UBound($atkTroops) - 1
If $atkTroops[$i][0] = "Barbarian" Then
$Barb = $i
ElseIf $atkTroops[$i][0] = "Archer" Then
$Arch = $i
ElseIf $atkTroops[$i][0] = "Clan Castle" Then
$CC = $i
ElseIf $atkTroops[$i][0] = "King" Then
$King = $i
ElseIf $atkTroops[$i][0] = "Queen" Then
$Queen = $i
ElseIf $atkTroops[$i][0] = "Warden" Then
$Warden = $i
EndIf
Next
If _Sleep($iDelayBarch2) Then ExitLoop
Switch $g_aiAttackStdDropSides[$g_iMatchMode]
Case 0
SetLog("~Attacking from two sides...")
If _Sleep($iDelayBarch3) Then ExitLoop
Local $numBarbPerSpot = Ceiling((($atkTroops[$Barb][1] / 2) / 5) / 2)
Local $numArchPerSpot = Ceiling((($atkTroops[$Arch][1] / 2) / 5) / 2)
SetLog("Dropping first wave of Barbarians", $COLOR_INFO)
For $i = 0 To 4
Click(GetXPosOfArmySlot($Barb, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0032")
If _Sleep($iDelayBarch1) Then ExitLoop(2)
Click($TopLeft[$i][0], $TopLeft[$i][1], $numBarbPerSpot, 1, "#0033")
Click($BottomRight[$i][0], $BottomRight[$i][1], $numBarbPerSpot, 1, "#0034")
Next
If _Sleep($iDelayBarch3) Then ExitLoop
SetLog("Dropping first wave of Archers", $COLOR_INFO)
For $i = 0 To 4
Click(GetXPosOfArmySlot($Arch, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0035")
If _Sleep($iDelayBarch1) Then ExitLoop(2)
Click($TopLeft[$i][0], $TopLeft[$i][1], $numArchPerSpot, 1, "#0036")
Click($BottomRight[$i][0], $BottomRight[$i][1], $numArchPerSpot, 1, "#0037")
Next
If _Sleep(2000) Then ExitLoop
SetLog("Dropping second wave of Barbarians", $COLOR_INFO)
For $i = 0 To 4
Click(GetXPosOfArmySlot($Barb, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0038")
If _Sleep($iDelayBarch1) Then ExitLoop(2)
Click($TopLeft[$i][0], $TopLeft[$i][1], $numBarbPerSpot, 1, "#0039")
Click($BottomRight[$i][0], $BottomRight[$i][1], $numBarbPerSpot, 1, "#0040")
Next
If _Sleep($iDelayBarch3) Then ExitLoop
SetLog("Dropping second wave of Archers", $COLOR_INFO)
For $i = 0 To 4
Click(GetXPosOfArmySlot($Arch, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0041")
If _Sleep($iDelayBarch1) Then ExitLoop(2)
Click($TopLeft[$i][0], $TopLeft[$i][1], $numArchPerSpot, 1, "#0042")
Click($BottomRight[$i][0], $BottomRight[$i][1], $numArchPerSpot, 1, "#0043")
Next
dropHeroes($TopLeft[3][0], $TopLeft[3][1], $King, $Queen, $Warden)
If _Sleep($iDelayBarch3) Then ExitLoop
dropCC($TopLeft[3][0], $TopLeft[3][1], $CC)
Case 1
SetLog("~Attacking from three sides...")
If _Sleep($iDelayBarch3) Then ExitLoop
Local $numBarbPerSpot = Ceiling((($atkTroops[$Barb][1] / 3) / 5) / 2)
Local $numArchPerSpot = Ceiling((($atkTroops[$Arch][1] / 3) / 5) / 2)
SetLog("Dropping first wave of Barbarians", $COLOR_INFO)
For $i = 0 To 4
Click(GetXPosOfArmySlot($Barb, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0044")
If _Sleep($iDelayBarch1) Then ExitLoop(2)
Click($TopLeft[$i][0], $TopLeft[$i][1], $numBarbPerSpot, 1, "#0045")
Click($TopRight[$i][0], $TopRight[$i][1], $numBarbPerSpot, 1, "#0046")
Click($BottomRight[$i][0], $BottomRight[$i][1], $numBarbPerSpot, 1, "#0047")
Next
If _Sleep($iDelayBarch3) Then ExitLoop
SetLog("Dropping first wave of Archers", $COLOR_INFO)
For $i = 0 To 4
Click(GetXPosOfArmySlot($Arch, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0048")
If _Sleep($iDelayBarch1) Then ExitLoop(2)
Click($TopLeft[$i][0], $TopLeft[$i][1], $numArchPerSpot, 1, "#0049")
Click($TopRight[$i][0], $TopRight[$i][1], $numArchPerSpot, 1, "#0050")
Click($BottomRight[$i][0], $BottomRight[$i][1], $numArchPerSpot, 1, "#0051")
Next
If _Sleep(2000) Then ExitLoop
SetLog("Dropping second wave of Barbarians", $COLOR_INFO)
For $i = 0 To 4
Click(GetXPosOfArmySlot($Barb, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0052")
If _Sleep($iDelayBarch1) Then ExitLoop(2)
Click($TopLeft[$i][0], $TopLeft[$i][1], $numBarbPerSpot, 1, "#0053")
Click($TopRight[$i][0], $TopRight[$i][1], $numBarbPerSpot, 1, "#0054")
Click($BottomRight[$i][0], $BottomRight[$i][1], $numBarbPerSpot, 1, "#0055")
Next
If _Sleep($iDelayBarch3) Then ExitLoop
SetLog("Dropping second wave of Archers", $COLOR_INFO)
For $i = 0 To 4
Click(GetXPosOfArmySlot($Arch, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0085")
If _Sleep($iDelayBarch1) Then ExitLoop(2)
Click($TopLeft[$i][0], $TopLeft[$i][1], $numArchPerSpot, 1, "#0056")
Click($TopRight[$i][0], $TopRight[$i][1], $numArchPerSpot, 1, "#0057")
Click($BottomRight[$i][0], $BottomRight[$i][1], $numArchPerSpot, 1, "#0058")
Next
dropHeroes($TopRight[3][0], $TopRight[3][1], $King, $Queen, $Warden)
If _Sleep($iDelayBarch3) Then ExitLoop
dropCC($TopRight[3][0], $TopRight[3][1], $CC)
Case 2
SetLog("~Attacking from all sides...")
If _Sleep($iDelayBarch3) Then ExitLoop
Local $numBarbPerSpot = Ceiling((($atkTroops[$Barb][1] / 4) / 5) / 2)
Local $numArchPerSpot = Ceiling((($atkTroops[$Arch][1] / 4) / 5) / 2)
SetLog("Dropping first wave of Barbarians", $COLOR_INFO)
For $i = 0 To 4
Click(GetXPosOfArmySlot($Barb, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0059")
If _Sleep($iDelayBarch1) Then ExitLoop(2)
Click($TopLeft[$i][0], $TopLeft[$i][1], $numBarbPerSpot, 1, "#0060")
Click($TopRight[$i][0], $TopRight[$i][1], $numBarbPerSpot, 1, "#0061")
Click($BottomLeft[$i][0], $BottomLeft[$i][1], $numBarbPerSpot, 1, "#0062")
Click($BottomRight[$i][0], $BottomRight[$i][1], $numBarbPerSpot, 1, "#0063")
Next
If _Sleep($iDelayBarch3) Then ExitLoop
SetLog("Dropping first wave of Archers", $COLOR_INFO)
For $i = 0 To 4
Click(GetXPosOfArmySlot($Arch, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0064")
If _Sleep($iDelayBarch1) Then ExitLoop(2)
Click($TopLeft[$i][0], $TopLeft[$i][1], $numArchPerSpot, 1, "#0065")
Click($TopRight[$i][0], $TopRight[$i][1], $numArchPerSpot, 1, "#0066")
Click($BottomLeft[$i][0], $BottomLeft[$i][1], $numArchPerSpot, 1, "#0067")
Click($BottomRight[$i][0], $BottomRight[$i][1], $numArchPerSpot, 1, "#0068")
Next
If _Sleep(2000) Then ExitLoop
SetLog("Dropping second wave of Barbarians", $COLOR_INFO)
For $i = 0 To 4
Click(GetXPosOfArmySlot($Barb, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0069")
If _Sleep($iDelayBarch1) Then ExitLoop(2)
Click($TopLeft[$i][0], $TopLeft[$i][1], $numBarbPerSpot, 1, "#0070")
Click($TopRight[$i][0], $TopRight[$i][1], $numBarbPerSpot, 1, "#0071")
Click($BottomLeft[$i][0], $BottomLeft[$i][1], $numBarbPerSpot, 1, "#0072")
Click($BottomRight[$i][0], $BottomRight[$i][1], $numBarbPerSpot, 1, "#0073")
Next
If _Sleep($iDelayBarch3) Then ExitLoop
SetLog("Dropping second wave of Archers", $COLOR_INFO)
For $i = 0 To 4
Click(GetXPosOfArmySlot($Arch, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0074")
If _Sleep($iDelayBarch1) Then ExitLoop(2)
Click($TopLeft[$i][0], $TopLeft[$i][1], $numArchPerSpot, 1, "#0075")
Click($TopRight[$i][0], $TopRight[$i][1], $numArchPerSpot, 1, "#0076")
Click($BottomLeft[$i][0], $BottomLeft[$i][1], $numArchPerSpot, 1, "#0077")
Click($BottomRight[$i][0], $BottomRight[$i][1], $numArchPerSpot, 1, "#0078")
Next
dropHeroes($BottomLeft[3][0], $BottomLeft[3][1], $King, $Queen, $Warden)
If _Sleep($iDelayBarch3) Then ExitLoop
dropCC($BottomLeft[3][0], $BottomLeft[3][1], $CC)
EndSwitch
If _Sleep($iDelayBarch1) Then ExitLoop
SetLog("Dropping left over troops", $COLOR_INFO)
$atkTroops[$Barb][1] = Number(ReadTroopQuantity($Barb))
$atkTroops[$Arch][1] = Number(ReadTroopQuantity($Arch))
While $atkTroops[$Barb][1] <> 0
Click(GetXPosOfArmySlot($Barb, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0079")
Click($TopLeft[3][0], $TopLeft[3][1], $atkTroops[$Barb][1], 1, "#0080")
$atkTroops[$Barb][1] = Number(ReadTroopQuantity($Barb))
WEnd
If _Sleep($iDelayBarch3) Then ExitLoop
While $atkTroops[$Arch][1] <> 0
Click(GetXPosOfArmySlot($Arch, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0081")
Click($TopLeft[3][0], $TopLeft[3][1], $atkTroops[$Arch][1], 1, "#0082")
$atkTroops[$Arch][1] = Number(ReadTroopQuantity($Arch))
WEnd
If _Sleep($iDelayBarch1) Then ExitLoop
If $checkKPower = True Or $checkQPower = True Then
SetLog("Waiting " & $delayActivateKQ / 1000 & " seconds before activating Hero abilities", $COLOR_SUCCESS)
If _Sleep($delayActivateKQ) Then Return
If $checkKPower = True Then
SetLog("Activate King's power", $COLOR_INFO)
Click(GetXPosOfArmySlot($King, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0083")
EndIf
If $checkQPower = True Then
SetLog("Activate Queen's power", $COLOR_INFO)
Click(GetXPosOfArmySlot($Queen, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0084")
EndIf
EndIf
SetLog("~Finished Attacking, waiting to finish")
ExitLoop
WEnd
EndFunc
Func AttackTHGrid($troopKind, $iNbOfSpots = 1, $iAtEachSpot = 1, $Sleep = Random(800, 900, 1), $waveNb = 0)
Local $TroopCountBeg
Local $THtroop = -1
Local $troopNb = 0
Local $name = ""
Local $plural = 0
Local $waveName = "first"
Local $NumTroopDeployed = 0
If _Sleep(5) Then Return
If $g_bRestart = True Then Return
If CheckOneStar(0, False, True) Then Return
For $i = 0 To UBound($atkTroops) - 1
If $atkTroops[$i][0] = $troopKind Then
$THtroop = $i
EndIf
Next
If($THtroop = -1) And $g_iDebugSetlog = 1 Then SetLog("No " & $name & " Found!!!")
If($THtroop = -1) Then Return False
If $troopKind >= $eKing And $troopKind <= $eCastle Then
$iNbOfSpots = 1
$iAtEachSpot = 1
$troopNb = 1
If $troopKind = $eKing Then
If $duringMilkingAttack = 0 And BitAND($g_aiAttackUseHeroes[$TS], $eHeroKing) <> $eHeroKing Then Return
If $duringMilkingAttack = 1 And BitAND($g_aiAttackUseHeroes[$DB], $eHeroKing) <> $eHeroKing Then Return
$checkKPower = True
SetLog("Dropping King", $COLOR_SUCCESS)
$THusedKing = 1
EndIf
If $troopKind = $eQueen Then
If $duringMilkingAttack = 0 And BitAND($g_aiAttackUseHeroes[$TS], $eHeroQueen) <> $eHeroQueen Then Return
If $duringMilkingAttack = 1 And BitAND($g_aiAttackUseHeroes[$DB], $eHeroQueen) <> $eHeroQueen Then Return
$checkQPower = True
SetLog("Dropping Queen", $COLOR_SUCCESS)
$THusedQueen = 1
EndIf
If $troopKind = $eWarden Then
If $duringMilkingAttack = 0 And BitAND($g_aiAttackUseHeroes[$TS], $eHeroWarden) <> $eHeroWarden Then Return
If $duringMilkingAttack = 1 And BitAND($g_aiAttackUseHeroes[$DB], $eHeroWarden) <> $eHeroWarden Then Return
$checkWPower = True
SetLog("Dropping Grand Warden", $COLOR_SUCCESS)
$THusedWarden = 1
EndIf
If $troopKind = $eCastle Then
If $duringMilkingAttack = 0 And $g_abAttackDropCC[$TS] Then Return
If $duringMilkingAttack = 1 And $g_abAttackDropCC[$DB] Then Return
If $iPlannedDropCCHoursEnable = 1 Then
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If $iPlannedDropCCHours[$hour[0]] = 0 Then
SetLog("Drop Clan Castle not Planned, Skipped..", $COLOR_SUCCESS)
Return
EndIf
EndIf
If $iChkUseCCBalanced = 1 Then
If Number($TroopsReceived) <> 0 Then
If Number(Number($TroopsDonated) / Number($TroopsReceived)) >=(Number($iCmbCCDonated) / Number($iCmbCCReceived)) Then
SetLog("Dropping Clan Castle, donated (" & $TroopsDonated & ") / received (" & $TroopsReceived & ") >= " & $iCmbCCDonated & "/" & $iCmbCCReceived, $COLOR_INFO)
Else
SetLog("Not Dropping Clan Castle, donated  (" & $TroopsDonated & ") / received (" & $TroopsReceived & ") < " & $iCmbCCDonated & "/" & $iCmbCCReceived, $COLOR_INFO)
Return
EndIf
Else
If Number(Number($TroopsDonated) / 1) >=(Number($iCmbCCDonated) / Number($iCmbCCReceived)) Then
SetLog("Dropping Clan Castle, donated (" & $TroopsDonated & ") / received (" & $TroopsReceived & ") >= " & $iCmbCCDonated & "/" & $iCmbCCReceived, $COLOR_INFO)
Else
SetLog("Not Dropping Clan Castle, donated  (" & $TroopsDonated & ") / received (" & $TroopsReceived & ") < " & $iCmbCCDonated & "/" & $iCmbCCReceived, $COLOR_INFO)
Return
EndIf
EndIf
EndIf
EndIf
EndIf
If $troopKind >= $eBarb And $troopKind <= $eBowl Then
$troopNb = $iNbOfSpots * $iAtEachSpot
If $troopNb > 1 Then $plural = 1
$name = NameOfTroop($troopKind, $plural)
$TroopCountBeg = Number(ReadTroopQuantity($THtroop))
If($TroopCountBeg = 0) And $g_iDebugSetlog = 1 Then SetLog("No " & $name & " Remaining!!!")
If($TroopCountBeg = 0) Then Return False
If $waveNb = 0 Then $waveName = "Only"
If $waveNb = 1 Then $waveName = "First"
If $waveNb = 2 Then $waveName = "Second"
If $waveNb = 3 Then $waveName = "Third"
If $waveNb = 4 Then $waveName = "Last"
SetLog("Dropping " & $waveName & " wave of " & $troopNb & " " & $name, $COLOR_SUCCESS)
EndIf
SelectDropTroop($THtroop)
If _Sleep($iDelayAttackTHGrid1) Then Return
DeployTHNormal($iAtEachSpot, $iNbOfSpots)
If $troopKind >= $eBarb And $troopKind <= $eBowl Then
If $TroopCountBeg <> Number(ReadTroopQuantity($THtroop)) Then
$NumTroopDeployed = $TroopCountBeg - Number(ReadTroopQuantity($THtroop))
SetLog("Deployment of " & $NumTroopDeployed & " " & $name & " was Successful!")
If _Sleep($Sleep) Then Return
Else
SetLog("Deployment of " & $name & " wasn't Successful!")
EndIf
EndIf
If $troopKind >= $eKing And $troopKind <= $eCastle Then
SelectDropTroop(0)
If _Sleep($Sleep) Then Return
EndIf
EndFunc
Func DeployTHNormal($iAtEachSpot, $iNbOfSpots)
Local $aThx = 0, $aThy = 0
Switch $THside
Case 0
For $num = 0 To $iAtEachSpot - 1
For $i = $THi - 1 To $THi - 1 + Ceiling(($iNbOfSpots - 1) / 2)
$aThx = 25 - $i * 16
$aThy = 314 + $i * 12
Next
For $ii = $THi - 1 To $THi - 1 +($iNbOfSpots - 1)
$aThx = 25 + $ii * 16
$aThy = 314 - $ii * 12
If CheckOneStar(0, False, False) Then Return
If IsAttackPage() Then Click(Random($aThx - 5, $aThx + 5, 1), Random($aThy - 5, $aThy + 5, 1), 1, 0, "#0019")
If _Sleep(Random(20, 40, 1)) Then Return
Next
Next
Case 1
For $num = 0 To $iAtEachSpot - 1
For $i = $THi To $THi + Ceiling(($iNbOfSpots - 1) / 2)
$aThx = 25 - $i * 16
$aThy = 314 - $i * 12
Next
For $ii = $THi To $THi +($iNbOfSpots - 1)
$aThx = 25 + $ii * 16
$aThy = 314 + $ii * 12
If CheckOneStar(0, False, False) Then Return
If IsAttackPage() Then Click(Random($aThx - 5, $aThx + 5, 1), Random($aThy - 5, $aThy + 5, 1), 1, 0, "#0020")
If _Sleep(Random(20, 40, 1)) Then Return
Next
Next
Case 2
For $num = 0 To $iAtEachSpot - 1
For $i = $THi To $THi + Ceiling(($iNbOfSpots - 1) / 2)
$aThx = 830 + $i * 16
$aThy = 314 + $i * 12
Next
For $ii = $THi To $THi +($iNbOfSpots - 1)
$aThx = 830 - $ii * 16
$aThy = 314 - $ii * 12
If CheckOneStar(0, False, False) Then Return
If IsAttackPage() Then Click(Random($aThx - 5, $aThx + 5, 1), Random($aThy - 5, $aThy + 5, 1), 1, 0, "#0021")
If _Sleep(Random(20, 40, 1)) Then Return
Next
Next
Case 3
For $num = 0 To $iAtEachSpot - 1
For $i = $THi + 1 To $THi + 1 + Ceiling(($iNbOfSpots - 1) / 2)
$aThx = 830 + $i * 16
$aThy = 314 - $i * 12
Next
For $ii = $THi + 1 To $THi + 1 +($iNbOfSpots - 1)
$aThx = 830 - $ii * 16
$aThy = 314 + $ii * 12
If CheckOneStar(0, False, False) Then Return
If IsAttackPage() Then Click(Random($aThx - 5, $aThx + 5, 1), Random($aThy - 5, $aThy + 5, 1), 1, 0, "#0022")
If _Sleep(Random(20, 40, 1)) Then Return
Next
Next
EndSwitch
EndFunc
Func SpellTHGrid($S)
If $duringMilkingAttack = 0 And(($S = $eHSpell And $g_abAttackUseHealSpell[$TS]) Or($S = $eLSpell And $g_abAttackUseLightSpell[$TS]) Or($S = $eRSpell And $g_abAttackUseRageSpell[$TS]) Or($S = $eJSpell And $g_abAttackUseJumpSpell[$TS]) Or($S = $eFSpell And $g_abAttackUseFreezeSpell[$TS]) Or($S = $ePSpell And $g_abAttackUsePoisonSpell[$TS]) Or($S = $eHaSpell And $g_abAttackUseHasteSpell[$TS]) Or($S = $eESpell And $g_abAttackUseEarthquakeSpell[$TS])) Or $duringMilkingAttack = 1 And(($S = $eHSpell And $g_abAttackUseHealSpell[$DB]) Or($S = $eLSpell And $g_abAttackUseLightSpell[$DB]) Or($S = $eRSpell And $g_abAttackUseRageSpell[$DB]) Or($S = $eJSpell And $g_abAttackUseJumpSpell[$DB]) Or($S = $eFSpell And $g_abAttackUseFreezeSpell[$DB]) Or($S = $ePSpell And $g_abAttackUsePoisonSpell[$DB]) Or($S = $eHaSpell And $g_abAttackUseHasteSpell[$DB]) Or($S = $eESpell And $g_abAttackUseEarthquakeSpell[$DB])) Then
If _Sleep(10) Then Return
If $g_bRestart = True Then Return
If CheckOneStar(0, False, True) Then Return
If $THi <= 15 Or $THside = 0 Or $THside = 2 Then
Switch $THside
Case 0
CastSpell($S, 114 + $THi * 16 + Ceiling(-2 * 16), 359 - $THi * 12 + Ceiling(-2 * 12))
Case 1
CastSpell($S, 117 + $THi * 16 + Ceiling(-2 * 16), 268 + $THi * 12 - Floor(-2 * 12))
Case 2
CastSpell($S, 743 - $THi * 16 - Floor(-2 * 16), 358 - $THi * 12 + Ceiling(-2 * 12))
Case 3
CastSpell($S, 742 - $THi * 16 - Floor(-2 * 16), 268 + $THi * 12 - Floor(-2 * 12))
EndSwitch
EndIf
If $THi > 15 And($THside = 1 Or $THside = 3) Then
CastSpell($S, $THx, $THy)
EndIf
EndIf
EndFunc
Func CastSpell($THSpell, $x, $y)
Local $Spell = -1
Local $name = ""
If _Sleep(10) Then Return
If $g_bRestart = True Then Return
If CheckOneStar(0, False, True) Then Return
For $i = 0 To UBound($atkTroops) - 1
If $atkTroops[$i][0] = $THSpell Then
$Spell = $i
$name = NameOfTroop($THSpell, 0)
EndIf
Next
If $Spell > -1 Then
SetLog("Dropping " & $name)
SelectDropTroop($Spell)
If _Sleep($iDelayCastSpell1) Then Return
If IsAttackPage() Then Click($x, $y, 1, 0, "#0029")
Else
If $g_iDebugSetlog = 1 Then SetLog("No " & $name & " Found")
EndIf
EndFunc
Func CheckOneStar($DelayInSec = 0, $Log = True, $CheckHeroes = True)
For $i = 0 To $DelayInSec
If _Sleep(5) Then Return True
If $g_bRestart = True Then Return True
CheckHeroesHealth()
If _ColorCheck(_GetPixelColor($aWonOneStar[0], $aWonOneStar[1], True), Hex($aWonOneStar[2], 6), $aWonOneStar[3]) Then
If $Log = True Then SetLog("Townhall has been destroyed!", $COLOR_ACTION)
If $g_bRestart = True Then Return True
If $checkQPower = True Then
SetLog("Activating Queen's power to restore some health before EndBattle", $COLOR_INFO)
SelectDropTroop($Queen)
$checkQPower = False
EndIf
If _Sleep(500) Then Return True
If $g_bRestart = True Then Return True
If $checkKPower = True Then
SetLog("Activating King's power to restore some health before EndBattle", $COLOR_INFO)
SelectDropTroop($King)
$checkKPower = False
EndIf
If $Log = True Then
If _Sleep(1000) Then Return
EndIf
Return True
Else
If $i <> 0 Then
If _Sleep(1000) Then Return True
If $g_bRestart = True Then Return True
EndIf
EndIf
Next
Return False
EndFunc
Func SwitchAttackTHType()
$THusedKing = 0
$THusedQueen = 0
AttackTHParseCSV()
EndFunc
Func AttackTHParseCSV($test = False)
If $g_iDebugSetlog = 1 Then Setlog("AttackTHParseCSV start", $COLOR_DEBUG)
Local $f, $line, $acommand, $command
Local $attackCSVtoUse = ""
Switch $g_iMatchMode
Case $TS
$attackCSVtoUse = $g_sAtkTSType
Case $LB
$attackCSVtoUse = $g_iTHSnipeBeforeScript[$LB]
Case $DB
If $duringMilkingAttack = 1 Then
$attackCSVtoUse = $g_sMilkFarmAlgorithmTh
Else
$attackCSVtoUse = $g_iTHSnipeBeforeScript[$DB]
EndIf
EndSwitch
If FileExists($g_sTHSnipeAttacksPath & "\" & $attackCSVtoUse & ".csv") Then
$f = FileOpen($g_sTHSnipeAttacksPath & "\" & $attackCSVtoUse & ".csv", 0)
If $g_iDebugSetlog=1 Then Setlog("Use algorithm " & $attackCSVtoUse &".csv",$COLOR_DEBUG)
While 1
$line = FileReadLine($f)
If @error = -1 Then ExitLoop
$acommand = StringSplit($line, "|")
If $acommand[0] >= 8 Then
$command = StringStripWS(StringUpper($acommand[1]), 2)
Select
Case $command = "TROOP" Or $command = ""
Case $command = "TEXT"
If $g_iDebugSetlog = 1 Then Setlog(">> SETLOG(""" & $acommand[8] & """)")
SetLog($acommand[8], $COLOR_INFO)
Case StringInStr(StringUpper("-Barb-Arch-Giant-Gobl-Wall-Ball-Wiza-Heal-Drag-Pekk-BabyD-Mine-Mini-Hogs-Valk-Gole-Witc-Lava-Bowl"), "-" & $command & "-") > 0
If $g_iDebugSetlog = 1 Then Setlog(">> AttackTHGrid($e" & $command & ", Random (" & Int($acommand[2]) & "," & Int($acommand[3]) & ",1), Random(" & Int($acommand[4]) & "," & Int($acommand[5]) & ",1), Random(" & Int($acommand[6]) & "," & Int($acommand[7]) & ",1) )")
Local $iNbOfSpots
If Int($acommand[2]) = Int($acommand[3]) Then
$iNbOfSpots = Int($acommand[2])
Else
$iNbOfSpots = Random(Int($acommand[2]), Int($acommand[3]), 1)
EndIf
Local $iAtEachSpot
If Int($acommand[4]) = Int($acommand[5]) Then
$iAtEachSpot = Int($acommand[4])
Else
$iAtEachSpot = Random(Int($acommand[4]), Int($acommand[5]), 1)
EndIf
Local $Sleep
If Int($acommand[6]) = Int($acommand[7]) Then
$Sleep = Int($acommand[6])
Else
$Sleep = Random(Int($acommand[6]), Int($acommand[7]), 1)
EndIf
AttackTHGrid(Eval("e" & $command), $iNbOfSpots, $iAtEachSpot, $Sleep, 0)
Case $command = "WAIT"
If $g_iDebugSetlog = 1 Then Setlog(">> GoldElixirChangeThSnipes(" & Int($acommand[7]) & ") ")
If CheckOneStar(Int($acommand[7]) / 2000) Then ExitLoop
If GoldElixirChangeThSnipes(Int($acommand[7]) / 2000) Then ExitLoop
Case StringInStr(StringUpper("-King-Queen-Castle-"), "-" & $command & "-") > 0
If $g_iDebugSetlog = 1 Then Setlog(">> AttackTHGrid($e" & $command & ")")
AttackTHGrid(Eval("e" & $command))
Case StringInStr(StringUpper("-HSpell-RSpell-LSpell-JSpell-FSpell-PSpell-ESpell-HaSpell"), "-" & $command & "-") > 0
If $g_iDebugSetlog = 1 Then Setlog(">> SpellTHGrid($e" & $command & ")")
SpellTHGrid(Eval("e" & $command))
Case StringInStr(StringUpper("-LSpell-"), "-" & $command & "-") > 0
If $g_iDebugSetlog = 1 Then Setlog(">> CastSpell($e" & $command & ",$THx, $THy)")
CastSpell(Eval("e" & $command), $THx, $THy)
Case Else
Setlog("attack row bad, discard: " & $line, $COLOR_ERROR)
EndSelect
If $acommand[8] <> "" And $command <> "TEXT" And $command <> "TROOP" Then
If $g_iDebugSetlog = 1 Then Setlog(">> SETLOG(""" & $acommand[8] & """)")
SETLOG($acommand[8], $COLOR_INFO)
EndIf
Else
If StringStripWS($acommand[1], 2) <> "" Then Setlog("attack row error, discard: " & $line, $COLOR_ERROR)
EndIf
If $g_iDebugSetlog = 1 Then Setlog(">> CheckOneStar()")
If CheckOneStar() Then ExitLoop
WEnd
FileClose($f)
Else
SetLog("Cannot found THSnipe attack file " & $g_sTHSnipeAttacksPath & "\" & $attackCSVtoUse & ".csv", $COLOR_ERROR)
EndIf
EndFunc
Global $MAINSIDE = "BOTTOM-RIGHT"
Global $FRONT_LEFT = "BOTTOM-RIGHT-DOWN"
Global $FRONT_RIGHT = "BOTTOM-RIGHT-UP"
Global $RIGHT_FRONT = "TOP-RIGHT-DOWN"
Global $RIGHT_BACK = "TOP-RIGHT-UP"
Global $LEFT_FRONT = "BOTTOM-LEFT-DOWN"
Global $LEFT_BACK = "BOTTOM-LEFT-UP"
Global $BACK_LEFT = "TOP-LEFT-DOWN"
Global $BACK_RIGHT = "TOP-LEFT-UP"
Global $PixelTopLeftDropLine
Global $PixelTopRightDropLine
Global $PixelBottomLeftDropLine
Global $PixelBottomRightDropLine
Global $PixelTopLeftUPDropLine
Global $PixelTopLeftDOWNDropLine
Global $PixelTopRightUPDropLine
Global $PixelTopRightDOWNDropLine
Global $PixelBottomLeftUPDropLine
Global $PixelBottomLeftDOWNDropLine
Global $PixelBottomRightUPDropLine
Global $PixelBottomRightDOWNDropLine
Local $DeployableLRTB = [0, $g_iGAME_WIDTH - 1, 0, 626]
Local $DiamandAdjX = -28
Local $DiamandAdjY = -24
Local $OuterDiamondLeft = -18 - $DiamandAdjX, $OuterDiamondRight = 857 + $DiamandAdjX, $OuterDiamondTop = 20 - $DiamandAdjY, $OuterDiamondBottom = 679 + $DiamandAdjY
Local $DiamondMiddleX =($OuterDiamondLeft + $OuterDiamondRight) / 2
Local $DiamondMiddleY =($OuterDiamondTop + $OuterDiamondBottom) / 2
Local $InnerDiamandDiffX = 55 + $DiamandAdjX
Local $InnerDiamandDiffY = 47 + $DiamandAdjY
Local $InnerDiamondLeft = $OuterDiamondLeft + $InnerDiamandDiffX, $InnerDiamondRight = $OuterDiamondRight - $InnerDiamandDiffX, $InnerDiamondTop = $OuterDiamondTop + $InnerDiamandDiffY, $InnerDiamondBottom = $OuterDiamondBottom - $InnerDiamandDiffY
Global $CocDiamondECD = "ECD"
Global $ExternalArea[8][3]
Global $ExternalAreaRef[8][3] = [ [$OuterDiamondLeft, $DiamondMiddleY, "LEFT"], [$OuterDiamondRight, $DiamondMiddleY, "RIGHT"], [$DiamondMiddleX, $OuterDiamondTop, "TOP"], [$DiamondMiddleX, $OuterDiamondBottom, "BOTTOM"], [$OuterDiamondLeft +($DiamondMiddleX - $OuterDiamondLeft) / 2, $OuterDiamondTop +($DiamondMiddleY - $OuterDiamondTop) / 2, "TOP-LEFT"], [$DiamondMiddleX +($OuterDiamondRight - $DiamondMiddleX) / 2, $OuterDiamondTop +($DiamondMiddleY - $OuterDiamondTop) / 2, "TOP-RIGHT"], [$OuterDiamondLeft +($DiamondMiddleX - $OuterDiamondLeft) / 2, $DiamondMiddleY +($OuterDiamondBottom - $DiamondMiddleY) / 2, "BOTTOM-LEFT"], [$DiamondMiddleX +($OuterDiamondRight - $DiamondMiddleX) / 2, $DiamondMiddleY +($OuterDiamondBottom - $DiamondMiddleY) / 2, "BOTTOM-RIGHT"] ]
Global $CocDiamondDCD = "DCD"
Global $InternalArea[8][3]
Global $InternalAreaRef[8][3] = [ [$InnerDiamondLeft, $DiamondMiddleY, "LEFT"], [$InnerDiamondRight, $DiamondMiddleY, "RIGHT"], [$DiamondMiddleX, $InnerDiamondTop, "TOP"], [$DiamondMiddleX, $InnerDiamondBottom, "BOTTOM"], [$InnerDiamondLeft +($DiamondMiddleX - $InnerDiamondLeft) / 2, $InnerDiamondTop +($DiamondMiddleY - $InnerDiamondTop) / 2, "TOP-LEFT"], [$DiamondMiddleX +($InnerDiamondRight - $DiamondMiddleX) / 2, $InnerDiamondTop +($DiamondMiddleY - $InnerDiamondTop) / 2, "TOP-RIGHT"], [$InnerDiamondLeft +($DiamondMiddleX - $InnerDiamondLeft) / 2, $DiamondMiddleY +($InnerDiamondBottom - $DiamondMiddleY) / 2, "BOTTOM-LEFT"], [$DiamondMiddleX +($InnerDiamondRight - $DiamondMiddleX) / 2, $DiamondMiddleY +($InnerDiamondBottom - $DiamondMiddleY) / 2, "BOTTOM-RIGHT"] ]
ConvertInternalExternArea()
Func ConvertInternalExternArea()
Local $x, $y
For $i = 0 To 7
$x = $ExternalAreaRef[$i][0]
$y = $ExternalAreaRef[$i][1]
ConvertToVillagePos($x, $y)
$ExternalArea[$i][0] = $x
$ExternalArea[$i][1] = $y
$ExternalArea[$i][2] = $ExternalAreaRef[$i][2]
Next
$x = $ExternalAreaRef[2][0]
$y = $ExternalAreaRef[2][1] + $DiamandAdjY
ConvertToVillagePos($x, $y)
$CocDiamondECD = $x & "," & $y
$x = $ExternalAreaRef[1][0] - $DiamandAdjX
$y = $ExternalAreaRef[1][1]
ConvertToVillagePos($x, $y)
$CocDiamondECD &= "|" & $x & "," & $y
$x = $ExternalAreaRef[3][0]
$y = $ExternalAreaRef[3][1] - $DiamandAdjY
ConvertToVillagePos($x, $y)
$CocDiamondECD &= "|" & $x & "," & $y
$x = $ExternalAreaRef[0][0] + $DiamandAdjX
$y = $ExternalAreaRef[0][1]
ConvertToVillagePos($x, $y)
$CocDiamondECD &= "|" & $x & "," & $y
For $i = 0 To 7
$x = $InternalAreaRef[$i][0]
$y = $InternalAreaRef[$i][1]
ConvertToVillagePos($x, $y)
$InternalArea[$i][0] = $x
$InternalArea[$i][1] = $y
$InternalArea[$i][2] = $InternalAreaRef[$i][2]
Next
$CocDiamondDCD = $InternalArea[2][0] & "," & $InternalArea[2][1] & "|" & $InternalArea[1][0] & "," & $InternalArea[1][1] & "|" & $InternalArea[3][0] & "," & $InternalArea[3][1] & "|" & $InternalArea[0][0] & "," & $InternalArea[0][1]
EndFunc
Func CheckAttackLocation(ByRef $x, ByRef $y)
If $y > $DeployableLRTB[3] Then
$y = $DeployableLRTB[3]
Return False
EndIf
Return True
EndFunc
Func GetMinPoint($PointList, $Dim)
Local $Result = [9999, 9999]
For $i = 0 To UBound($PointList) - 1
Local $Point = $PointList[$i]
If $Point[$Dim] < $Result[$Dim] Then $Result = $Point
Next
Return $Result
EndFunc
Func GetMaxPoint($PointList, $Dim)
Local $Result = [-9999, -9999]
For $i = 0 To UBound($PointList) - 1
Local $Point = $PointList[$i]
If $Point[$Dim] > $Result[$Dim] Then $Result = $Point
Next
Return $Result
EndFunc
Func Algorithm_AttackCSV($testattack = False, $captureredarea = True)
Local $PixelNearCollectorTopLeft[0]
Local $PixelNearCollectorBottomLeft[0]
Local $PixelNearCollectorTopRight[0]
Local $PixelNearCollectorBottomRight[0]
ParseAttackCSV_Read_SIDE_variables()
$lastTroopPositionDropTroopFromINI = -1
If _Sleep($iDelayRespond) Then Return
debugAttackCSV("Troops to be used (purged from troops) ")
For $i = 0 To UBound($atkTroops) - 1
debugAttackCSV("SLOT n.: " & $i & " - Troop: " & NameOfTroop($atkTroops[$i][0]) & " (" & $atkTroops[$i][0] & ") - Quantity: " & $atkTroops[$i][1])
Next
Local $hTimerTOTAL = TimerInit()
Local $hTimer = TimerInit()
SetDebugLog("Redline mode: " & $g_aiAttackScrRedlineRoutine[$g_iMatchMode])
SetDebugLog("Dropline mode: " & $g_aiAttackScrDroplineEdge[$g_iMatchMode])
_CaptureRegion2()
If $captureredarea Then _GetRedArea($g_aiAttackScrRedlineRoutine[$g_iMatchMode])
If _Sleep($iDelayRespond) Then Return
Local $htimerREDAREA = Round(TimerDiff($hTimer) / 1000, 2)
debugAttackCSV("Calculated  (in " & $htimerREDAREA & " seconds) :")
debugAttackCSV("	[" & UBound($PixelTopLeft) & "] pixels TopLeft")
debugAttackCSV("	[" & UBound($PixelTopRight) & "] pixels TopRight")
debugAttackCSV("	[" & UBound($PixelBottomLeft) & "] pixels BottomLeft")
debugAttackCSV("	[" & UBound($PixelBottomRight) & "] pixels BottomRight")
If $g_aiAttackScrDroplineEdge[$g_iMatchMode] = $DROPLINE_DROPPOINTS_ONLY Then
$PixelTopLeftDropLine = $PixelTopLeft
$PixelTopRightDropLine = $PixelTopRight
$PixelBottomLeftDropLine = $PixelBottomLeft
$PixelBottomRightDropLine = $PixelBottomRight
Else
Local $coordLeft = [$ExternalArea[0][0], $ExternalArea[0][1]]
Local $coordTop = [$ExternalArea[2][0], $ExternalArea[2][1]]
Local $coordRight = [$ExternalArea[1][0], $ExternalArea[1][1]]
Local $coordBottom = [$ExternalArea[3][0], $ExternalArea[3][1]]
Local $StartEndTopLeft = [$coordLeft, $coordTop]
If UBound($PixelTopLeft) > 2 Then Local $StartEndTopLeft = [$PixelTopLeft[0], $PixelTopLeft[UBound($PixelTopLeft) - 1]]
Local $StartEndTopRight = [$coordTop, $coordRight]
If UBound($PixelTopRight) > 2 Then Local $StartEndTopRight = [$PixelTopRight[0], $PixelTopRight[UBound($PixelTopRight) - 1]]
Local $StartEndBottomLeft = [$coordLeft, $coordBottom]
If UBound($PixelBottomLeft) > 2 Then Local $StartEndBottomLeft = [$PixelBottomLeft[0], $PixelBottomLeft[UBound($PixelBottomLeft) - 1]]
Local $StartEndBottomRight = [$coordBottom, $coordRight]
If UBound($PixelBottomRight) > 2 Then Local $StartEndBottomRight = [$PixelBottomRight[0], $PixelBottomRight[UBound($PixelBottomRight) - 1]]
Switch $g_aiAttackScrDroplineEdge[$g_iMatchMode]
Case $DROPLINE_EDGE_FIXED, $DROPLINE_FULL_EDGE_FIXED
Local $StartEndTopLeft = [$coordLeft, $coordTop]
Local $StartEndTopRight = [$coordTop, $coordRight]
Local $StartEndBottomLeft = [$coordLeft, $coordBottom]
Local $StartEndBottomRight = [$coordBottom, $coordRight]
EndSwitch
SetDebugLog("MakeDropLines, StartEndTopLeft     = " & PixelArrayToString($StartEndTopLeft, ","))
SetDebugLog("MakeDropLines, StartEndTopRight    = " & PixelArrayToString($StartEndTopRight, ","))
SetDebugLog("MakeDropLines, StartEndBottomLeft  = " & PixelArrayToString($StartEndBottomLeft, ","))
SetDebugLog("MakeDropLines, StartEndBottomRight = " & PixelArrayToString($StartEndBottomRight, ","))
Switch $g_aiAttackScrDroplineEdge[$g_iMatchMode]
Case $DROPLINE_EDGE_FIXED, $DROPLINE_EDGE_FIRST
$PixelTopLeftDropLine = MakeDropLineOriginal($PixelTopLeft, $StartEndTopLeft[0], $StartEndTopLeft[1])
$PixelTopRightDropLine = MakeDropLineOriginal($PixelTopRight, $StartEndTopRight[0], $StartEndTopRight[1])
$PixelBottomLeftDropLine = MakeDropLineOriginal($PixelBottomLeft, $StartEndBottomLeft[0], $StartEndBottomLeft[1])
$PixelBottomRightDropLine = MakeDropLineOriginal($PixelBottomRight, $StartEndBottomRight[0], $StartEndBottomRight[1])
Case $DROPLINE_FULL_EDGE_FIXED, $DROPLINE_FULL_EDGE_FIRST
Local $iLineDistanceThreshold = 75
If $g_aiAttackScrRedlineRoutine[$g_iMatchMode] = $REDLINE_IMGLOC Then $iLineDistanceThreshold = 25
$PixelTopLeftDropLine = MakeDropLine($PixelTopLeft, $StartEndTopLeft[0], $StartEndTopLeft[1], $iLineDistanceThreshold, $g_aiAttackScrDroplineEdge[$g_iMatchMode] = $DROPLINE_FULL_EDGE_FIXED)
$PixelTopRightDropLine = MakeDropLine($PixelTopRight, $StartEndTopRight[0], $StartEndTopRight[1], $iLineDistanceThreshold, $g_aiAttackScrDroplineEdge[$g_iMatchMode] = $DROPLINE_FULL_EDGE_FIXED)
$PixelBottomLeftDropLine = MakeDropLine($PixelBottomLeft, $StartEndBottomLeft[0], $StartEndBottomLeft[1], $iLineDistanceThreshold, $g_aiAttackScrDroplineEdge[$g_iMatchMode] = $DROPLINE_FULL_EDGE_FIXED)
$PixelBottomRightDropLine = MakeDropLine($PixelBottomRight, $StartEndBottomRight[0], $StartEndBottomRight[1], $iLineDistanceThreshold, $g_aiAttackScrDroplineEdge[$g_iMatchMode] = $DROPLINE_FULL_EDGE_FIXED)
EndSwitch
EndIf
Local $tempvectstr1 = ""
Local $tempvectstr2 = ""
For $i = 0 To UBound($PixelTopLeftDropLine) - 1
Local $pixel = $PixelTopLeftDropLine[$i]
Local $slice = Slice8($pixel)
Switch StringLeft($slice, 1)
Case "6"
$tempvectstr1 &= $pixel[0] & "," & $pixel[1] & "|"
Case "5"
$tempvectstr2 &= $pixel[0] & "," & $pixel[1] & "|"
Case Else
SetDebugLog("TOP LEFT: Skip slice " & $slice & " at " & $pixel[0] & ", " & $pixel[1])
EndSwitch
Next
If StringLen($tempvectstr1) > 0 Then $tempvectstr1 = StringLeft($tempvectstr1, StringLen($tempvectstr1) - 1)
If StringLen($tempvectstr2) > 0 Then $tempvectstr2 = StringLeft($tempvectstr2, StringLen($tempvectstr2) - 1)
$PixelTopLeftDOWNDropLine = GetListPixel($tempvectstr1, ",", "TL-DOWN")
$PixelTopLeftUPDropLine = GetListPixel($tempvectstr2, ",", "TL-UP")
Local $tempvectstr1 = ""
Local $tempvectstr2 = ""
For $i = 0 To UBound($PixelTopRightDropLine) - 1
Local $pixel = $PixelTopRightDropLine[$i]
Local $slice = Slice8($pixel)
Switch StringLeft($slice, 1)
Case "3"
$tempvectstr1 &= $pixel[0] & "," & $pixel[1] & "|"
Case "4"
$tempvectstr2 &= $pixel[0] & "," & $pixel[1] & "|"
Case Else
SetDebugLog("TOP RIGHT: Skip slice " & $slice & " at " & $pixel[0] & ", " & $pixel[1])
EndSwitch
Next
If StringLen($tempvectstr1) > 0 Then $tempvectstr1 = StringLeft($tempvectstr1, StringLen($tempvectstr1) - 1)
If StringLen($tempvectstr2) > 0 Then $tempvectstr2 = StringLeft($tempvectstr2, StringLen($tempvectstr2) - 1)
$PixelTopRightDOWNDropLine = GetListPixel($tempvectstr1, ",", "TR-DOWN")
$PixelTopRightUPDropLine = GetListPixel($tempvectstr2, ",", "TR-UP")
Local $tempvectstr1 = ""
Local $tempvectstr2 = ""
For $i = 0 To UBound($PixelBottomLeftDropLine) - 1
Local $pixel = $PixelBottomLeftDropLine[$i]
Local $slice = Slice8($pixel)
Switch StringLeft($slice, 1)
Case "8"
$tempvectstr1 &= $pixel[0] & "," & $pixel[1] & "|"
Case "7"
$tempvectstr2 &= $pixel[0] & "," & $pixel[1] & "|"
Case Else
SetDebugLog("BOTTOM LEFT: Skip slice " & $slice & " at " & $pixel[0] & ", " & $pixel[1])
EndSwitch
Next
If StringLen($tempvectstr1) > 0 Then $tempvectstr1 = StringLeft($tempvectstr1, StringLen($tempvectstr1) - 1)
If StringLen($tempvectstr2) > 0 Then $tempvectstr2 = StringLeft($tempvectstr2, StringLen($tempvectstr2) - 1)
$PixelBottomLeftDOWNDropLine = GetListPixel($tempvectstr1, ",", "BL-DOWN")
$PixelBottomLeftUPDropLine = GetListPixel($tempvectstr2, ",", "BL-UP")
Local $tempvectstr1 = ""
Local $tempvectstr2 = ""
For $i = 0 To UBound($PixelBottomRightDropLine) - 1
Local $pixel = $PixelBottomRightDropLine[$i]
Local $slice = Slice8($pixel)
Switch StringLeft($slice, 1)
Case "1"
$tempvectstr1 &= $pixel[0] & "," & $pixel[1] & "|"
Case "2"
$tempvectstr2 &= $pixel[0] & "," & $pixel[1] & "|"
Case Else
SetDebugLog("BOTTOM RIGHT: Skip slice " & $slice & " at " & $pixel[0] & ", " & $pixel[1])
EndSwitch
Next
If StringLen($tempvectstr1) > 0 Then $tempvectstr1 = StringLeft($tempvectstr1, StringLen($tempvectstr1) - 1)
If StringLen($tempvectstr2) > 0 Then $tempvectstr2 = StringLeft($tempvectstr2, StringLen($tempvectstr2) - 1)
$PixelBottomRightDOWNDropLine = GetListPixel($tempvectstr1, ",", "BR-DOWN")
$PixelBottomRightUPDropLine = GetListPixel($tempvectstr2, ",", "BR-UP")
Setlog("> Drop Lines located in  " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds", $COLOR_INFO)
If _Sleep($iDelayRespond) Then Return
If $searchTH = "-" Then
If $attackcsv_locate_townhall = 1 Then
SuspendAndroid()
$hTimer = TimerInit()
Local $searchTH = imgloccheckTownHallADV2(0, 0, False)
Setlog("> Townhall located in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds", $COLOR_INFO)
ResumeAndroid()
Else
Setlog("> Townhall search not needed, skip")
EndIf
Else
Setlog("> Townhall has already been located in while searching for an image", $COLOR_INFO)
EndIf
If _Sleep($iDelayRespond) Then Return
Global $PixelMine[0]
Global $PixelElixir[0]
Global $PixelDarkElixir[0]
Local $PixelNearCollectorTopLeftSTR = ""
Local $PixelNearCollectorBottomLeftSTR = ""
Local $PixelNearCollectorTopRightSTR = ""
Local $PixelNearCollectorBottomRightSTR = ""
If $attackcsv_locate_mine = 1 Then
$hTimer = TimerInit()
SuspendAndroid()
$PixelMine = GetLocationMine()
ResumeAndroid()
If _Sleep($iDelayRespond) Then Return
CleanRedArea($PixelMine)
Local $htimerMine = Round(TimerDiff($hTimer) / 1000, 2)
If(IsArray($PixelMine)) Then
For $i = 0 To UBound($PixelMine) - 1
$pixel = $PixelMine[$i]
Local $str = $pixel[0] & "-" & $pixel[1] & "-" & "MINE"
If isInsideDiamond($pixel) Then
If $pixel[0] <= $InternalArea[2][0] Then
If $pixel[1] <= $InternalArea[0][1] Then
$PixelNearCollectorTopLeftSTR &= $str & "|"
Else
$PixelNearCollectorBottomLeftSTR &= $str & "|"
EndIf
Else
If $pixel[1] <= $InternalArea[0][1] Then
$PixelNearCollectorTopRightSTR &= $str & "|"
Else
$PixelNearCollectorBottomRightSTR &= $str & "|"
EndIf
EndIf
EndIf
Next
EndIf
Setlog("> Mines located in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds", $COLOR_INFO)
Else
Setlog("> Mines detection not needed, skip", $COLOR_INFO)
EndIf
If _Sleep($iDelayRespond) Then Return
If $attackcsv_locate_elixir = 1 Then
$hTimer = TimerInit()
SuspendAndroid()
$PixelElixir = GetLocationElixir()
ResumeAndroid()
If _Sleep($iDelayRespond) Then Return
CleanRedArea($PixelElixir)
Local $htimerMine = Round(TimerDiff($hTimer) / 1000, 2)
If(IsArray($PixelElixir)) Then
For $i = 0 To UBound($PixelElixir) - 1
$pixel = $PixelElixir[$i]
Local $str = $pixel[0] & "-" & $pixel[1] & "-" & "ELIXIR"
If isInsideDiamond($pixel) Then
If $pixel[0] <= $InternalArea[2][0] Then
If $pixel[1] <= $InternalArea[0][1] Then
$PixelNearCollectorTopLeftSTR &= $str & "|"
Else
$PixelNearCollectorBottomLeftSTR &= $str & "|"
EndIf
Else
If $pixel[1] <= $InternalArea[0][1] Then
$PixelNearCollectorTopRightSTR &= $str & "|"
Else
$PixelNearCollectorBottomRightSTR &= $str & "|"
EndIf
EndIf
EndIf
Next
EndIf
Setlog("> Elixir collectors located in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds", $COLOR_INFO)
Else
Setlog("> Elixir collectors detection not needed, skip", $COLOR_INFO)
EndIf
If _Sleep($iDelayRespond) Then Return
If $attackcsv_locate_drill = 1 Then
$hTimer = TimerInit()
SuspendAndroid()
$PixelDarkElixir = GetLocationDarkElixir()
ResumeAndroid()
If _Sleep($iDelayRespond) Then Return
CleanRedArea($PixelDarkElixir)
Local $htimerMine = Round(TimerDiff($hTimer) / 1000, 2)
If(IsArray($PixelDarkElixir)) Then
For $i = 0 To UBound($PixelDarkElixir) - 1
$pixel = $PixelDarkElixir[$i]
Local $str = $pixel[0] & "-" & $pixel[1] & "-" & "DRILL"
If isInsideDiamond($pixel) Then
If $pixel[0] <= $InternalArea[2][0] Then
If $pixel[1] <= $InternalArea[0][1] Then
$PixelNearCollectorTopLeftSTR &= $str & "|"
Else
$PixelNearCollectorBottomLeftSTR &= $str & "|"
EndIf
Else
If $pixel[1] <= $InternalArea[0][1] Then
$PixelNearCollectorTopRightSTR &= $str & "|"
Else
$PixelNearCollectorBottomRightSTR &= $str & "|"
EndIf
EndIf
EndIf
Next
EndIf
Setlog("> Drills located in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds", $COLOR_INFO)
Else
Setlog("> Drills detection not needed, skip", $COLOR_INFO)
EndIf
If _Sleep($iDelayRespond) Then Return
If StringLen($PixelNearCollectorTopLeftSTR) > 0 Then $PixelNearCollectorTopLeftSTR = StringLeft($PixelNearCollectorTopLeftSTR, StringLen($PixelNearCollectorTopLeftSTR) - 1)
If StringLen($PixelNearCollectorTopRightSTR) > 0 Then $PixelNearCollectorTopRightSTR = StringLeft($PixelNearCollectorTopRightSTR, StringLen($PixelNearCollectorTopRightSTR) - 1)
If StringLen($PixelNearCollectorBottomLeftSTR) > 0 Then $PixelNearCollectorBottomLeftSTR = StringLeft($PixelNearCollectorBottomLeftSTR, StringLen($PixelNearCollectorBottomLeftSTR) - 1)
If StringLen($PixelNearCollectorBottomRightSTR) > 0 Then $PixelNearCollectorBottomRightSTR = StringLeft($PixelNearCollectorBottomRightSTR, StringLen($PixelNearCollectorBottomRightSTR) - 1)
$PixelNearCollectorTopLeft = GetListPixel3($PixelNearCollectorTopLeftSTR)
$PixelNearCollectorTopRight = GetListPixel3($PixelNearCollectorTopRightSTR)
$PixelNearCollectorBottomLeft = GetListPixel3($PixelNearCollectorBottomLeftSTR)
$PixelNearCollectorBottomRight = GetListPixel3($PixelNearCollectorBottomRightSTR)
If $attackcsv_locate_gold_storage = 1 Then
SuspendAndroid()
$GoldStoragePos = GetLocationGoldStorage()
ResumeAndroid()
EndIf
If $attackcsv_locate_elixir_storage = 1 Then
SuspendAndroid()
$ElixirStoragePos = GetLocationElixirStorage()
ResumeAndroid()
EndIf
If $attackcsv_locate_dark_storage = 1 Then
$hTimer = TimerInit()
SuspendAndroid()
Local $PixelDarkElixirStorage = GetLocationDarkElixirStorageWithLevel()
ResumeAndroid()
If _Sleep($iDelayRespond) Then Return
CleanRedArea($PixelDarkElixirStorage)
Local $pixel = StringSplit($PixelDarkElixirStorage, "#", 2)
If UBound($pixel) >= 2 Then
Local $pixelpos = StringSplit($pixel[1], "-", 2)
If UBound($pixelpos) >= 2 Then
Local $temp = [Int($pixelpos[0]), Int($pixelpos[1])]
$darkelixirStoragePos = $temp
EndIf
EndIf
Setlog("> Dark Elixir Storage located in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds", $COLOR_INFO)
Else
Setlog("> Dark Elixir Storage detection not need, skip", $COLOR_INFO)
EndIf
$EagleArtilleryPos[0] = ""
$EagleArtilleryPos[1] = ""
If $searchTH = "-" Or Int($searchTH) > 10 Then
If $attackcsv_locate_Eagle = 1 Then
$hTimer = TimerInit()
SuspendAndroid()
Local $result = returnSingleMatch(@ScriptDir & "\imgxml\WeakBase\Eagle")
ResumeAndroid()
If UBound($result) > 1 Then
Local $tempeaglePos = $result[1][5]
If $g_iDebugSetlog = 1 Then
Setlog(": ImageName: " & $result[1][0], $COLOR_DEBUG)
Setlog(": ObjectName: " & $result[1][1], $COLOR_DEBUG)
Setlog(": ObjectLevel: " & $result[1][2], $COLOR_DEBUG)
EndIf
If $tempeaglePos[0][0] <> "" Then
$EagleArtilleryPos[0] = $tempeaglePos[0][0]
$EagleArtilleryPos[1] = $tempeaglePos[0][1]
Setlog("> Eagle located in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds", $COLOR_INFO)
If $g_iDebugSetlog = 1 Then
Setlog(": $EagleArtilleryPosition X:Y= " & $EagleArtilleryPos[0] & ":" & $EagleArtilleryPos[1], $COLOR_DEBUG)
EndIf
Else
Setlog("> Eagle detection error", $COLOR_WARNING)
EndIf
Else
Setlog("> Eagle detection error", $COLOR_WARNING)
EndIf
Else
Setlog("> Eagle Artillery detection not need, skip", $COLOR_INFO)
EndIf
Else
Setlog("> TH Level to low for Eagle detection, skip", $COLOR_INFO)
EndIf
Setlog(">> Total time: " & Round(TimerDiff($hTimerTOTAL) / 1000, 2) & " seconds", $COLOR_INFO)
If $g_iDebugMakeIMGCSV = 1 Then AttackCSVDEBUGIMAGE()
If $g_bTHSnipeBeforeEnable[$DB] And $searchTH = "-" Then FindTownHall(True)
If $g_bTHSnipeBeforeEnable[$DB] Then
If $searchTH <> "-" Then
If SearchTownHallLoc() Then
Setlog(_PadStringCenter(" TH snipe Before Scripted Attack ", 54, "="), $COLOR_INFO)
$THusedKing = 0
$THusedQueen = 0
AttackTHParseCSV()
Else
If $g_iDebugSetlog = 1 Then Setlog("TH snipe before scripted attack skip, th internal village", $COLOR_DEBUG)
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog("TH snipe before scripted attack skip, no th found", $COLOR_DEBUG)
EndIf
EndIf
SetSlotSpecialTroops()
If _Sleep($iDelayRespond) Then Return
If TestCapture() = True Then
Return
EndIf
ParseAttackCSV($testattack)
CheckHeroesHealth()
EndFunc
Func AttackCSVDEBUGIMAGE()
_CaptureRegion2()
Local $EditedImage = _GDIPlus_BitmapCreateFromHBITMAP($hHBitmap2)
Local $testx
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($EditedImage)
Local $hBrush = _GDIPlus_BrushCreateSolid(0xFFFFFFFF)
Local $pixel
Local $hPenLtGreen = _GDIPlus_PenCreate(0xFF00DC00, 2)
Local $hPenDkGreen = _GDIPlus_PenCreate(0xFF006E00, 2)
Local $hPenMdGreen = _GDIPlus_PenCreate(0xFF4CFF00, 2)
Local $hPenRed = _GDIPlus_PenCreate(0xFFFF0000, 2)
Local $hPenDkRed = _GDIPlus_PenCreate(0xFF6A0000, 2)
Local $hPenBlue = _GDIPlus_PenCreate(0xFF0026FF, 2)
Local $hPenCyan = _GDIPlus_PenCreate(0xFF00FFFF, 2)
Local $hPenYellow = _GDIPlus_PenCreate(0xFFFFD800, 2)
Local $hPenLtGrey = _GDIPlus_PenCreate(0xFFCCCCCC, 2)
_GDIPlus_GraphicsDrawLine($hGraphic, $ExternalArea[0][0], $ExternalArea[0][1], $ExternalArea[2][0], $ExternalArea[2][1], $hPenLtGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $ExternalArea[0][0], $ExternalArea[0][1], $ExternalArea[3][0], $ExternalArea[3][1], $hPenLtGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $ExternalArea[1][0], $ExternalArea[1][1], $ExternalArea[2][0], $ExternalArea[2][1], $hPenLtGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $ExternalArea[1][0], $ExternalArea[1][1], $ExternalArea[3][0], $ExternalArea[3][1], $hPenLtGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $InternalArea[0][0], $InternalArea[0][1], $InternalArea[2][0], $InternalArea[2][1], $hPenDkGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $InternalArea[0][0], $InternalArea[0][1], $InternalArea[3][0], $InternalArea[3][1], $hPenDkGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $InternalArea[1][0], $InternalArea[1][1], $InternalArea[2][0], $InternalArea[2][1], $hPenDkGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $InternalArea[1][0], $InternalArea[1][1], $InternalArea[3][0], $InternalArea[3][1], $hPenDkGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $InternalArea[2][0], 0, $InternalArea[2][0], $g_iDEFAULT_HEIGHT, $hPenDkGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, 0, $InternalArea[0][1], $g_iDEFAULT_WIDTH, $InternalArea[0][1], $hPenDkGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $ExternalArea[4][0], $ExternalArea[4][1], $ExternalArea[7][0], $ExternalArea[7][1], $hPenLtGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $ExternalArea[5][0], $ExternalArea[5][1], $ExternalArea[6][0], $ExternalArea[6][1], $hPenLtGreen)
For $i = 0 To UBound($PixelTopLeft) - 1
$pixel = $PixelTopLeft[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenRed)
Next
For $i = 0 To UBound($PixelTopRight) - 1
$pixel = $PixelTopRight[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenRed)
Next
For $i = 0 To UBound($PixelBottomLeft) - 1
$pixel = $PixelBottomLeft[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenRed)
Next
For $i = 0 To UBound($PixelBottomRight) - 1
$pixel = $PixelBottomRight[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenRed)
Next
For $i = 0 To UBound($PixelTopLeftDropLine) - 1
$pixel = $PixelTopLeftDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenBlue)
Next
For $i = 0 To UBound($PixelTopRightDropLine) - 1
$pixel = $PixelTopRightDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenCyan)
Next
For $i = 0 To UBound($PixelBottomLeftDropLine) - 1
$pixel = $PixelBottomLeftDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenYellow)
Next
For $i = 0 To UBound($PixelBottomRightDropLine) - 1
$pixel = $PixelBottomRightDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenLtGrey)
Next
For $i = 0 To UBound($PixelTopLeftDOWNDropLine) - 1
$pixel = $PixelTopLeftDOWNDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenBlue)
Next
For $i = 0 To UBound($PixelTopLeftUPDropLine) - 1
$pixel = $PixelTopLeftUPDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenCyan)
Next
For $i = 0 To UBound($PixelBottomLeftDOWNDropLine) - 1
$pixel = $PixelBottomLeftDOWNDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenYellow)
Next
For $i = 0 To UBound($PixelBottomLeftUPDropLine) - 1
$pixel = $PixelBottomLeftUPDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenLtGrey)
Next
For $i = 0 To UBound($PixelTopRightDOWNDropLine) - 1
$pixel = $PixelTopRightDOWNDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenBlue)
Next
For $i = 0 To UBound($PixelTopRightUPDropLine) - 1
$pixel = $PixelTopRightUPDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenCyan)
Next
For $i = 0 To UBound($PixelBottomRightDOWNDropLine) - 1
$pixel = $PixelBottomRightDOWNDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenYellow)
Next
For $i = 0 To UBound($PixelBottomRightUPDropLine) - 1
$pixel = $PixelBottomRightUPDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenLtGrey)
Next
$testx = MakeDropPoints("TOP-LEFT-DOWN", 10, 2, "EXT-INT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0], $pixel[1], "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenRed)
Next
$testx = MakeDropPoints("TOP-LEFT-DOWN", 10, 4, "EXT-INT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0] - 10, $pixel[1] - 10, "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenMdGreen)
Next
$testx = MakeDropPoints("BOTTOM-LEFT-UP", 10, 2, "EXT-INT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0], $pixel[1], "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenRed)
Next
$testx = MakeDropPoints("BOTTOM-LEFT-UP", 10, 4, "EXT-INT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0] - 10, $pixel[1] - 10, "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenMdGreen)
Next
$testx = MakeDropPoints("TOP-RIGHT-DOWN", 10, 2, "EXT-INT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0], $pixel[1], "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenRed)
Next
$testx = MakeDropPoints("TOP-RIGHT-DOWN", 10, 4, "EXT-INT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0] - 10, $pixel[1] - 10, "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenMdGreen)
Next
$testx = MakeDropPoints("BOTTOM-RIGHT-UP", 10, 2, "EXT-INT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0], $pixel[1], "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenRed)
Next
$testx = MakeDropPoints("BOTTOM-RIGHT-UP", 10, 4, "EXT-INT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0] - 10, $pixel[1] - 10, "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenMdGreen)
Next
$testx = MakeDropPoints("TOP-LEFT-UP", 10, 2, "INT-EXT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0], $pixel[1], "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenRed)
Next
$testx = MakeDropPoints("TOP-LEFT-UP", 10, 4, "INT-EXT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0] - 10, $pixel[1] - 10, "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenMdGreen)
Next
$testx = MakeDropPoints("BOTTOM-LEFT-DOWN", 10, 2, "INT-EXT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0], $pixel[1], "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenRed)
Next
$testx = MakeDropPoints("BOTTOM-LEFT-DOWN", 10, 4, "INT-EXT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0] - 10, $pixel[1] - 10, "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenMdGreen)
Next
$testx = MakeDropPoints("TOP-RIGHT-UP", 10, 2, "INT-EXT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0], $pixel[1], "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenRed)
Next
$testx = MakeDropPoints("TOP-RIGHT-UP", 10, 4, "INT-EXT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0] - 10, $pixel[1] - 10, "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenMdGreen)
Next
$testx = MakeDropPoints("BOTTOM-RIGHT-DOWN", 10, 2, "INT-EXT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0], $pixel[1], "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenRed)
Next
$testx = MakeDropPoints("BOTTOM-RIGHT-DOWN", 10, 4, "INT-EXT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0] - 10, $pixel[1] - 10, "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenMdGreen)
Next
For $i = 0 To UBound($PixelMine) - 1
$pixel = $PixelMine[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 10, $pixel[1] - 10, 20, 20, $hPenLtGreen)
Next
For $i = 0 To UBound($PixelElixir) - 1
$pixel = $PixelElixir[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 10, $pixel[1] - 10, 20, 20, $hPenDkGreen)
Next
For $i = 0 To UBound($PixelDarkElixir) - 1
$pixel = $PixelDarkElixir[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 10, $pixel[1] - 10, 20, 20, $hPenDkRed)
Next
_GDIPlus_GraphicsDrawRect($hGraphic, $THX - 15, $THY - 15, 30, 30, $hPenRed)
If $attackcsv_locate_Eagle = 1 And IsArray($EagleArtilleryPos) Then
_GDIPlus_GraphicsDrawRect($hGraphic, $EagleArtilleryPos[0] - 15, $EagleArtilleryPos[1] - 15, 30, 30, $hPenBlue)
EndIf
_GDIPlus_GraphicsDrawString($hGraphic, "1", 580, 580, "Arial", 20)
_GDIPlus_GraphicsDrawString($hGraphic, "2", 750, 450, "Arial", 20)
_GDIPlus_GraphicsDrawString($hGraphic, "3", 750, 200, "Arial", 20)
_GDIPlus_GraphicsDrawString($hGraphic, "4", 580, 110, "Arial", 20)
_GDIPlus_GraphicsDrawString($hGraphic, "5", 260, 110, "Arial", 20)
_GDIPlus_GraphicsDrawString($hGraphic, "6", 110, 200, "Arial", 20)
_GDIPlus_GraphicsDrawString($hGraphic, "7", 110, 450, "Arial", 20)
_GDIPlus_GraphicsDrawString($hGraphic, "8", 310, 580, "Arial", 20)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
Local $filename = $g_sProfileTempDebugPath & String("AttackDebug_" & $Date & "_" & $Time) & ".jpg"
_GDIPlus_ImageSaveToFile($EditedImage, $filename)
SetDebugLog("Attack CSV image saved: " & $filename)
_GDIPlus_PenDispose($hPenLtGreen)
_GDIPlus_PenDispose($hPenDkGreen)
_GDIPlus_PenDispose($hPenMdGreen)
_GDIPlus_PenDispose($hPenRed)
_GDIPlus_PenDispose($hPenDkRed)
_GDIPlus_PenDispose($hPenBlue)
_GDIPlus_PenDispose($hPenCyan)
_GDIPlus_PenDispose($hPenYellow)
_GDIPlus_PenDispose($hPenLtGrey)
_GDIPlus_BrushDispose($hBrush)
_GDIPlus_GraphicsDispose($hGraphic)
_GDIPlus_BitmapDispose($EditedImage)
If TestCapture() = True Then
ShellExecute($filename)
EndIf
EndFunc
Func CheckCsvValues($instruction, $variablenumber, $variable)
Switch $instruction
Case "MAKE"
Switch $variablenumber
Case 1
If $variable = "RANDOM" Then
Return True
Else
Local $vect1 = StringSplit($variable, "-", 2)
If UBound($vect1) = 0 Then
If StringLen($vect1) = 1 Then
If(Asc($vect1[$i]) >= 65 And Asc($vect1[$i]) <= 90) Then
Return True
Else
Return False
EndIf
Else
Return False
EndIf
Else
For $i = 0 To UBound($vect1) - 1
Local $tempstr = $vect1[$i]
If StringLen($tempstr) <> 1 Then
Return False
Else
If Not(Asc($vect1[$i]) >= 65 And Asc($vect1[$i]) <= 90) Then Return False
EndIf
Next
Return True
EndIf
EndIf
Case 2
Switch $variable
Case "FRONT-LEFT"
Return True
Case "FRONT-RIGHT"
Return True
Case "RIGHT-FRONT"
Return True
Case "RIGHT-BACK"
Return True
Case "LEFT-FRONT"
Return True
Case "LEFT-BACK"
Return True
Case "BACK-LEFT"
Return True
Case "BACK-RIGHT"
Return True
Case "RANDOM"
Return True
EndSwitch
Case 5
Switch $variable
Case "EXT-INT"
Return True
Case "INT-EXT"
Return True
Case Else
Return False
EndSwitch
EndSwitch
EndSwitch
Return False
EndFunc
Func debugAttackCSV($string)
If $g_iDebugAttackCSV = 1 Then
ConsoleWrite("A " & TimeDebug() & $string & @CRLF)
Local $hfile = FileOpen($g_sProfileLogsPath & "debugAttackCSV.log", $FO_APPEND)
_FileWriteLog($hfile, $string)
FileClose($hfile)
EndIf
EndFunc
Func GetListPixel3($listPixel)
Local $listPixelSideStr = StringSplit($listPixel, "|")
If($listPixelSideStr[0] > 1) Then
Local $listPixelSide[UBound($listPixelSideStr) - 1]
For $i = 0 To UBound($listPixelSide) - 1
Local $pixelStr = StringSplit($listPixelSideStr[$i + 1], "-")
If($pixelStr[0] > 2) Then
Local $pixel = [Int($pixelStr[1]), Int($pixelStr[2]), Int($pixelStr[3])]
$listPixelSide[$i] = $pixel
EndIf
Next
Return $listPixelSide
Else
If StringInStr($listPixel, "-") > 0 Then
Local $pixelStrHere = StringSplit($listPixel, "-")
Local $pixelHere = [Int($pixelStrHere[1]), Int($pixelStrHere[2]), Int($pixelStrHere[3])]
Local $listPixelHere = [$pixelHere]
Return $listPixelHere
EndIf
Return -1
EndIf
EndFunc
Func isInsideDiamondRedArea($aCoords)
Local $Left = $ExternalArea[0][0], $Right = $ExternalArea[1][0], $Top = $ExternalArea[2][1], $Bottom = $ExternalArea[3][1]
Local $aDiamond[2][2] = [[$Left, $Top], [$Right, $Bottom]]
Local $aMiddle = [($aDiamond[0][0] + $aDiamond[1][0]) / 2,($aDiamond[0][1] + $aDiamond[1][1]) / 2]
Local $aSize = [$aMiddle[0] - $aDiamond[0][0], $aMiddle[1] - $aDiamond[0][1]]
Local $DX = Abs($aCoords[0] - $aMiddle[0])
Local $DY = Abs($aCoords[1] - $aMiddle[1])
If $DX >= 5 Then $DX -= 5
If $DY >= 5 Then $DY -= 5
If($DX / $aSize[0] + $DY / $aSize[1] <= 1) And $aCoords[0] > $DeployableLRTB[0] And $aCoords[0] <= $DeployableLRTB[1] And $aCoords[1] >= $DeployableLRTB[2] And $aCoords[1] <= $DeployableLRTB[3] Then
Return True
Else
Return False
EndIf
EndFunc
Func Line2Points($pixel0, $pixel1, $iXY, $iDim0 = 0)
Local $iDim1 = 1 - $iDim0
Return Round(($iXY - $pixel0[$iDim0]) /($pixel1[$iDim0] - $pixel0[$iDim0]) *($pixel1[$iDim1] - $pixel0[$iDim1]) + $pixel0[$iDim1])
EndFunc
Func MakeDropLine($searchvect, $startpoint, $endpoint, $iLineDistanceThreshold = 75, $bLineToCorner = False)
SetDebugLog("MakeDropLine for " & UBound($searchvect) & " points")
If $bLineToCorner = False And UBound($searchvect) > 0 Then $startpoint = $searchvect[0]
If $bLineToCorner = False And UBound($searchvect) > 0 Then $endpoint = $searchvect[UBound($searchvect) - 1]
SetDebugLog("MakeDropLine: Start = " & PixelToString($startpoint) & ", End = " & PixelToString($endpoint) & ": " & PixelArrayToString($searchvect, ","))
Local $startX = $startpoint[0]
Local $startY = $startpoint[1]
Local $size = UBound($searchvect)
ReDim $searchvect[$size + 1]
$searchvect[$Size] = $endpoint
Local $Pixel0 = [$startX, $starty]
Local $ReturnVect = $startX & "," & $startY
For $idx = 0 To $size
Local $Pixel1 = $searchvect[$idx]
If $Pixel1[0] < 0 Then ContinueLoop
Local $aLen = [$Pixel1[0] - $Pixel0[0], $Pixel1[1] - $Pixel0[1]]
Local $iStart
Local $iEnd
Local $iStep
Local $iLoopAxis =((Abs($aLen[0]) >= Abs($aLen[1])) ?(0) :(1))
Local $iOtherAxis = 1 - $iLoopAxis
Local $iDistance
$iStep =(($aLen[$iLoopAxis] > 0) ?(1) :(-1))
$iStart = $Pixel0[$iLoopAxis]
$iEnd = $Pixel1[$iLoopAxis]
$iDistance = GetPixelDistance($Pixel0, $Pixel1)
If $iLineDistanceThreshold = -1 Or $iDistance <= $iLineDistanceThreshold Or($bLineToCorner = True And($idx = 0 Or $idx = $size)) Then
For $i = $iStart + $iStep To $iEnd Step $iStep
Local $j = Line2Points($Pixel0, $Pixel1, $i, $iLoopAxis)
Local $p[2]
$p[$iLoopAxis] = $i
$p[$iOtherAxis] = $j
$ReturnVect &= "|" & $p[0] & "," & $p[1]
Next
Else
$ReturnVect &= "|" & $Pixel1[0] & "," & $Pixel1[1]
EndIf
$Pixel0 = $Pixel1
Next
SetDebugLog("MakeDropLine: Done: " & $ReturnVect)
Return GetListPixel($ReturnVect, ",")
EndFunc
Func MakeDropLineOriginal($searchvect, $startpoint, $endpoint)
SetDebugLog("MakeDropLine for " & UBound($searchvect) & " points")
Local $startX = $startpoint[0]
Local $startY = $startpoint[1]
Local $endX = $endpoint[0]
Local $endY = $endpoint[1]
CheckAttackLocation($startX, $startY)
CheckAttackLocation($endX, $endY)
Local $point1 = [$startX, $starty]
Local $t, $f
$t = 0
$f = 0
Local $ReturnVect = $startX & "," & $startY
For $i = $startX + 1 To $endX
For $j = $t To UBound($searchvect) - 1
Local $pixel = $searchvect[$j]
If $i < $pixel[0] Then
Local $h = Line2Points($point1, $pixel, $i)
CheckAttackLocation($i, $h)
$ReturnVect &= "|" & $i & "," & $h
$f = $i
ExitLoop
Else
If $i = $pixel[0] Then
Local $x = $pixel[0]
Local $h = $pixel[1]
CheckAttackLocation($x, $h)
$ReturnVect &= "|" & $x & "," & $h
$point1 = $pixel
$t = $j + 1
$f = $i
ExitLoop
EndIf
EndIf
Next
Next
For $i = $f + 1 To $endX
Local $h = Line2Points($point1, $endpoint, $i)
CheckAttackLocation($i, $h)
$ReturnVect &= "|" & $i & "," & $h
Next
Return GetListPixel($ReturnVect, ",")
EndFunc
Func MakeDropPoints($side, $pointsQty, $addtiles, $versus, $randomx = 2, $randomy = 2)
debugAttackCSV("make for side " & $side)
Local $Vector, $Output = ""
Local $rndx = Random(0, Abs(Int($randomx)), 1)
Local $rndy = Random(0, Abs(Int($randomy)), 1)
If $side = "RANDOM" Then
EndIf
Switch $side
Case "TOP-LEFT-DOWN"
Local $Vector = $PixelTopLeftDOWNDropLine
Case "TOP-LEFT-UP"
Local $Vector = $PixelTopLeftUPDropLine
Case "TOP-RIGHT-DOWN"
Local $Vector = $PixelTopRightDOWNDropLine
Case "TOP-RIGHT-UP"
Local $Vector = $PixelTopRightUPDropLine
Case "BOTTOM-LEFT-UP"
Local $Vector = $PixelBottomLeftUPDropLine
Case "BOTTOM-LEFT-DOWN"
Local $Vector = $PixelBottomLeftDOWNDropLine
Case "BOTTOM-RIGHT-UP"
Local $Vector = $PixelBottomRightUPDropLine
Case "BOTTOM-RIGHT-DOWN"
Local $Vector = $PixelBottomRightDOWNDropLine
Case Else
EndSwitch
If Int($pointsQty) > 0 Then
Local $pointsQtyCleaned = Abs(Int($pointsQty))
Else
Local $pointsQtyCleaned = 1
EndIf
Local $p = Int(UBound($Vector) / $pointsQtyCleaned)
If $p = 0 Then $p = 1
Local $x = 0
Local $y = 0
Local $str = ""
For $i = 0 To UBound($Vector) - 1
Local $pixel = $Vector[$i]
$str &= $pixel[0] & "-" & $pixel[1] & "|"
Next
Switch $side & "|" & $versus
Case "TOP-LEFT-DOWN|INT-EXT", "TOP-LEFT-UP|EXT-INT", "TOP-RIGHT-DOWN|EXT-INT", "TOP-RIGHT-UP|INT-EXT", "BOTTOM-LEFT-DOWN|EXT-INT", "BOTTOM-LEFT-UP|INT-EXT", "BOTTOM-RIGHT-DOWN|INT-EXT", "BOTTOM-RIGHT-UP|EXT-INT"
For $i = UBound($Vector) To 1 Step -1
$pixel = $Vector[$i - 1]
$x += $pixel[0]
$y += $pixel[1]
If Mod(UBound($Vector) - $i + 1, $p) = 0 Then
For $u = 8 * Abs(Int($addtiles)) To 0 Step -1
If Int($addtiles) > 0 Then
Local $l = $u
Else
Local $l = -$u
EndIf
Switch $side
Case "TOP-LEFT-UP", "TOP-LEFT-DOWN"
Local $x1 = Round($x / $p) - $l
Local $y1 = Round($y / $p) - $l
Local $x2 = Round($x / $p) - $l - $rndx
Local $y2 = Round($y / $p) - $l - $rndy
Case "TOP-RIGHT-UP", "TOP-RIGHT-DOWN"
Local $x1 = Round($x / $p) + $l
Local $y1 = Round($y / $p) - $l
Local $x2 = Round($x / $p) + $l + $rndx
Local $y2 = Round($y / $p) - $l - $rndy
Case "BOTTOM-LEFT-UP", "BOTTOM-LEFT-DOWN"
Local $x1 = Round($x / $p) - $l
Local $y1 = Round($y / $p) + $l
Local $x2 = Round($x / $p) - $l - $rndx
Local $y2 = Round($y / $p) + $l + $rndy
Case "BOTTOM-RIGHT-UP", "BOTTOM-RIGHT-DOWN"
Local $x1 = Round($x / $p) + $l
Local $y1 = Round($y / $p) + $l
Local $x2 = Round($x / $p) + $l + $rndx
Local $y2 = Round($y / $p) + $l + $rndy
Case Else
EndSwitch
$pixel = StringSplit($x2 & "-" & $y2, "-", 2)
If isInsideDiamondRedArea($pixel) Then ExitLoop
Next
$pixel = StringSplit($x2 & "-" & $y2, "-", 2)
$Output &= $pixel[0] & "-" & $pixel[1] & "|"
$x = 0
$y = 0
EndIf
Next
Case "TOP-LEFT-DOWN|EXT-INT", "TOP-LEFT-UP|INT-EXT", "TOP-RIGHT-DOWN|INT-EXT", "TOP-RIGHT-UP|EXT-INT", "BOTTOM-LEFT-DOWN|INT-EXT", "BOTTOM-LEFT-UP|EXT-INT", "BOTTOM-RIGHT-DOWN|EXT-INT", "BOTTOM-RIGHT-UP|INT-EXT"
For $i = 1 To UBound($Vector)
$pixel = $Vector[$i - 1]
$x += $pixel[0]
$y += $pixel[1]
If Mod($i, $p) = 0 Then
For $u = 8 * Abs(Int($addtiles)) To 0 Step -1
If Int($addtiles) > 0 Then
Local $l = $u
Else
Local $l = -$u
EndIf
Switch $side
Case "TOP-LEFT-UP", "TOP-LEFT-DOWN"
Local $x1 = Round($x / $p) - $l
Local $y1 = Round($y / $p) - $l
Local $x2 = Round($x / $p) - $l - $rndx
Local $y2 = Round($y / $p) - $l - $rndy
Case "TOP-RIGHT-UP", "TOP-RIGHT-DOWN"
Local $x1 = Round($x / $p) + $l
Local $y1 = Round($y / $p) - $l
Local $x2 = Round($x / $p) + $l + $rndx
Local $y2 = Round($y / $p) - $l - $rndy
Case "BOTTOM-LEFT-UP", "BOTTOM-LEFT-DOWN"
Local $x1 = Round($x / $p) - $l
Local $y1 = Round($y / $p) + $l
Local $x2 = Round($x / $p) - $l - $rndx
Local $y2 = Round($y / $p) + $l + $rndy
Case "BOTTOM-RIGHT-UP", "BOTTOM-RIGHT-DOWN"
Local $x1 = Round($x / $p) + $l
Local $y1 = Round($y / $p) + $l
Local $x2 = Round($x / $p) + $l + $rndx
Local $y2 = Round($y / $p) + $l + $rndy
Case Else
EndSwitch
$pixel = StringSplit($x2 & "-" & $y2, "-", 2)
If isInsideDiamondRedArea($pixel) Then ExitLoop
Next
$pixel = StringSplit($x2 & "-" & $y2, "-", 2)
$Output &= $pixel[0] & "-" & $pixel[1] & "|"
$x = 0
$y = 0
EndIf
Next
Case Else
EndSwitch
If StringLen($Output) > 0 Then $Output = StringLeft($Output, StringLen($Output) - 1)
Return GetListPixel($Output)
EndFunc
Func Slice8($pixel)
If UBound($pixel) < 2 Then Return "0_NO_ARRAY"
Local $Left = $ExternalArea[0][0]
Local $Right = $ExternalArea[1][0]
Local $Top = $ExternalArea[2][1]
Local $Bottom = $ExternalArea[3][1]
Local $LeftY = $ExternalArea[0][1]
Local $RightY = $ExternalArea[1][1]
Local $TopX = $ExternalArea[2][0]
Local $BottomX = $ExternalArea[3][0]
Local $TLX = $ExternalArea[4][0]
Local $TLY = $ExternalArea[4][1]
Local $TRX = $ExternalArea[5][0]
Local $TRY = $ExternalArea[5][1]
Local $BLX = $ExternalArea[6][0]
Local $BLY = $ExternalArea[6][1]
Local $BRX = $ExternalArea[7][0]
Local $BRY = $ExternalArea[7][1]
Local $isIn = 1.01
If $pixel[0] < $Left Or $pixel[0] > $Right Or $pixel[1] < $Top Or $pixel[1] > $Bottom Then
Return "0_O"
Else
If $pixel[0] <= $TopX Then
If $pixel[1] <= $LeftY Then
If $pixel[0] <= $TLX Then
If($TLX - $pixel[0]) /($TLX - $Left) +($LeftY - $pixel[1]) /($LeftY - $TLY) <= $isIn Then
Return "6E"
Else
Return "0_6E"
EndIf
Else
If($pixel[0] - $TLX) /($TopX - $TLX) +($LeftY - $pixel[1]) /($LeftY - $TLY) <= $isIn Then
Return "6_I"
Else
If($TopX - $pixel[0]) /($TopX - $TLX) + Abs($TLY - $pixel[1]) /($LeftY - $TLY) <= $isIn Then
If $pixel[1] <= $TLY Then
Return "5_E"
Else
Return "5_I"
EndIf
Else
Return "O_5"
EndIf
EndIf
EndIf
Else
If $pixel[0] <= $BLX Then
If($BLX - $pixel[0]) /($BLX - $Left) +($pixel[1] - $LeftY) /($BLY - $LeftY) <= $isIn Then
Return "7_E"
Else
Return "0_7"
EndIf
Else
If($pixel[0] - $BLX) /($TopX - $BLX) +($pixel[1] - $LeftY) /($BLY - $LeftY) <= $isIn Then
Return "7_I"
Else
If($TopX - $pixel[0]) /($TopX - $BLX) + Abs($BLY - $pixel[1]) /($BLY - $LeftY) <= $isIn Then
If $pixel[1] <= $BLY Then
Return "8_I"
Else
Return "8_E"
EndIf
Else
Return "0_8"
EndIf
EndIf
EndIf
EndIf
Else
If $pixel[1] <= $RightY Then
If $pixel[0] > $TRX Then
If($pixel[0] - $TRX) /($Right - $TRX) +($RightY - $pixel[1]) /($RightY - $TRY) <= $isIn Then
Return "3_E"
Else
Return "0_3"
EndIf
Else
If($TRX - $pixel[0]) /($TRX - $TopX) +($RightY - $pixel[1]) /($RightY - $TRY) <= $isIn Then
Return "3_I"
Else
If($pixel[0] - $TopX) /($TRX - $TopX) + Abs($TRY - $pixel[1]) /($RightY - $TRY) <= $isIn Then
If $pixel[1] <= $TRY Then
Return "4_E"
Else
Return "4_I"
EndIf
Else
Return "0_4"
EndIf
EndIf
EndIf
Else
If $pixel[0] > $BRX Then
If($pixel[0] - $BRX) /($Right - $BRX) +($pixel[1] - $RightY) /($BRY - $RightY) <= $isIn Then
Return "2_E"
Else
Return "0_2"
EndIf
Else
If($BRX - $pixel[0]) /($BRX - $BottomX) +($pixel[1] - $RightY) /($BRY - $RightY) <= $isIn Then
Return "2_I"
Else
If($pixel[0] - $BottomX) /($BRX - $BottomX) + Abs($BRY - $pixel[1]) /($BRY - $RightY) <= $isIn Then
If $pixel[1] <= $BRY Then
Return "1_I"
Else
Return "1_E"
EndIf
Else
Return "0_1"
EndIf
EndIf
EndIf
EndIf
EndIf
EndIf
EndFunc
Func CleanRedArea(ByRef $InputVect, $side = "")
Local $TempVectStr = ""
For $i = 0 To UBound($InputVect) - 1
Local $pixel = $InputVect[$i]
If isInsideDiamondRedArea($pixel) Then
$TempVectStr &= $pixel[0] & "-" & $pixel[1] & "|"
Else
debugAttackCSV("CleanRedArea removed (" & $pixel[0] & "," & $pixel[1] & ")")
EndIf
Next
If StringLen($TempVectStr) > 0 Then
$TempVectStr = StringLeft($TempVectStr, StringLen($TempVectStr) - 1)
$InputVect = GetListPixel($TempVectStr)
EndIf
EndFunc
Func ChkAttackCSVConfig()
If Not(FileExists($g_sCSVAttacksPath & "\" & $g_sAttackScrScriptName[$DB] & ".csv")) Then
Setlog("Dead base scripted attack file do not exists (renamed, deleted?)", $COLOR_ERROR)
SetLog("Please select a new scripted algorithm from 'scripted attack' tab", $COLOR_ERROR)
PopulateComboScriptsFilesDB()
btnStop()
EndIf
If Not(FileExists($g_sCSVAttacksPath & "\" & $g_sAttackScrScriptName[$LB] & ".csv")) Then
Setlog("Dead base scripted attack file do not exists (renamed, deleted?)", $COLOR_ERROR)
SetLog("Please select a new scripted algorithm from 'scripted attack' tab", $COLOR_ERROR)
PopulateComboScriptsFilesAB()
btnStop()
EndIf
EndFunc
Func Alogrithm_MilkingAttack()
If $g_bTHSnipeBeforeEnable[$DB] and $searchTH = "-" Then FindTownHall(True)
If $g_bTHSnipeBeforeEnable[$DB] Then
If $searchTH <> "-" Then
If SearchTownHallLoc() Then
Setlog(_PadStringCenter(" TH snipe Before Milking ", 54,"="),$COLOR_INFO)
$THusedKing = 0
$THusedQueen = 0
AttackTHParseCSV()
Else
Setlog("TH snipe Before Milking skip, TH inside village",$COLOR_INFO)
EndIf
Else
Setlog("TH snipe Before Milking skip, no th detected",$COLOR_INFO)
EndIf
EndIf
$duringMilkingAttack = 1
Local $hTimerTOTAL = TimerInit()
Setlog(_PadStringCenter(" Milking Attack ", 54,"="),$COLOR_INFO)
If StringLen($MilkFarmObjectivesSTR) > 0 Then
Local $vect = StringSplit($MilkFarmObjectivesSTR, "|", 2)
If $g_iDebugSetlog = 1 Then Setlog("MilkFarmObjectivesSTR = <" & $MilkFarmObjectivesSTR & ">.. UBOUND=" & UBound($vect))
If UBound($vect) > 0 Then
If StringLen($vect[0]) > 0 Then
If $g_iDebugSetlog = 1 Then SetLog(">Structures to attack: (" & UBound($vect) & ")", $COLOR_DEBUG)
For $i = 0 To UBound($vect) - 1
If $g_iDebugSetlog = 1 Then Setlog("> " & $i & " " & $vect[$i], $COLOR_DEBUG)
Next
MilkFarmObjectivesDebugImage($MilkFarmObjectivesSTR, 0)
Local $troopPosition = -1
For $i = 0 To UBound($atkTroops) - 1
If $atkTroops[$i][1] <> -1 Then
If $atkTroops[$i][0] = $eGobl Then
If $g_iDebugSetlog = 1 Then SetLog("-*-" & $atkTroops[$i][0] & " " & NameOfTroop($atkTroops[$i][0]) & " " & $atkTroops[$i][1] & " <<---" & $eGobl, $COLOR_SUCCESS)
$troopPosition = $i
Else
If $g_iDebugSetlog = 1 Then SetLog("-*-" & $atkTroops[$i][0] & " " & NameOfTroop($atkTroops[$i][0]) & " " & $atkTroops[$i][1] & "", $COLOR_GRAY)
EndIf
EndIf
Next
If $troopPosition >= 0 Then
SelectDropTroop($troopPosition)
If UBound($vect) > 2 Then
Switch $g_iMilkingAttackStructureOrder
Case 1
Local $rnd = _RandomUnique(UBound($vect) - 1, 0, UBound($vect) - 2, 1)
For $i = 0 To UBound($rnd) - 1
If $g_iDebugSetlog = 1 Then Setlog("random vect pos " & $i & " value " & $rnd[$i],$COLOR_DEBUG)
Next
Case 2
Local $rnd = _OrderBySideObjectives($vect)
For $i = 0 To UBound($rnd) - 1
If $g_iDebugSetlog = 1 Then Setlog("order by side vect pos " & $i & " value " & $rnd[$i],$COLOR_DEBUG)
Next
Case else
Local $tmpstr = ""
For $k=0 To UBound($vect) -1
$tmpstr &= $k &"-"
Next
$tmpstr=StringLeft($tmpStr,StringLen($tmpstr)-1)
Local $rnd = StringSplit($tmpStr,"-",2)
For $i = 0 To UBound($rnd) - 1
If $g_iDebugSetlog = 1 Then Setlog("as found vect pos " & $i & " value " & $rnd[$i],$COLOR_DEBUG)
Next
EndSwitch
For $i = 0 To UBound($rnd) - 1
Local $vect2 = StringSplit($vect[$i], ".", 2)
If UBound($vect2) > 1 Then
If $g_iDebugSetlog = 1 Then Setlog($i & "- Attack structure n. " & $rnd[$i] +1 & "/" & UBound($vect) & " - " & $vect2[0], $COLOR_DEBUG)
If UBound($vect) > $rnd[$i] Then
MilkingAttackStructure($vect[$rnd[$i]])
Else
If $g_iDebugSetlog = 1 Then Setlog($i & " range exceeded of $vect!")
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog("Error @18")
EndIf
Next
EndIf
If UBound($vect) = 2 Then
For $i = 0 To 1
If $g_iDebugSetlog = 1 Then Setlog($i & "- Attack structure n. " & $i & "/1 ", $COLOR_DEBUG)
MilkingAttackStructure($vect[$i])
Next
EndIf
If UBound($vect) = 1 Then
If $g_iDebugSetlog = 1 Then Setlog($i & "- Attack structure n. 0/0 ", $COLOR_DEBUG)
MilkingAttackStructure($vect[0])
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog("No Goblins left ")
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog("No structures to attack...")
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog("No structures to attack..")
EndIf
Else
Setlog("No structures to attack, skip attack structures!")
EndIf
If $g_bMilkAttackAfterTHSnipeEnable Then
FindTownHall(True)
If $searchTH <>"-" Then
If SearchTownHallLoc() Then
$g_iMatchMode = $TS
Setlog(_PadStringCenter(" Attack TH snipe after Milking Attack ", 54,"="),$COLOR_INFO)
If $g_bMilkAttackAfterScriptedAtkEnable = False Then
PrepareAttack($g_iMatchMode, True)
algorithm_AllTroops()
Else
SetSlotSpecialTroops()
$THusedKing = 0
$THusedQueen = 0
AttackTHParseCSV()
EndIf
Else
Setlog("TH it is not outside, skip attack", $COLOR_INFO)
EndIf
Else
Setlog("Cannot detect Townhall, skip THsnipe after Milking", $COLOR_INFO)
EndIf
EndIf
If $g_bMilkAttackAfterScriptedAtkEnable Then
Setlog(_PadStringCenter("Scripted Attack after Miliking ", 54,"="),$COLOR_INFO)
Algorithm_AttackCSV(False,False)
EndIf
$duringMilkingAttack = 0
EndFunc
Func _OrderBySideObjectives($vect)
Local $slice1 = ""
Local $slice2 = ""
Local $slice3 = ""
Local $slice4 = ""
Local $slice5 = ""
Local $slice6 = ""
Local $slice7 = ""
Local $slice8 = ""
For $j = 0 To Ubound($vect) -1
Local $structure = StringSplit($vect[$j],".",2)
Local $pixel = StringSplit($structure[2],"-",2)
Switch StringLeft(Slice8($pixel),1)
Case 1
$slice1 &= $j & "-"
Case 2
$slice2 &= $j & "-"
Case 3
$slice3 &= $j & "-"
Case 4
$slice4 &= $j & "-"
Case 5
$slice5 &= $j & "-"
Case 6
$slice6 &= $j & "-"
Case 7
$slice7 &= $j & "-"
Case else
$slice8 &= $j & "-"
EndSwitch
Next
Local $result
If $slice7 <>"" Then $result &=$slice7
If $slice8 <>"" Then $result &=$slice8
If $slice1 <>"" Then $result &=$slice1
If $slice2 <>"" Then $result &=$slice2
If $slice3 <>"" Then $result &=$slice3
If $slice4 <>"" Then $result &=$slice4
If $slice5 <>"" Then $result &=$slice5
If $slice6 <>"" Then $result &=$slice6
$result = StringLeft($result,StringLen($result)-1)
Return StringSplit($result,"-",2)
EndFunc
Func AmountOfResourcesInStructure($type, $coordinate, $level)
Switch $type
Case "elixir"
If $level <= 8 And $level >= 0 Then
Local $temp = Int($g_aiMilkFarmElixirParam[$level])
If $temp > 0 Then
If $g_iMilkAttackType = 0 Then
Local $capacity = DetectAmountOfResourceInStructure($type, $coordinate, $level, $temp)
If $capacity >= $temp Then
If $g_iDebugSetlog=1 Then Setlog("elixir " & $type & " " & $coordinate & " " & $level & " " & $capacity ,$COLOR_DEBUG)
Return True
Else
If $g_iDebugSetlog = 1 Then Setlog("Discard, capacity of structure under settings:  liv " & $level & " cap " & $temp & " detected "& $capacity, $COLOR_DEBUG)
EndIf
Else
If $g_iDebugSetlog=1 Then Setlog("elixir " & $type & " " & $coordinate & " " & $level & " PASSED LOW CPU SETTINGS" ,$COLOR_DEBUG)
Return True
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog("Discard, level settings discard this structure (requested min. " & Int($g_aiMilkFarmElixirParam[$level]) & ")", $COLOR_DEBUG)
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog("Discard, out of bounds", $COLOR_DEBUG)
EndIf
Return False
Case "mine"
If $level <= 8 And $level >= 0 Then
If $level >= $g_iMilkFarmMineParam Then
Return True
Else
If $g_iDebugSetlog = 1 Then Setlog("Discard, level settings discard this structure (level=" & $level & ",filter=" & $g_iMilkFarmMineParam & ")", $COLOR_DEBUG)
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog("Discard, out of bounds", $COLOR_DEBUG)
EndIf
Return False
Case "drill"
If $level <= 6 And $level >= 1 Then
If $level >= $g_iMilkFarmDrillParam Then
Return True
Else
If $g_iDebugSetlog = 1 Then Setlog("Discard, level settings discard this structure (level=" & $level & ",filter=" & $g_iMilkFarmDrillParam & ")", $COLOR_DEBUG)
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog("Discard, out of bounds", $COLOR_DEBUG)
EndIf
Return False
Case Else
Return False
EndSwitch
EndFunc
Func DetectAmountOfResourceInStructure($type, $coordinate, $level, $mincapacity)
If $type = "elixir" Then
Local $tolerance
Local $posx, $posy
Local $filename
Local $endoffilename
_CaptureRegion($coordinate[0] - 10, $coordinate[1] - 10, $coordinate[0] + 10, $coordinate[1] + 20)
Local $found = 0
For $t = UBound($CapacityStructureElixir[$level]) - 1 To 1 Step -1
Local $a = $CapacityStructureElixir[$level]
$filename = $a[$t]
Local $capacityanalized = StringMid($filename, StringInStr($filename, "_", 0, 2) + 1, StringInStr($filename, "_", 0, 3) - StringInStr($filename, "_", 0, 2) - 1)
$tolerance = StringMid($filename, StringInStr($filename, "_", 0, 3) + 1, StringInStr($filename, "_", 0, 4) - StringInStr($filename, "_", 0, 3) - 1)
If $g_bMilkFarmForceToleranceEnable Then
$endoffilename = StringMid($filename, StringInStr($filename, "_", 0, 4) + 1, 1)
If $endoffilename = "Z" Then
$tolerance = $g_iMilkFarmForceToleranceBoosted
Else
$tolerance = $g_iMilkFarmForceToleranceNormal
EndIf
EndIf
If $capacityanalized < $mincapacity And $g_iDebugContinueSearchElixir = 0 Then
If $g_iDebugSetlog = 1 Then Setlog("IMAGECKECK STOP, capacity < mincapacity " & $filename, $COLOR_DEBUG)
Return -1
ExitLoop
Else
$found = _ImageSearch(@ScriptDir & "\images\CapacityStructure\" & $a[$t], 1, $posx, $posy, $tolerance)
If $found = 1 Then
If $g_iDebugSetlog = 1 Then Setlog("IMAGECKECK OK (" & $tolerance & ") " & $filename, $COLOR_DEBUG)
If $g_iDebugImageSave = 1 Then DebugImageSave("IMAGECKECK OK (" & $tolerance & ") " & $filename, False)
Return $capacityanalized
ExitLoop
EndIf
EndIf
Next
If $found = 0 Then
If $g_iDebugImageSave = 1 Then DebugImageSave("elixir_" & $level & "_", False)
If $g_iDebugSetlog = 1 Then SETLOG("FAIL STRUCTURE POSITION (" & $coordinate[0] & "," & $coordinate[1] & ") level " & $level & " (" & $level + 4 & ")", $COLOR_DEBUG)
EndIf
Return -1
Else
Return -1
EndIf
EndFunc
Func MilkFarmObjectivesSTR_INSERT($type, $level, $coordinate)
Local $ResourceToInsertQty = 0
Local $ResourceToInsert = ""
$ResourceToInsert = $type
$ResourceToInsert &= "." & $level
$ResourceToInsert &= "." & $coordinate
Local $pixel = StringSplit($coordinate, "-", 2)
Local $diamondx = $MilkFarmOffsetX + $MilkFarmOffsetXStep * $g_iMilkFarmResMaxTilesFromBorder
Local $diamondy = $MilkFarmOffsetY + $MilkFarmOffsetYStep * $g_iMilkFarmResMaxTilesFromBorder
If UBound($pixel) = 2 Then
Switch $type
Case "gomine"
Local $px = StringSplit($MilkFarmOffsetMine[$level], "-", 2)
Case "elixir"
Local $px = StringSplit($MilkFarmOffsetElixir[$level], "-", 2)
Case "ddrill"
Local $px = StringSplit($MilkFarmOffsetDark[$level], "-", 2)
Case Else
Local $px = StringSplit("0-0", "-", 2)
EndSwitch
$pixel[0] += $px[0]
$pixel[1] += $px[1]
Local $vector = $PixelTopLeft
For $i = 0 To UBound($vector) - 1
Local $pixel2 = $vector[$i]
If UBound($pixel2) = 2 Then
If Abs(($pixel[0] - $pixel2[0]) / $diamondx) + Abs(($pixel[1] - $pixel2[1]) / $diamondy) <= 1 Then
$ResourceToInsert &= "." & $pixel2[0] & "-" & $pixel2[1]
$ResourceToInsertQty += 1
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog("MilkFarmObjectivesSTR_INSERT Discard error #3", $COLOR_ERROR)
EndIf
Next
Local $vector = $PixelTopRight
For $i = 0 To UBound($vector) - 1
Local $pixel2 = $vector[$i]
If UBound($pixel2) = 2 Then
If Abs(($pixel[0] - $pixel2[0]) / $diamondx) + Abs(($pixel[1] - $pixel2[1]) / $diamondy) <= 1 Then
$ResourceToInsert &= "." & $pixel2[0] & "-" & $pixel2[1]
$ResourceToInsertQty += 1
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog("MilkFarmObjectivesSTR_INSERT Discard error #3", $COLOR_ERROR)
EndIf
Next
Local $vector = $PixelBottomLeft
For $i = 0 To UBound($vector) - 1
Local $pixel2 = $vector[$i]
If UBound($pixel2) = 2 Then
If Abs(($pixel[0] - $pixel2[0]) / $diamondx) + Abs(($pixel[1] - $pixel2[1]) / $diamondy) <= 1 Then
$ResourceToInsert &= "." & $pixel2[0] & "-" & $pixel2[1]
$ResourceToInsertQty += 1
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog("MilkFarmObjectivesSTR_INSERT Discard error #3", $COLOR_ERROR)
EndIf
Next
Local $vector = $PixelBottomRight
For $i = 0 To UBound($vector) - 1
Local $pixel2 = $vector[$i]
If UBound($pixel2) = 2 Then
If Abs(($pixel[0] - $pixel2[0]) / $diamondx) + Abs(($pixel[1] - $pixel2[1]) / $diamondy) <= 1 Then
$ResourceToInsert &= "." & $pixel2[0] & "-" & $pixel2[1]
$ResourceToInsertQty += 1
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog("MilkFarmObjectivesSTR_INSERT Discard error #3", $COLOR_ERROR)
EndIf
Next
If $ResourceToInsertQty > 0 Then
If StringLen($MilkFarmObjectivesSTR) > 0 Then $MilkFarmObjectivesSTR &= "|"
$MilkFarmObjectivesSTR &= $ResourceToInsert
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog("MilkFarmObjectivesSTR_INSERT Discard error #1 " & $pixel & " " & UBound($pixel), $COLOR_ERROR)
EndIf
Return $ResourceToInsertQty
EndFunc
Func LoadAmountOfResourcesImages()
Local $x
Local $useImages = "*.bmp"
For $t = 0 To 8
$CapacityStructureElixir[$t] = StringSplit("", "")
$x = _FileListToArrayRec(@ScriptDir & "\images\CapacityStructure\", "elixir_" & $t & $useImages, $FLTAR_FILES, $FLTAR_NORECUR, $FLTAR_SORT, $FLTAR_NOPATH)
If UBound($x) > 0 Then $CapacityStructureElixir[$t] = $x
Next
For $t = 0 To 8
$DestroyedMineIMG[$t] = StringSplit("", "")
$x = _FileListToArrayRec(@ScriptDir & "\images\CapacityStructure\", "destroyed_mine_" & $t & $useImages, $FLTAR_FILES, $FLTAR_NORECUR, $FLTAR_SORT, $FLTAR_NOPATH)
If UBound($x) > 0 Then $DestroyedMineIMG[$t] = $x
Next
For $t = 0 To 8
$DestroyedElixirIMG[$t] = StringSplit("", "")
$x = _FileListToArrayRec(@ScriptDir & "\images\CapacityStructure\", "destroyed_elixir_" & $t & $useImages, $FLTAR_FILES, $FLTAR_NORECUR, $FLTAR_SORT, $FLTAR_NOPATH)
If UBound($x) > 0 Then $DestroyedElixirIMG[$t] = $x
Next
For $t = 0 To 8
$DestroyedDarkIMG[$t] = StringSplit("", "")
$x = _FileListToArrayRec(@ScriptDir & "\images\CapacityStructure\", "destroyed_dark_" & $t & $useImages, $FLTAR_FILES, $FLTAR_NORECUR, $FLTAR_SORT, $FLTAR_NOPATH)
If UBound($x) > 0 Then $DestroyedDarkIMG[$t] = $x
Next
EndFunc
Func MilkFarmObjectivesDebugImage($vector, $maxtiles = 0)
If $g_iDebugMilkingIMGmake = 1 Then
_CaptureRegion()
Local $EditedImage
$EditedImage = $hBitmap
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($EditedImage)
Local $hBrush = _GDIPlus_BrushCreateSolid(0xFFFFFFFF)
Local $pixel
Local $hPen = _GDIPlus_PenCreate(0xFFFF0000, 2)
For $i = 0 To UBound($PixelTopLeft) - 1
$pixel = $PixelTopLeft[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPen)
Next
For $i = 0 To UBound($PixelTopRight) - 1
$pixel = $PixelTopRight[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPen)
Next
For $i = 0 To UBound($PixelBottomLeft) - 1
$pixel = $PixelBottomLeft[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPen)
Next
For $i = 0 To UBound($PixelBottomRight) - 1
$pixel = $PixelBottomRight[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPen)
Next
Local $testx = StringSplit($vector, "|", 2)
For $i = 0 To UBound($testx) - 1
Local $pixel1 = StringSplit($testx[$i], ".", 2)
If UBound($pixel1) >= 2 Then
Local $level = $pixel1[1]
Else
Local $level = 0
EndIf
Local $resourceoffsetx = 0
Local $resourceoffsety = 0
Switch $pixel1[0]
Case "gomine"
Local $px = StringSplit($MilkFarmOffsetMine[$level], "-", 2)
Case "elixir"
Local $px = StringSplit($MilkFarmOffsetElixir[$level], "-", 2)
Case "ddrill"
Local $px = StringSplit($MilkFarmOffsetDark[$level], "-", 2)
Case Else
Local $px = StringSplit("0-0", "-", 2)
EndSwitch
$resourceoffsetx = $px[0]
$resourceoffsety = $px[1]
If UBound($pixel1) >= 2 Then
$pixel = StringSplit($pixel1[2], "-", 2)
If UBound($pixel) = 2 Then
_GDIPlus_PenDispose($hPen)
Local $hPen = _GDIPlus_PenCreate(0xFFFF0000, 1)
Local $x = 20
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety - $x, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety - 10, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety + 10, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety + $x, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx - $x, $pixel[1] + $resourceoffsety, $pixel[0] + $resourceoffsetx - 10, $pixel[1] + $resourceoffsety, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx + 10, $pixel[1] + $resourceoffsety, $pixel[0] + $resourceoffsetx + $x, $pixel[1] + $resourceoffsety, $hPen)
If $maxtiles >= 0 Then
_GDIPlus_PenDispose($hPen)
Local $hPen = _GDIPlus_PenCreate(0xFF0026FF, 1)
Local $multiplier = 0
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx - $MilkFarmOffsetX - $MilkFarmOffsetXStep * $multiplier, $pixel[1] + $resourceoffsety, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety - $MilkFarmOffsetY - $MilkFarmOffsetYStep * $multiplier, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx - $MilkFarmOffsetX - $MilkFarmOffsetXStep * $multiplier, $pixel[1] + $resourceoffsety, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety + $MilkFarmOffsetY + $MilkFarmOffsetYStep * $multiplier, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety - $MilkFarmOffsetY - $MilkFarmOffsetYStep * $multiplier, $pixel[0] + $resourceoffsetx + $MilkFarmOffsetX + $MilkFarmOffsetXStep * $multiplier, $pixel[1] + $resourceoffsety, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety + $MilkFarmOffsetY + $MilkFarmOffsetYStep * $multiplier, $pixel[0] + $resourceoffsetx + $MilkFarmOffsetX + $MilkFarmOffsetXStep * $multiplier, $pixel[1] + $resourceoffsety, $hPen)
EndIf
If $maxtiles >= 1 Then
_GDIPlus_PenDispose($hPen)
Local $hPen = _GDIPlus_PenCreate(0xFF00FFFF, 1)
Local $multiplier = 1
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx - $MilkFarmOffsetX - $MilkFarmOffsetXStep * $multiplier, $pixel[1] + $resourceoffsety, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety - $MilkFarmOffsetY - $MilkFarmOffsetYStep * $multiplier, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx - $MilkFarmOffsetX - $MilkFarmOffsetXStep * $multiplier, $pixel[1] + $resourceoffsety, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety + $MilkFarmOffsetY + $MilkFarmOffsetYStep * $multiplier, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety - $MilkFarmOffsetY - $MilkFarmOffsetYStep * $multiplier, $pixel[0] + $resourceoffsetx + $MilkFarmOffsetX + $MilkFarmOffsetXStep * $multiplier, $pixel[1] + $resourceoffsety, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety + $MilkFarmOffsetY + $MilkFarmOffsetYStep * $multiplier, $pixel[0] + $resourceoffsetx + $MilkFarmOffsetX + $MilkFarmOffsetXStep * $multiplier, $pixel[1] + $resourceoffsety, $hPen)
EndIf
If $maxtiles >= 2 Then
_GDIPlus_PenDispose($hPen)
Local $hPen = _GDIPlus_PenCreate(0xFFFFD800, 1)
Local $multiplier = 2
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx - $MilkFarmOffsetX - $MilkFarmOffsetXStep * $multiplier, $pixel[1] + $resourceoffsety, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety - $MilkFarmOffsetY - $MilkFarmOffsetYStep * $multiplier, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx - $MilkFarmOffsetX - $MilkFarmOffsetXStep * $multiplier, $pixel[1] + $resourceoffsety, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety + $MilkFarmOffsetY + $MilkFarmOffsetYStep * $multiplier, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety - $MilkFarmOffsetY - $MilkFarmOffsetYStep * $multiplier, $pixel[0] + $resourceoffsetx + $MilkFarmOffsetX + $MilkFarmOffsetXStep * $multiplier, $pixel[1] + $resourceoffsety, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety + $MilkFarmOffsetY + $MilkFarmOffsetYStep * $multiplier, $pixel[0] + $resourceoffsetx + $MilkFarmOffsetX + $MilkFarmOffsetXStep * $multiplier, $pixel[1] + $resourceoffsety, $hPen)
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog("MilkFarmObjectivesDebugImage #1", $COLOR_DEBUG)
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog("MilkFarmObjectivesDebugImage #2", $COLOR_DEBUG)
EndIf
Next
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
Local $savefolder = $g_sProfileTempDebugPath & "MilkFarmDebug_" & "\"
DirCreate($savefolder)
Local $filename = String("MilkFarmDebug_" & $Date & "_" & $Time)
_GDIPlus_ImageSaveToFile($EditedImage, $savefolder & $filename & ".jpg")
_GDIPlus_PenDispose($hPen)
_GDIPlus_BrushDispose($hBrush)
_GDIPlus_GraphicsDispose($hGraphic)
EndIf
EndFunc
Func MilkingAttackStructure($vectstr)
If $g_iDebugSetlog = 1 Then SetLog("###### Attack " & $vectstr & "######")
Local $vect = StringSplit($vectstr, ".", 2)
If UBound($vect) = 4 Then
Else
Local $troopxwave
If $g_iMilkFarmTroopForWaveMin = $g_iMilkFarmTroopForWaveMax Then
$troopxwave = $g_iMilkFarmTroopForWaveMin
Else
$troopxwave = Random($g_iMilkFarmTroopForWaveMin, $g_iMilkFarmTroopForWaveMax, 1)
EndIf
If $g_iDebugSetlog = 1 Then Setlog("drop n.: " & $troopxwave & " troops | structure:" & $vect[0])
Local $skipdelay = False
For $i = 1 To $g_iMilkFarmTroopMaxWaves
If $g_iDebugSetlog = 1 Then Setlog("Wave attack number " & $i)
$skipdelay = False
If IsAttackPage() Then
If $g_bMilkingAttackCheckStructureDestroyedBeforeAttack Then
If MilkingAttackStructureDestroyed($vect[0], $vect[1], $vect[2]) Then
$skipdelay = True
ExitLoop
EndIf
EndIf
If $g_iMilkingAttackDropGoblinAlgorithm = 1 Then
For $j = 1 To $troopxwave
If UBound($vect) = 4 Then
Local $rndpos = 3
Else
Local $rndpos = Random(3, UBound($vect) - 1, 1)
EndIf
Local $pixel = StringSplit($vect[$rndpos], "-", 2)
Local $delaypoint = 0
If UBound($pixel) = 2 Then
Click($pixel[0], $pixel[1], 1, $delaypoint, "#0777")
Else
If $g_iDebugSetlog = 1 Then Setlog("MilkingAttackStructure error #1")
EndIf
Next
Else
If UBound($vect) = 4 Then
Local $rndpos = 3
Else
Local $rndpos = Random(3, UBound($vect) - 1, 1)
EndIf
$pixel = StringSplit($vect[$rndpos], "-", 2)
If UBound($pixel) = 2 Then
Click($pixel[0], $pixel[1], $troopxwave, Random(2, 7, 1), "#0778")
Else
If $g_iDebugSetlog = 1 Then Setlog("MilkingAttackStructure error #1")
EndIf
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog("You are not in Attack phase")
Return
EndIf
If $skipdelay = False Then
Local $delayfromwaves
If $g_iMilkFarmDelayFromWavesMin = $g_iMilkFarmDelayFromWavesMax Then
$delayfromwaves = $g_iMilkFarmDelayFromWavesMin
Else
$delayfromwaves = Random($g_iMilkFarmDelayFromWavesMin, $g_iMilkFarmDelayFromWavesMax, 1)
EndIf
If $g_iDebugSetlog = 1 Then Setlog("wait " & $delayfromwaves)
If _Sleep($delayfromwaves) Then Return
EndIf
Next
If $g_bMilkingAttackCheckStructureDestroyedAfterAttack Then
If MilkingAttackStructureDestroyed($vect[0], $vect[1], $vect[2]) Then Return
EndIf
EndIf
EndFunc
Func MilkingAttackStructureDestroyed($type, $level, $coordinate)
Local $pixel = StringSplit($coordinate, "-", 2)
Switch $type
Case "gomine"
Local $px = StringSplit($MilkFarmOffsetMine[$level], "-", 2)
Local $name = "Mine"
Case "elixir"
Local $px = StringSplit($MilkFarmOffsetElixir[$level], "-", 2)
Local $name = "Elixir"
Case "ddrill"
Local $px = StringSplit($MilkFarmOffsetDark[$level], "-", 2)
Local $name = "Dark"
Case Else
Local $px = StringSplit("0-0", "-", 2)
Local $name = ""
If $g_iDebugSetlog = 1 Then Setlog("MilkingAttackStructureDestroyed error #1")
EndSwitch
$pixel[0] += $px[0]
$pixel[1] += $px[1]
If UBound($pixel) = 2 Then
_CaptureRegion($pixel[0] - 15, $pixel[1] - 15, $pixel[0] + 15, $pixel[1] + 15)
Local $found = 0
Local $posx, $posy
Local $aDestroyedImgFilenames = 0
If $name = "Mine" Then
$aDestroyedImgFilenames = $DestroyedMineIMG[$level]
ElseIf $name = "Elixir" Then
$aDestroyedImgFilenames = $DestroyedElixirIMG[$level]
ElseIf $name = "Dark" Then
$aDestroyedImgFilenames = $DestroyedDarkIMG[$level]
EndIf
If $g_iDebugSetlog = 1 Then Setlog("##start search in vector Destroyed" & $name & "IMG" & $level & ": numbers of files=" & UBound($aDestroyedImgFilenames), $COLOR_SUCCESS)
For $t = UBound($aDestroyedImgFilenames) - 1 To 1 Step -1
Local $filename = $aDestroyedImgFilenames[$t]
Local $tolerance = Int(StringMid($filename, StringInStr($filename, "_", 0, 3) + 1, StringInStr($filename, "_", 0, 4) - StringInStr($filename, "_", 0, 3) - 1))
If $g_bMilkFarmForceToleranceEnable Then $tolerance = Int($g_iMilkFarmForceToleranceDestroyed)
$found = _ImageSearch(@ScriptDir & "\images\CapacityStructure\" & $filename, 1, $posx, $posy, $tolerance)
If $found = 1 Then
If $g_iDebugSetlog = 1 Then Setlog("IMAGECHECK OK " & $filename, $COLOR_DEBUG)
If $g_iDebugSetlog = 1 Then SetLog(">>Structure Destroyed! (" & $name & "," & $level & "," & $tolerance & ")", $COLOR_ERROR)
Return True
ExitLoop
Else
EndIf
Next
If $found = 0 Then
DebugImageSave("debugMilkingAttackStructureDestroyed_" & $type & "_" & $level & "_", False)
EndIf
Return False
Else
If $g_iDebugSetlog = 1 Then Setlog("error MilkingAttackStructureDestroyed #1")
EndIf
EndFunc
Func _RandomUnique($iCount, $nMin, $nMax, $iInt = 0, $nSeed = Default)
Select
Case($iCount < 1)
Return SetError(1, 0, 0)
Case($iCount > 10 ^ 6 - 1)
Return SetError(2, 0, 0)
Case($nMin = $nMax)
Return SetError(3, 0, 0)
Case($nMin > $nMax)
Return SetError(4, 0, 0)
Case(($nMin < -2 ^ 31) Or($nMax > 2 ^ 31 - 1))
Return SetError(5, 0, 0)
EndSelect
If IsNumber($nSeed) Then
If(($nSeed < -2 ^ 31) Or($nSeed > 2 ^ 31 - 1)) Then Return SetError(6, 0, 0)
SRandom($nSeed)
EndIf
Local $iCountInval = 0
If($iInt) Then
If($nMin >= 0) Then
If($iCount >($nMax - $nMin) + 1) Then
$iCountInval = 1
ElseIf($iCount =($nMax - $nMin) + 1) Then
$iCountInval = 3
EndIf
Else
If($iCount >($nMax + Abs($nMin) + 1)) Then
$iCountInval = 2
ElseIf($iCount =($nMax + Abs($nMin) + 1)) Then
$iCountInval = 3
EndIf
EndIf
EndIf
If($iInt And $iCount = 1) Then
Local $aArray[2] = [1, Random($nMin, $nMax, $iInt)]
ElseIf $iCountInval Then
If $iCountInval = 1 Then
$iCount = Int($nMax - $nMin) + 1
ElseIf $iCountInval = 2 Then
$iCount = Int($nMax + Abs($nMin)) + 1
EndIf
If $iCountInval = 3 Then $iCountInval = 0
Local $aTmp, $iA, $iNumber = $nMin, $aArray[$iCount + 1] = [$iCount]
For $i = 1 To $aArray[0]
$aArray[$i] = $iNumber
$iNumber += 1
Next
For $i = 1 To $aArray[0]
$iA = Random($i, $aArray[0], 1)
If $i = $iA Then ContinueLoop
If $iA = 0 Then $iA = $aArray[0]
$aTmp = $aArray[$i]
$aArray[$i] = $aArray[$iA]
$aArray[$iA] = $aTmp
Next
Else
Local $nRnd, $iStep = 0, $aArray[$iCount + 1] = [$iCount]
While($iStep <= $iCount - 1)
$nRnd = Random($nMin, $nMax, $iInt)
If IsDeclared($nRnd) <> -1 Then
$iStep += 1
$aArray[$iStep] = $nRnd
Assign($nRnd, '', 1)
EndIf
WEnd
EndIf
Return SetError(0, Number($iCountInval > 0), $aArray)
EndFunc
Func MilkingDetectElixirExtractors()
If $g_bMilkFarmAttackElixirExtractors and $iElixirCurrent >= $g_iMilkFarmLimitElixir Then
If $g_iDebugSetlog = 1 Then setlog("skip attack of elixir extractors, current elixir (" & $iElixirCurrent & ") >= limit (" & $g_iMilkFarmLimitElixir & ")",$COLOR_DEBUG)
return 0
Else
If $g_iDebugSetlog = 1 Then setlog("current elixir (" & $iElixirCurrent & ") < limit (" & $g_iMilkFarmLimitElixir & ")",$COLOR_DEBUG)
EndIf
$MilkFarmObjectivesSTR = ""
Local $MilkFarmAtkPixelListSTR = ""
Local $hTimer = TimerInit()
_CaptureRegion2()
Local $ElixirVect = StringSplit(GetLocationElixirWithLevel(), "~", 2)
Local $elixirfounds = UBound($ElixirVect)
Local $elixirmatch = 0
Local $elixirdiscard = 0
Local $redareapointsnearstructure = ""
For $i = 0 To UBound($ElixirVect) - 1
If $g_iDebugSetlog = 1 Then Setlog($i & " : " & $ElixirVect[$i])
Local $temp = StringSplit($ElixirVect[$i], "#", 2)
If UBound($temp) = 2 Then
Local $pixel = StringSplit($temp[1], "-", 2)
If UBound($pixel) = 2 Then
If isInsideDiamondRedArea($pixel) Then
$redareapointsnearstructure = MilkingRedAreaPointsNearStructure("elixir", $temp[0], $temp[1])
if $redareapointsnearstructure <>"" Then
If AmountOfResourcesInStructure("elixir", $pixel, $temp[0]) Then
If $g_bMilkFarmLocateElixir Then
if $MilkFarmObjectivesSTR <> "" then $MilkFarmObjectivesSTR &= "|"
$MilkFarmObjectivesSTR &= "elixir"
$MilkFarmObjectivesSTR &= "." & $temp[0]
$MilkFarmObjectivesSTR &= "." & $temp[1]
$MilkFarmObjectivesSTR &= $redareapointsnearstructure
$elixirmatch += 1
Else
If $g_iDebugSetlog = 1 Then Setlog(" - discard #6 skip locate elixir", $COLOR_DEBUG)
$elixirdiscard += 1
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog(" - discard #5 no match condition % amount of elixir", $COLOR_DEBUG)
$elixirdiscard += 1
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog(" - discard #4 no redarea points matching conditions", $COLOR_DEBUG)
$elixirdiscard += 1
EndIf
If $g_iDebugResourcesOffset = 1 Then
Local $resourceoffsetx = 0
Local $resourceoffsety = 0
Local $px = StringSplit($MilkFarmOffsetElixir[$temp[0]], "-", 2)
$resourceoffsetx = $px[0]
$resourceoffsety = $px[1]
_CaptureRegion($pixel[0] + $resourceoffsetx - 30, $pixel[1] + $resourceoffsety - 30, $pixel[0] + $resourceoffsetx + 30, $pixel[1] + $resourceoffsety + 30)
Local $hPen = _GDIPlus_PenCreate(0xFFFFD800, 1)
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($hBitmap)
Local $hBrush = _GDIPlus_BrushCreateSolid(0xFFFFFFFF)
_GDIPlus_GraphicsDrawLine($hGraphic, 0, 30, 60, 30, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, 30, 0, 30, 60, $hPen)
_GDIPlus_PenDispose($hPen)
_GDIPlus_BrushDispose($hBrush)
_GDIPlus_GraphicsDispose($hGraphic)
DebugImageSave("debugresourcesoffset_" & "elixir" & "_" & $temp[0] & "_", False)
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog(" - discard #3 out of insidediamond", $COLOR_DEBUG)
$elixirdiscard += 1
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog(" - discard #2 no pixel coordinate", $COLOR_DEBUG)
$elixirdiscard += 1
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog(" - discard #1 no valid point", $COLOR_DEBUG)
$elixirdiscard += 1
EndIf
Next
If StringLen($MilkFarmAtkPixelListSTR) > 1 Then
$MilkFarmAtkPixelListSTR = StringLeft($MilkFarmAtkPixelListSTR, StringLen($MilkFarmAtkPixelListSTR) - 1)
EndIf
If $g_iDebugSetlog = 1 Then Setlog("> Elixir Extractors to attack list: " & $MilkFarmAtkPixelListSTR, $COLOR_DEBUG)
Local $htimerLocateElixir = Round(TimerDiff($hTimer) / 1000, 2)
If $g_iDebugSetlog = 1 Then Setlog("> Elixir Extractors found: " & $elixirfounds & " | match conditions: " & $elixirmatch & " | discard " & $elixirdiscard, $COLOR_INFO)
If $g_iDebugSetlog = 1 Then SetLog("> Elixir Extractors position and %full detectecd in " & $htimerLocateElixir & " seconds", $COLOR_INFO)
Return $elixirmatch
EndFunc
Func MilkingDetectMineExtractors()
If $g_bMilkFarmAttackGoldMines and $iGoldCurrent >= $g_iMilkFarmLimitGold Then
If $g_iDebugSetlog = 1 Then setlog("skip attack of gold mines, current gold (" & $iGoldCurrent & ") >= limit (" & $g_iMilkFarmLimitGold & ")",$COLOR_DEBUG)
Return 0
Else
If $g_iDebugSetlog = 1 Then setlog("current gold (" & $iGoldCurrent & ") < limit (" & $g_iMilkFarmLimitGold & ")",$COLOR_DEBUG)
EndIf
Local $MilkFarmAtkPixelListMINESTR = ""
If $g_bMilkFarmLocateMine Then
Local $hTimer = TimerInit()
_CaptureRegion2()
Local $MineVect = StringSplit(GetLocationMineWithLevel(), "~", 2)
Local $Minefounds = 0
Local $Minematch = 0
Local $Minediscard = 0
For $i = 0 To UBound($MineVect) - 1
Local $temp = StringSplit($MineVect[$i], "#", 2)
If UBound($temp) = 2 Then
Local $pixel = StringSplit($temp[1], "-", 2)
If UBound($pixel) = 2 Then
Local $tempPixel[2] = [$pixel[0] , $pixel[1] ]
$pixel = $tempPixel
$temp[1] = String($pixel[0] & "-" & $pixel[1])
If isInsideDiamondRedArea($pixel) Then
$Minefounds += 1
If $g_iDebugResourcesOffset = 1 Then
Local $level = $temp[0]
Local $type = "mine"
Local $resourceoffsetx = 0
Local $resourceoffsety = 0
Local $px = StringSplit($MilkFarmOffsetMine[$level], "-", 2)
$resourceoffsetx = $px[0]
$resourceoffsety = $px[1]
_CaptureRegion($pixel[0] + $resourceoffsetx - 30, $pixel[1] + $resourceoffsety - 30, $pixel[0] + $resourceoffsetx + 30, $pixel[1] + $resourceoffsety + 30)
Local $hPen = _GDIPlus_PenCreate(0xFFFFD800, 1)
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($hBitmap)
Local $hBrush = _GDIPlus_BrushCreateSolid(0xFFFFFFFF)
_GDIPlus_GraphicsDrawLine($hGraphic, 0, 30, 60, 30, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, 30, 0, 30, 60, $hPen)
_GDIPlus_PenDispose($hPen)
_GDIPlus_BrushDispose($hBrush)
_GDIPlus_GraphicsDispose($hGraphic)
DebugImageSave("debugresourcesoffset_" & $type & "_" & $level & "_" , False)
EndIf
If AmountOfResourcesInStructure("mine", $pixel, $temp[0]) Then
$MilkFarmAtkPixelListMINESTR &= $temp[1] & "|"
If MilkFarmObjectivesSTR_INSERT("gomine", $temp[0], $temp[1]) Then
$Minematch += 1
Else
$Minediscard += 1
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog(" - discard #4 no match conditions", $COLOR_DEBUG)
$Minediscard += 1
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog(" - discard #3 out of insidediamond", $COLOR_DEBUG)
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog(" - discard #2 no pixel coordinate", $COLOR_DEBUG)
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog(" - discard #1 no valid point", $COLOR_DEBUG)
$Minediscard += 1
EndIf
Next
If StringLen($MilkFarmAtkPixelListMINESTR) > 1 Then $MilkFarmAtkPixelListMINESTR = StringLeft($MilkFarmAtkPixelListMINESTR, StringLen($MilkFarmAtkPixelListMINESTR) - 1)
If $g_iDebugSetlog = 1 Then Setlog("> Mine Extractors to attack list: " & $MilkFarmAtkPixelListMINESTR, $COLOR_DEBUG)
Local $htimerLocateMine = Round(TimerDiff($hTimer) / 1000, 2)
If $g_iDebugSetlog = 1 Then Setlog("> Mine Extractors found: " & $Minefounds & " | match conditions: " & $Minematch & " | discard " & $Minediscard, $COLOR_INFO)
If $g_iDebugSetlog = 1 Then SetLog("> Mine Extractors position detectecd in " & $htimerLocateMine & " seconds", $COLOR_INFO)
Return $Minematch
Else
Return 0
EndIf
EndFunc
Func MilkingDetectDarkExtractors()
If $g_bMilkFarmAttackDarkDrills and Number($iDarkCurrent) >= number($g_iMilkFarmLimitDark) Then
If $g_iDebugSetlog=1 and $g_bMilkFarmAttackDarkDrills Then setlog("skip attack of dark drills, current dark (" & $iDarkCurrent & ") >= limit (" & $g_iMilkFarmLimitDark & ")",$COLOR_DEBUG)
If $g_iDebugSetlog=1 and $g_bMilkFarmAttackDarkDrills = False Then setlog("skip attack of dark drills",$COLOR_DEBUG)
return 0
Else
If $g_iDebugSetlog=1 Then setlog("current dark (" & $iDarkCurrent & ") < limit (" & $g_iMilkFarmLimitDark & ")",$COLOR_DEBUG)
EndIf
Local $MilkFarmAtkPixelListDRILLSTR = ""
If $g_bMilkFarmLocateDrill Then
Local $hTimer = TimerInit()
_CaptureRegion2()
Local $DrillVect = StringSplit(GetLocationDarkElixirWithLevel(), "~", 2)
Local $Drillfounds = UBound($DrillVect)
Local $Drillmatch = 0
Local $Drilldiscard = 0
For $i = 0 To UBound($DrillVect) - 1
Local $temp = StringSplit($DrillVect[$i], "#", 2)
If UBound($temp) = 2 Then
Local $pixel = StringSplit($temp[1], "-", 2)
If UBound($pixel) = 2 Then
If isInsideDiamondRedArea($pixel) Then
If $g_iDebugResourcesOffset = 1 Then
Local $level = $temp[0]
Local $type = "drill"
Local $resourceoffsetx = 0
Local $resourceoffsety = 0
Local $px = StringSplit($MilkFarmOffsetDark[$level], "-", 2)
$resourceoffsetx = $px[0]
$resourceoffsety = $px[1]
_CaptureRegion($pixel[0] + $resourceoffsetx - 30, $pixel[1] + $resourceoffsety - 30, $pixel[0] + $resourceoffsetx + 30, $pixel[1] + $resourceoffsety + 30)
Local $hPen = _GDIPlus_PenCreate(0xFFFFD800, 1)
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($hBitmap)
Local $hBrush = _GDIPlus_BrushCreateSolid(0xFFFFFFFF)
_GDIPlus_GraphicsDrawLine($hGraphic, 0, 30, 60, 30, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, 30, 0, 30, 60, $hPen)
_GDIPlus_PenDispose($hPen)
_GDIPlus_BrushDispose($hBrush)
_GDIPlus_GraphicsDispose($hGraphic)
DebugImageSave("debugresourcesoffset_" & $type & "_" & $level & "_" , False)
EndIf
If AmountOfResourcesInStructure("drill", $pixel, $temp[0]) Then
$MilkFarmAtkPixelListDRILLSTR &= $temp[1] & "|"
If MilkFarmObjectivesSTR_INSERT("ddrill", $temp[0], $temp[1]) > 0 Then
$Drillmatch += 1
Else
$Drilldiscard += 1
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog(" - discard #4 no match conditions", $COLOR_DEBUG)
$Drilldiscard += 1
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog(" - discard #3 out of insidediamond", $COLOR_DEBUG)
$Drilldiscard += 1
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog(" - discard #2 no pixel coordinate", $COLOR_DEBUG)
$Drilldiscard += 1
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog(" - discard #1 no valid point", $COLOR_DEBUG)
$Drilldiscard += 1
EndIf
Next
If StringLen($MilkFarmAtkPixelListDRILLSTR) > 1 Then $MilkFarmAtkPixelListDRILLSTR = StringLeft($MilkFarmAtkPixelListDRILLSTR, StringLen($MilkFarmAtkPixelListDRILLSTR) - 1)
If $g_iDebugSetlog = 1 Then Setlog("> Drill Extractors to attack list: " & $MilkFarmAtkPixelListDRILLSTR, $COLOR_DEBUG)
Local $htimerLocateDrill = Round(TimerDiff($hTimer) / 1000, 2)
If $g_iDebugSetlog = 1 Then Setlog("> Drill Extractors found: " & $Drillfounds & " | match conditions: " & $Drillmatch & " | discard " & $Drilldiscard, $COLOR_INFO)
If $g_iDebugSetlog = 1 Then SetLog("> Drill Extractors position detectecd in " & $htimerLocateDrill & " seconds", $COLOR_INFO)
Return $Drillmatch
Else
Return 0
EndIf
EndFunc
Func MilkingDetectRedArea()
$MilkFarmObjectivesSTR = ""
Local $hTimer = TimerInit()
_CaptureRegion2()
_GetRedArea()
Local $htimerREDAREA = Round(TimerDiff($hTimer) / 1000, 2)
If $g_iDebugSetlog = 1 Then SetLog("> RedArea completed in " & $htimerREDAREA & " seconds", $COLOR_INFO)
CleanRedArea($PixelTopLeft)
CleanRedArea($PixelTopRight)
CleanRedArea($PixelBottomLeft)
CleanRedArea($PixelBottomRight)
EndFunc
Func MilkingDebug()
Local $debugselogLocal = $g_iDebugSetlog
Local $MilkingExtractorsMatch
$g_iDebugSetlog = 1
Setlog("1 - Zoom out")
CheckZoomOut()
Local $TimeCheckMilkingAttack = TimerInit()
Setlog("2 - Detect Elixir Collectors")
Setlog("  2.1 Detect RedArea")
MilkingDetectRedArea()
$MilkFarmObjectivesSTR = ""
Setlog("  2.2bis detect elixir extractors2")
$MilkingExtractorsMatch = MilkingDetectElixirExtractors()
Setlog("  2.3 Detect Mine Extractors")
$MilkingExtractorsMatch += MilkingDetectMineExtractors()
Setlog("  2.4 Detect Dark Elixir Extractors")
Local $TimeCheckMilkingAttackSeconds = Round(TimerDiff($TimeCheckMilkingAttack) / 1000, 2)
Setlog("Computing Time Milking Attack : " & $TimeCheckMilkingAttackSeconds & " seconds", $COLOR_INFO)
$g_iDebugSetlog = $debugselogLocal
Setlog("Make DebugImage")
MilkFarmObjectivesDebugImage($MilkFarmObjectivesSTR, 0)
EndFunc
Func CheckMilkingBaseTest()
Local $MilkingElixirImages = _FileListToArray(@ScriptDir & "\images\Milking\Elixir", "*.*")
If @error = 1 Then
MsgBox(0, "", "Folder" & @ScriptDir & "\images\Milking\Elixir" & " not Found.")
EndIf
If @error = 4 Then
MsgBox(0, "", "No Files in folder " &@ScriptDir & "\images\Milking\Elixir" )
EndIf
Setlog("Locate Elixir..." )
_CaptureRegion2()
_CaptureRegion()
Local $ElixirVect = StringSplit(GetLocationElixirWithLevel(), "~", 2)
Local $elixirfounds = UBound($ElixirVect)
Local $elixirdiscard = 0
For $i = 0 To UBound($ElixirVect) - 1
Local $temp = StringSplit($ElixirVect[$i], "#", 2)
If UBound($temp) = 2 Then
Setlog("examine elixir vector #" & $i & " placed in " & $ElixirVect[$i],$COLOR_ERROR)
Local $pixelTemp = StringSplit($ElixirVect[$i],"-",2)
$pixelTemp[0] += 0
$pixelTemp[1] += 10
Local $arrPixelsCloser = _FindPixelCloser($PixelRedArea, $pixelTemp, 1)
Setlog("pixelcloser=" & $arrPixelsCloser & "ubound = " & Ubound($arrPixelsCloser))
For $t=0 to Ubound($arrPixelsCloser) -1
Local $temp = $arrPixelsCloser[$t]
Setlog("$arrPixelsCloser " & $arrPixelsCloser[$t] & " ubound = " & Ubound($temp) & " " & $temp[0] & "-" & $temp[1])
Next
If UBound($arrPixelsCloser) > 1 Then
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog(" - discard #1 no valid point", $COLOR_DEBUG)
$elixirdiscard += 1
EndIf
Setlog("............ next ..........")
Next
EndFunc
Func MilkingRedAreaPointsNearStructure($type, $level, $coordinate)
Local $ResourceToInsertQty = 0
Local $ResourceToInsert = ""
Local $pixelCoord = StringSplit($coordinate, "-", 2)
Local $diamondx = $MilkFarmOffsetX + $MilkFarmOffsetXStep * $g_iMilkFarmResMaxTilesFromBorder
Local $diamondy = $MilkFarmOffsetY + $MilkFarmOffsetYStep * $g_iMilkFarmResMaxTilesFromBorder
If UBound($pixelCoord) = 2 Then
Switch $type
Case "gomine"
Local $px = StringSplit($MilkFarmOffsetMine[$level], "-", 2)
Case "elixir"
Local $px = StringSplit($MilkFarmOffsetElixir[$level], "-", 2)
Case "ddrill"
Local $px = StringSplit($MilkFarmOffsetDark[$level], "-", 2)
Case Else
Local $px = StringSplit("0-0", "-", 2)
EndSwitch
$pixelCoord[0] += $px[0]
$pixelCoord[1] += $px[1]
Local $vector = $pixelTopLeft
For $i = 0 To UBound($vector) - 1
Local $pixelCoord2 = $vector[$i]
If UBound($pixelCoord2) = 2 Then
If Abs(($pixelCoord[0] - $pixelCoord2[0]) / $diamondx) + Abs(($pixelCoord[1] - $pixelCoord2[1]) / $diamondy) <= 1 Then
$ResourceToInsert &= "." & $pixelCoord2[0] & "-" & $pixelCoord2[1]
$ResourceToInsertQty += 1
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog("MilkingRedAreaPointsNearStructure Discard error #3", $COLOR_ERROR)
EndIf
Next
Local $vector = $pixelTopRight
For $i = 0 To UBound($vector) - 1
Local $pixelCoord2 = $vector[$i]
If UBound($pixelCoord2) = 2 Then
If Abs(($pixelCoord[0] - $pixelCoord2[0]) / $diamondx) + Abs(($pixelCoord[1] - $pixelCoord2[1]) / $diamondy) <= 1 Then
$ResourceToInsert &= "." & $pixelCoord2[0] & "-" & $pixelCoord2[1]
$ResourceToInsertQty += 1
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog("MilkingRedAreaPointsNearStructure Discard error #3", $COLOR_ERROR)
EndIf
Next
Local $vector = $pixelBottomLeft
For $i = 0 To UBound($vector) - 1
Local $pixelCoord2 = $vector[$i]
If UBound($pixelCoord2) = 2 Then
If Abs(($pixelCoord[0] - $pixelCoord2[0]) / $diamondx) + Abs(($pixelCoord[1] - $pixelCoord2[1]) / $diamondy) <= 1 Then
$ResourceToInsert &= "." & $pixelCoord2[0] & "-" & $pixelCoord2[1]
$ResourceToInsertQty += 1
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog("MilkingRedAreaPointsNearStructure Discard error #3", $COLOR_ERROR)
EndIf
Next
Local $vector = $pixelBottomRight
For $i = 0 To UBound($vector) - 1
Local $pixelCoord2 = $vector[$i]
If UBound($pixelCoord2) = 2 Then
If Abs(($pixelCoord[0] - $pixelCoord2[0]) / $diamondx) + Abs(($pixelCoord[1] - $pixelCoord2[1]) / $diamondy) <= 1 Then
$ResourceToInsert &= "." & $pixelCoord2[0] & "-" & $pixelCoord2[1]
$ResourceToInsertQty += 1
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog("MilkingRedAreaPointsNearStructure Discard error #3", $COLOR_ERROR)
EndIf
Next
If $g_iDebugSetlog=1 Then Setlog("$ResourceToInsertQty = " & $ResourceToInsertQty & " value " & $ResourceToInsert,$COLOR_DEBUG)
Return $ResourceToInsert
Else
If $g_iDebugSetlog = 1 Then Setlog("MilkingRedAreaPointsNearStructure Discard error #1 " & $pixelCoord & " " & UBound($pixelCoord), $COLOR_ERROR)
EndIf
EndFunc
Func CheckMilkingBase($matchDB, $dbBase)
Local $MilkingExtractorsMatch = 0
$MilkFarmObjectivesSTR = ""
$milkingAttackOutside = 0
If $matchDB And $g_aiAttackAlgorithm[$DB] = 2 Then
If(($g_iMilkAttackType=1 and $dbBase ) or($g_iMilkAttackType= 0 ) ) then
Local $TimeCheckMilkingAttack = TimerInit()
If $g_iDebugSetlog = 1 Then Setlog("Check Milking...", $COLOR_DEBUG)
MilkingDetectRedArea()
$MilkingExtractorsMatch = MilkingDetectElixirExtractors()
If $MilkingExtractorsMatch > 0 Then
$MilkingExtractorsMatch += MilkingDetectMineExtractors() + MilkingDetectDarkExtractors()
EndIf
If StringLen($MilkFarmObjectivesSTR) > 0 Then
If $g_iMilkAttackType = 1 Then
If $g_iDebugSetlog = 1 Then Setlog("Milking match LOW CPU SETTINGS", $COLOR_DEBUG)
If $g_iDebugSetlog = 1 Then Setlog("objectives: " & $MilkFarmObjectivesSTR , $COLOR_DEBUG)
Else
If $g_iDebugSetlog = 1 Then Setlog("Milking match HIGH CPU SETTINGS", $COLOR_DEBUG)
If $g_iDebugSetlog = 1 Then Setlog("objectives: " & $MilkFarmObjectivesSTR , $COLOR_DEBUG)
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog("Milking no match", $COLOR_DEBUG)
If $g_bMilkAttackAfterTHSnipeEnable and $g_bMilkFarmSnipeEvenIfNoExtractorsFound Then
If $g_iDebugSetlog = 1 Then Setlog("Milking no match but Snipe even if no structures detected... check...",$COLOR_DEBUG)
If $searchTH = "-" Then FindTownHall(True)
If $searchTH <>"-" Then
$milkingAttackOutside = 1
If SearchTownHallLoc() Then
If $g_iDebugSetlog = 1 Then Setlog("Milking Attack TH outside match!",$COLOR_DEBUG)
$milkingAttackOutside = 1
Else
If $g_iDebugSetlog = 1 Then Setlog("TH it is not outside, skip attack")
EndIf
$milkingAttackOutside = 0
Else
If $g_iDebugSetlog = 1 Then Setlog("Cannot detect Townhall, skip THsnipe")
EndIf
EndIf
EndIf
Local $TimeCheckMilkingAttackSeconds = Round(TimerDiff($TimeCheckMilkingAttack) / 1000, 2)
If $TimeCheckMilkingAttackSeconds >= 23 Then
Setlog("Computing Time Milking Attack too HIGH", $COLOR_ERROR)
Setlog("Your computer it is too slow to use this algorithm :(", $COLOR_ERROR)
Setlog("Please change algorithm", $COLOR_ERROR)
Else
Setlog("Computing Time Milking Attack : " & $TimeCheckMilkingAttackSeconds & " seconds", $COLOR_INFO)
EndIf
EndIf
EndIf
EndFunc
Func _FindPixelCloser($arrPixel, $pixel, $nb = 1)
If IsArray($arrPixel) = False Then Return
Local $arrPixelCloser[0]
For $j = 0 To $nb
Local $PixelCloser = $arrPixel[0]
For $i = 0 To UBound($arrPixel) - 1
Local $alreadyExist = False
Local $arrTemp = $arrPixel[$i]
Local $found = False
If($pixel[0] = -1) Then
If(Abs($arrTemp[1] - $pixel[1]) < Abs($PixelCloser[1] - $pixel[1])) Then
$found = True
EndIf
ElseIf($pixel[1] = -1) Then
If(Abs($arrTemp[0] - $pixel[0]) < Abs($PixelCloser[0] - $pixel[0])) Then
$found = True
EndIf
Else
If((Abs($arrTemp[0] - $pixel[0]) + Abs($arrTemp[1] - $pixel[1])) <(Abs($PixelCloser[0] - $pixel[0]) + Abs($PixelCloser[1] - $pixel[1]))) Then
$found = True
EndIf
EndIf
If($found) Then
For $k = 0 To UBound($arrPixelCloser) - 1
Local $arrTemp2 = $arrPixelCloser[$k]
If($arrTemp[0] = $arrTemp2[0] And $arrTemp[1] = $arrTemp2[1]) Then
$alreadyExist = True
ExitLoop
EndIf
Next
If($alreadyExist = False) Then
$PixelCloser = $arrTemp
EndIf
EndIf
Next
ReDim $arrPixelCloser[UBound($arrPixelCloser) + 1]
$arrPixelCloser[UBound($arrPixelCloser) - 1] = $PixelCloser
Next
Return $arrPixelCloser
EndFunc
Func _GetOffsetTroopFurther($pixel, $eVectorType, $offset)
debugRedArea("_GetOffsetTroopFurther IN")
Local $xMin, $xMax, $yMin, $yMax, $xStep, $yStep, $xOffset, $yOffset
Local $pixelOffset = GetOffestPixelRedArea2($pixel, $eVectorType, $offset)
If($eVectorType = $eVectorLeftTop) Then
$xMin = $InternalArea[0][0] + 2
$yMin = $InternalArea[0][1]
$xMax = $InternalArea[2][0]
$yMax = $InternalArea[2][1] + 2
$xStep = 4
$yStep = -3
$yOffset = -1 * $offset
$xOffset = Floor($yOffset)
ElseIf($eVectorType = $eVectorRightTop) Then
$xMin = $InternalArea[2][0]
$yMin = $InternalArea[2][1] + 2
$xMax = $InternalArea[1][0] - 2
$yMax = $InternalArea[1][1]
$xStep = 4
$yStep = 3
$yOffset = -1 * $offset
$xOffset = Floor($yOffset) * -1
ElseIf($eVectorType = $eVectorLeftBottom) Then
$xMin = $InternalArea[0][0] + 2
$yMin = $InternalArea[0][1]
$xMax = $InternalArea[3][0]
$yMax = $InternalArea[3][1] - 2
$xStep = 4
$yStep = 3
$yOffset = $offset
$xOffset = Floor($yOffset) * -1
Else
$xMin = $InternalArea[3][0]
$yMin = $InternalArea[3][1] - 2
$xMax = $InternalArea[1][0] - 2
$yMax = $InternalArea[1][1]
$xStep = 4
$yStep = -3
$yOffset = $offset
$xOffset = Floor($yOffset)
EndIf
Local $y = $yMin
Local $found = False
For $x = $xMin To $xMax Step $xStep
If($eVectorType = $eVectorRightBottom And $y > $yMax And $pixelOffset[0] > $x And $pixelOffset[1] > $y) Then
$pixelOffset[0] = $x + $xOffset
$pixelOffset[1] = $y + $yOffset
$found = True
ElseIf($eVectorType = $eVectorLeftBottom And $y < $yMax And $pixelOffset[0] < $x And $pixelOffset[1] > $y) Then
$pixelOffset[0] = $x + $xOffset
$pixelOffset[1] = $y + $yOffset
$found = True
ElseIf($eVectorType = $eVectorLeftTop And $y > $yMax And $pixelOffset[0] < $x And $pixelOffset[1] < $y) Then
$pixelOffset[0] = $x + $xOffset
$pixelOffset[1] = $y + $yOffset
$found = True
ElseIf($eVectorType = $eVectorRightTop And $y < $yMax And $pixelOffset[0] > $x And $pixelOffset[1] < $y) Then
$pixelOffset[0] = $x + $xOffset
$pixelOffset[1] = $y + $yOffset
$found = True
EndIf
$y += $yStep
If($found) Then ExitLoop
Next
If $pixelOffset[1] > 555 + $g_iBottomOffsetY Then
$pixelOffset[1] = 555 + $g_iBottomOffsetY
EndIf
debugRedArea("$pixelOffset x : [" & $pixelOffset[0] & "] / y : [" & $pixelOffset[1] & "]")
Return $pixelOffset
EndFunc
Func _GetVectorOutZone($eVectorType)
debugRedArea("_GetVectorOutZone IN")
Local $vectorOutZone[0]
Local $iSteps = 100
Local $xMin, $yMin, $xMax, $yMax
If($eVectorType = $eVectorLeftTop) Then
$xMin = $ExternalArea[0][0] + 2
$yMin = $ExternalArea[0][1]
$xMax = $ExternalArea[2][0]
$yMax = $ExternalArea[2][1] + 2
ElseIf($eVectorType = $eVectorRightTop) Then
$xMin = $ExternalArea[2][0]
$yMin = $ExternalArea[2][1] + 2
$xMax = $ExternalArea[1][0] - 2
$yMax = $ExternalArea[1][1]
ElseIf($eVectorType = $eVectorLeftBottom) Then
$xMin = $ExternalArea[0][0] + 2
$yMin = $ExternalArea[0][1]
$xMax = $ExternalArea[3][0]
$yMax = $ExternalArea[3][1] - 2
Else
$xMin = $ExternalArea[3][0]
$yMin = $ExternalArea[3][1] - 2
$xMax = $ExternalArea[1][0] - 2
$yMax = $ExternalArea[1][1]
EndIf
For $i = 0 To $iSteps
Local $pixel = [Round($xMin +(($xMax - $xMin) * $i) / $iSteps), Round($yMin +(($yMax - $yMin) * $i) / $iSteps)]
ReDim $vectorOutZone[UBound($vectorOutZone) + 1]
If $pixel[1] > 555 + $g_iBottomOffsetY Then
$pixel[1] = 555 + $g_iBottomOffsetY
EndIf
$vectorOutZone[UBound($vectorOutZone) - 1] = $pixel
Next
Return $vectorOutZone
EndFunc
Func debugRedArea($string)
If $g_iDebugRedArea = 1 Then
Local $hFile = FileOpen($g_sProfileLogsPath & "debugRedArea.log", $FO_APPEND)
_FileWriteLog($hFile, $string)
FileClose($hFile)
EndIf
EndFunc
Func DropOnPixel($troop, $listArrPixel, $number, $slotsPerEdge = 0)
If isProblemAffect(True) Then Return
If Not IsAttackPage() Then Return
Local $nameFunc = "[DropOnPixel]"
debugRedArea($nameFunc & " IN ")
debugRedArea("troop : [" & $troop & "] / size arrPixel [" & UBound($listArrPixel) & "] / number [" & $number & "]/ $slotsPerEdge [" & $slotsPerEdge & "] ")
If($number = 0 Or UBound($listArrPixel) = 0) Then Return
KeepClicks()
If $number = 1 Or $slotsPerEdge = 1 Then
For $i = 0 To UBound($listArrPixel) - 1
debugRedArea("$listArrPixel $i : [" & $i & "] ")
Local $arrPixel = $listArrPixel[$i]
debugRedArea("$arrPixel $UBound($arrPixel) : [" & UBound($arrPixel) & "] ")
If UBound($arrPixel) > 0 Then
Local $pixel = $arrPixel[0]
If $i = Int(UBound($arrPixel) / 2) And $isHeroesDropped = False Then
$DeployHeroesPosition[0] = $pixel[0]
$DeployHeroesPosition[1] = $pixel[1]
debugRedArea("Heroes : $slotsPerEdge = 1 ")
EndIf
If $i = Int(UBound($arrPixel) / 2) And $isCCDropped = False Then
$DeployCCPosition[0] = $pixel[0]
$DeployCCPosition[1] = $pixel[1]
debugRedArea("CC : $slotsPerEdge = 1 ")
EndIf
AttackClick($pixel[0], $pixel[1], $number, $iDelayDropOnPixel2, $iDelayDropOnPixel1, "#0096")
EndIf
Next
ElseIf $slotsPerEdge = 2 Then
For $i = 0 To UBound($listArrPixel) - 1
Local $arrPixel = $listArrPixel[$i]
If UBound($arrPixel) > 0 Then
Local $pixel = $arrPixel[0]
If $i = Int(UBound($arrPixel) / 2) And $isHeroesDropped = False Then
$DeployHeroesPosition[0] = $pixel[0]
$DeployHeroesPosition[1] = $pixel[1]
debugRedArea("Heroes : $slotsPerEdge = 2 ")
EndIf
If $i = Int(UBound($arrPixel) / 2) And $isCCDropped = False Then
$DeployCCPosition[0] = $pixel[0]
$DeployCCPosition[1] = $pixel[1]
debugRedArea("CC : $slotsPerEdge = 2 ")
EndIf
AttackClick($pixel[0], $pixel[1], $number, SetSleep(0), SetSleep(1), "#0097")
EndIf
Next
Else
For $i = 0 To UBound($listArrPixel) - 1
debugRedArea("$listArrPixel $i : [" & $i & "] ")
Local $nbTroopsLeft = $number
Local $offset = 1
Local $nbTroopByPixel = 1
Local $arrPixel = $listArrPixel[$i]
debugRedArea("UBound($arrPixel) " & UBound($arrPixel) & "$number :" & $number)
While($nbTroopsLeft > 0)
If(UBound($arrPixel) = 0) Then
ExitLoop
EndIf
If(UBound($arrPixel) > $nbTroopsLeft) Then
$offset = UBound($arrPixel) / $nbTroopsLeft
Else
$nbTroopByPixel = Floor($number / UBound($arrPixel))
EndIf
If($offset < 1) Then
$offset = 1
EndIf
If($nbTroopByPixel < 1) Then
$nbTroopByPixel = 1
EndIf
For $j = 0 To UBound($arrPixel) - 1 Step $offset
Local $index = Round($j)
If($index > UBound($arrPixel) - 1) Then
$index = UBound($arrPixel) - 1
EndIf
Local $currentPixel = $arrPixel[Floor($index)]
If $j >= Round(UBound($arrPixel) / 2) And $j <= Round((UBound($arrPixel) / 2) + $offset) And $isHeroesDropped = False Then
$DeployHeroesPosition[0] = $currentPixel[0]
$DeployHeroesPosition[1] = $currentPixel[1]
debugRedArea("Heroes : $slotsPerEdge = else ")
debugRedArea("$offset: " & $offset)
EndIf
If $j >= Round(UBound($arrPixel) / 2) And $j <= Round((UBound($arrPixel) / 2) + $offset) And $isCCDropped = False Then
$DeployCCPosition[0] = $currentPixel[0]
$DeployCCPosition[1] = $currentPixel[1]
debugRedArea("CC : $slotsPerEdge = else ")
debugRedArea("$offset: " & $offset)
EndIf
If Number($currentPixel[1]) > 555 + $g_iBottomOffsetY then $currentPixel[1] = 555 + $g_iBottomOffsetY
AttackClick($currentPixel[0], $currentPixel[1], $nbTroopByPixel, SetSleep(0), 0, "#0098")
$nbTroopsLeft -= $nbTroopByPixel
Next
WEnd
Next
EndIf
ReleaseClicks()
debugRedArea($nameFunc & " OUT ")
EndFunc
Func GetOffestPixelRedArea2($pixel, $eVectorType, $offset = 3)
Local $pixelOffest = $pixel
If($eVectorType = $eVectorLeftTop) Then
$pixelOffest[0] = Round($pixel[0] - $offset * 4 / 3)
$pixelOffest[1] = $pixel[1] - $offset
ElseIf($eVectorType = $eVectorRightBottom) Then
$pixelOffest[0] = Round($pixel[0] + $offset * 4 / 3)
$pixelOffest[1] = $pixel[1] + $offset
ElseIf($eVectorType = $eVectorLeftBottom) Then
$pixelOffest[0] = Round($pixel[0] - $offset * 4 / 3)
$pixelOffest[1] = $pixel[1] + $offset
ElseIf($eVectorType = $eVectorRightTop) Then
$pixelOffest[0] = Round($pixel[0] + $offset * 4 / 3)
$pixelOffest[1] = $pixel[1] - $offset
EndIf
If $pixelOffest[1] > 555 + $g_iBottomOffsetY Then
$pixelOffest[1] = 555 + $g_iBottomOffsetY
EndIf
Return $pixelOffest
EndFunc
Func GetPixelDropTroop($troop, $number, $slotsPerEdge)
Local $newPixelTopLeft
Local $newPixelBottomLeft
Local $newPixelTopRight
Local $newPixelBottomRight
If($troop = $eArch Or $troop = $eWiza Or $troop = $eMini Or $troop = $eBarb) Then
if Ubound($PixelTopLeftFurther) >0 then
$newPixelTopLeft = $PixelTopLeftFurther
Else
$newPixelTopLeft = $PixelTopLeft
EndIf
If Ubound($PixelBottomLeftFurther) >0 Then
$newPixelBottomLeft = $PixelBottomLeftFurther
Else
$newPixelBottomLeft = $PixelBottomLeft
EndIf
If Ubound( $PixelTopRightFurther) >0 Then
$newPixelTopRight = $PixelTopRightFurther
Else
$newPixelTopRight = $PixelTopRight
EndIf
If Ubound( $PixelBottomRightFurther) then
$newPixelBottomRight = $PixelBottomRightFurther
Else
$newPixelBottomRight = $PixelBottomRight
EndIf
Else
$newPixelTopLeft = $PixelTopLeft
$newPixelBottomLeft = $PixelBottomLeft
$newPixelTopRight = $PixelTopRight
$newPixelBottomRight = $PixelBottomRight
EndIf
If($slotsPerEdge = 1) Then
$newPixelTopLeft = GetVectorPixelAverage($newPixelTopLeft, 0)
$newPixelBottomLeft = GetVectorPixelAverage($newPixelBottomLeft, 1)
$newPixelTopRight = GetVectorPixelAverage($newPixelTopRight, 1)
$newPixelBottomRight = GetVectorPixelAverage($newPixelBottomRight, 0)
ElseIf($slotsPerEdge = 2) Then
$newPixelTopLeft = GetVectorPixelOnEachSide($newPixelTopLeft, 0)
$newPixelBottomLeft = GetVectorPixelOnEachSide($newPixelBottomLeft, 1)
$newPixelTopRight = GetVectorPixelOnEachSide($newPixelTopRight, 1)
$newPixelBottomRight = GetVectorPixelOnEachSide($newPixelBottomRight, 0)
Else
debugRedArea("GetPixelDropTroop :  $slotsPerEdge [" & $slotsPerEdge & "] ")
$newPixelTopLeft = GetVectorPixelToDeploy($newPixelTopLeft, 0, $slotsPerEdge)
$newPixelBottomLeft = GetVectorPixelToDeploy($newPixelBottomLeft, 1, $slotsPerEdge)
$newPixelTopRight = GetVectorPixelToDeploy($newPixelTopRight, 1, $slotsPerEdge)
$newPixelBottomRight = GetVectorPixelToDeploy($newPixelBottomRight, 0, $slotsPerEdge)
EndIf
Local $edgesPixelToDrop[4] = [$newPixelBottomRight, $newPixelTopLeft, $newPixelBottomLeft, $newPixelTopRight]
Return $edgesPixelToDrop
EndFunc
Func GetPixelSide($listPixel, $index)
If $g_iDebugSetlog = 1 Then SetDebugLog("GetPixelSide " & $index & " = " & StringReplace($listPixel[$index], "-", ","))
Return GetListPixel($listPixel[$index])
EndFunc
Func GetVectorPixelAverage($arrPixel, $vectorDirection)
Local $vectorPixelAverage[1]
debugRedArea("GetVectorPixelAverage IN $vectorDirection [" & $vectorDirection & "]")
If(UBound($arrPixel) > 1) Then
Local $pixelSearch[2] = [-1, -1]
Local $minPixel = $arrPixel[0]
Local $maxPixel = $arrPixel[UBound($arrPixel) - 1]
Local $min = $minPixel[$vectorDirection]
Local $max = $maxPixel[$vectorDirection]
Local $posAverage =($max - $min) / 2
debugRedArea("GetVectorPixelAverage IN $min [" & $min & "]")
debugRedArea("GetVectorPixelAverage IN $max [" & $max & "]")
$pixelSearch[$vectorDirection] = $min + $posAverage
debugRedArea("GetVectorPixelAverage $pixelSearch x : [" & $pixelSearch[0] & "] / y [" & $pixelSearch[1] & "] ")
Local $arrPixelCloser = _FindPixelCloser($arrPixel, $pixelSearch, 1)
Local $arrTemp = $arrPixelCloser[0]
debugRedArea("GetVectorPixelAverage $arrTemp x : [" & $arrTemp[0] & "] / y [" & $arrTemp[1] & "] ")
$vectorPixelAverage[0] = $arrPixelCloser[0]
EndIf
Return $vectorPixelAverage
EndFunc
Func GetVectorPixelOnEachSide($arrPixel, $vectorDirection)
Local $vectorPixelEachSide[2]
If(UBound($arrPixel) > 1) Then
Local $pixelSearch[2] = [-1, -1]
Local $minPixel = $arrPixel[0]
Local $maxPixel = $arrPixel[UBound($arrPixel) - 1]
Local $min = $minPixel[$vectorDirection]
Local $max = $maxPixel[$vectorDirection]
Local $posSide =($max - $min) / 4
$pixelSearch[$vectorDirection] = $min + $posSide
Local $arrPixelCloser = _FindPixelCloser($arrPixel, $pixelSearch, 1)
$vectorPixelEachSide[0] = $arrPixelCloser[0]
$pixelSearch[$vectorDirection] = $min + $posSide * 3
Local $arrPixelCloser = _FindPixelCloser($arrPixel, $pixelSearch, 1)
$vectorPixelEachSide[1] = $arrPixelCloser[0]
EndIf
Return $vectorPixelEachSide
EndFunc
Func GetVectorPixelToDeploy($arrPixel, $vectorDirection , $sizeVector)
Local $vectorPixel[0]
debugRedArea("GetVectorPixelToDeploy IN")
debugRedArea("size " & UBound($arrPixel))
If(UBound($arrPixel) > 1) Then
Local $pixelSearch[2] = [-1, -1]
Local $minPixel = $arrPixel[0]
Local $maxPixel = $arrPixel[UBound($arrPixel) - 1]
Local $min = $minPixel[$vectorDirection]
Local $max = $maxPixel[$vectorDirection]
Local $offset =($max - $min) / $sizeVector
debugRedArea("min : [" & $min & "] / max [" & $max & "] / offset [" & $offset & "]")
If($min <= $max And $offset <= 0) Then
$offset = 1
ElseIf($min >= $max And $offset >= 0) Then
$offset = -1
EndIf
For $i = $min To $max Step $offset
$pixelSearch[$vectorDirection] = $i
Local $arrPixelCloser = _FindPixelCloser($arrPixel, $pixelSearch, 1)
ReDim $vectorPixel[UBound($vectorPixel) + 1]
$vectorPixel[UBound($vectorPixel) - 1] = $arrPixelCloser[0]
Next
EndIf
Return $vectorPixel
EndFunc
Func dropCC($x, $y, $slot)
Local $test1 = false
Local $test2 = false
If $g_iMatchMode = $MA and $g_abAttackDropCC[$DB] then $test1= True
if $g_iMatchMode <>$MA Then
If($g_iMatchMode <> $DB And $g_iMatchMode <> $LB and $g_iMatchMode <> $MA) Or $g_abAttackDropCC[$g_iMatchMode] Then $test2 = True
EndIf
If $slot <> -1 and($test1 or $test2 ) Then
If $iPlannedDropCCHoursEnable = 1 Then
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If $iPlannedDropCCHours[$hour[0]] = 0 Then
SetLog("Drop CC not Planned, Skipped..", $COLOR_SUCCESS)
Return
EndIf
EndIf
If $iChkUseCCBalanced = 1 Then
If Number($TroopsReceived) <> 0 Then
If Number(Number($TroopsDonated) / Number($TroopsReceived)) >=(Number($iCmbCCDonated) / Number($iCmbCCReceived)) Then
SetLog("Dropping Clan Castle, donated (" & $TroopsDonated & ") / received (" & $TroopsReceived & ") >= " & $iCmbCCDonated & "/" & $iCmbCCReceived, $COLOR_INFO)
Click(GetXPosOfArmySlot($slot, 68), 595 + $g_iBottomOffsetY, 1, $iDelaydropCC2, "#0086")
If _Sleep($iDelaydropCC1) Then Return
Click($x, $y, 1, 0, "#0087")
Else
SetLog("No Dropping Clan Castle, donated  (" & $TroopsDonated & ") / received (" & $TroopsReceived & ") < " & $iCmbCCDonated & "/" & $iCmbCCReceived, $COLOR_INFO)
EndIf
Else
If Number(Number($TroopsDonated) / 1) >=(Number($iCmbCCDonated) / Number($iCmbCCReceived)) Then
SetLog("Dropping Clan Castle, donated (" & $TroopsDonated & ") / received (" & $TroopsReceived & ") >= " & $iCmbCCDonated & "/" & $iCmbCCReceived, $COLOR_INFO)
Click(GetXPosOfArmySlot($slot, 68), 595 + $g_iBottomOffsetY, 1, $iDelaydropCC2, "#0088")
If _Sleep($iDelaydropCC1) Then Return
Click($x, $y, 1, 0, "#0089")
Else
SetLog("No Dropping Clan Castle, donated  (" & $TroopsDonated & ") / received (" & $TroopsReceived & ") < " & $iCmbCCDonated & "/" & $iCmbCCReceived, $COLOR_INFO)
EndIf
EndIf
Else
SetLog("Dropping Clan Castle", $COLOR_INFO)
Click(GetXPosOfArmySlot($slot, 68), 595 + $g_iBottomOffsetY, 1, $iDelaydropCC2, "#0090")
If _Sleep($iDelaydropCC1) Then Return
Click($x, $y, 1, 0, "#0091")
EndIf
EndIf
EndFunc
Func dropHeroes($x, $y, $KingSlot = -1, $QueenSlot = -1, $WardenSlot = -1)
If $g_iDebugSetlog = 1 Then SetLog("dropHeroes KingSlot " & $KingSlot & " QueenSlot " & $QueenSlot & " WardenSlot " & $WardenSlot & " matchmode " & $g_iMatchMode, $COLOR_DEBUG)
If _Sleep($iDelaydropHeroes1) Then Return
$dropKing = False
$dropQueen = False
$dropWarden = False
Local $MatchMode
If $g_iMatchMode = $TS and $duringMilkingAttack = 1 Then
$MatchMode = $DB
Else
$MatchMode = $g_iMatchMode
EndIf
If $KingSlot <> -1 And(($MatchMode <> $DB And $MatchMode <> $LB) Or BitAND($g_aiAttackUseHeroes[$MatchMode], $eHeroKing) = $eHeroKing) Then $dropKing = True
If $QueenSlot <> -1 And(($MatchMode <> $DB And $MatchMode <> $LB) Or BitAND($g_aiAttackUseHeroes[$MatchMode], $eHeroQueen) = $eHeroQueen) Then $dropQueen = True
If $WardenSlot <> -1 And(($MatchMode <> $DB And $MatchMode <> $LB) Or BitAND($g_aiAttackUseHeroes[$MatchMode], $eHeroWarden) = $eHeroWarden) Then $dropWarden = True
If $g_iDebugSetlog = 1 Then SetLog("drop KING = " & $dropKing, $COLOR_DEBUG)
If $g_iDebugSetlog = 1 Then SetLog("drop QUEEN = " & $dropQueen, $COLOR_DEBUG)
If $g_iDebugSetlog = 1 Then SetLog("drop WARDEN = " & $dropWarden, $COLOR_DEBUG)
If $dropKing Then
SetLog("Dropping King", $COLOR_INFO)
Click(GetXPosOfArmySlot($KingSlot, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0092")
If _Sleep($iDelaydropHeroes2) Then Return
Click($x, $y, 1, 0, "#0093")
$checkKPower = True
EndIf
If _Sleep($iDelaydropHeroes1) Then Return
If $dropQueen Then
SetLog("Dropping Queen", $COLOR_INFO)
Click(GetXPosOfArmySlot($QueenSlot, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0094")
If _Sleep($iDelaydropHeroes2) Then Return
Click($x, $y, 1, 0, "#0095")
$checkQPower = True
EndIf
If _Sleep($iDelaydropHeroes1) Then Return
If $dropWarden Then
SetLog("Dropping Grand Warden", $COLOR_INFO)
Click(GetXPosOfArmySlot($WardenSlot, 68), 595 + $g_iBottomOffsetY, 1, 0, "#X998")
If _Sleep($iDelaydropHeroes2) Then Return
Click($x, $y, 1, 0, "#x999")
$checkWPower = True
EndIf
EndFunc
Func GetSlotIndexFromXPos($xPos)
For $slot = 0 To 11
If $xPos < 68 +($slot * 72) Then
Return $slot
EndIf
Next
EndFunc
Func NameOfTroop($iKind, $iPlural = 0)
Local $sTroopname
Switch $iKind
Case $eBarb
$sTroopname = "Barbarian"
Case $eArch
$sTroopname = "Archer"
Case $eGobl
$sTroopname = "Goblin"
Case $eGiant
$sTroopname = "Giant"
Case $eWall
$sTroopname = "Wall Breaker"
Case $eWiza
$sTroopname = "Wizard"
Case $eBall
$sTroopname = "Balloon"
Case $eHeal
$sTroopname = "Healer"
Case $eDrag
$sTroopname = "Dragon"
Case $ePekk
$sTroopname = "Pekka"
Case $eBabyD
$sTroopname = "Baby Dragon"
Case $eMine
$sTroopname = "Miner"
Case $eMini
$sTroopname = "Minion"
Case $eHogs
$sTroopname = "Hog Rider"
Case $eValk
$sTroopname = "Valkyrie"
Case $eWitc
$sTroopname = "Witch"
Case $eGole
$sTroopname = "Golem"
Case $eLava
$sTroopname = "Lava Hound"
Case $eBowl
$sTroopname = "Bowler"
Case $eKing
$sTroopname = "King"
$iPlural = 0
Case $eQueen
$sTroopname = "Queen"
$iPlural = 0
Case $eWarden
$sTroopname = "Grand Warden"
$iPlural = 0
Case $eCastle
$sTroopname = "Clan Castle"
$iPlural = 0
Case $eLSpell
$sTroopname = "Lightning Spell"
Case $eHSpell
$sTroopname = "Heal Spell"
Case $eRSpell
$sTroopname = "Rage Spell"
Case $eJSpell
$sTroopname = "Jump Spell"
Case $eFSpell
$sTroopname = "Freeze Spell"
Case $eCSpell
$sTroopname = "Clone Spell"
Case $ePSpell
$sTroopname = "Poison Spell"
Case $eESpell
$sTroopname = "Earthquake Spell"
Case $eHaSpell
$sTroopname = "Haste Spell"
Case $eSkSpell
$sTroopname = "Skeleton Spell"
Case Else
Return ""
EndSwitch
If $iPlural = 1 And $iKind = $eWitc Then $sTroopname &= "e"
If $iPlural = 1 Then $sTroopname &= "s"
Return $sTroopname
EndFunc
Func OldDropTroop($troop, $position, $nbperspot)
SelectDropTroop($troop)
If _Sleep($iDelayOldDropTroop1) Then Return
For $i = 0 To 4
Click($position[$i][0], $position[$i][1], $nbperspot, 1, "#0110")
If _Sleep($iDelayOldDropTroop2) Then Return
Next
EndFunc
Func SelectDropTroop($Troop)
If IsAttackPage() Then Click(GetXPosOfArmySlot($Troop, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0111")
EndFunc
Func SetSleep($type)
If IsKeepClicksActive() = True Then Return 0
Local $factor0 = 10
Local $factor1 = 100
If $g_bAndroidAdbClick = True Then
$factor0 = 10
$factor1 = 100
EndIf
Switch $type
Case 0
If $g_abAttackStdRandomizeDelay[$g_iMatchMode] Then
Return Round(Random(1, 10)) * $factor0
Else
Return($g_aiAttackStdUnitDelay[$g_iMatchMode] + 1) * $factor0
EndIf
Case 1
If $g_abAttackStdRandomizeDelay[$g_iMatchMode] Then
Return Round(Random(1, 10)) * $factor1
Else
Return($g_aiAttackStdWaveDelay[$g_iMatchMode] + 1) * $factor1
EndIf
EndSwitch
EndFunc
Func _SleepAttack($iDelay, $iSleep = True)
If $g_bRunState = False Then
ResumeAndroid()
Return True
EndIf
If IsKeepClicksActive() = True Then Return False
Return _Sleep($iDelay, $iSleep)
EndFunc
Func drillSearch()
Local $aReturnResult[0][4]
Local $pixelerror = 15
Local $directory = @ScriptDir & "\imgxml\Storages\Drills"
Local $Maxpositions = 0
Local $aResult = multiMatches($directory, $Maxpositions, "ECD", "ECD")
For $iResult = 1 To UBound($aResult) - 1
If _Sleep(10) Then Return
Local $aTemp[0][2]
_ArrayAdd($aTemp, $aResult[$iResult][5])
_ArrayColInsert($aTemp, 2)
_ArrayColInsert($aTemp, 3)
For $iRow = 0 To UBound($aTemp) - 1
$aTemp[$iRow][2] = $aResult[$iResult][2]
Next
_ArrayAdd($aReturnResult, $aTemp)
Next
Local $iResult = 0
While $iResult < Ubound($aReturnResult)
If _Sleep(10) Then Return
Local $jResult = $iResult + 1
While $jResult < Ubound($aReturnResult)
If Abs($aReturnResult[$iResult][0] - $aReturnResult[$jResult][0]) <= $pixelerror And Abs($aReturnResult[$iResult][1] - $aReturnResult[$jResult][1]) <= $pixelerror Then
$aReturnResult[$iResult][2] = _Min(Number($aReturnResult[$iResult][2]), Number($aReturnResult[$jResult][2]))
If $DebugSmartZap = 1 Then
SetLog("Found Duplicate Dark Elixir Drill: [" & $aReturnResult[$jResult][0] & "," & $aReturnResult[$jResult][1] & "], Level: " & $aReturnResult[$jResult][2], $COLOR_DEBUG)
EndIf
_ArrayDelete($aReturnResult, $jResult)
EndIf
$jResult += 1
WEnd
Local $iDrillLevel = CheckDrillLvl($aReturnResult[$iResult][0], $aReturnResult[$iResult][1])
If $iDrillLevel > 0 And $aReturnResult[$iResult][2] <> $iDrillLevel Then
If $DebugSmartZap = 1 Then SetLog("Correcting Drill Level, old = " & $aReturnResult[$iResult][2] & ", new = " & $iDrillLevel, $COLOR_DEBUG)
$aReturnResult[$iResult][2] = $iDrillLevel
EndIf
$aReturnResult[$iResult][3] = Ceiling(Number($g_aDrillLevelTotal[$aReturnResult[$iResult][2] - 1] * $g_fDarkStealFactor))
If $DebugSmartZap = 1 Then
SetLog(($iResult + 1) & ". Valid Drill: [" & $aReturnResult[$iResult][0] & "," & $aReturnResult[$iResult][1] & "], Level: " & $aReturnResult[$iResult][2] & ", Hold: " & $aReturnResult[$iResult][3], $COLOR_DEBUG)
EndIf
$iResult += 1
WEnd
Return $aReturnResult
EndFunc
Func CheckDrillLvl($x, $y)
_CaptureRegion2($x - 25, $y - 25, $x + 25, $y + 25)
Local $directory = @ScriptDir & "\imgxml\Storages\Drills\Level"
Local $Maxpositions = 1
Local $aResult = multiMatches($directory, $Maxpositions, "FV", "FV", "", 0, 1000, False)
If $DebugSmartZap = 1 Then SetLog("CheckDrillLvl: UBound($aresult) = " & UBound($aResult), $COLOR_DEBUG)
If UBound($aResult) > 1 Then
If $DebugSmartZap = 1 Then SetLog("CheckDrillLvl: $aresult[" &(UBound($aResult) - 1) & "][2] = " & $aResult[UBound($aResult) - 1][2], $COLOR_DEBUG)
Return $aResult[UBound($aResult) - 1][2]
EndIf
Return 0
EndFunc
Func getDrillCluster(Const ByRef $aDarkDrills)
Local $iMaxMedianDist = 26
Local $aBestCluster[4] = [0, 0, 0, -1]
If UBound($aDarkDrills) < 2 Then Return -1
If UBound($aDarkDrills) > 2 Then
Local $iMedianX = Ceiling(Number(($aDarkDrills[0][0] + $aDarkDrills[1][0] + $aDarkDrills[2][0])/3))
Local $iMedianY = Ceiling(Number(($aDarkDrills[0][1] + $aDarkDrills[1][1] + $aDarkDrills[2][1])/3))
If $DebugSmartZap = 1 Then SetLog("TripleDrill Unweighted Median Point: x = " & $iMedianX & ", y = " & $iMedianY, $COLOR_DEBUG)
For $i = 0 To 2
If Abs($aDarkDrills[$i][0] - $iMedianX) > $iMaxMedianDist Or Abs($aDarkDrills[$i][1] - $iMedianY) > $iMaxMedianDist Then
$aBestCluster[3] = -1
ExitLoop
Else
Local $aTemp[3] = [0, 1, 2]
$aBestCluster[3] = $aTemp
EndIf
Next
If $DebugSmartZap = 1 And $aBestCluster[3] <> -1 Then SetLog("TripleDrill Cluster found." & $aBestCluster[3], $COLOR_DEBUG)
EndIf
If $aBestCluster[3] = -1 Then
Local $iMaxHold = 0
For $i = 0 To UBound($aDarkDrills) - 1
Local $iMedianX = Ceiling(Number(($aDarkDrills[$i][0] + $aDarkDrills[Mod($i + 1, UBound($aDarkDrills))][0])/2))
Local $iMedianY = Ceiling(Number(($aDarkDrills[$i][1] + $aDarkDrills[Mod($i + 1, UBound($aDarkDrills))][1])/2))
If $DebugSmartZap = 1 Then SetLog("[" & $i & "," & Mod($i + 1, UBound($aDarkDrills)) & "] DoubleDrill Unweighted Median Point: x = " & $iMedianX & ", y = " & $iMedianY, $COLOR_DEBUG)
If $aDarkDrills[$i][3] + $aDarkDrills[Mod($i + 1, UBound($aDarkDrills))][3] > $iMaxHold Then
If Abs($aDarkDrills[$i][0] - $iMedianX) <= $iMaxMedianDist And Abs($aDarkDrills[$i][1] - $iMedianY) <= $iMaxMedianDist And Abs($aDarkDrills[Mod($i + 1, UBound($aDarkDrills))][0] - $iMedianX) <= $iMaxMedianDist And Abs($aDarkDrills[Mod($i + 1, UBound($aDarkDrills))][1] - $iMedianY) <= $iMaxMedianDist Then
$iMaxHold = $aDarkDrills[$i][3] + $aDarkDrills[Mod($i + 1, UBound($aDarkDrills))][3]
Local $aTemp[2] = [$i, Mod($i + 1, UBound($aDarkDrills))]
$aBestCluster[3] = $aTemp
EndIf
EndIf
Next
If $DebugSmartZap = 1 And $aBestCluster[3] <> -1 Then SetLog("DoubleDrill Cluster found: [" &($aBestCluster[3])[0] & "," &($aBestCluster[3])[1] & "]", $COLOR_DEBUG)
EndIf
If $aBestCluster[3] = -1 Then
Return -1
Else
Local $iWeightedMedianX = 0
Local $iWeightedMedianY = 0
Local $iWeightedMedianDiv = 0
Local $iTotalHold = 0
For $i = 0 To UBound($aBestCluster[3]) - 1
$iWeightedMedianX += $aDarkDrills[($aBestCluster[3])[$i]][0] * $g_aDrillLevelHP[$aDarkDrills[($aBestCluster[3])[$i]][2] - 1]
$iWeightedMedianY += $aDarkDrills[($aBestCluster[3])[$i]][1] * $g_aDrillLevelHP[$aDarkDrills[($aBestCluster[3])[$i]][2] - 1]
$iWeightedMedianDiv += $g_aDrillLevelHP[$aDarkDrills[($aBestCluster[3])[$i]][2] - 1]
$iTotalHold += $aDarkDrills[($aBestCluster[3])[$i]][3]
Next
$aBestCluster[0] = Ceiling(Number($iWeightedMedianX / $iWeightedMedianDiv))
$aBestCluster[1] = Ceiling(Number($iWeightedMedianY / $iWeightedMedianDiv))
$aBestCluster[2] = $iTotalHold
If $DebugSmartZap = 1 Then SetLog("Best Cluster: weighted x = " & $aBestCluster[0] & ", weighted y = " & $aBestCluster[1] & ", hold = " & $aBestCluster[2], $COLOR_DEBUG)
Return $aBestCluster
EndIf
EndFunc
Func CheckOverviewFullArmy($bOpenArmyWindow = False, $bCloseArmyWindow = False)
If $bOpenArmyWindow = True Then
ClickP($aAway, 1, 0, "#0346")
If _Sleep($iDelayCheckFullArmy1) Then Return
If $iUseRandomClick = 0 then
Click($aArmyTrainButton[0], $aArmyTrainButton[1], 1, 0, "#0347")
Else
ClickR($aArmyTrainButtonRND, $aArmyTrainButton[0], $aArmyTrainButton[1], 1, 0)
EndIF
If _Sleep($iDelayCheckFullArmy2) Then Return
Local $j = 0
While Not _ColorCheck(_GetPixelColor($btnpos[0][0], $btnpos[0][1], True), Hex(0xE8E8E0, 6), 20)
If $g_iDebugSetlogTrain = 1 Then Setlog("OverView TabColor=" & _GetPixelColor($btnpos[0][0], $btnpos[0][1], True), $COLOR_DEBUG)
If _Sleep($iDelayCheckFullArmy1) Then Return
$j += 1
If $j > 15 Then ExitLoop
WEnd
If $j > 15 Then
SetLog("Training Overview Window didn't open", $COLOR_ERROR)
Return
EndIf
EndIf
If _sleep($iDelayCheckFullArmy2) Then Return
Local $Pixel = _CheckPixel($aIsCampFull, True) And _ColorCheck(_GetPixelColor(128, 176, True), Hex(0x90C030, 6), 20)
If Not $Pixel Then
If _sleep($iDelayCheckFullArmy2) Then Return
$Pixel = _CheckPixel($aIsCampFull, True) And _ColorCheck(_GetPixelColor(128, 176, True), Hex(0x90C030, 6), 20)
EndIf
If $g_iDebugSetlogTrain = 1 Then Setlog("Checking Overview for full army [!] " & $Pixel & ", " & _GetPixelColor(128, 176, True), $COLOR_DEBUG)
If $Pixel Then
$fullArmy = True
EndIf
$canRequestCC = _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1], True), Hex($aRequestTroopsAO[2], 6), $aRequestTroopsAO[5])
If $g_iDebugSetlog = 1 Then Setlog("Can Request CC: " & $canRequestCC, $COLOR_DEBUG)
If $bCloseArmyWindow = True Then
ClickP($aAway, 1, 0, "#0348")
If _Sleep($iDelayCheckFullArmy3) Then Return
EndIf
EndFunc
Func CheckFullBarrack()
If _sleep(200) Then Return
Local $Pixel = _CheckPixel($aBarrackFull, True)
If $g_iDebugSetlogTrain = 1 Then Setlog("Check Barrack Full color : " & _GetPixelColor($aBarrackFull[0], $aBarrackFull[1], True) & " Expected if Full : " & Hex($aBarrackFull[2], 6), $COLOR_DEBUG)
If $g_iDebugSetlogTrain = 1 Then Setlog("Checking for Full Normal or Dark Barrack [!]" & $Pixel, $COLOR_DEBUG)
If $Pixel Then
Return True
Else
Return False
EndIf
EndFunc
Func checkArmyCamp($bOpenArmyWindow = False, $bCloseArmyWindow = False, $bGetHeroesTime = False)
If $g_iDebugSetlogTrain = 1 Then SETLOG("Begin checkArmyCamp:", $COLOR_DEBUG1)
If $bOpenArmyWindow = False And IsTrainPage() = False Then
SetError(1)
Return
ElseIf $bOpenArmyWindow = True Then
If openArmyOverview() = False Then
SetError(2)
Return
EndIf
If _Sleep($iDelaycheckArmyCamp5) Then Return
EndIf
GetArmyCapacity()
If _Sleep($iDelaycheckArmyCamp6) Then Return
If ISArmyWindow(False, $ArmyTAB) then CheckExistentArmy("Troops")
If _Sleep($iDelaycheckArmyCamp6) Then Return
getArmyTroopTime()
If _Sleep($iDelaycheckArmyCamp6) Then Return
Local $HeroesRegenTime
getArmyHeroCount()
If _Sleep($iDelaycheckArmyCamp6) Then Return
If $bGetHeroesTime = True Then $HeroesRegenTime = getArmyHeroTime("all")
If _Sleep($iDelaycheckArmyCamp6) Then Return
getArmySpellCapacity()
If _Sleep($iDelaycheckArmyCamp6) Then Return
If ISArmyWindow(False, $ArmyTAB) then CheckExistentArmy("Spells")
If _Sleep($iDelaycheckArmyCamp6) Then Return
getArmySpellTime()
If _Sleep($iDelaycheckArmyCamp6) Then Return
getArmyCCStatus()
If _Sleep($iDelaycheckArmyCamp6) Then Return
If Not $fullArmy Then DeleteExcessTroops()
If $bCloseArmyWindow = True Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($iDelaycheckArmyCamp4) Then Return
EndIf
If $g_iDebugSetlogTrain = 1 Then SETLOG("End checkArmyCamp: canRequestCC= " & $canRequestCC & ", fullArmy= " & $fullArmy, $COLOR_DEBUG)
Return $HeroesRegenTime
EndFunc
Func IsTroopToDonateOnly($pTroopType)
If $g_abAttackTypeEnable[$DB] Then
Local $tempArr = $troopsToBeUsed[$g_aiAttackTroopSelection[$DB]]
For $x = 0 To UBound($tempArr) - 1
If $tempArr[$x] = $pTroopType Then
Return False
EndIf
Next
EndIf
If $g_abAttackTypeEnable[$LB] Then
Local $tempArr = $troopsToBeUsed[$g_aiAttackTroopSelection[$LB]]
For $x = 0 To UBound($tempArr) - 1
If $tempArr[$x] = $pTroopType Then
Return False
EndIf
Next
EndIf
Return True
EndFunc
Func DeleteExcessTroops()
Local $SlotTemp, $Delete
Local $IsNecessaryDeleteTroop = 0
Local $CorrectDonation
For $i = 0 To $eTroopCount - 1
$CorrectDonation = 0
If IsTroopToDonateOnly($i) Then
If($g_aiCurrentTroops[$i] * -1) > $g_aiArmyCompTroops[$i] Then
$IsNecessaryDeleteTroop = 1
$g_aiDonateTroops[$i] = 0
EndIf
If($g_aiCurrentTroops[$i] * -1) = $g_aiArmyCompTroops[$i] Then
$g_aiDonateTroops[$i] = 0
EndIf
If($g_aiCurrentTroops[$i] * -1) + $g_aiDonateTroops[$i] >= $g_aiArmyCompTroops[$i] Then
$CorrectDonation = $g_aiCurrentTroops[$i] + $g_aiArmyCompTroops[$i]
$g_aiDonateTroops[$i] = $CorrectDonation
EndIf
EndIf
Next
If $IsNecessaryDeleteTroop = 0 Then Return
If _ColorCheck(_GetPixelColor(670, 485 + $g_iMidOffsetY, True), Hex(0x60B010, 6), 5) Then
Click(670, 485 + $g_iMidOffsetY)
EndIf
SetLog("Troops in excess!...")
If $g_iDebugSetlogTrain = 1 Then SetLog("Start-Loop Regular Troops Only To Donate ")
For $i = 0 To $eTroopCount - 1
If IsTroopToDonateOnly($i) Then
If $g_iDebugSetlogTrain = 1 Then SetLog("Troop :" & $g_asTroopNames[$i])
If($g_aiCurrentTroops[$i] * -1) > $g_aiArmyCompTroops[$i] Then
$Delete =($g_aiCurrentTroops[$i] * -1) - $g_aiArmyCompTroops[$i]
If $g_iDebugSetlogTrain = 1 Then SetLog("$Delete :" & $Delete)
$SlotTemp = $g_aiSlotInArmy[$i]
If $g_iDebugSetlogTrain = 1 Then SetLog("$SlotTemp :" & $SlotTemp)
If _Sleep(250) Then Return
If _ColorCheck(_GetPixelColor(170 +(62 * $SlotTemp), 235 + $g_iMidOffsetY, True), Hex(0xD40003, 6), 10) Then
Click(170 +(62 * $SlotTemp), 235 + $g_iMidOffsetY, $Delete, 300)
SetLog("~Deleted " & $Delete & " " & $g_asTroopNames[$i], $COLOR_ERROR)
$g_aiCurrentTroops[$i] += $Delete
EndIf
EndIf
EndIf
Next
If $g_iDebugSetlogTrain = 1 Then SetLog("Start-Loop Dark Troops Only To Donate ")
If _ColorCheck(_GetPixelColor(674, 436 + $g_iMidOffsetY, True), Hex(0x60B010, 6), 5) Then
Click(674, 436 + $g_iMidOffsetY)
EndIf
If WaitforPixel(505, 411 + $g_iMidOffsetY, 506, 412 + $g_iMidOffsetY, Hex(0x60B010, 6), 5, 10) Then
Click(505, 411 + $g_iMidOffsetY)
EndIf
EndFunc
Func getArmyCapacity($bOpenArmyWindow = False, $bCloseArmyWindow = False)
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then SETLOG("Begin getArmyCapacity:", $COLOR_DEBUG1)
If $bOpenArmyWindow = False And IsTrainPage() = False Then
SetError(1)
Return
ElseIf $bOpenArmyWindow = True Then
If openArmyOverview() = False Then
SetError(2)
Return
EndIf
If _Sleep($iDelaycheckArmyCamp5) Then Return
EndIf
Local $aGetArmySize[3] = ["", "", ""]
Local $sArmyInfo = ""
Local $sInputbox, $iTried, $iHoldCamp
Local $tmpTotalCamp = 0
Local $tmpCurCamp = 0
$iTried = 0
$sArmyInfo = getArmyCampCap($aArmyCampSize[0], $aArmyCampSize[1])
If $g_iDebugSetlogTrain = 1 Then Setlog("OCR $sArmyInfo = " & $sArmyInfo, $COLOR_DEBUG)
While $iTried < 100
$iTried += 1
If _Sleep($iDelaycheckArmyCamp5) Then Return
ForceCaptureRegion()
$sArmyInfo = getArmyCampCap($aArmyCampSize[0], $aArmyCampSize[1])
If $g_iDebugSetlogTrain = 1 Then Setlog("OCR $sArmyInfo = " & $sArmyInfo, $COLOR_DEBUG)
If StringInStr($sArmyInfo, "#", 0, 1) < 2 Then ContinueLoop
$aGetArmySize = StringSplit($sArmyInfo, "#")
If IsArray($aGetArmySize) Then
If $aGetArmySize[0] > 1 Then
If Number($aGetArmySize[2]) < 10 Or Mod(Number($aGetArmySize[2]), 5) <> 0 Then
If $g_iDebugSetlogTrain = 1 Then Setlog(" OCR value is not valid camp size", $COLOR_DEBUG)
ContinueLoop
EndIf
$tmpCurCamp = Number($aGetArmySize[1])
If $g_iDebugSetlogTrain = 1 Then Setlog("$tmpCurCamp = " & $tmpCurCamp, $COLOR_DEBUG)
$tmpTotalCamp = Number($aGetArmySize[2])
If $g_iDebugSetlogTrain = 1 Then Setlog("$TotalCamp = " & $TotalCamp & ", Camp OCR = " & $tmpTotalCamp, $COLOR_DEBUG)
If $iHoldCamp = $tmpTotalCamp Then ExitLoop
$iHoldCamp = $tmpTotalCamp
EndIf
EndIf
WEnd
If $iTried <= 99 Then
$CurCamp = $tmpCurCamp
If $TotalCamp = 0 Then $TotalCamp = $tmpTotalCamp
If $g_iDebugSetlogTrain = 1 Then Setlog("$CurCamp = " & $CurCamp & ", $TotalCamp = " & $TotalCamp, $COLOR_DEBUG)
Else
Setlog("Army size read error, Troop numbers may not train correctly", $COLOR_ERROR)
$CurCamp = 0
CheckOverviewFullArmy()
EndIf
If $TotalCamp = 0 Or($TotalCamp <> $tmpTotalCamp) Then
If $g_bTotalCampForced = False Then
Local $proposedTotalCamp = $tmpTotalCamp
If $TotalCamp > $tmpTotalCamp Then $proposedTotalCamp = $TotalCamp
$sInputbox = InputBox("Question", "Enter your total Army Camp capacity." & @CRLF & @CRLF & "Please check it matches with total Army Camp capacity" & @CRLF & "you see in Army Overview right now in Android Window:" & @CRLF & $Title & @CRLF & @CRLF & "(This window closes in 2 Minutes with value of " & $proposedTotalCamp & ")", $proposedTotalCamp, "", 330, 220, Default, Default, 120, $g_hFrmBot)
Local $error = @error
If $error = 1 Then
Setlog("Army Camp User input cancelled, still using " & $TotalCamp, $COLOR_ACTION)
Else
If $error = 2 Then
$TotalCamp = $proposedTotalCamp
Else
$TotalCamp = Number($sInputbox)
EndIf
If $error = 0 Then
$g_iTotalCampForcedValue = $TotalCamp
$g_bTotalCampForced = True
Setlog("Army Camp User input = " & $TotalCamp, $COLOR_INFO)
Else
Setlog("Army Camp proposed value = " & $TotalCamp, $COLOR_ACTION)
EndIf
EndIF
Else
$TotalCamp = Number($g_iTotalCampForcedValue)
EndIf
EndIf
If _Sleep($iDelaycheckArmyCamp4) Then Return
If $g_bTotalCampForced = True Then $TotalCamp = Number($g_iTotalCampForcedValue)
If $TotalCamp > 0 Then
SetLog("Total Army Camp capacity: " & $CurCamp & "/" & $TotalCamp & " (" & Int($CurCamp / $TotalCamp * 100) & "%)")
$ArmyCapacity = Int($CurCamp / $TotalCamp * 100)
Else
SetLog("Total Army Camp capacity: " & $CurCamp & "/" & $TotalCamp)
$ArmyCapacity = 0
EndIf
If($CurCamp >=($TotalCamp * $g_iTrainArmyFullTroopPct / 100)) Then
$fullArmy = True
Else
$fullArmy = False
EndIf
If $CurCamp >= $TotalCamp * $g_aiSearchCampsPct[$DB] / 100 And $g_abSearchCampsEnable[$DB] And IsSearchModeActive($DB) Then $fullArmy = True
If $CurCamp >= $TotalCamp * $g_aiSearchCampsPct[$LB] / 100 And $g_abSearchCampsEnable[$LB] And IsSearchModeActive($LB) Then $fullArmy = True
If $CurCamp >= $TotalCamp * $g_aiSearchCampsPct[$TS] / 100 And $g_abSearchCampsEnable[$TS] And IsSearchModeActive($TS) Then $fullArmy = True
If $bCloseArmyWindow = True Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($iDelaycheckArmyCamp4) Then Return
EndIf
EndFunc
Func getArmyCCStatus($bOpenArmyWindow = False, $bCloseArmyWindow = False)
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then Setlog("Begin getArmyCCStatus:", $COLOR_DEBUG1)
$iCCRemainTime = 0
If $bOpenArmyWindow = False And IsTrainPage() = False Then
SetError(1)
Return
ElseIf $bOpenArmyWindow = True Then
If openArmyOverview() = False Then
SetError(2)
Return
EndIf
If _Sleep($iDelaycheckArmyCamp5) Then Return
EndIf
$canRequestCC = _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1], True), Hex($aRequestTroopsAO[2], 6), $aRequestTroopsAO[5])
If $g_iDebugSetlogTrain = 1 Then SETLOG("Can Request CC: " & $canRequestCC, $COLOR_DEBUG)
If $canRequestCC = false then
If _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1], True), Hex($aRequestTroopsAO[3], 6), $aRequestTroopsAO[5]) then
Setlog(" - Castle request allready made.", $COLOR_INFO)
EndIf
If _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1], True), Hex($aRequestTroopsAO[4], 6), $aRequestTroopsAO[5]) then
Setlog("Castle Full/No clan.", $COLOR_INFO)
EndIf
EndIf
If _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1], True), Hex($aRequestTroopsAO[3], 6), $aRequestTroopsAO[5]) Then
Local $sResultCC = getRequestRemainTime( $aArmyCCRemainTime[0] , $aArmyCCRemainTime[1] )
If $g_iDebugSetlogTrain = 1 Then Setlog("getArmyCampCap returned: " & $sResultCC, $COLOR_DEBUG)
$iCCRemainTime = ConvertOCRTime("CC request", $sResultCC)
EndIf
If $bCloseArmyWindow = True Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($iDelaycheckArmyCamp4) Then Return
EndIf
EndFunc
Func getArmyHeroCount($bOpenArmyWindow = False, $bCloseArmyWindow = False)
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then SETLOG("Begin getArmyTHeroCount:", $COLOR_DEBUG)
If $bOpenArmyWindow = False And ISArmyWindow() = False Then
SetError(1)
Return
ElseIf $bOpenArmyWindow = True Then
If OpenArmyWindow() = False Then
SetError(2)
Return
EndIf
If _Sleep($iDelaycheckArmyCamp5) Then Return
EndIf
If $bHaveAnyHero = -1 Then
Local $rImgSearch = Not(StringInStr(FindImageInPlace("HaveAnyHero", @ScriptDir & "\imgxml\trainwindow\HeroSlots\NoHero_1_95.xml", "620,400,675,430", True), ","))
If $g_iDebugSetlog = 1 Then SetLog("Setting $bHaveAnyHero Value To: " & $rImgSearch, $COLOR_DEBUG)
If $rImgSearch = True Then
$bHaveAnyHero = 1
Else
$bHaveAnyHero = 0
Return
EndIf
ElseIf $bHaveAnyHero = 0 Then
If $g_iDebugSetlog = 1 Then SetLog("$bHaveAnyHero = 0", $COLOR_DEBUG)
Return
EndIf
$iHeroAvailable = $eHeroNone
$bFullArmyHero = False
Local $debugArmyHeroCount = 0
Local $sResult
Local Const $HeroSlots[3][2] = [[464, 446], [526, 446], [588, 446]]
Local $sMessage = ""
Local $tmpUpgradingHeroes[3] = [ $eHeroNone, $eHeroNone, $eHeroNone ]
$iHeroUpgrading[0] = 0
$iHeroUpgrading[1] = 0
$iHeroUpgrading[2] = 0
For $index = 0 To UBound($HeroSlots) - 1
$sResult = ArmyHeroStatus($index)
If $sResult <> "" Then
Select
Case StringInStr($sResult, "king", $STR_NOCASESENSEBASIC)
Setlog(" - Barbarian King available", $COLOR_GREEN)
$iHeroAvailable = BitOR($iHeroAvailable, $eHeroKing)
Case StringInStr($sResult, "queen", $STR_NOCASESENSEBASIC)
Setlog(" - Archer Queen available", $COLOR_GREEN)
$iHeroAvailable = BitOR($iHeroAvailable, $eHeroQueen)
Case StringInStr($sResult, "warden", $STR_NOCASESENSEBASIC)
Setlog(" - Grand Warden available", $COLOR_GREEN)
$iHeroAvailable = BitOR($iHeroAvailable, $eHeroWarden)
Case StringInStr($sResult, "heal", $STR_NOCASESENSEBASIC)
If $g_iDebugSetlogTrain = 1 Or $debugArmyHeroCount = 1 Then
Switch $index
Case 0
$sMessage = "-Barbarian King"
Case 1
$sMessage = "-Archer Queen"
Case 2
$sMessage = "-Grand Warden"
Case Else
$sMessage = "-Very Bad Monkey Needs"
EndSwitch
SetLog("Hero slot#" & $index + 1 & $sMessage & " Healing", $COLOR_DEBUG)
EndIf
Local $HealTime = number(getArmyHeroTime(19 + $index))
If @error Then
Setlog("getArmyHeroTime return error, on getArmyHeroCount!", $COLOR_ERROR)
EndIf
If $HealTime <> "" then
If $index = 0 then Setlog(" - Barbarian King will recover in " & Min2Time($HealTime), $COLOR_ACTION)
If $index = 1 then Setlog(" - Archer Queen will recover in " & Min2Time($HealTime) , $COLOR_ACTION)
If $index = 2 then Setlog(" - Grand Warden will recover in " & Min2Time($HealTime), $COLOR_ACTION)
Else
Setlog("slot " & $index + 1 & " getArmyHeroTime error!")
if Not ISArmyWindow() then return
EndIf
Case StringInStr($sResult, "upgrade", $STR_NOCASESENSEBASIC)
Switch $index
Case 0
$sMessage = "-Barbarian King"
$tmpUpgradingHeroes[$index] = $eHeroKing
If BitAND($g_aiAttackUseHeroes[$DB], $g_aiSearchHeroWaitEnable[$DB], $eHeroKing) = $eHeroKing Or BitAND($g_aiAttackUseHeroes[$LB], $g_aiSearchHeroWaitEnable[$LB], $eHeroKing) = $eHeroKing Then
_GUI_Value_STATE("SHOW", $groupKingSleeping)
EndIf
Case 1
$sMessage = "-Archer Queen"
$tmpUpgradingHeroes[$index] = $eHeroQueen
If BitAND($g_aiAttackUseHeroes[$DB], $g_aiSearchHeroWaitEnable[$DB], $eHeroQueen) = $eHeroQueen Or BitAND($g_aiAttackUseHeroes[$LB], $g_aiSearchHeroWaitEnable[$LB], $eHeroQueen) = $eHeroQueen Then
_GUI_Value_STATE("SHOW", $groupQueenSleeping)
EndIf
Case 2
$sMessage = "-Grand Warden"
$tmpUpgradingHeroes[$index] = $eHeroWarden
If BitAND($g_aiAttackUseHeroes[$DB], $g_aiSearchHeroWaitEnable[$DB], $eHeroWarden) = $eHeroWarden Or BitAND($g_aiAttackUseHeroes[$LB], $g_aiSearchHeroWaitEnable[$LB], $eHeroWarden) = $eHeroWarden Then
_GUI_Value_STATE("SHOW", $groupWardenSleeping)
EndIf
Case Else
$sMessage = "-Need to Get Monkey"
EndSwitch
$iHeroUpgrading[$index] = 1
If $g_iDebugSetlogTrain = 1 Or $debugArmyHeroCount = 1 Then SetLog("Hero slot#" & $index + 1 & $sMessage & " Upgrade in Process", $COLOR_DEBUG)
Case StringInStr($sResult, "none", $STR_NOCASESENSEBASIC)
If $g_iDebugSetlogTrain = 1 Or $debugArmyHeroCount = 1 Then SetLog("Hero slot#" & $index + 1 & " Empty, stop count", $COLOR_DEBUG)
ExitLoop
Case Else
SetLog("Hero slot#" & $i + 1 & " bad OCR string returned!", $COLOR_RED)
EndSelect
Else
SetLog("Hero slot#" & $index + 1 & " status read problem!", $COLOR_RED)
EndIf
Next
$iHeroUpgradingBit = BitOR($tmpUpgradingHeroes[0], $tmpUpgradingHeroes[1], $tmpUpgradingHeroes[2])
If $g_abAttackTypeEnable[$DB] = False then $g_aiSearchHeroWaitEnable[$DB] = $eHeroNone
If $g_abAttackTypeEnable[$LB] = False then $g_aiSearchHeroWaitEnable[$LB] = $eHeroNone
If(($g_abAttackTypeEnable[$DB] and $g_aiSearchHeroWaitEnable[$DB]<= $iHeroAvailable) Or($g_abAttackTypeEnable[$LB] and $g_aiSearchHeroWaitEnable[$LB]<= $iHeroAvailable)) Or($g_aiSearchHeroWaitEnable[$DB] = $eHeroNone And $g_aiSearchHeroWaitEnable[$LB] = $eHeroNone) Then
$bFullArmyHero = True
If $g_iDebugSetlogTrain = 1 Or $debugArmyHeroCount = 1 Then SetLog("$bFullArmyHero= " & $bFullArmyHero, $COLOR_DEBUG)
EndIf
If $g_iDebugSetlogTrain = 1 Or $debugArmyHeroCount = 1 Then
Setlog("====== DEBUG HEROES ======" )
Setlog("$g_aiSearchHeroWaitEnable[$DB]: " & $g_aiSearchHeroWaitEnable[$DB])
Setlog("$g_aiSearchHeroWaitEnable[$LB]: " & $g_aiSearchHeroWaitEnable[$LB])
Setlog("$iHeroAvailable: " & $iHeroAvailable)
Setlog("$bFullArmyHero: " & $bFullArmyHero)
SetLog("Hero Status K|Q|W : " & BitAND($iHeroAvailable, $eHeroKing) & "|" & BitAND($iHeroAvailable, $eHeroQueen) & "|" & BitAND($iHeroAvailable, $eHeroWarden), $COLOR_DEBUG)
Setlog("====== ########### ======" )
EndIF
If $bCloseArmyWindow = True Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($iDelaycheckArmyCamp4) Then Return
EndIf
EndFunc
Func Min2Time($nr_min)
Local $nr_sec = $nr_min * 60
Local $sec2time_hour = Int($nr_sec / 3600)
Local $sec2time_min = Int(($nr_sec - $sec2time_hour * 3600) / 60)
Local $sec2time_sec = $nr_sec - $sec2time_hour * 3600 - $sec2time_min * 60
Return StringFormat('%02d:%02d:%02d', $sec2time_hour, $sec2time_min, $sec2time_sec)
EndFunc
Func getArmyHeroTime($HeroType = "all", $bOpenArmyWindow = False, $bCloseArmyWindow = False, $bForceReadTime = False)
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then Setlog("Begin getArmyHeroTime:", $COLOR_DEBUG1)
If $HeroType <> $eKing And $HeroType <> $eQueen And $HeroType <> $eWarden And StringInStr($HeroType, "all", $STR_NOCASESENSEBASIC) = 0 Then
Setlog("getHeroTime slipped on banana, get doctor, tell him: " & $HeroType, $COLOR_ERROR)
SetError(1)
Return
EndIf
If $bOpenArmyWindow = False And IsTrainPage() = False Then
SetError(2)
Return
ElseIf $bOpenArmyWindow = True Then
If openArmyOverview() = False Then
SetError(3)
Return
EndIf
If _Sleep($iDelaycheckArmyCamp5) Then Return
EndIf
If $bHaveAnyHero = -1 Then
Local $rImgSearch = Not(StringInStr(FindImageInPlace("HaveAnyHero", @ScriptDir & "\imgxml\trainwindow\HeroSlots\NoHero_1_95.xml", "620,400,675,430", True), ","))
If $g_iDebugSetlog = 1 Then SetLog("Setting $bHaveAnyHero Value To: " & $rImgSearch, $COLOR_DEBUG)
If $rImgSearch = True Then
$bHaveAnyHero = 1
Else
$bHaveAnyHero = 0
Return
EndIf
ElseIf $bHaveAnyHero = 0 Then
If $g_iDebugSetlog = 1 Then SetLog("$bHaveAnyHero = 0", $COLOR_DEBUG)
Return
EndIf
Local $iRemainTrainHeroTimer = 0
Local $sResult
Local $iResultHeroes[3] = [0, 0, 0]
Local $tmpUpgradingHeroes[3] = [ $eHeroNone, $eHeroNone, $eHeroNone ]
If StringInStr($HeroType, "all", $STR_NOCASESENSEBASIC) > 0 Then
$iHeroUpgrading[0] = 0
$iHeroUpgrading[1] = 0
$iHeroUpgrading[2] = 0
EndIf
Local Const $aHeroRemainData[3][4] = [[620, 414, "King", $eKing], [690, 414, "Queen", $eQueen], [765, 414, "Warden", $eWarden]]
For $index = 0 To UBound($aHeroRemainData) - 1
If StringInStr($HeroType, "all", $STR_NOCASESENSEBASIC) = 0 And $HeroType <> $aHeroRemainData[$index][3] Then ContinueLoop
$sResult = ArmyHeroStatus($index)
If $g_iDebugSetlog = 1 or $g_iDebugSetlogTrain = 1 Then SetLog($aHeroRemainData[$index][2] & " Status: " & $sResult, $COLOR_DEBUG)
If $sResult <> "" Then
If StringInStr($sResult, "upgrade", $STR_NOCASESENSEBASIC) <> 0 Then
Switch $index
Case 0
$tmpUpgradingHeroes[$index] = $eHeroKing
Case 1
$tmpUpgradingHeroes[$index] = $eHeroQueen
Case 2
$tmpUpgradingHeroes[$index] = $eHeroWarden
EndSwitch
$iHeroUpgrading[$index] = 1
EndIf
If $bForceReadTime = False And StringInStr($sResult, "heal", $STR_NOCASESENSEBASIC) = 0 or StringInStr($sResult, "none", $STR_NOCASESENSEBASIC) <> 0 Then
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then
SetLog("Hero slot#" & $index + 1 & " status: " & $sResult & " :skip time read", $COLOR_DEBUG)
EndIf
ContinueLoop
Else
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then SetLog("Hero slot#" & $index + 1 & " status: " & $sResult, $COLOR_DEBUG)
EndIf
Else
SetLog("Hero slot#" & $index + 1 & " Status read problem!", $COLOR_ERROR)
EndIf
$sResult = getRemainTHero($aHeroRemainData[$index][0], $aHeroRemainData[$index][1])
If $g_iDebugSetlog = 1 Then SetLog("OCR|Remain Hero Regen Time = " & $sResult, $COLOR_DEBUG)
If $sResult <> "" Then
Local $sResultHeroTime = 0
Select
Case StringInStr($sResult, "m", $STR_NOCASESENSEBASIC) >= 1
$sResultHeroTime = StringTrimRight($sResult, 1)
$iResultHeroes[$index] = Number($sResultHeroTime)
Case StringInStr($sResult, "s", $STR_NOCASESENSEBASIC) >= 1
$sResultHeroTime = StringTrimRight($sResult, 1)
$iResultHeroes[$index] = Number($sResultHeroTime) / 60
Case Else
SetLog("Bad read of remaining " & $aHeroRemainData[$index][2] & " heal time: " & $sResult, $COLOR_RED)
EndSelect
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then SetLog("Remaining " & $aHeroRemainData[$index][2] & " heal time: " & StringFormat("%.2f", $iResultHeroes[$index]), $COLOR_DEBUG)
If $HeroType = $aHeroRemainData[$index][3] Then
$iRemainTrainHeroTimer = Number($sResultHeroTime)
ExitLoop
EndIf
Else
If $HeroType = $aHeroRemainData[$index][3] Then
SetLog("Can not read remaining " & $aHeroRemainData[$index][2] & " heal time", $COLOR_RED)
Else
For $pMatchMode = $DB To $g_iMatchMode - 1
If IsSpecialTroopToBeUsed($pMatchMode, $aHeroRemainData[$index][3]) And BitAND($g_aiAttackUseHeroes[$pMatchMode], $g_aiSearchHeroWaitEnable[$pMatchMode]) = $g_aiSearchHeroWaitEnable[$pMatchMode] Then
SetLog("Can not read remaining " & $aHeroRemainData[$index][2] & " heal time", $COLOR_RED)
ExitLoop
Else
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then SetLog("Bad read remain " & $aHeroRemainData[$index][2] & " heal time, but not enabled", $COLOR_DEBUG)
EndIf
Next
EndIf
EndIf
Next
If StringInStr($HeroType, "all", $STR_NOCASESENSEBASIC) > 0 Then $iHeroUpgradingBit = BitOR($tmpUpgradingHeroes[0], $tmpUpgradingHeroes[1], $tmpUpgradingHeroes[2])
If $bCloseArmyWindow = True Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($iDelaycheckArmyCamp4) Then Return
EndIf
If $HeroType = $eKing Or $HeroType = $eQueen Or $HeroType = $eWarden Then
Return $iRemainTrainHeroTimer
ElseIf StringInStr($HeroType, "all", $STR_NOCASESENSEBASIC) > 0 Then
Return $iResultHeroes
EndIf
EndFunc
Func getArmySpellCapacity($bOpenArmyWindow = False, $bCloseArmyWindow = False)
Local $TotalSFactory = 0
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then SETLOG("Begin getArmySpellCapacity:", $COLOR_DEBUG1)
If $bOpenArmyWindow = False And IsTrainPage() = False Then
SetError(1)
Return
ElseIf $bOpenArmyWindow = True Then
If openArmyOverview() = False Then
SetError(2)
Return
EndIf
If _Sleep($iDelaycheckArmyCamp5) Then Return
EndIf
Local $aGetSFactorySize[3] = ["", "", ""]
Local $iCount
Local $sSpellsInfo = ""
If $g_iTotalSpellValue > 0 Then
$sSpellsInfo = getArmyCampCap($aArmySpellSize[0], $aArmySpellSize[1])
$iCount = 0
While $sSpellsInfo = ""
$sSpellsInfo = getArmyCampCap($aArmySpellSize[0], $aArmySpellSize[1])
$iCount += 1
If $iCount > 10 Then ExitLoop
If _Sleep($iDelaycheckArmyCamp5) Then Return
WEnd
If $g_iDebugSetlogTrain = 1 Then Setlog("$sSpellsInfo = " & $sSpellsInfo, $COLOR_DEBUG)
$aGetSFactorySize = StringSplit($sSpellsInfo, "#")
If IsArray($aGetSFactorySize) Then
If $aGetSFactorySize[0] > 1 Then
$TotalSFactory = Number($aGetSFactorySize[2])
$CurSFactory = Number($aGetSFactorySize[1])
Else
Setlog("Spell Factory size read error.", $COLOR_ERROR)
$CurSFactory = 0
$TotalSFactory = $g_iTotalSpellValue
EndIf
Else
Setlog("Spell Factory size read error.", $COLOR_ERROR)
$CurSFactory = 0
$TotalSFactory = $g_iTotalSpellValue
EndIf
SetLog("Total Spell(s) Capacity: " & $CurSFactory & "/" & $TotalSFactory)
EndIf
If $TotalSFactory <> $g_iTotalSpellValue Then
Setlog("Note: Spell Factory Size read not same User Input Value.", $COLOR_WARNING)
EndIf
If $bCloseArmyWindow = True Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($iDelaycheckArmyCamp4) Then Return
EndIf
EndFunc
Func GetCurTotalSpell()
Local $iCount = 0
For $i = 0 To $eSpellCount - 1
$iCount += $g_aiCurrentSpells[$i]
Next
Return $iCount
EndFunc
Func GetCurTotalDarkSpell()
Local $iCount = 0
For $i = $eSpellPoison To $eSpellSkeleton - 1
$iCount += $g_aiCurrentSpells[$i]
Next
Return $iCount
EndFunc
Func GetCurTotalSpells()
Local $aCount[2]
For $i = $eSpellLightning To $eSpellSkeleton - 1
$aCount[0] += $g_aiCurrentSpells[$i]
If $g_aiCurrentSpells[$i] >= 1 Then $aCount[1] += 1
Next
Return $aCount
EndFunc
Func getArmySpellTime($bOpenArmyWindow = False, $bCloseArmyWindow = False)
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then Setlog("Begin getArmySpellTime:", $COLOR_DEBUG1)
$aTimeTrain[1] = 0
If $bOpenArmyWindow = False And IsTrainPage() = False Then
SetError(1)
Return
ElseIf $bOpenArmyWindow = True Then
If openArmyOverview() = False Then
SetError(2)
Return
EndIf
If _Sleep($iDelaycheckArmyCamp5) Then Return
EndIf
Local $sResultSpells = getRemainTrainTimer(495, 315)
$aTimeTrain[1] = ConvertOCRTime("Spells", $sResultSpells)
If $bCloseArmyWindow = True Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($iDelaycheckArmyCamp4) Then Return
EndIf
EndFunc
Func getArmyTroopTime($bOpenArmyWindow = False, $bCloseArmyWindow = False)
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then SETLOG("Begin getArmyTroopTime:", $COLOR_DEBUG1)
$aTimeTrain[0] = 0
If $bOpenArmyWindow = False And IsTrainPage() = False Then
SetError(1)
Return
ElseIf $bOpenArmyWindow = True Then
If openArmyOverview() = False Then
SetError(2)
Return
EndIf
If _Sleep($iDelaycheckArmyCamp5) Then Return
EndIf
Local $sResultTroops = getRemainTrainTimer(756, 169)
$aTimeTrain[0] = ConvertOCRTime("Troops", $sResultTroops)
If $bCloseArmyWindow = True Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($iDelaycheckArmyCamp4) Then Return
EndIf
EndFunc
Func openArmyOverview()
If IsMainPage() = False Then
SetLog("Can not open Army Overview window", $COLOR_ERROR)
SetError(1)
Return False
EndIf
If WaitforPixel(28, 505 + $g_iBottomOffsetY, 30, 507 + $g_iBottomOffsetY, Hex(0xE4A438, 6), 5, 10) Then
If $g_iDebugSetlogTrain = 1 Then SetLog("Click $aArmyTrainButton", $COLOR_SUCCESS)
If $iUseRandomClick = 0 then
Click($aArmyTrainButton[0], $aArmyTrainButton[1], 1, 0, "#0293")
Else
ClickR($aArmyTrainButtonRND, $aArmyTrainButton[0], $aArmyTrainButton[1], 1, 0)
EndIF
EndIf
If _Sleep($iDelayRunBot6) Then Return
If IsTrainPage() = False Then
SetError(1)
Return False
EndIf
Return True
EndFunc
Func SmartWait4Train()
Static $ichkCloseWaitSpell = 0, $ichkCloseWaitHero = 0
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then Setlog("Begin SmartWait4Train:", $COLOR_DEBUG1)
If $g_bCloseWhileTrainingEnable = False Then Return
Local $iExitCount = 0
If _Sleep($iDelaySmartWait) Then Return
While IsMainPage() = False
If _Sleep($iDelayIdle1) Then Return
$iExitCount += 1
If $iExitCount > 25 Then
Setlog("SmartWait4Train not finding Main Page, skip function!", $COLOR_ERROR)
Return
EndIf
WEnd
If $g_bCloseWhileTrainingEnable = False And $g_bCloseWithoutShield = False Then Return
Local $aResult, $iActiveHero
Local $aHeroResult[3]
Local Const $TRAINWAIT_NOWAIT = 0x00
Local Const $TRAINWAIT_SHIELD = 0x01
Local Const $TRAINWAIT_TROOP = 0x02
Local Const $TRAINWAIT_SPELL = 0x04
Local Const $TRAINWAIT_HERO = 0x08
Local $iTrainWaitCloseFlag = $TRAINWAIT_NOWAIT
Local $sNowTime = "", $sTrainEndTime = ""
Local $iShieldTime = 0, $iDiffDateTime = 0, $iDiffTime = 0
Local $RandomAddPercent = Random(0, $g_iCloseRandomTimePercent / 100)
Local $MinimumTimeClose = Number($g_iCloseMinimumTime * 60)
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then Setlog("Random add percent = " & StringFormat("%.4f", $RandomAddPercent), $COLOR_DEBUG)
If $g_iDebugSetlog = 1 Then Setlog("$MinimumTimeClose = " & $MinimumTimeClose & "s", $COLOR_DEBUG)
Local $StopEmulator = False
If $g_bCloseRandom = True Then $StopEmulator = "random"
If $g_bCloseEmulator = True Then $StopEmulator = True
If IsArray($aShieldStatus) And(StringInStr($aShieldStatus[0], "shield", $STR_NOCASESENSEBASIC) Or StringInStr($aShieldStatus[0], "guard", $STR_NOCASESENSEBASIC)) Then
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then SetLog("Have shield till " & $aShieldStatus[2] & ", close game while wait for train)", $COLOR_DEBUG)
$iTrainWaitCloseFlag = BitOR($iTrainWaitCloseFlag, $TRAINWAIT_SHIELD)
EndIf
If _Sleep($iDelayRespond) Then Return
If IsArray($aShieldStatus) = 0 Or $aShieldStatus[0] = "" Or $aShieldStatus[0] = "none" Then
$aResult = getShieldInfo()
If @error Then
Setlog("SmartWait4Train Shield OCR error = " & @error & "Extended = " & @extended, $COLOR_ERROR)
Return False
Else
$aShieldStatus = $aResult
EndIf
If IsArray($aShieldStatus) And(StringInStr($aShieldStatus[0], "shield", $STR_NOCASESENSEBASIC) Or StringInStr($aShieldStatus[0], "guard", $STR_NOCASESENSEBASIC)) Then
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then SetLog("Have shield till " & $aShieldStatus[2] & ", close game while wait for train)", $COLOR_DEBUG)
$iTrainWaitCloseFlag = BitOR($iTrainWaitCloseFlag, $TRAINWAIT_SHIELD)
EndIf
EndIf
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 And IsArray($aShieldStatus) Then Setlog("Shield Status:" & $aShieldStatus[0] & ", till " & $aShieldStatus[2], $COLOR_DEBUG)
Local $result = OpenArmyWindow()
If $result = False Then
If $g_iDebugImageSave = 1 Or $g_iDebugSetlogTrain = 1 Then Debugimagesave("SmartWait4Troop2_")
EndIf
If _Sleep($iDelayRespond) Then Return
If $g_bCloseWithoutShield = True Or BitAND($iTrainWaitCloseFlag, $TRAINWAIT_SHIELD) = $TRAINWAIT_SHIELD Then
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then Setlog("$g_bCloseWithoutShield enabled", $COLOR_DEBUG)
getArmyTroopTime()
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then SetLog("getArmyTroopTime returned: " & $aTimeTrain[0], $COLOR_DEBUG)
If _Sleep($iDelayRespond) Then Return
If $aTimeTrain[0] > 0 Then
If $g_bCloseRandomTime = True Then
$aTimeTrain[0] += $aTimeTrain[0] * $RandomAddPercent
EndIf
$iTrainWaitCloseFlag = BitOR($iTrainWaitCloseFlag, $TRAINWAIT_TROOP)
EndIf
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then Setlog("$iTrainWaitCloseFlag:" & $iTrainWaitCloseFlag & ", troop time = " & StringFormat("%.2f", $aTimeTrain[0]), $COLOR_DEBUG)
EndIf
If($g_bCloseWithoutShield = True Or BitAND($iTrainWaitCloseFlag, $TRAINWAIT_SHIELD) = $TRAINWAIT_SHIELD) And IsWaitforSpellsActive() Then
$ichkCloseWaitSpell = 1
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then Setlog("$ichkCloseWaitSpell enabled", $COLOR_DEBUG)
getArmySpellTime()
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then SetLog("getArmySpellTime returned: " & $aTimeTrain[1], $COLOR_DEBUG)
If _Sleep($iDelayRespond) Then Return
If $aTimeTrain[1] > 0 Then
If $g_bCloseRandomTime = True Then
$aTimeTrain[1] += $aTimeTrain[1] * $RandomAddPercent
EndIf
$iTrainWaitCloseFlag = BitOR($iTrainWaitCloseFlag, $TRAINWAIT_SPELL)
EndIf
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then Setlog("$iTrainWaitCloseFlag:" & $iTrainWaitCloseFlag & ", spell time = " & StringFormat("%.2f", $aTimeTrain[1]), $COLOR_DEBUG)
Else
$ichkCloseWaitSpell = 0
EndIf
If($g_bCloseWithoutShield = True Or BitAND($iTrainWaitCloseFlag, $TRAINWAIT_SHIELD) = $TRAINWAIT_SHIELD) And IsWaitforHeroesActive() Then
$ichkCloseWaitHero = 1
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then Setlog("$ichkCloseWaitHero enabled", $COLOR_DEBUG)
For $j = 0 To UBound($aResult) - 1
$aHeroResult[$j] = 0
Next
If _Sleep($iDelayRespond) Then Return
$aHeroResult = getArmyHeroTime("all")
If @error Then
Setlog("getArmyHeroTime return error: " & @error & ", exit SmartWait!", $COLOR_ERROR)
Return
EndIf
If Not IsArray($aHeroResult) Then
Setlog("getArmyHeroTime OCR fail, exit SmartWait!", $COLOR_ERROR)
Return
EndIf
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then SetLog("getArmyHeroTime returned: " & $aHeroResult[0] & ":" & $aHeroResult[1] & ":" & $aHeroResult[2], $COLOR_DEBUG)
If _Sleep($iDelayRespond) Then Return
If $aHeroResult[0] > 0 Or $aHeroResult[1] > 0 Or $aHeroResult[2] > 0 Then
For $pTroopType = $eKing To $eWarden
For $pMatchMode = $DB To $g_iModeCount - 1
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then
SetLog("$pTroopType: " & NameOfTroop($pTroopType) & ", $pMatchMode: " & $g_asModeText[$pMatchMode], $COLOR_DEBUG)
Setlog("TroopToBeUsed: " & IsSpecialTroopToBeUsed($pMatchMode, $pTroopType) & ", Hero Wait Status: " & String(IsSearchModeActiveMini($pMatchMode) And IsSpecialTroopToBeUsed($pMatchMode, $pTroopType) And $iHeroUpgrading[$pTroopType - $eKing] <> 1 And $iHeroWaitAttackNoBit[$pMatchMode][$pTroopType - $eKing] = 1), $COLOR_DEBUG)
SetLog("$g_aiAttackUseHeroes[" & $pMatchMode & "]= " & $g_aiAttackUseHeroes[$pMatchMode] & ", $g_aiSearchHeroWaitEnable[" & $pMatchMode & "]= " & $g_aiSearchHeroWaitEnable[$pMatchMode] & ", $g_aiAttackUseHeroes[" & $pMatchMode & "]= " & $g_aiAttackUseHeroes[$pMatchMode] & ", $iHeroUpgradingBit=" & $iHeroUpgradingBit, $COLOR_DEBUG)
EndIf
$iActiveHero = -1
If IsSearchModeActiveMini($pMatchMode) And IsSpecialTroopToBeUsed($pMatchMode, $pTroopType) And $iHeroUpgrading[$pTroopType - $eKing] <> 1 And $iHeroWaitAttackNoBit[$pMatchMode][$pTroopType - $eKing] = 1 Then
$iActiveHero = $pTroopType - $eKing
EndIf
If $iActiveHero <> -1 And $aHeroResult[$iActiveHero] > 0 Then
If $g_bCloseRandomTime = True And $aTimeTrain[2] < $aHeroResult[$iActiveHero] Then
$aTimeTrain[2] = $aHeroResult[$iActiveHero] +($aHeroResult[$iActiveHero] * $RandomAddPercent)
ElseIf $g_bCloseExactTime = True And $aTimeTrain[2] < $aHeroResult[$iActiveHero] Then
$aTimeTrain[2] = $aHeroResult[$iActiveHero]
EndIf
$iTrainWaitCloseFlag = BitOR($iTrainWaitCloseFlag, $TRAINWAIT_HERO)
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then
SetLog("Wait enabled: " & NameOfTroop($pTroopType) & ":" & $g_asModeText[$pMatchMode] & ", $iTrainWaitCloseFlag:" & $iTrainWaitCloseFlag & ", Hero Time:" & $aHeroResult[$iActiveHero] & ", Wait Time: " & StringFormat("%.2f", $aTimeTrain[2]), $COLOR_DEBUG)
EndIf
EndIf
Next
If _Sleep($iDelayRespond) Then Return
Next
Else
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then Setlog("getArmyHeroTime return all zero hero wait times", $COLOR_DEBUG)
EndIf
If $aTimeTrain[2] > 0 Then
If $g_bCloseRandomTime = True Then
$aTimeTrain[2] += $aTimeTrain[2] * $RandomAddPercent
EndIf
$iTrainWaitCloseFlag = BitOR($iTrainWaitCloseFlag, $TRAINWAIT_HERO)
EndIf
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then Setlog("$iTrainWaitCloseFlag:" & $iTrainWaitCloseFlag & ", hero time = " & StringFormat("%.2f", $aTimeTrain[2]), $COLOR_DEBUG)
Else
$ichkCloseWaitHero = 0
$aTimeTrain[2] = 0
EndIf
If $iCCRemainTime = 0 And _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1], True), Hex($aRequestTroopsAO[3], 6), $aRequestTroopsAO[5]) Then
getArmyCCStatus()
EndIf
ClickP($aAway, 1, 0, "#0000")
If _Sleep($iDelaycheckArmyCamp4) Then Return
If $iTrainWaitCloseFlag = $TRAINWAIT_NOWAIT Then Return
Local $iTrainWaitTime
Switch $iTrainWaitCloseFlag
Case 14 To 15
$iTrainWaitTime = _ArrayMax($aTimeTrain, 1, 0, 2, 0)
Case 12 To 13
$iTrainWaitTime = _Max($aTimeTrain[1], $aTimeTrain[2])
Case 10 To 11
$iTrainWaitTime = _Max($aTimeTrain[0], $aTimeTrain[2])
Case 8 To 9
$iTrainWaitTime = $aTimeTrain[2]
Case 6 To 7
$iTrainWaitTime = _Max($aTimeTrain[0], $aTimeTrain[1])
Case 4 To 5
$iTrainWaitTime = $aTimeTrain[1]
Case 2 To 3
$iTrainWaitTime = $aTimeTrain[0]
Case 1
If $aTimeTrain[0] <= 1 Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($iDelaycheckArmyCamp4) Then Return
Setlog("No smart troop wait needed", $COLOR_SUCCESS)
Return
Else
$iTrainWaitTime = $aTimeTrain[0]
EndIf
Case Else
Setlog("Impossible > Slipped on banana checking train time flag!", $COLOR_ERROR)
Return
EndSwitch
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then
Setlog("Training time values: " & StringFormat("%.2f", $aTimeTrain[0]) & " : " & StringFormat("%.2f", $aTimeTrain[1]) & " : " & StringFormat("%.2f", $aTimeTrain[2]), $COLOR_DEBUG)
SetLog("$iTrainWaitTime = " & StringFormat("%.2f", $iTrainWaitTime) & " minutes", $COLOR_DEBUG)
Setlog("$iTrainWaitCloseFlag: " & $iTrainWaitCloseFlag)
EndIf
If $g_bRequestTroopsEnable = True And $iCCRemainTime > 0 And $iCCRemainTime < $iTrainWaitTime Then
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then Setlog("Wait time reduced for CC from: " & StringFormat("%.2f", $iTrainWaitTime) & " To " & StringFormat("%.2f", $iCCRemainTime), $COLOR_DEBUG)
$iTrainWaitTime = $iCCRemainTime
EndIf
$iTrainWaitTime = $iTrainWaitTime * 60
$sNowTime = _NowCalc()
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then Setlog("Train end time: " & _DateAdd("s", Int($iTrainWaitTime), $sNowTime), $COLOR_DEBUG)
If IsArray($aShieldStatus) And _DateIsValid($aShieldStatus[2]) Then
$iShieldTime = _DateDiff("s", $sNowTime, $aShieldStatus[2])
If @error Then _logErrorDateDiff(@error)
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then Setlog("Shield time remain: " & $iShieldTime & " seconds", $COLOR_DEBUG)
If $iShieldTime < 45 Then
$iShieldTime = 0
Else
$iShieldTime -= 45
EndIf
EndIf
$iDiffTime = $iShieldTime -($iTrainWaitTime)
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then Setlog("Time Train:Shield:Diff " &($iTrainWaitTime) & ":" & $iShieldTime & ":" & $iDiffTime, $COLOR_DEBUG)
If($iTrainWaitTime >= $MinimumTimeClose) Then
If $iShieldTime > 0 Then
If $iDiffTime <= 0 Then
Setlog("Smart wait while shield time = " & StringFormat("%.2f", $iShieldTime / 60) & " Minutes", $COLOR_INFO)
UniversalCloseWaitOpenCoC($iShieldTime * 1000, "SmartWait4Train_", $StopEmulator)
$g_bRestart = True
ResetTrainTimeArray()
Else
Setlog("Smart wait train time = " & StringFormat("%.2f", $iTrainWaitTime / 60) & " Minutes", $COLOR_INFO)
UniversalCloseWaitOpenCoC($iTrainWaitTime * 1000, "SmartWait4Train_", $StopEmulator)
$g_bRestart = True
ResetTrainTimeArray()
EndIf
ElseIf($g_bCloseWithoutShield = True And $aTimeTrain[0] > 0) Or($ichkCloseWaitSpell = 1 And $aTimeTrain[1] > 0) Or($ichkCloseWaitHero = 1 And $aTimeTrain[2] > 0) Then
Setlog("Smart Wait time = " & StringFormat("%.2f", $iTrainWaitTime / 60) & " Minutes", $COLOR_INFO)
UniversalCloseWaitOpenCoC($iTrainWaitTime * 1000, "SmartWait4TrainNoShield_", $StopEmulator)
$g_bRestart = True
ResetTrainTimeArray()
Else
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then Setlog("$ichkCloseWaitSpell=" & $ichkCloseWaitSpell & ", $aTimeTrain[1]=" & $aTimeTrain[1], $COLOR_DEBUG)
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then Setlog("$ichkCloseWaitHero=" & $ichkCloseWaitHero & ", $aTimeTrain[2]=" & $aTimeTrain[2], $COLOR_DEBUG)
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then Setlog("Troop training with time remaining not enabled, skip SmartWait game exit", $COLOR_DEBUG)
EndIf
Else
Setlog("Smart Wait Time < Minimum Time Required To Close [" &($MinimumTimeClose / 60) & " Min]", $COLOR_INFO)
Setlog("Wait Train Time = " & StringFormat("%.2f", $iTrainWaitTime / 60) & " Minutes", $COLOR_INFO)
Setlog("Remain Shield Time = " & StringFormat("%.2f", $iShieldTime / 60) & " Minutes", $COLOR_INFO)
Setlog("Not Close CoC Just Wait In The Main Screen", $COLOR_INFO)
If($iShieldTime < $iTrainWaitTime) And($g_bCloseWithoutShield = False) Then
_SleepStatus($iShieldTime * 1000)
Else
_SleepStatus($iTrainWaitTime * 1000)
EndIf
ResetTrainTimeArray()
EndIf
EndFunc
Func ResetTrainTimeArray()
For $i = 0 To UBound($aTimeTrain) - 1
$aTimeTrain[$i] = 0
Next
EndFunc
Func TrainClick($x, $y, $iTimes, $iSpeed, $aWatchSpot, $sdebugtxt, $TypeTroops)
If IsTrainPage() Then
If $g_iDebugClick = 1 Then
Local $txt = _DecodeDebug($sdebugtxt)
SetLog("TrainClick " & $x & "," & $y & "," & $iTimes & "," & $iSpeed & " " & $sdebugtxt & $txt, $COLOR_ACTION, "Verdana", "7.5", 0)
EndIf
If $iTimes <> 1 Then
If FastCaptureRegion() = True Then
For $i = 0 To($iTimes - 1)
If isProblemAffect(True) Then checkMainScreen(False)
Local $sLogText = Default
If $g_iDebugSetlogTrain = 1 Then $sLogText = "TrainClick " & $x & "," & $y & "," & $iTimes
If _CheckPixel($aWatchSpot, True, Default, $sLogText) = True Then
If $g_iDebugClick = 1 Then SetLog("Camp is FULL after " & $i & " clicks", $COLOR_DEBUG)
ExitLoop
EndIf
If $iUseRandomClick = 0 then
PureClick($x, $y)
Else
PureClickR($TypeTroops, $x, $y)
EndIf
If _Sleep($iSpeed, False) Then ExitLoop
Next
Else
If isProblemAffect(True) Then checkMainScreen(False)
Local $sLogText = Default
If $g_iDebugSetlogTrain = 1 Then $sLogText = "TrainClick " & $x & "," & $y & "," & $iTimes
If _CheckPixel($aWatchSpot, True, Default, $sLogText) = True Then
If $g_iDebugClick = 1 Then SetLog("Camp is FULL", $COLOR_DEBUG)
Return
EndIf
If $iUseRandomClick = 0 then
PureClick($x, $y, $iTimes, $iSpeed)
Else
PureClickR($TypeTroops, $x, $y, $iTimes, $iSpeed)
EndIf
If _Sleep($iSpeed, False) Then Return
EndIf
Else
Local $sLogText = Default
If $g_iDebugSetlogTrain = 1 Then $sLogText = "TrainClick " & $x & "," & $y & "," & $iTimes
If isProblemAffect(True) Then checkMainScreen(False)
If $g_iDebugSetlogTrain = 1 Then SetLog("Full Check=" & _GetPixelColor($aWatchSpot[0], $aWatchSpot[1], False), $COLOR_DEBUG)
If _CheckPixel($aWatchSpot, True, Default, $sLogText) = True Then
If $g_iDebugClick = 1 Then SetLog("Camp is FULL", $COLOR_DEBUG)
Return
EndIf
If $iUseRandomClick = 0 then
PureClick($x, $y)
Else
PureClickR($TypeTroops, $x, $y)
EndIF
If _Sleep($iSpeed, False) Then Return
EndIf
Return True
Else
Return False
EndIf
EndFunc
Func TrainClickP($point, $howMany, $speed, $aWatchSpot, $debugtxt, $TypeTroops)
Return TrainClick($point[0], $point[1], $howMany, $speed, $aWatchSpot, $debugtxt, $TypeTroops)
EndFunc
Global $IsFullArmywithHeroesAndSpells = False
Func TrainRevamp()
If $bTrainEnabled = False Then
If $g_iDebugSetlogTrain = 1 Then Setlog("Halt mode - training disabled", $COLOR_DEBUG)
Return
EndIf
$g_iTimeBeforeTrain = 0
StartGainCost()
If $g_bQuickTrainEnable = False Then
TrainRevampOldStyle()
Return
EndIf
If $g_iDebugSetlogTrain = 1 Then Setlog(" - Initial Quick train Function")
If $g_iDebugSetlogTrain = 1 Then Setlog(" - Line Open Army Window")
CheckArmySpellCastel()
If($g_iCommandStop = 3 Or $g_iCommandStop = 0) And $fullarmy Then
SetLog("You are in halt attack mode and your Army is prepared!", $COLOR_DEBUG)
If $g_bFirstStart Then $g_bFirstStart = False
Return
EndIf
$aCurTotalSpell = GetCurTotalSpells()
If $g_bRunState = False Then Return
If($IsFullArmywithHeroesAndSpells = True) Or($CurCamp = 0 And $g_bFirstStart) Then
If $IsFullArmywithHeroesAndSpells Then Setlog(" - Your Army is Full, let's make troops before Attack!", $COLOR_BLUE)
If($CurCamp = 0 And $g_bFirstStart) Then
Setlog(" - Your Army is Empty, let's make troops before Attack!", $COLOR_ACTION1)
Setlog(" - Go to TrainRevamp Tab and select your Quick Army position!", $COLOR_ACTION1)
EndIf
DeleteQueued("Troops")
If _Sleep(250) Then Return
DeleteQueued("Spells")
If _Sleep(500) Then Return
CheckCamp()
ResetVariables("donated")
If $g_bFirstStart Then $g_bFirstStart = False
If _Sleep(700) Then Return
Else
If $bDonationEnabled And $g_bChkDonate Then MakingDonatedTroops()
CheckIsFullQueuedAndNotFullArmy()
If $g_bRunState = False Then Return
CheckIsEmptyQueuedAndNotFullArmy()
If $g_bRunState = False Then Return
If $g_bFirstStart Then $g_bFirstStart = False
EndIf
ClickP($aAway, 2, 0, "#0346")
If _Sleep(1000) Then Return
SetLog(" - Army Window Closed!", $COLOR_ACTION1)
EndGainCost("Train")
checkAttackDisable($iTaBChkIdle)
EndFunc
Func CheckCamp($NeedOpenArmy = False, $CloseCheckCamp = False)
If $NeedOpenArmy Then
OpenArmyWindow()
If _Sleep(500) Then Return
EndIf
Local $ReturnCamp = TestMaxCamp()
If $ReturnCamp = 1 Then
OpenTrainTabNumber($QuickTrainTAB, "CheckCamp()")
If _Sleep(1000) Then Return
TrainArmyNumber($g_iQuickTrainArmyNum)
If _Sleep(700) Then Return
EndIf
If $ReturnCamp = 0 Then
CheckIsFullQueuedAndNotFullArmy()
CheckIsEmptyQueuedAndNotFullArmy()
EndIf
If $CloseCheckCamp Then
ClickP($aAway, 2, 0, "#0346")
If _Sleep(250) Then Return
EndIf
EndFunc
Func TestMaxCamp()
Local $ToReturn = 0
If ISArmyWindow(False, $TrainTroopsTAB) = False Then OpenTrainTabNumber($TrainTroopsTAB, "TestMaxCamp()")
If _Sleep(250) Then Return
Local $ArmyCamp = GetOCRCurrent(48, 160)
If UBound($ArmyCamp) = 3 Then
If $ArmyCamp[2] = 0 Or $ArmyCamp[0] = 0 Then
$ToReturn = 1
Else
If $ArmyCamp[1] > 240 Then Setlog(" Your CoC is outdated!!! ", $COLOR_RED)
Setlog(" - Your army is: " & $ArmyCamp[1], $COLOR_RED)
$ToReturn = 0
EndIf
EndIf
Return $ToReturn
EndFunc
Func TrainRevampOldStyle()
If $g_iDebugSetlogTrain = 1 Then Setlog(" - Initial Custom train Function")
If $bActiveDonate = -1 Then PrepareDonateCC()
CheckArmySpellCastel()
If($g_iCommandStop = 3 Or $g_iCommandStop = 0) And $fullarmy Then
SetLog("You are in halt attack mode and your Army is prepared!", $COLOR_DEBUG)
If $g_bFirstStart Then $g_bFirstStart = False
Return
EndIf
If ThSnipesSkiptrain() Then Return
If $g_bRunState = False Then Return
Local $rWhatToTrain = WhatToTrain(True)
Local $rRemoveExtraTroops = RemoveExtraTroops($rWhatToTrain)
If $rRemoveExtraTroops = 1 Or $rRemoveExtraTroops = 2 Then
CheckArmySpellCastel()
If($g_iCommandStop = 3 Or $g_iCommandStop = 0) And $fullarmy Then
SetLog("You are in halt attack mode and your Army is prepared!", $COLOR_DEBUG)
If $g_bFirstStart Then $g_bFirstStart = False
Return
EndIf
EndIf
If $g_bRunState = False Then Return
If $rRemoveExtraTroops = 2 Then
$rWhatToTrain = WhatToTrain(False, False)
If Not ISArmyWindow(False, $TrainTroopsTAB) Then OpenTrainTabNumber($TrainTroopsTAB, "TrainRevampOldStyle()")
TrainUsingWhatToTrain($rWhatToTrain)
EndIf
If IsQueueEmpty($TrainTroopsTAB) Then
If $g_bRunState = False Then Return
If Not ISArmyWindow(False, $ArmyTAB) Then OpenTrainTabNumber($ArmyTAB, "TrainRevampOldStyle()")
$rWhatToTrain = WhatToTrain(False, False)
If Not ISArmyWindow(False, $TrainTroopsTAB) Then OpenTrainTabNumber($TrainTroopsTAB, "TrainRevampOldStyle()")
TrainUsingWhatToTrain($rWhatToTrain)
Else
If $g_bRunState = False Then Return
If Not ISArmyWindow(False, $ArmyTAB) Then OpenTrainTabNumber($ArmyTAB, "TrainRevampOldStyle()")
EndIf
$rWhatToTrain = WhatToTrain(False, False)
If DoWhatToTrainContainSpell($rWhatToTrain) Then
If IsQueueEmpty($BrewSpellsTAB) Then
TrainUsingWhatToTrain($rWhatToTrain, True)
Else
If Not ISArmyWindow(False, $ArmyTAB) Then OpenTrainTabNumber($ArmyTAB, "TrainRevampOldStyle()")
EndIf
EndIf
If _Sleep(250) Then Return
If $g_bRunState = False Then Return
ClickP($aAway, 2, 0, "#0346")
If _Sleep(250) Then Return
EndGainCost("Train")
checkAttackDisable($iTaBChkIdle)
EndFunc
Func CheckArmySpellCastel()
Local $fullcastlespells = False
Local $fullcastletroops = False
If OpenArmyWindow() = False Then Return
If _Sleep(250) Then Return
If ISArmyWindow(False, $ArmyTAB) = False Then OpenTrainTabNumber($ArmyTAB, "CheckArmySpellCastel()")
SetLog(" - Army Window Opened!", $COLOR_ACTION1)
If _Sleep(250) Then Return
If $g_bRunState = False Then Return
checkArmyCamp(False, False)
If $g_iDebugSetlogTrain = 1 Then $g_iDebugOcr = 1
Local $sSpells = getArmyCampCap(99, 313)
Local $aGetSpellsSize = StringSplit($sSpells, "#", $STR_NOCOUNT)
If $g_iDebugSetlogTrain = 1 Then Setlog(" - $sSpells : " & $sSpells)
Local $scastle = getArmyCampCap(300, 468)
Local $aGetCastleSize = StringSplit($scastle, "#", $STR_NOCOUNT)
If $g_iDebugSetlogTrain = 1 Then Setlog(" - $scastle : " & $scastle)
If $g_iDebugSetlogTrain = 1 Then $g_iDebugOcr = 0
If $g_iDebugSetlogTrain = 1 Then Setlog(" - $CurCamp : " & $CurCamp)
If $g_iDebugSetlogTrain = 1 Then Setlog(" - $TotalCamp : " & $TotalCamp)
$bFullArmySpells = False
Local $totalCapacitySpellsToBrew = 0
For $i = 0 To $eSpellCount - 1
$totalCapacitySpellsToBrew += $g_aiArmyCompSpells[$i] * $g_aiSpellSpace[$i]
Next
If UBound($aGetSpellsSize) = 2 Then
If $aGetSpellsSize[0] = $aGetSpellsSize[1] Or $aGetSpellsSize[0] >= $g_iTotalSpellValue Or $aGetSpellsSize[0] >= $totalCapacitySpellsToBrew Then
$bFullArmySpells = True
EndIf
Else
If $iTownHallLevel > 4 And $g_iTotalSpellValue > 0 Then
SetLog("Error reading spells size!", $COLOR_RED)
Return
Else
$bFullArmySpells = True
EndIf
EndIf
$checkSpells = checkspells()
If $g_bRunState = False Then Return
$fullcastlespells = IsFullCastleSpells()
If $g_bRunState = False Then Return
$fullcastletroops = IsFullCastleTroops()
If UBound($aGetCastleSize) <> 2 Then
SetLog("Error reading Castle size")
Return
EndIf
If $aGetCastleSize[0] <> "" And $aGetCastleSize[1] <> "" Then Setlog("Total Clan Castle: " & $aGetCastleSize[0] & "/" & $aGetCastleSize[1])
If IsWaitforHeroesActive() = False And $iChkTrophyHeroes = 0 Then $bFullArmyHero = True
If IsWaitforHeroesActive() = False And $iChkTrophyHeroes = 1 And $bFullArmyHero = False Then
If $iHeroAvailable > 0 Or Number($iTrophyCurrent) <= Number($iTxtMaxTrophy) Then
$bFullArmyHero = True
Else
Setlog("Waiting for Heroes to drop trophies!", $COLOR_ACTION)
EndIf
EndIf
If(IsSearchModeActive($DB) And checkCollectors(True, False)) Or IsSearchModeActive($LB) Or IsSearchModeActive($TS) Then
If $fullarmy And $checkSpells And $bFullArmyHero And $fullcastlespells And $fullcastletroops Then
$IsFullArmywithHeroesAndSpells = True
If $g_bFirstStart Then $g_bFirstStart = False
Else
$IsFullArmywithHeroesAndSpells = False
EndIf
Else
$IsFullArmywithHeroesAndSpells = False
EndIf
Local $text = ""
If $fullarmy = False Then $text &= " Troops,"
If $checkSpells = False Then $text &= " Spells,"
If $bFullArmyHero = False Then $text &= " Heroes,"
If $fullcastlespells = False Then $text &= " CC Spells,"
If $fullcastletroops = False Then $text &= " CC Troops,"
If StringRight($text, 1) = "," Then $text = StringTrimRight($text, 1)
If $IsFullArmywithHeroesAndSpells = True Then
If(($g_bNotifyPBEnable = True Or $g_bNotifyTGEnable = True) And $g_bNotifyAlertCampFull = True) Then PushMsg("CampFull")
Setlog("Chief, is your Army ready for battle? Yes, it is!", $COLOR_GREEN)
Else
Setlog("Chief, is your Army ready for the battle? No, not yet!", $COLOR_ACTION)
If $text <> "" Then Setlog(" -" & $text & " are not Ready!", $COLOR_ACTION)
EndIf
If $g_iDebugSetlog = 1 Then
SetLog(" $fullarmy: " & String($fullarmy), $COLOR_DEBUG)
SetLog(" $bFullArmyHero: " & String($bFullArmyHero), $COLOR_DEBUG)
SetLog(" $fullcastlespells: " & String($fullcastlespells), $COLOR_DEBUG)
SetLog(" $fullcastletroops: " & String($fullcastletroops), $COLOR_DEBUG)
SetLog(" $IsFullArmywithHeroesAndSpells: " & String($IsFullArmywithHeroesAndSpells), $COLOR_DEBUG)
SetLog(" $iTownHallLevel: " & Number($iTownHallLevel), $COLOR_DEBUG)
EndIf
EndFunc
Func IsFullArmy($log = False)
If ISArmyWindow(False, $ArmyTAB) = False Then OpenTrainTabNumber($ArmyTAB, "IsFullArmy()")
If $g_bRunState = False Then Return
Local Const $rColorCheck = _ColorCheck(_GetPixelColor(28, 176, True), Hex(0xFFFFFF, 6), 20) And _ColorCheck(_GetPixelColor(24, 168, True), Hex(0x92C232, 6), 20)
If $rColorCheck = True Then $fullarmy = True
Local $sArmyCamp = getArmyCampCap(110, 166)
Local $aGetArmySize = StringSplit($sArmyCamp, "#", $STR_NOCOUNT)
If UBound($aGetArmySize) >= 2 Then
If $log Then SetLog("Troops: " & $aGetArmySize[0] & "/" & $aGetArmySize[1], $COLOR_GREEN)
$fullarmy = False
$CurCamp = 0
If $g_bTotalCampForced = False Then
$CurCamp = $aGetArmySize[0]
$TotalCamp = $aGetArmySize[1]
Else
$CurCamp = $aGetArmySize[0]
$TotalCamp = Number($g_iTotalCampForcedValue)
EndIf
Local $thePercent = Number(($CurCamp / $TotalCamp) * 100, 1)
If $thePercent >= $g_iTrainArmyFullTroopPct Then $fullarmy = True
EndIf
Return $fullarmy
EndFunc
Func IsFullSpells($log = False)
If ISArmyWindow(False, $ArmyTAB) = False Then OpenTrainTabNumber($ArmyTAB, "IsFullSpells()")
If $g_bRunState = False Then Return
Local $sSpells = getArmyCampCap(99, 313)
Local $aGetSpellsSize = StringSplit($sSpells, "#", $STR_NOCOUNT)
$bFullArmySpells = False
If UBound($aGetSpellsSize) = 2 Then
If $log Then SetLog("Spells: " & $aGetSpellsSize[0] & "/" & $aGetSpellsSize[1], $COLOR_GREEN)
If $aGetSpellsSize[0] = $aGetSpellsSize[1] Or $aGetSpellsSize[0] >= $g_iTotalSpellValue Or $aGetSpellsSize[0] >= TotalSpellsToBrewInGUI() Then
$bFullArmySpells = True
Return True
EndIf
Else
SetLog("Error reading Spells size")
Return
EndIf
If $aGetSpellsSize[0] = $g_iTotalSpellValue Then
$bFullArmySpells = True
Return True
EndIf
Return $bFullArmySpells
EndFunc
Func checkspells()
Local $ToReturn = False
If $g_bRunState = False Then Return
If($g_abSearchSpellsWaitEnable[$DB] = False And $g_abSearchSpellsWaitEnable[$LB] = False) Or($bFullArmySpells And($g_abSearchSpellsWaitEnable[$DB] Or $g_abSearchSpellsWaitEnable[$LB])) Then
$ToReturn = True
Return $ToReturn
EndIf
$ToReturn =(IIf($g_abAttackTypeEnable[$DB], IIf($g_abSearchSpellsWaitEnable[$DB], $bFullArmySpells, True), 1) And IIf($g_abAttackTypeEnable[$LB], IIf($g_abSearchSpellsWaitEnable[$LB], $bFullArmySpells, True), 1))
Return $ToReturn
EndFunc
Func IsFullCastleSpells($returnOnly = False)
Local $CCSpellFull = False
Local $ToReturn = False
If $g_bRunState = False Then Return
If $g_abSearchCastleSpellsWaitEnable[$DB] = False And $g_abSearchCastleSpellsWaitEnable[$LB] = False Then
$ToReturn = True
If $returnOnly = False Then
Return $ToReturn
Else
Return ""
EndIf
EndIf
Local $sTempCCSpells = getArmyCampCap(527, 438 + $g_iMidOffsetY)
Local $iCurCCSpell, $iMaxCCSpell
If $g_iDebugSetlogTrain Then setlog("CCSpells OCR string: " & $sTempCCSpells)
If $sTempCCSpells <> "" Then
Local $aTempCCSpells = StringSplit($sTempCCSpells, "#", $STR_NOCOUNT)
$iCurCCSpell = $aTempCCSpells[0]
$iMaxCCSpell = $aTempCCSpells[1]
Setlog("Total Clan Castle Spells: " & $aTempCCSpells[0] & "/" & $aTempCCSpells[1])
Else
Setlog("Castle Spells unavailable!", $COLOR_INFO)
$iMaxCCSpell = 0
$iCurCCSpell = 0
$CCSpellFull = True
Return True
EndIf
If $iCurCCSpell = $iMaxCCSpell Then $CCSpellFull = True
Local $rColCheckFullCCTroops = False
$ToReturn =(IIf($g_abAttackTypeEnable[$DB], IIf($g_abSearchCastleSpellsWaitEnable[$DB], $CCSpellFull, True), 1) And IIf($g_abAttackTypeEnable[$LB], IIf($g_abSearchCastleSpellsWaitEnable[$LB], $CCSpellFull, True), 1))
If $g_iDebugSetlogTrain Then Setlog("Is necessary proceed with Castle Spells detection? " & $ToReturn, $COLOR_DEBUG)
If $ToReturn = True Then
If $g_iDebugSetlogTrain Then Setlog("Getting current available spell in clan castle.")
Local $CurCCSpell1, $CurCCSpell2
If $iMaxCCSpell < 3 Then $CurCCSpell1 = GetCurCCSpell(1)
If $iMaxCCSpell > 1 Then $CurCCSpell2 = GetCurCCSpell(2)
If $CurCCSpell1 = "" And $iCurCCSpell > 0 Then
If $returnOnly = False Then
SetLog("Failed to get current available spell in clan castle", $COLOR_ERROR)
$ToReturn = False
Return $ToReturn
Else
Return ""
EndIf
EndIf
Local $aShouldRemove[2] = [0, 0]
$aShouldRemove = CompareCCSpellWithGUI($CurCCSpell1, $CurCCSpell2, $iMaxCCSpell)
If $iMaxCCSpell > 1 Then
If $g_iDebugSetlogTrain Then Setlog(" » Slot 1 to remove: " & $aShouldRemove[0])
If $g_iDebugSetlogTrain Then Setlog(" » Slot 2 to remove: " & $aShouldRemove[1])
Else
If $g_iDebugSetlogTrain Then Setlog(" » Slot 1 to remove: " & $aShouldRemove[0])
EndIf
If $aShouldRemove[0] > 0 Or $aShouldRemove[1] > 0 Then
SetLog("Removing Useless Castle Spells!", $COLOR_BLUE)
RemoveCastleSpell($aShouldRemove)
If _Sleep(1000) Then Return
$canRequestCC = _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1], True), Hex($aRequestTroopsAO[2], 6), $aRequestTroopsAO[5])
If $g_iDebugSetlogTrain Then Setlog(" » Clans Castle button available? " & $canRequestCC)
If $canRequestCC = True Then
$rColCheckFullCCTroops = _ColorCheck(_GetPixelColor(24, 470, True), Hex(0x93C230, 6), 30)
If $rColCheckFullCCTroops = True Then SetLog("Clan Castle Spell is empty, Requesting for...")
If $returnOnly = False Then
RequestCC(False, IIf($rColCheckFullCCTroops = True Or($g_abSearchCastleTroopsWaitEnable[$DB] = False And $g_abSearchCastleTroopsWaitEnable[$LB] = False), IIf($g_abSearchCastleSpellsWaitEnable[$LB], IIf(String(GUICtrlRead($g_hCmbABWaitForCastleSpell)) = "Any", "", String(GUICtrlRead($g_hCmbABWaitForCastleSpell) & " Spell")), IIf($g_abSearchCastleSpellsWaitEnable[$DB], IIf(String(GUICtrlRead($g_hCmbDBWaitForCastleSpell)) = "Any", "", String(GUICtrlRead($g_hCmbDBWaitForCastleSpell) & " Spell")), "")), ""))
Else
$ToReturn = IIf($rColCheckFullCCTroops = True Or($g_abSearchCastleTroopsWaitEnable[$DB] = False And $g_abSearchCastleTroopsWaitEnable[$LB] = False), IIf($g_abSearchCastleSpellsWaitEnable[$LB], IIf(String(GUICtrlRead($g_hCmbABWaitForCastleSpell)) = "Any", "", String(GUICtrlRead($g_hCmbABWaitForCastleSpell) & " Spell")), IIf($g_abSearchCastleSpellsWaitEnable[$DB], IIf(String(GUICtrlRead($g_hCmbDBWaitForCastleSpell)) = "Any", "", String(GUICtrlRead($g_hCmbDBWaitForCastleSpell) & " Spell")), "")), "")
Return $ToReturn
EndIf
EndIf
$ToReturn = False
EndIf
Else
$canRequestCC = _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1], True), Hex($aRequestTroopsAO[2], 6), $aRequestTroopsAO[5])
If $canRequestCC = True Then
$rColCheckFullCCTroops = _ColorCheck(_GetPixelColor(24, 470, True), Hex(0x93C230, 6), 30)
If $rColCheckFullCCTroops = True Then SetLog("Clan Castle Spell is empty, Requesting for...")
If $returnOnly = False Then
RequestCC(False, IIf($rColCheckFullCCTroops = True Or($g_abSearchCastleTroopsWaitEnable[$DB] = False And $g_abSearchCastleTroopsWaitEnable[$LB] = False), IIf($g_abSearchCastleSpellsWaitEnable[$LB], IIf(String(GUICtrlRead($g_hCmbABWaitForCastleSpell)) = "Any", "", String(GUICtrlRead($g_hCmbABWaitForCastleSpell) & " Spell")), IIf($g_abSearchCastleSpellsWaitEnable[$DB], IIf(String(GUICtrlRead($g_hCmbDBWaitForCastleSpell)) = "Any", "", String(GUICtrlRead($g_hCmbDBWaitForCastleSpell) & " Spell")), "")), ""))
Else
$ToReturn = IIf($rColCheckFullCCTroops = True Or($g_abSearchCastleTroopsWaitEnable[$DB] = False And $g_abSearchCastleTroopsWaitEnable[$LB] = False), IIf($g_abSearchCastleSpellsWaitEnable[$LB], IIf(String(GUICtrlRead($g_hCmbABWaitForCastleSpell)) = "Any", "", String(GUICtrlRead($g_hCmbABWaitForCastleSpell) & " Spell")), IIf($g_abSearchCastleSpellsWaitEnable[$DB], IIf(String(GUICtrlRead($g_hCmbDBWaitForCastleSpell)) = "Any", "", String(GUICtrlRead($g_hCmbDBWaitForCastleSpell) & " Spell")), "")), "")
Return $ToReturn
EndIf
EndIf
EndIf
If $returnOnly = False Then
Return $ToReturn
Else
Return ""
EndIf
EndFunc
Func RemoveCastleSpell($Slots)
If $Slots[0] = 0 And $Slots[1] = 0 Then Return
If _ColorCheck(_GetPixelColor(806, 472, True), Hex(0xD0E878, 6), 25) = False Then
SetLog("Cannot find/verify 'Edit Army' Button in Army tab", $COLOR_ORANGE)
Return False
EndIf
Click(Random(723, 812, 1), Random(469, 513, 1))
If $g_bRunState = False Then Return
If _Sleep(500) Then Return
Local $pos[2] = [575, 575], $pos2[2] = [645, 575]
If $Slots[0] > 0 Then
ClickRemoveTroop($pos, $Slots[0], $g_iTrainClickDelay)
EndIf
If $Slots[1] > 0 Then
ClickRemoveTroop($pos2, $Slots[1], $g_iTrainClickDelay)
EndIf
If _Sleep(400) Then Return
If _ColorCheck(_GetPixelColor(806, 561, True), Hex(0xD0E878, 6), 25) = False Then
SetLog("Cannot find/verify 'Okay' Button in Army tab", $COLOR_ORANGE)
ClickP($aAway, 2, 0, "#0346")
If _Sleep(400) Then OpenArmyWindow()
Return False
EndIf
If _Sleep(700) Then Return
Click(Random(720, 815, 1), Random(558, 589, 1))
If _Sleep(1200) Then Return
If _ColorCheck(_GetPixelColor(508, 428, True), Hex(0xFFFFFF, 6), 30) = False Then
SetLog("Cannot find/verify 'Okay #2' Button in Army tab", $COLOR_ORANGE)
ClickP($aAway, 2, 0, "#0346")
Return False
EndIf
Click(Random(445, 585, 1), Random(400, 455, 1))
SetLog("Clan Castle Spell Removed", $COLOR_GREEN)
If _Sleep(200) Then Return
Return True
EndFunc
Func CompareCCSpellWithGUI($CCSpell1, $CCSpell2, $CastleCapacity)
If $g_iDebugSetlogTrain Then
For $i = 0 To UBound($CCSpell1, $UBOUND_COLUMNS) - 1
Setlog("$CCSpell1[0][" & $i & "]: " & $CCSpell1[0][$i])
Next
If IsArray($CCSpell2) And $CastleCapacity = 2 And $CCSpell1[0][3] < 2 Then
For $i = 0 To UBound($CCSpell2, $UBOUND_COLUMNS) - 1
Setlog("$CCSpell2[0][" & $i & "]: " & $CCSpell2[0][$i])
Next
EndIf
EndIf
If Not $g_bRunState Then Return
If _Sleep(100) Then Return
Local $sCCSpell, $sCCSpell2, $bCheckDBCCSpell = False, $bCheckABCCSpell = False
Local $bCheckCCSpell2 = False
Local $aShouldRemove[2] = [0, 0]
If $CastleCapacity = 0 Or $CastleCapacity = "" Then Return $aShouldRemove
If $g_abAttackTypeEnable[$DB] And $g_abSearchCastleSpellsWaitEnable[$DB] Then
If $g_iDebugSetlogTrain Then Setlog("- Let's compare CC Spells on Dead Bases!", $COLOR_DEBUG)
$bCheckDBCCSpell = True
EndIf
If $g_abAttackTypeEnable[$LB] And $g_abSearchCastleSpellsWaitEnable[$LB] Then
If $g_iDebugSetlogTrain Then Setlog("- Let's compare CC Spells on live Bases", $COLOR_DEBUG)
$bCheckABCCSpell = True
EndIf
If $bCheckDBCCSpell = False And $bCheckABCCSpell = False Then Return $aShouldRemove
For $Mode = $DB To $LB
If BitOR($g_aiSearchCastleSpellsWaitRegular[$Mode], $g_aiSearchCastleSpellsWaitDark[$Mode]) > 0 Then
Local $txt = "DB"
$txt =($Mode = $LB) ?("LB") :("DB")
If $Mode = $DB And $bCheckDBCCSpell = False Then ContinueLoop
Switch $g_aiSearchCastleSpellsWaitRegular[$Mode]
Case 0
$sCCSpell = "Any"
Case 1
$sCCSpell = "LSpell"
Case 2
$sCCSpell = "HSpell"
Case 3
$sCCSpell = "RSpell"
Case 4
$sCCSpell = "JSpell"
Case 5
$sCCSpell = "FSpell"
Case 6
$sCCSpell = "PSpell"
Case 7
$sCCSpell = "ESpell"
Case 8
$sCCSpell = "HaSpell"
Case 9
$sCCSpell = "SkSpell"
EndSwitch
If $g_aiSearchCastleSpellsWaitRegular[$Mode] > 5 And $CastleCapacity = 2 Then $bCheckCCSpell2 = True
If $g_iDebugSetlogTrain Then Setlog("[1][" & $txt & "] GUI Spell is " & $sCCSpell, $COLOR_DEBUG)
If($sCCSpell = $CCSpell1[0][0] Or $sCCSpell = "Any") And $CCSpell1[0][3] = 1 Then
$aShouldRemove[0] = 0
ElseIf($sCCSpell = $CCSpell1[0][0] Or $sCCSpell = "Any") And $CCSpell1[0][3] = 2 And($CCSpell1[0][0] <> $CCSpell2[0][0] Or $CCSpell2[0][0] <> "Any") Then
$aShouldRemove[0] = 1
Else
$aShouldRemove[0] = $CCSpell1[0][3]
EndIf
If $bCheckCCSpell2 Then
Switch $g_aiSearchCastleSpellsWaitDark[$Mode]
Case 0
$sCCSpell2 = "Any"
Case 1
$sCCSpell2 = "PSpell"
Case 2
$sCCSpell2 = "ESpell"
Case 3
$sCCSpell2 = "HaSpell"
Case 4
$sCCSpell2 = "SkSpell"
EndSwitch
If $CCSpell1[0][3] = 2 And $sCCSpell2 <> $sCCSpell And $bCheckCCSpell2 = True Then
Setlog("One more Dark Spell on Slot 1 than is needed!")
$aShouldRemove[0] = 1
EndIf
If $g_iDebugSetlogTrain Then Setlog("[2][" & $txt & "] GUI Spell is " & $sCCSpell2, $COLOR_DEBUG)
If $sCCSpell2 = $CCSpell2[0][0] Or $sCCSpell2 = "Any" Or($sCCSpell2 = $sCCSpell And $CCSpell1[0][3] = $CastleCapacity) Then
$aShouldRemove[1] = 0
Else
$aShouldRemove[1] = $CCSpell2[0][3]
EndIf
EndIf
ExitLoop
EndIf
Next
Return $aShouldRemove
EndFunc
Func GetCurCCSpell($SpellNr)
If $g_bRunState = False Then Return
Local $directory = @ScriptDir & "\imgxml\ArmySpells"
Local $x1 = 0, $x2 = 0, $y1 = 0, $y2 = 0
Local $failresult[1][4] =[["",-1,-1,0]]
If $SpellNr = 1 Then
$x1 = 508
$x2 = 587
$y1 = 500
$y2 = 570
ElseIf $SpellNr = 2 Then
$x1 = 587
$x2 = 660
$y1 = 500
$y2 = 570
Else
If $g_iDebugSetlog = 1 Then SetLog("GetCurCCSpell() called with the wrong argument!", $COLOR_ERROR)
Return
EndIf
Local $res = SearchArmy($directory, $x1, $y1, $x2, $y2, "CCSpells", True)
If ValidateSearchArmyResult($res) Then
For $i = 0 To UBound($res) - 1
Setlog(" - " & $g_asSpellNames[TroopIndexLookup($res[$i][0]) - $eLSpell], $COLOR_GREEN)
Next
Return $res
EndIf
Return $failresult
EndFunc
Func IsFullCastleTroops()
Local $ToReturn = False
If $g_bRunState = False Then Return
If $g_abSearchCastleTroopsWaitEnable[$DB] = False And $g_abSearchCastleTroopsWaitEnable[$LB] = False Then
$ToReturn = True
Return $ToReturn
EndIf
Local Const $rColCheck = _ColorCheck(_GetPixelColor(24, 470, True), Hex(0x93C230, 6), 30)
$ToReturn =(IIf($g_abAttackTypeEnable[$DB], IIf($g_abSearchCastleTroopsWaitEnable[$DB], $rColCheck, True), 1) And IIf($g_abAttackTypeEnable[$LB], IIf($g_abSearchCastleTroopsWaitEnable[$LB], $rColCheck, True), 1))
Return $ToReturn
EndFunc
Func TrainUsingWhatToTrain($rWTT, $SpellsOnly = False)
If $g_bRunState = False Then Return
If UBound($rWTT) = 1 And $rWTT[0][0] = "Arch" And $rWTT[0][1] = 0 Then
Return True
EndIf
If $SpellsOnly = False Then
If ISArmyWindow(False, $TrainTroopsTAB) = False Then OpenTrainTabNumber($TrainTroopsTAB, "TrainUsingWhatToTrain()")
Else
If ISArmyWindow(False, $BrewSpellsTAB) = False Then OpenTrainTabNumber($BrewSpellsTAB, "TrainUsingWhatToTrain()")
EndIf
Select
Case $IsFullArmywithHeroesAndSpells = False
For $i = 0 To(UBound($rWTT) - 1)
If $g_bRunState = False Then Return
If $rWTT[$i][1] > 0 Then
If IsSpellToBrew($rWTT[$i][0]) Then
BrewUsingWhatToTrain($rWTT[$i][0], $rWTT[$i][1])
ContinueLoop
Else
If $SpellsOnly = True Then ContinueLoop
EndIf
Local $NeededSpace = CalcNeededSpace($rWTT[$i][0], $rWTT[$i][1])
Local $LeftSpace = LeftSpace()
If $g_bRunState = False Then Return
If $NeededSpace <= $LeftSpace Then
If DragIfNeeded($rWTT[$i][0]) = False Then
Return False
EndIf
Local $iTroopIndex = TroopIndexLookup($rWTT[$i][0])
Local $sTroopName =($rWTT[$i][1] > 1 ? $g_asTroopNamesPlural[$iTroopIndex] : $g_asTroopNames[$iTroopIndex])
If CheckValuesCost($rWTT[$i][0], $rWTT[$i][1]) Then
SetLog("Training " & $rWTT[$i][1] & "x " & $sTroopName, $COLOR_GREEN)
TrainIt($iTroopIndex, $rWTT[$i][1], $g_iTrainClickDelay)
Else
SetLog("No resources to Train " & $rWTT[$i][1] & "x " & $sTroopName, $COLOR_ORANGE)
$OutOfElixir = 1
EndIf
Else
Local $CountToTrain = 0
Local $CanAdd = True
Do
$NeededSpace = CalcNeededSpace($rWTT[$i][0], $CountToTrain)
If $NeededSpace <= $LeftSpace Then
$CountToTrain += 1
Else
$CanAdd = False
EndIf
Until $CanAdd = False
If $CountToTrain > 0 Then
If DragIfNeeded($rWTT[$i][0]) = False Then
Return False
EndIf
EndIf
Local $iTroopIndex = TroopIndexLookup($rWTT[$i][0])
Local $sTroopName =($CountToTrain > 1 ? $g_asTroopNamesPlural[$iTroopIndex] : $g_asTroopNames[$iTroopIndex])
If CheckValuesCost($rWTT[$i][0], $CountToTrain) Then
SetLog("Training " & $CountToTrain & "x " & $sTroopName, $COLOR_GREEN)
TrainIt($iTroopIndex, $CountToTrain, $g_iTrainClickDelay)
Else
SetLog("No resources to Train " & $CountToTrain & "x " & $sTroopName, $COLOR_ORANGE)
$OutOfElixir = 1
EndIf
EndIf
EndIf
Next
Case $IsFullArmywithHeroesAndSpells = True
For $i = 0 To(UBound($rWTT) - 1)
If $g_bRunState = False Then Return
If $rWTT[$i][1] > 0 Then
If IsSpellToBrew($rWTT[$i][0]) Then
BrewUsingWhatToTrain($rWTT[$i][0], $rWTT[$i][1])
ContinueLoop
Else
If $SpellsOnly = True Then ContinueLoop
EndIf
Local $NeededSpace = CalcNeededSpace($rWTT[$i][0], $rWTT[$i][1])
Local $LeftSpace = LeftSpace(True)
If $g_bRunState = False Then Return
$LeftSpace =($LeftSpace[1] * 2) - $LeftSpace[0]
If $NeededSpace <= $LeftSpace Then
If DragIfNeeded($rWTT[$i][0]) = False Then
Return False
EndIf
Local $iTroopIndex = TroopIndexLookup($rWTT[$i][0])
Local $sTroopName =($rWTT[$i][1] > 1 ? $g_asTroopNamesPlural[$iTroopIndex] : $g_asTroopNames[$iTroopIndex])
If CheckValuesCost($rWTT[$i][0], $rWTT[$i][1]) Then
SetLog("Training " & $rWTT[$i][1] & "x " & $sTroopName, $COLOR_GREEN)
TrainIt($iTroopIndex, $rWTT[$i][1], $g_iTrainClickDelay)
Else
SetLog("No resources to Train " & $rWTT[$i][1] & "x " & $sTroopName, $COLOR_ORANGE)
$OutOfElixir = 1
EndIf
Else
Local $CountToTrain = 0
Local $CanAdd = True
Do
$NeededSpace = CalcNeededSpace($rWTT[$i][0], $CountToTrain)
If $NeededSpace <= $LeftSpace Then
$CountToTrain += 1
Else
$CanAdd = False
EndIf
Until $CanAdd = False
If $CountToTrain > 0 Then
If DragIfNeeded($rWTT[$i][0]) = False Then
Return False
EndIf
EndIf
Local $iTroopIndex = TroopIndexLookup($rWTT[$i][0])
Local $sTroopName =($CountToTrain > 1 ? $g_asTroopNamesPlural[$iTroopIndex] : $g_asTroopNames[$iTroopIndex])
If CheckValuesCost($rWTT[$i][0], $CountToTrain) Then
SetLog("Training " & $CountToTrain & "x " & $sTroopName, $COLOR_GREEN)
TrainIt($iTroopIndex, $CountToTrain, $g_iTrainClickDelay)
Else
SetLog("No resources to Train " & $CountToTrain & "x " & $sTroopName, $COLOR_ORANGE)
$OutOfElixir = 1
EndIf
EndIf
EndIf
Next
EndSelect
Return True
EndFunc
Func BrewUsingWhatToTrain($Spell, $Quantity)
Local $iSpellIndex = TroopIndexLookup($Spell)
Local $sSpellName = $g_asSpellNames[$iSpellIndex - $eLSpell]
If $Quantity <= 0 Then Return False
If $Quantity = 9999 Then
SetLog("Brewing " & $sSpellName & " Spell Cancelled " & @CRLF & "                  Reason: Enough as set in GUI " & @CRLF & "                               This Spell not used in Attack")
Return True
EndIf
If $g_bRunState = False Then Return
If ISArmyWindow(False, $BrewSpellsTAB) = False Then OpenTrainTabNumber($BrewSpellsTAB, "BrewUsingWhatToTrain()")
Select
Case $IsFullArmywithHeroesAndSpells = False
If _ColorCheck(_GetPixelColor(230, 208, True), Hex(0x677CB5, 6), 30) = False Then RemoveExtraTroopsQueue()
Local $NeededSpace = CalcNeededSpace($Spell, $Quantity)
Local $LeftSpace = LeftSpace()
If $g_bRunState = False Then Return
If $NeededSpace <= $LeftSpace Then
If CheckValuesCost($Spell, $Quantity) Then
SetLog("Brewing " & $Quantity & "x " & $sSpellName &($Quantity > 1 ? " Spells" : " Spell"), $COLOR_GREEN)
TrainIt($iSpellIndex, $Quantity, $g_iTrainClickDelay)
Else
SetLog("No resources to Brew " & $Quantity & "x " & $sSpellName &($Quantity > 1 ? " Spells" : " Spell"), $COLOR_ORANGE)
$OutOfElixir = 1
EndIf
EndIf
Case $IsFullArmywithHeroesAndSpells = True
Local $NeededSpace = CalcNeededSpace($Spell, $Quantity)
Local $LeftSpace = LeftSpace(True)
If $g_bRunState = False Then Return
$LeftSpace =($LeftSpace[1] * 2) - $LeftSpace[0]
If $NeededSpace <= $LeftSpace Then
If CheckValuesCost($Spell, $Quantity) Then
SetLog("Brewing " & $Quantity & "x " & $sSpellName &($Quantity > 1 ? " Spells" : " Spell"), $COLOR_GREEN)
TrainIt($iSpellIndex, $Quantity, $g_iTrainClickDelay)
Else
SetLog("No resources to Brew " & $Quantity & "x " & $sSpellName &($Quantity > 1 ? " Spells" : " Spell"), $COLOR_ORANGE)
$OutOfElixir = 1
EndIf
EndIf
EndSelect
EndFunc
Func TotalSpellsToBrewInGUI()
Local $ToReturn = 0
If $g_iTotalSpellValue = 0 Then Return $ToReturn
If $g_bRunState = False Then Return
For $i = 0 To $eSpellCount - 1
$ToReturn += $g_aiArmyCompSpells[$i] * $g_aiSpellSpace[$i]
Next
Return $ToReturn
EndFunc
Func HowManyTimesWillBeUsed($Spell)
Local $ToReturn = -1
If $g_bRunState = False Then Return
If $g_bForceBrewSpells = True Then
$ToReturn = 2
Return $ToReturn
EndIf
If $g_abAttackTypeEnable[$DB] Then
If $g_aiAttackAlgorithm[$DB] = 1 Then
If IsGUICheckedForSpell($Spell, $DB) Then
$ToReturn = CountCommandsForSpell($Spell, $DB)
If $ToReturn = 0 Then $ToReturn = -1
Else
$ToReturn = -1
EndIf
Else
$ToReturn = -1
EndIf
EndIf
If $g_abAttackTypeEnable[$LB] Then
If $g_aiAttackAlgorithm[$LB] = 1 Then
If IsGUICheckedForSpell($Spell, $LB) Then
$ToReturn = CountCommandsForSpell($Spell, $LB)
If $ToReturn = 0 Then $ToReturn = -1
EndIf
EndIf
EndIf
Return $ToReturn
EndFunc
Func CountCommandsForSpell($Spell, $Mode)
Local $ToReturn = 0
Local $filename = ""
If $g_bRunState = False Then Return
If $Mode = $DB Then
$filename = $g_sAttackScrScriptName[$DB]
Else
$filename = $g_sAttackScrScriptName[$LB]
EndIf
Local $rownum = 0
If FileExists($g_sCSVAttacksPath & "\" & $filename & ".csv") Then
Local $f, $line, $acommand, $command
Local $value1, $Troop
$f = FileOpen($g_sCSVAttacksPath & "\" & $filename & ".csv", 0)
While 1
$line = FileReadLine($f)
$rownum += 1
If @error = -1 Then ExitLoop
$acommand = StringSplit($line, "|")
If $acommand[0] >= 8 Then
$command = StringStripWS(StringUpper($acommand[1]), 2)
$Troop = StringStripWS(StringUpper($acommand[5]), 2)
If $Troop = $Spell Then $ToReturn += 1
EndIf
WEnd
FileClose($f)
Else
$ToReturn = 0
EndIf
Return $ToReturn
EndFunc
Func IsGUICheckedForSpell($Spell, $Mode)
Local $sSpell = ""
Local $aVal = 0
If $g_bRunState = False Then Return
Switch TroopIndexLookup($Spell)
Case $eLSpell
$sSpell = "Light"
$aVal = $g_abAttackUseLightSpell
Case $eHSpell
$sSpell = "Heal"
$aVal = $g_abAttackUseHealSpell
Case $eRSpell
$sSpell = "Rage"
$aVal = $g_abAttackUseRageSpell
Case $eJSpell
$sSpell = "Jump"
$aVal = $g_abAttackUseJumpSpell
Case $eFSpell
$sSpell = "Freeze"
$aVal = $g_abAttackUseFreezeSpell
Case $ePSpell
$sSpell = "Poison"
$aVal = $g_abAttackUsePoisonSpell
Case $eESpell
$sSpell = "Earthquake"
$aVal = $g_abAttackUseEarthquakeSpell
Case $eHaSpell
$sSpell = "Haste"
$aVal = $g_abAttackUseHasteSpell
EndSwitch
If IsArray($aVal) Then Return $aVal[$Mode]
Return False
EndFunc
Func DragIfNeeded($Troop)
If $g_bRunState = False Then Return
Local $rCheckPixel = False
If IsDarkTroop($Troop) Then
If _ColorCheck(_GetPixelColor(834, 403, True), Hex(0xD3D3CB, 6), 5) Then $rCheckPixel = True
If $g_iDebugSetlogTrain Then Setlog("DragIfNeeded Dark Troops: " & $rCheckPixel)
For $i = 1 To 3
If $rCheckPixel = False Then
ClickDrag(715, 445 + $g_iMidOffsetY, 220, 445 + $g_iMidOffsetY, 2000)
If _Sleep(1500) Then Return
If _ColorCheck(_GetPixelColor(834, 403, True), Hex(0xD3D3CB, 6), 5) Then $rCheckPixel = True
Else
Return True
EndIf
Next
Else
If _ColorCheck(_GetPixelColor(22, 403, True), Hex(0xD3D3CB, 6), 5) Then $rCheckPixel = True
If $g_iDebugSetlogTrain Then Setlog("DragIfNeeded Normal Troops: " & $rCheckPixel)
For $i = 1 To 3
If $rCheckPixel = False Then
ClickDrag(220, 445 + $g_iMidOffsetY, 725, 445 + $g_iMidOffsetY, 2000)
If _Sleep(1500) Then Return
If _ColorCheck(_GetPixelColor(22, 403, True), Hex(0xD3D3CB, 6), 5) Then $rCheckPixel = True
Else
Return True
EndIf
Next
EndIf
SetLog("Failed to Verify Troop " & $g_asTroopNames[TroopIndexLookup($Troop)] & " Position or Failed to Drag Successfully", $COLOR_RED)
Return False
EndFunc
Func DoWhatToTrainContainSpell($rWTT)
For $i = 0 To(UBound($rWTT) - 1)
If $g_bRunState = False Then Return
If IsSpellToBrew($rWTT[$i][0]) Then
If $rWTT[$i][1] > 0 Then Return True
EndIf
Next
Return False
EndFunc
Func IsElixirTroop($Troop)
Local $iIndex = TroopIndexLookup($Troop)
If $iIndex >= $eBarb And $iIndex <= $eMine Then Return True
Return False
EndFunc
Func IsDarkTroop($Troop)
Local $iIndex = TroopIndexLookup($Troop)
If $iIndex >= $eMini And $iIndex <= $eBowl Then Return True
Return False
EndFunc
Func IsElixirSpell($Spell)
Local $iIndex = TroopIndexLookup($Spell)
If $iIndex >= $eLSpell And $iIndex <= $eCSpell Then Return True
Return False
EndFunc
Func IsDarkSpell($Spell)
Local $iIndex = TroopIndexLookup($Spell)
If $iIndex >= $ePSpell And $iIndex <= $eSkSpell Then Return True
Return False
EndFunc
Func IsSpellToBrew($sName)
Local $iIndex = TroopIndexLookup($sName)
If $iIndex >= $eLSpell And $iIndex <= $eSkSpell Then Return True
Return False
EndFunc
Func CalcNeededSpace($Troop, $Quantity)
If $g_bRunState = False Then Return -1
Local $iIndex = TroopIndexLookup($Troop)
If $iIndex = -1 Then Return -1
If $iIndex >= $eBarb And $iIndex <= $eBowl Then
Return Number($g_aiTroopSpace[$iIndex] * $Quantity)
EndIf
If $iIndex >= $eLSpell And $iIndex <= $eSkSpell Then
Return Number($g_aiSpellSpace[$iIndex - $eLSpell] * $Quantity)
EndIf
Return -1
EndFunc
Func RemoveExtraTroops($toRemove)
Local $CounterToRemove = 0
Local $ToReturn = 0
If UBound($toRemove) = 1 And $toRemove[0][0] = "Arch" And $toRemove[0][1] = 0 Then
$ToReturn = 3
Return $ToReturn
EndIf
If $IsFullArmywithHeroesAndSpells = True Or $fullarmy = True Or($g_iCommandStop = 3 Or $g_iCommandStop = 0) = True And Not $bActiveDonate Then
$ToReturn = 3
Return $ToReturn
EndIf
If UBound($toRemove) > 0 Then
Local $rGetSlotNumber = GetSlotNumber()
Local $rGetSlotNumberSpells = GetSlotNumber(True)
If Not IsQueueEmpty($TrainTroopsTAB) Then
OpenTrainTabNumber($TrainTroopsTAB, "RemoveExtraTroops()")
For $i = 0 To(UBound($toRemove) - 1)
If $g_bRunState = False Then Return
If IsSpellToBrew($toRemove[$i][0]) Then ExitLoop
$CounterToRemove += 1
If IsAlreadyTraining($toRemove[$i][0]) Then
SetLog($g_asTroopNames[TroopIndexLookup($toRemove[$i][0])] & " Is in Train Tab Queue By Mistake!", $COLOR_BLUE)
DeleteQueued("Troops")
$ToReturn = 2
EndIf
Next
EndIf
If Not IsQueueEmpty($BrewSpellsTAB) Then
If TotalSpellsToBrewInGUI() > 0 Then
OpenTrainTabNumber($BrewSpellsTAB, "RemoveExtraTroops()")
For $i = $CounterToRemove To(UBound($toRemove) - 1)
If $g_bRunState = False Then Return
If IsAlreadyTraining($toRemove[$i][0], True) Then
SetLog($g_asSpellNames[TroopIndexLookup($toRemove[$i][0]) - $eLSpell] & " Is in Spells Tab Queue By Mistake!", $COLOR_BLUE)
DeleteQueued("Spells")
$ToReturn = 2
EndIf
Next
EndIf
EndIf
OpenTrainTabNumber($ArmyTAB, "RemoveExtraTroops()")
$toRemove = WhatToTrain(True, False)
$rGetSlotNumber = GetSlotNumber()
$rGetSlotNumberSpells = GetSlotNumber(True)
SetLog("Troops To Remove: ", $COLOR_GREEN)
$CounterToRemove = 0
For $i = 0 To(UBound($toRemove) - 1)
If IsSpellToBrew($toRemove[$i][0]) Then ExitLoop
$CounterToRemove += 1
SetLog("  " & $g_asTroopNames[TroopIndexLookup($toRemove[$i][0])] & ": " & $toRemove[$i][1] & "x", $COLOR_GREEN)
Next
If TotalSpellsToBrewInGUI() > 0 Then
If $CounterToRemove <= UBound($toRemove) Then
SetLog("Spells To Remove: ", $COLOR_GREEN)
For $i = $CounterToRemove To(UBound($toRemove) - 1)
SetLog("  " & $g_asSpellNames[TroopIndexLookup($toRemove[$i][0]) - $eLSpell] & ": " & $toRemove[$i][1] & "x", $COLOR_GREEN)
Next
EndIf
EndIf
If _ColorCheck(_GetPixelColor(806, 472, True), Hex(0xD0E878, 6), 25) = False Then
SetLog("Cannot find/verify 'Edit Army' Button in Army tab", $COLOR_ORANGE)
Return False
EndIf
Click(Random(723, 812, 1), Random(469, 513, 1))
$CounterToRemove = 0
For $j = 0 To(UBound($toRemove) - 1)
If IsSpellToBrew($toRemove[$j][0]) Then ExitLoop
$CounterToRemove += 1
For $i = 0 To(UBound($rGetSlotNumber) - 1)
If $toRemove[$j][0] = $rGetSlotNumber[$i] Then
Local $pos = GetSlotRemoveBtnPosition($i + 1)
ClickRemoveTroop($pos, $toRemove[$j][1], $g_iTrainClickDelay)
EndIf
Next
Next
If TotalSpellsToBrewInGUI() > 0 Then
For $j = $CounterToRemove To(UBound($toRemove) - 1)
For $i = 0 To(UBound($rGetSlotNumberSpells) - 1)
If $toRemove[$j][0] = $rGetSlotNumberSpells[$i] Then
Local $pos = GetSlotRemoveBtnPosition($i + 1, True)
ClickRemoveTroop($pos, $toRemove[$j][1], $g_iTrainClickDelay)
EndIf
Next
Next
EndIf
If _Sleep(150) Then Return
If _ColorCheck(_GetPixelColor(806, 561, True), Hex(0xD0E878, 6), 25) = False Then
SetLog("Cannot find/verify 'Okay' Button in Army tab", $COLOR_ORANGE)
ClickP($aAway, 2, 0, "#0346")
If _Sleep(400) Then OpenArmyWindow()
Return False
EndIf
If _Sleep(700) Then Return
If $g_bRunState = False Then Return
Click(Random(720, 815, 1), Random(558, 589, 1))
If _Sleep(1200) Then Return
If _ColorCheck(_GetPixelColor(508, 428, True), Hex(0xFFFFFF, 6), 30) = False Then
SetLog("Cannot find/verify 'Okay #2' Button in Army tab", $COLOR_ORANGE)
ClickP($aAway, 2, 0, "#0346")
Return False
EndIf
Click(Random(445, 585, 1), Random(400, 455, 1))
SetLog("All Extra troops removed", $COLOR_GREEN)
If _Sleep(200) Then Return
If $ToReturn = 0 Then $ToReturn = 1
Else
SetLog("No extra troop to remove, Great", $COLOR_GREEN)
$ToReturn = 3
EndIf
Return $ToReturn
EndFunc
Func DeleteInvalidTroopInArray(ByRef $Array)
Switch(UBound($Array, 2) > 0)
Case True
Local $canKeep = True
Local $2DBound = UBound($Array, 2)
Local $Counter = 0
For $i = 0 To(UBound($Array) - 1)
If TroopIndexLookup($Array[$i][0]) = -1 Or $Array[$i][0] = "" Then
$canKeep = False
Else
$canKeep = True
EndIf
If $canKeep = True Then
For $j = 0 To(UBound($Array, 2) - 1)
$Array[$Counter][$j] = $Array[$i][$j]
Next
$Counter += 1
EndIf
Next
ReDim $Array[$Counter][$2DBound]
Case Else
Local $Counter = 0
For $i = 0 To(UBound($Array) - 1)
If TroopIndexLookup($Array[$i]) = -1 Or $Array[$i] = "" Then
$Array[$Counter] = $Array[$i]
$Counter += 1
EndIf
Next
ReDim $Array[$Counter]
EndSwitch
EndFunc
Func RemoveExtraTroopsQueue()
If $IsFullArmywithHeroesAndSpells = True Then Return True
Local Const $y = 259, $yRemoveBtn = 200, $xDecreaseRemoveBtn = 10
Local $rColCheck = ""
Local $Removed = False
For $x = 834 To 58 Step -70
If $g_bRunState = False Then Return
$rColCheck = _ColorCheck(_GetPixelColor($x, $y, True), Hex(0xD7AFA9, 6), 20)
If $rColCheck = True Then
$Removed = True
Do
Click($x - $xDecreaseRemoveBtn, $yRemoveBtn, 2, $g_iTrainClickDelay)
If _Sleep(20) Then Return
$rColCheck = _ColorCheck(_GetPixelColor($x, $y, True), Hex(0xD7AFA9, 6), 20)
Until $rColCheck = False
ElseIf $rColCheck = False And $Removed Then
ExitLoop
EndIf
Next
Return True
EndFunc
Func IsAlreadyTraining($Troop, $Spells = False)
If $g_bRunState = False Then Return
Select
Case $Spells = False
If IsQueueEmpty($TrainTroopsTAB) Then Return False
Local $QueueTroops = CheckQueueTroops(False, False)
For $i = 0 To(UBound($QueueTroops) - 1)
If $QueueTroops[$i] = $Troop Then Return True
Next
Return False
Case $Spells = True
If IsQueueEmpty($BrewSpellsTAB, False, IIf($g_bForceBrewSpells = True, False, True)) Then Return False
Local $QueueSpells = CheckQueueSpells(False, False)
For $i = 0 To(UBound($QueueSpells) - 1)
If $QueueSpells[$i] = $Troop Then Return True
Next
Return False
EndSelect
EndFunc
Func IsQueueEmpty($Tab = -1, $bSkipTabCheck = False, $removeExtraTroopsQueue = True)
Local $iArrowX, $iArrowY
If $g_bRunState = False Then Return
If $Tab = $TrainTroopsTAB Or $Tab = -1 Then
$iArrowX = $aGreenArrowTrainTroops[0]
$iArrowY = $aGreenArrowTrainTroops[1]
ElseIf $Tab = $BrewSpellsTAB Then
$iArrowX = $aGreenArrowBrewSpells[0]
$iArrowY = $aGreenArrowBrewSpells[1]
EndIf
If Not _ColorCheck(_GetPixelColor($iArrowX, $iArrowY, True), Hex(0xAADA82, 6), 30) And Not _ColorCheck(_GetPixelColor($iArrowX, $iArrowY + 3, True), Hex(0x6ab320, 6), 30) Then
Return True
ElseIf _ColorCheck(_GetPixelColor($iArrowX, $iArrowY, True), Hex(0xAADA82, 6), 30) And _ColorCheck(_GetPixelColor($iArrowX, $iArrowY + 3, True), Hex(0x74be2c, 6), 30) And Not $removeExtraTroopsQueue Then
Return False
EndIf
If $bSkipTabCheck = False Then
If $Tab = -1 Then $Tab = $TrainTroopsTAB
If ISArmyWindow(False, $Tab) = False Then OpenTrainTabNumber($Tab, "IsQueueEmpty()")
EndIf
If $IsFullArmywithHeroesAndSpells = False Then
If $removeExtraTroopsQueue Then
If _ColorCheck(_GetPixelColor(230, 208, True), Hex(0x677CB5, 6), 30) = False Then RemoveExtraTroopsQueue()
EndIf
EndIf
If _ColorCheck(_GetPixelColor(230, 208, True), Hex(0x677CB5, 6), 20) Then Return True
Return False
EndFunc
Func ClickRemoveTroop($pos, $iTimes, $iSpeed)
$pos[0] = Random($pos[0] - 3, $pos[0] + 10, 1)
$pos[1] = Random($pos[1] - 5, $pos[1] + 5, 1)
If $g_bRunState = False Then Return
If _Sleep(400) Then Return
If $iTimes <> 1 Then
If FastCaptureRegion() = True Then
For $i = 0 To($iTimes - 1)
PureClick($pos[0], $pos[1], 1, $iSpeed)
If _Sleep($iSpeed, False) Then ExitLoop
Next
Else
PureClick($pos[0], $pos[1], $iTimes, $iSpeed)
If _Sleep($iSpeed, False) Then Return
EndIf
Else
PureClick($pos[0], $pos[1], 1, $iSpeed)
If _Sleep($iSpeed, False) Then Return
EndIf
EndFunc
Func GetSlotRemoveBtnPosition($iSlot, $Spells = False)
Local Const $aResult[2] = [Number((74 * $iSlot) - 4), IIf($Spells = False, 270, 417)]
Return $aResult
EndFunc
Func GetSlotNumber($Spells = False)
Select
Case $Spells = False
Local Const $Orders[19] = [$eBarb, $eArch, $eGiant, $eGobl, $eWall, $eBall, $eWiza, $eHeal, $eDrag, $ePekk, $eBabyD, $eMine, $eMini, $eHogs, $eValk, $eGole, $eWitc, $eLava, $eBowl]
Local $allCurTroops[UBound($Orders)]
For $i = 0 To $eTroopCount - 1
If $g_bRunState = False Then Return
If $g_aiCurrentTroops[$i] > 0 Then
For $j = 0 To(UBound($Orders) - 1)
If TroopIndexLookup($g_asTroopShortNames[$i]) = $Orders[$j] Then
$allCurTroops[$j] = $g_asTroopShortNames[$i]
EndIf
Next
EndIf
Next
_ArryRemoveBlanks($allCurTroops)
Return $allCurTroops
Case $Spells = True
Local Const $SpellsOrders[10] = [$eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell]
Local $allCurSpells[UBound($SpellsOrders)]
For $i = 0 To $eSpellCount - 1
If $g_bRunState = False Then Return
If $g_aiCurrentSpells[$i] > 0 Then
For $j = 0 To(UBound($SpellsOrders) - 1)
If TroopIndexLookup($g_asSpellShortNames[$i]) = $SpellsOrders[$j] Then
$allCurSpells[$j] = $g_asSpellShortNames[$i]
EndIf
Next
EndIf
Next
_ArryRemoveBlanks($allCurSpells)
Return $allCurSpells
EndSelect
EndFunc
Func WhatToTrain($ReturnExtraTroopsOnly = False, $showlog = True)
If ISArmyWindow(False, $ArmyTAB) = False Then OpenTrainTabNumber($ArmyTAB, "WhatToTrain()")
Local $ToReturn[1][2] = [["Arch", 0]]
If $IsFullArmywithHeroesAndSpells And $ReturnExtraTroopsOnly = False Then
If $g_iCommandStop = 3 Or $g_iCommandStop = 0 Then
If $g_bFirstStart Then $g_bFirstStart = False
Return $ToReturn
EndIf
Setlog(" - Your Army is Full, let's make troops before Attack!")
For $ii = 0 To $eTroopCount - 1
Local $troopIndex = $g_aiTrainOrder[$ii]
If $g_aiArmyCompTroops[$troopIndex] > 0 Then
$ToReturn[UBound($ToReturn) - 1][0] = $g_asTroopShortNames[$troopIndex]
$ToReturn[UBound($ToReturn) - 1][1] = $g_aiArmyCompTroops[$troopIndex]
ReDim $ToReturn[UBound($ToReturn) + 1][2]
EndIf
Next
For $i = 0 To $eSpellCount - 1
If $g_bRunState = False Then Return
If TotalSpellsToBrewInGUI() = 0 Then ExitLoop
If $g_aiArmyCompSpells[$i] > 0 Then
If HowManyTimesWillBeUsed($g_asSpellShortNames[$i]) > 0 Then
$ToReturn[UBound($ToReturn) - 1][0] = $g_asSpellShortNames[$i]
$ToReturn[UBound($ToReturn) - 1][1] = $g_aiArmyCompSpells[$i]
ReDim $ToReturn[UBound($ToReturn) + 1][2]
Else
CheckExistentArmy("Spells", False)
If $g_aiArmyCompSpells[$i] - $g_aiCurrentSpells[$i] > 0 Then
$ToReturn[UBound($ToReturn) - 1][0] = $g_asSpellShortNames[$i]
$ToReturn[UBound($ToReturn) - 1][1] = $g_aiArmyCompSpells[$i] - $g_aiCurrentSpells[$i]
ReDim $ToReturn[UBound($ToReturn) + 1][2]
Else
$ToReturn[UBound($ToReturn) - 1][0] = $g_asSpellShortNames[$i]
$ToReturn[UBound($ToReturn) - 1][1] = 9999
ReDim $ToReturn[UBound($ToReturn) + 1][2]
EndIf
EndIf
EndIf
Next
Return $ToReturn
EndIf
CheckExistentArmy("Troops", $showlog)
CheckExistentArmy("Spells", $showlog)
Switch $ReturnExtraTroopsOnly
Case False
For $ii = 0 To $eTroopCount - 1
Local $troopIndex = $g_aiTrainOrder[$ii]
If $g_bRunState = False Then Return
If $g_aiArmyCompTroops[$troopIndex] > 0 Then
$ToReturn[UBound($ToReturn) - 1][0] = $g_asTroopShortNames[$troopIndex]
$ToReturn[UBound($ToReturn) - 1][1] = $g_aiArmyCompTroops[$troopIndex] - $g_aiCurrentTroops[$troopIndex]
ReDim $ToReturn[UBound($ToReturn) + 1][2]
EndIf
Next
For $i = 0 To $eSpellCount - 1
If $g_bRunState = False Then Return
If TotalSpellsToBrewInGUI() = 0 Then ExitLoop
If $g_aiArmyCompSpells[$i] > 0 Then
$ToReturn[UBound($ToReturn) - 1][0] = $g_asSpellShortNames[$i]
$ToReturn[UBound($ToReturn) - 1][1] = $g_aiArmyCompSpells[$i] - $g_aiCurrentSpells[$i]
ReDim $ToReturn[UBound($ToReturn) + 1][2]
EndIf
Next
Case Else
For $ii = 0 To $eTroopCount - 1
Local $troopIndex = $g_aiTrainOrder[$ii]
If $g_bRunState = False Then Return
If $g_aiCurrentTroops[$troopIndex] > 0 Then
If $g_aiArmyCompTroops[$troopIndex] - $g_aiCurrentTroops[$troopIndex] < 0 Then
$ToReturn[UBound($ToReturn) - 1][0] = $g_asTroopShortNames[$troopIndex]
$ToReturn[UBound($ToReturn) - 1][1] = Abs($g_aiArmyCompTroops[$troopIndex] - $g_aiCurrentTroops[$troopIndex])
ReDim $ToReturn[UBound($ToReturn) + 1][2]
EndIf
EndIf
Next
For $i = 0 To $eSpellCount - 1
If $g_bRunState = False Then Return
If TotalSpellsToBrewInGUI() = 0 Then ExitLoop
If $g_aiCurrentSpells[$i] > 0 Then
If $g_aiArmyCompSpells[$i] - $g_aiCurrentSpells[$i] < 0 Then
$ToReturn[UBound($ToReturn) - 1][0] = $g_asSpellShortNames[$i]
$ToReturn[UBound($ToReturn) - 1][1] = Abs($g_aiArmyCompSpells[$i] - $g_aiCurrentSpells[$i])
ReDim $ToReturn[UBound($ToReturn) + 1][2]
EndIf
EndIf
Next
EndSwitch
DeleteInvalidTroopInArray($ToReturn)
Return $ToReturn
EndFunc
Func TestTroopsCoords()
Local $iCount = 3
$g_bRunState = True
For $i = 0 To $eTroopCount - 1
DragIfNeeded($g_asTroopShortNames[$i])
TrainIt(TroopIndexLookup($g_asTroopShortNames[$i]), $iCount, $g_iTrainClickDelay)
Next
$g_bRunState = False
EndFunc
Func TestSpellsCoords()
$g_bRunState = True
Local $iCount = 1
TrainIt($eLSpell, $iCount, 300)
TrainIt($eHSpell, $iCount, 300)
TrainIt($eRSpell, $iCount, 300)
TrainIt($eJSpell, $iCount, 300)
TrainIt($eFSpell, $iCount, 300)
TrainIt($eCSpell, $iCount, 300)
TrainIt($ePSpell, $iCount, 300)
TrainIt($eESpell, $iCount, 300)
TrainIt($eHaSpell, $iCount, 300)
TrainIt($eSkSpell, $iCount, 300)
$g_bRunState = False
EndFunc
Func LeftSpace($ReturnAll = False)
Local $RemainTrainSpace = GetOCRCurrent(48, 160)
If $g_bRunState = False Then Return
If $ReturnAll = False Then
Return Number($RemainTrainSpace[2])
Else
Return $RemainTrainSpace
EndIf
EndFunc
Func OpenArmyWindow()
ClickP($aAway, 2, 0, "#0346")
If $g_bRunState = False Then Return
If _Sleep($iDelayRunBot3) Then Return
If IsMainPage() = False Then
SetLog("Can not open Army Overview window", $COLOR_RED)
SetError(1)
Return False
EndIf
If WaitforPixel(31, 515 + $g_iBottomOffsetY, 33, 517 + $g_iBottomOffsetY, Hex(0xF8F0E0, 6), 10, 20) Then
If _Sleep($iDelayTrain4) Then Return
If $g_iDebugSetlogTrain = 1 Then SetLog("Click $aArmyTrainButton", $COLOR_GREEN)
If $iUseRandomClick = 0 Then
Click($aArmyTrainButton[0], $aArmyTrainButton[1], 1, 0, "#0293")
Else
ClickR($aArmyTrainButtonRND, $aArmyTrainButton[0], $aArmyTrainButton[1], 1, 0)
EndIf
EndIf
If _Sleep($iDelayTrain4) Then Return
Local $x = 0
While ISArmyWindow(False, $ArmyTAB) = False
If _sleep($iDelayTrain4) Then Return
$x += 1
If $x = 5 And IsMainPage() Then
If _Sleep($iDelayTrain4) Then Return
If $g_iDebugSetlogTrain = 1 Then SetLog("Click $aArmyTrainButton", $COLOR_GREEN)
If $iUseRandomClick = 0 Then
Click($aArmyTrainButton[0], $aArmyTrainButton[1], 1, 0, "#0293")
Else
ClickR($aArmyTrainButtonRND, $aArmyTrainButton[0], $aArmyTrainButton[1], 1, 0)
EndIf
EndIf
If $x = 10 Then
SetError(1)
AndroidPageError("OpenArmyWindow")
Return False
EndIf
WEnd
Return True
EndFunc
Func ISArmyWindow($writelogs = False, $TabNumber = 0)
Local $i = 0
Local $_aIsTrainPgChk1[4] = [816, 136, 0xc40608, 15]
Local $_aIsTrainPgChk2[4] = [843, 183, 0xe8e8e0, 15]
Local $_TabNumber[4][4] = [[147, 128, 0Xf8f8f7, 15], [366, 128, 0Xf8f8f7, 15], [555, 128, 0Xf8f8f7, 15], [758, 128, 0Xf8f8f7, 15]]
Local $CheckIT[4] = [$_TabNumber[$TabNumber][0], $_TabNumber[$TabNumber][1], $_TabNumber[$TabNumber][2], $_TabNumber[$TabNumber][3]]
While $i < 30
If $g_bRunState = False Then Return
If _CheckPixel($_aIsTrainPgChk1, True) And _CheckPixel($_aIsTrainPgChk2, True) And _CheckPixel($CheckIT, True) Then ExitLoop
If _Sleep($iDelayIsTrainPage1) Then ExitLoop
$i += 1
WEnd
If $i <= 28 Then
If($g_iDebugSetlog = 1 Or $g_iDebugClick = 1) And $writelogs = True Then Setlog("**Train Window OK**", $COLOR_DEBUG)
Return True
Else
If $writelogs = True Then SetLog("Cannot find train Window | TAB " & $TabNumber, $COLOR_RED)
If $g_iDebugImageSave = 1 Then DebugImageSave("IsTrainPage_")
Return False
EndIf
EndFunc
Func CheckExistentArmy($txt = "", $showlog = True)
If ISArmyWindow(False, $ArmyTAB) = False Then
OpenArmyWindow()
If _Sleep(1500) Then Return
EndIf
If $txt = "Troops" Then
ResetVariables("Troops")
ResetDropTrophiesVariable()
Local $directory = @ScriptDir & "\imgxml\ArmyTroops"
Local $x = 23, $y = 215, $x1 = 840, $y1 = 255
EndIf
If $txt = "Spells" Then
ResetVariables("Spells")
Local $directory = @ScriptDir & "\imgxml\ArmySpells"
Local $x = 23, $y = 366, $x1 = 585, $y1 = 400
EndIf
If $txt = "Heroes" Then
Local $directory = "armyheroes-bundle"
Local $x = 610, $y = 366, $x1 = 830, $y1 = 400
EndIf
Local $result = SearchArmy($directory, $x, $y, $x1, $y1, $txt)
If UBound($result) > 0 Then
For $i = 0 To UBound($result) - 1
If $g_bRunState = False Then Return
Local $Plural = 0
If $result[$i][0] <> "" Then
If $result[$i][3] > 1 Then $Plural = 1
If StringInStr($result[$i][0], "queued") Then
$result[$i][0] = StringTrimRight($result[$i][0], 6)
If $txt = "Troops" Then
Local $iTroopIndex = TroopIndexLookup($result[$i][0])
If $showlog = True Then
Local $sTroopName =($Plural ? $g_asTroopNamesPlural[$iTroopIndex] : $g_asTroopNames[$iTroopIndex])
Setlog(" - " & $result[$i][3] & " " & $sTroopName & " Queued", $COLOR_BLUE)
EndIf
$g_aiCurrentTroops[$iTroopIndex] += $result[$i][3]
EndIf
If $txt = "Spells" Then
If $result[$i][3] = 0 Then
If $showlog = True Then SetLog(" - No Spells are Brewed", $COLOR_BLUE)
Else
Local $iSpellIndex = TroopIndexLookup($result[$i][0])
If $showlog = True Then Setlog(" - " & $result[$i][3] & " " & $g_asSpellNames[$iSpellIndex - $eLSpell] &($Plural ? " Spells" : " Spell") & " Brewed", $COLOR_BLUE)
$g_aiCurrentSpells[$iSpellIndex - $eLSpell] += $result[$i][3]
EndIf
EndIf
If $txt = "Heroes" Then
Local $iHeroIndex = TroopIndexLookup($result[$i][0])
If ArmyHeroStatus($iHeroIndex) = "heal" Then Setlog("  " & $g_asHeroNames[$iHeroIndex - $eKing] & " Recovering, Remain of " & $result[$i][3], $COLOR_BLUE)
EndIf
Else
If $txt = "Heroes" Then
If $showlog = True Then Setlog(" - " & $g_asHeroNames[TroopIndexLookup($result[$i][0]) - $eKing] & " Recovered", $COLOR_GREEN)
ElseIf $txt = "Troops" Then
Local $iTroopIndex = TroopIndexLookup($result[$i][0])
If $showlog = True Then
Local $sTroopName =($Plural ? $g_asTroopNamesPlural[$iTroopIndex] : $g_asTroopNames[$iTroopIndex])
Setlog(" - " & $result[$i][3] & " " & $sTroopName & " Available", $COLOR_GREEN)
EndIf
$g_aiCurrentTroops[$iTroopIndex] += $result[$i][3]
CanBeUsedToDropTrophies($iTroopIndex, $g_aiCurrentTroops[$iTroopIndex])
Else
If $result[$i][3] = 0 Then
If $showlog = True Then SetLog(" - No Spells are Brewed", $COLOR_GREEN)
Else
Local $iSpellIndex = TroopIndexLookup($result[$i][0])
If $showlog = True Then Setlog(" - " & $result[$i][3] & " " & $g_asSpellNames[$iSpellIndex - $eLSpell] &($Plural ? " Spells" : " Spell") & " Brewed", $COLOR_GREEN)
$g_aiCurrentSpells[$iSpellIndex - $eLSpell] += $result[$i][3]
EndIf
EndIf
EndIf
EndIf
Next
EndIf
If $txt = "Spells" Then
$aCurTotalSpell = GetCurTotalSpells()
EndIf
EndFunc
Func CanBeUsedToDropTrophies($eTroop, $Quantity)
If $eTroop = $eBarb Then
$aDTtroopsToBeUsed[0][1] = $Quantity
ElseIf $eTroop = $eArch Then
$aDTtroopsToBeUsed[1][1] = $Quantity
ElseIf $eTroop = $eGiant Then
$aDTtroopsToBeUsed[2][1] = $Quantity
ElseIf $eTroop = $eGobl Then
$aDTtroopsToBeUsed[4][1] = $Quantity
ElseIf $eTroop = $eWall Then
$aDTtroopsToBeUsed[3][1] = $Quantity
ElseIf $eTroop = $eMini Then
$aDTtroopsToBeUsed[5][1] = $Quantity
EndIf
EndFunc
Func ResetDropTrophiesVariable()
For $i = 0 To(UBound($aDTtroopsToBeUsed, 1) - 1)
$aDTtroopsToBeUsed[$i][1] = 0
Next
EndFunc
Func CheckQueueTroops($getQuantity = True, $showlog = True)
Local $res[1] = [""]
If $showlog Then SetLog("Checking Troops Queue...", $COLOR_BLUE)
Local $directory = "trainwindow-TrainTroops-bundle"
Local $result = SearchArmy($directory, 18, 182, 839, 261)
ReDim $res[UBound($result)]
For $i = 0 To(UBound($result) - 1)
If $g_bRunState = False Then Return
$res[$i] = $result[$i][0]
Next
_ArrayReverse($res)
If $getQuantity Then
Local $Quantities = GetQueueQuantity($res)
If $showlog Then
For $i = 0 To(UBound($Quantities) - 1)
SetLog("  - " & $g_asTroopNames[TroopIndexLookup($Quantities[$i][0])] & ": " & $Quantities[$i][1] & "x", $COLOR_GREEN)
Next
EndIf
EndIf
Return $res
EndFunc
Func CheckQueueSpells($getQuantity = True, $showlog = True)
Local $res[1] = [""]
If $showlog Then SetLog("Checking Spells Queue...", $COLOR_BLUE)
Local $directory = "trainwindow-SpellsInQueue-bundle"
Local $result = SearchArmy($directory, 18, 182, 839, 261)
ReDim $res[UBound($result)]
For $i = 0 To(UBound($result) - 1)
If $g_bRunState = False Then Return
$res[$i] = $result[$i][0]
Next
_ArrayReverse($res)
If $getQuantity Then
Local $Quantities = GetQueueQuantity($res)
If $showlog Then
For $i = 0 To(UBound($Quantities) - 1)
If $g_bRunState = False Then Return
SetLog("  - " & $g_asSpellNames[TroopIndexLookup($Quantities[$i][0]) - $eLSpell] & ": " & $Quantities[$i][1] & "x", $COLOR_GREEN)
Next
EndIf
EndIf
Return $res
EndFunc
Func GetQueueQuantity($AvailableTroops)
If IsArray($AvailableTroops) Then
If $AvailableTroops[0] = "" Or StringLen($AvailableTroops[0]) = 0 Then _ArrayDelete($AvailableTroops, 0)
If $AvailableTroops[UBound($AvailableTroops) - 1] = "" Or StringLen($AvailableTroops[UBound($AvailableTroops) - 1]) = 0 Then _ArrayDelete($AvailableTroops, Number(UBound($AvailableTroops) - 1))
Local $result[UBound($AvailableTroops)][2] = [["", 0]]
Local $x = 770, $y = 189
_CaptureRegion2()
For $i = 0 To(UBound($AvailableTroops) - 1)
If $g_bRunState = False Then Return
Local $OCRResult = getQueueTroopsQuantity($x, $y)
$result[$i][0] = $AvailableTroops[$i]
$result[$i][1] = $OCRResult
$x -= 70
Next
Return $result
EndIf
Return False
EndFunc
Func SearchArmy($directory = "", $x = 0, $y = 0, $x1 = 0, $y1 = 0, $txt = "", $skipReceivedTroopsCheck = False)
Local $aResult[1][4], $aCoordArray[1][2], $aCoords, $aCoordsSplit, $aValue
Local $Redlines = "FV"
For $waiting = 0 To 10
If $g_bRunState = False Then Return $aResult
If getReceivedTroops(162, 200, $skipReceivedTroopsCheck) = False Then
_CaptureRegion2($x, $y, $x1, $y1)
Local $res = DllCall($g_hLibImgLoc, "str", "SearchMultipleTilesBetweenLevels", "handle", $hHBitmap2, "str", $directory, "str", "FV", "Int", 0, "str", $Redlines, "Int", 0, "Int", 1000)
If $res[0] <> "" Then
Local $aKeys = StringSplit($res[0], "|", $STR_NOCOUNT)
ReDim $aResult[UBound($aKeys)][4]
For $i = 0 To UBound($aKeys) - 1
$aResult[$i][0] = returnPropertyValue($aKeys[$i], "objectname")
$aValue = returnPropertyValue($aKeys[$i], "objectpoints")
$aCoords = StringSplit($aValue, "|", $STR_NOCOUNT)
$aCoordsSplit = StringSplit($aCoords[0], ",", $STR_NOCOUNT)
If UBound($aCoordsSplit) = 2 Then
$aCoordArray[0][0] = $aCoordsSplit[0] + $x
$aCoordArray[0][1] = $aCoordsSplit[1]
Else
$aCoordArray[0][0] = -1
$aCoordArray[0][1] = -1
EndIf
$aResult[$i][1] = Number($aCoordArray[0][0])
$aResult[$i][2] = Number($aCoordArray[0][1])
Next
EndIf
ExitLoop
Else
If $waiting = 1 Then Setlog("You have received castle troops! Wait 5's...")
If _Sleep($iDelayTrain8) Then Return $aResult
EndIf
Next
_ArraySort($aResult, 0, 0, 0, 1)
If $txt = "Troops" Then
For $i = 0 To UBound($aResult) - 1
$aResult[$i][3] = Number(getBarracksNewTroopQuantity(Slot($aResult[$i][1], "troop"), 196))
Next
EndIf
If $txt = "Spells" Then
For $i = 0 To UBound($aResult) - 1
$aResult[$i][3] = Number(getBarracksNewTroopQuantity(Slot($aResult[$i][1], "spells"), 341))
Next
EndIf
If $txt = "CCSpells" Then
For $i = 0 To UBound($aResult) - 1
$aResult[$i][3] = Number(getBarracksNewTroopQuantity(Slot($aResult[$i][1], "troop"), 498))
Next
EndIf
If $txt = "Heroes" Then
For $i = 0 To UBound($aResult) - 1
If StringInStr($aResult[$i][0], "Kingqueued") Then
$aResult[$i][3] = getRemainTHero(620, 414)
ElseIf StringInStr($aResult[$i][0], "Queenqueued") Then
$aResult[$i][3] = getRemainTHero(695, 414)
ElseIf StringInStr($aResult[$i][0], "Wardenqueued") Then
$aResult[$i][3] = getRemainTHero(775, 414)
Else
$aResult[$i][3] = 0
EndIf
Next
EndIf
Return $aResult
EndFunc
Func ResetVariables($txt = "")
If $txt = "troops" Or $txt = "all" Then
For $i = 0 To $eTroopCount - 1
If $g_bRunState = False Then Return
$g_aiCurrentTroops[$i] = 0
If _Sleep($iDelayTrain6) Then Return
Next
EndIf
If $txt = "Spells" Or $txt = "all" Then
For $i = 0 To $eSpellCount - 1
If $g_bRunState = False Then Return
$g_aiCurrentSpells[$i] = 0
If _Sleep($iDelayTrain6) Then Return
Next
EndIf
If $txt = "donated" Or $txt = "all" Then
For $i = 0 To $eTroopCount - 1
If $g_bRunState = False Then Return
$g_aiDonateTroops[$i] = 0
If _Sleep($iDelayTrain6) Then Return
Next
EndIf
EndFunc
Func OpenTrainTabNumber($Num, $WhereFrom)
Local $CalledFrom = ""
Local $Message[4] = ["Army Camp", "Train Troops", "Brew Spells", "Quick Train"]
Local $TabNumber[4][2] = [[90, 128], [245, 128], [440, 128], [650, 128]]
If $g_bRunState = False Then Return
If IsTrainPage() Then
Click($TabNumber[$Num][0], $TabNumber[$Num][1], 2, 200)
If _Sleep(1500) Then Return
If ISArmyWindow(False, $Num) Then
If $g_iDebugSetlogTrain = 1 Then $CalledFrom = " (Called from " & $WhereFrom & ")"
Setlog(" - Opened the " & $Message[$Num] & $CalledFrom, $COLOR_ACTION1)
EndIf
Else
Setlog(" - Error Clicking On " &($Num >= 0 And $Num < UBound($Message)) ?($Message[$Num]) :("Not selectable") & " Tab!!!", $COLOR_RED)
EndIf
EndFunc
Func TrainArmyNumber($Num)
$Num = $Num - 1
Local $a_TrainArmy[3][4] = [[817, 366, 0x6bb720, 10], [817, 484, 0x6bb720, 10], [817, 601, 0x6bb720, 10]]
Setlog("Using Quick Train Tab.")
If $g_bRunState = False Then Return
If ISArmyWindow(False, $QuickTrainTAB) Then
If _ColorCheck(_GetPixelColor($a_TrainArmy[$Num][0], $a_TrainArmy[$Num][1], True), Hex($a_TrainArmy[$Num][2], 6), $a_TrainArmy[$Num][3]) Then
Click($a_TrainArmy[$Num][0], $a_TrainArmy[$Num][1], 1)
SetLog("Making the Army " & $Num + 1, $COLOR_INFO)
If _Sleep(1000) Then Return
Else
Setlog(" - Error Clicking On Army: " & $Num + 1 & "| Pixel was :" & _GetPixelColor($a_TrainArmy[$Num][0], $a_TrainArmy[$Num][1], True), $COLOR_ORANGE)
Setlog(" - Please 'edit' the Army " & $Num + 1 & " before start the BOT!!!", $COLOR_RED)
EndIf
Else
Setlog(" - Error Clicking On Army! You are not on Quick Train Window", $COLOR_RED)
EndIf
EndFunc
Func DeleteQueued($TypeQueued, $OffsetQueued = 802)
Local $Slot2Use = -1
If $TypeQueued = "Troops" Then
If ISArmyWindow(False, $TrainTroopsTAB) = False Then OpenTrainTabNumber($TrainTroopsTAB, "DeleteQueued()")
If _Sleep(1500) Then Return
If ISArmyWindow(True, $TrainTroopsTAB) = False Then Return
$Slot2Use = $TrainTroopsTAB
ElseIf $TypeQueued = "Spells" Then
OpenTrainTabNumber($BrewSpellsTAB, "DeleteQueued()")
If _Sleep(1500) Then Return
If ISArmyWindow(True, $BrewSpellsTAB) = False Then Return
$Slot2Use = $BrewSpellsTAB
Else
Return
EndIf
If _Sleep(500) Then Return
Local $x = 0
While Not IsQueueEmpty($Slot2Use, True, False)
If $x = 0 Then SetLog(" - Delete " & $TypeQueued & " Queued!", $COLOR_ACTION)
If _Sleep(20) Then Return
If $g_bRunState = False Then Return
Click($OffsetQueued + 24, 202, 2, 50)
$x += 1
If $x = 250 Then ExitLoop
WEnd
EndFunc
Func Slot($x = 0, $txt = "")
If $g_bRunState = False Then Return
Switch $x
Case $x < 94
If $txt = "troop" Then Return 35
If $txt = "spells" Then Return 40
Case $x > 94 And $x < 171
If $txt = "troop" Then Return 111
If $txt = "spells" Then Return 120
Case $x > 171 And $x < 244
If $txt = "troop" Then Return 184
If $txt = "spells" Then Return 195
Case $x > 244 And $x < 308
If $txt = "troop" Then Return 255
If $txt = "spells" Then Return 272
Case $x > 308 And $x < 393
If $txt = "troop" Then Return 330
If $txt = "spells" Then Return 341
Case $x > 393 And $x < 465
If $txt = "troop" Then Return 403
If $txt = "spells" Then Return 415
Case $x > 465 And $x < 538
If $txt = "troop" Then Return 477
If $txt = "spells" Then Return 485
Case $x > 538 And $x < 611
Return 551
Case $x > 611 And $x < 683
Return 625
Case $x > 683 And $x < 753
Return 694
Case $x > 753 And $x < 825
Return 764
EndSwitch
EndFunc
Func MakingDonatedTroops()
Local $avDefaultTroopGroup[19][6] = [ ["Arch", 1, 1, 25, 0, "e"], ["Giant", 2, 5, 120, 0, "e"], ["Wall", 4, 2, 60, 0, "e"], ["Barb", 0, 1, 20, 0, "e"], ["Gobl", 3, 1, 30, 0, "e"], ["Heal", 7, 14, 600, 0, "e"], ["Pekk", 9, 25, 900, 0, "e"], ["Ball", 5, 5, 300, 0, "e"], ["Wiza", 6, 4, 300, 0, "e"], ["Drag", 8, 20, 900, 0, "e"], ["BabyD", 10, 10, 600, 0, "e"],["Mine", 11, 5, 300, 0, "e"], ["Mini", 0, 2, 45, 0, "d"], ["Hogs", 1, 5, 120, 0, "d"], ["Valk", 2, 8, 300, 0, "d"], ["Gole", 3, 30, 900, 0, "d"], ["Witc", 4, 12, 600, 0, "d"], ["Lava", 5, 30, 900, 0, "d"], ["Bowl", 6, 6, 300, 0, "d"]]
Local $RemainTrainSpace
Local $Plural = 0
Local $areThereDonTroop = 0
Local $areThereDonSpell = 0
For $j = 0 To $eTroopCount - 1
If $g_bRunState = False Then Return
$areThereDonTroop += $g_aiDonateTroops[$j]
Next
For $j = 0 To $eSpellCount - 1
If $g_bRunState = False Then Return
$areThereDonSpell += $g_aiDonateSpells[$j]
Next
If $areThereDonSpell = 0 And $areThereDonTroop = 0 Then Return
SetLog("  making donated troops", $COLOR_ACTION1)
If $areThereDonTroop > 0 Then
For $i = 0 To UBound($avDefaultTroopGroup) - 1
For $j = 0 To $eTroopCount - 1
If $g_asTroopShortNames[$j] = $avDefaultTroopGroup[$i][0] Then
$avDefaultTroopGroup[$i][4] = $g_aiDonateTroops[$j]
$g_aiDonateTroops[$j] = 0
EndIf
Next
Next
If IsTrainPage() And ISArmyWindow(False, $TrainTroopsTAB) = False Then OpenTrainTabNumber($TrainTroopsTAB, "MakingDonatedTroops()")
If _Sleep(1500) Then Return
If ISArmyWindow(True, $TrainTroopsTAB) = False Then Return
For $i = 0 To UBound($avDefaultTroopGroup, 1) - 1
If $g_bRunState = False Then Return
$Plural = 0
If $avDefaultTroopGroup[$i][4] > 0 Then
$RemainTrainSpace = GetOCRCurrent(48, 160)
If $RemainTrainSpace[0] = $RemainTrainSpace[1] Then
For $j = 0 To UBound($avDefaultTroopGroup, 1) - 1
$avDefaultTroopGroup[$j][4] = 0
Next
ExitLoop
EndIf
Local $iTroopIndex = TroopIndexLookup($avDefaultTroopGroup[$i][0])
If $avDefaultTroopGroup[$i][2] * $avDefaultTroopGroup[$i][4] <= $RemainTrainSpace[2] Then
Local $howMuch = $avDefaultTroopGroup[$i][4]
If $avDefaultTroopGroup[$i][5] = "e" Then
TrainIt($iTroopIndex, $howMuch, $g_iTrainClickDelay)
Else
ClickDrag(715, 445 + $g_iMidOffsetY, 220, 445 + $g_iMidOffsetY, 2000)
TrainIt($iTroopIndex, $howMuch, $g_iTrainClickDelay)
ClickDrag(220, 445 + $g_iMidOffsetY, 725, 445 + $g_iMidOffsetY, 2000)
EndIf
Local $sTroopName =($avDefaultTroopGroup[$i][4] > 1 ? $g_asTroopNamesPlural[$iTroopIndex] : $g_asTroopNames[$iTroopIndex])
Setlog(" - Trained " & $avDefaultTroopGroup[$i][4] & " " & $sTroopName, $COLOR_ACTION)
$avDefaultTroopGroup[$i][4] = 0
If _Sleep(1000) Then Return
Else
For $z = 0 To $RemainTrainSpace[2] - 1
$RemainTrainSpace = GetOCRCurrent(48, 160)
If $RemainTrainSpace[0] = $RemainTrainSpace[1] Then
For $j = 0 To UBound($avDefaultTroopGroup, 1) - 1
$avDefaultTroopGroup[$j][4] = 0
Next
ExitLoop(2)
EndIf
If $avDefaultTroopGroup[$i][2] <= $RemainTrainSpace[2] And $avDefaultTroopGroup[$i][4] > 0 Then
Local $howMuch = 1
If $iTroopIndex >= $eBarb And $iTroopIndex <= $eMine Then
TrainIt($iTroopIndex, $howMuch, $g_iTrainClickDelay)
Else
ClickDrag(715, 445 + $g_iMidOffsetY, 220, 445 + $g_iMidOffsetY, 2000)
TrainIt($iTroopIndex, $howMuch, $g_iTrainClickDelay)
ClickDrag(220, 445 + $g_iMidOffsetY, 725, 445 + $g_iMidOffsetY, 2000)
EndIf
Local $sTroopName =($avDefaultTroopGroup[$i][4] > 1 ? $g_asTroopNamesPlural[$iTroopIndex] : $g_asTroopNames[$iTroopIndex])
Setlog(" - Trained " & $avDefaultTroopGroup[$i][4] & " " & $sTroopName, $COLOR_ACTION)
$avDefaultTroopGroup[$i][4] -= 1
If _Sleep(1000) Then Return
Else
ExitLoop
EndIf
Next
EndIf
EndIf
Next
$RemainTrainSpace = GetOCRCurrent(48, 160)
If $RemainTrainSpace[0] < $RemainTrainSpace[1] Then
Local $howMuch = $RemainTrainSpace[2]
TrainIt($eTroopArcher, $howMuch, $g_iTrainClickDelay)
If $RemainTrainSpace[2] > 0 Then $Plural = 1
Setlog(" - Trained " & $howMuch & " archer(s)!", $COLOR_ACTION)
If _Sleep(1000) Then Return
EndIf
For $j = 0 To UBound($avDefaultTroopGroup, 1) - 1
$avDefaultTroopGroup[$j][4] = 0
Next
EndIf
If $areThereDonSpell > 0 Then
If IsTrainPage() And ISArmyWindow(False, 2) = False Then OpenTrainTabNumber(2, "MakingDonatedTroops()")
If _Sleep(1500) Then Return
If ISArmyWindow(True, 2) = False Then Return
For $i = 0 To $eSpellCount - 1
If $g_bRunState = False Then Return
If $g_aiDonateSpells[$i] > 0 Then
Local $pos = GetTrainPos($i + $eLSpell)
Local $howMuch = $g_aiDonateSpells[$i]
TrainIt($eLSpell + $i, $howMuch, $g_iTrainClickDelay)
Setlog(" - Brewed " & $howMuch & " " & $g_asSpellNames[$i] &($howMuch > 1 ? " Spells" : " Spell"), $COLOR_ACTION)
$g_aiDonateTroops[$i] -= $howMuch
EndIf
Next
EndIf
If _Sleep(1000) Then Return
$RemainTrainSpace = GetOCRCurrent(48, 160)
Setlog(" - Current Capacity: " & $RemainTrainSpace[0] & "/" &($RemainTrainSpace[1]))
EndFunc
Func GetOCRCurrent($x_start, $y_start)
Local $FinalResult[3] = [0, 0, 0]
If $g_bRunState = False Then Return $FinalResult
Local $result = getArmyCapacityOnTrainTroops($x_start, $y_start)
If StringInStr($result, "#") Then
Local $resultSplit = StringSplit($result, "#", $STR_NOCOUNT)
$FinalResult[0] = Number($resultSplit[0])
$FinalResult[1] = Number($resultSplit[1])
$FinalResult[2] = $FinalResult[1] - $FinalResult[0]
Else
Setlog("DEBUG | ERROR on GetOCRCurrent", $COLOR_RED)
EndIf
Return $FinalResult
EndFunc
Func CheckIsFullQueuedAndNotFullArmy()
SetLog(" - Checking: FULL Queue and Not Full Army", $COLOR_ACTION1)
Local $CheckTroop[4] = [824, 243, 0x949522, 20]
If $g_bRunState = False Then Return
If IsTrainPage() And ISArmyWindow(False, $TrainTroopsTAB) = False Then OpenTrainTabNumber($TrainTroopsTAB, "CheckIsFullQueuedAndNotFullArmy()")
If _Sleep(1500) Then Return
If ISArmyWindow(True, $TrainTroopsTAB) = False Then Return
Local $ArmyCamp = GetOCRCurrent(48, 160)
If UBound($ArmyCamp) = 3 And $ArmyCamp[2] < 0 Then
If _ColorCheck(_GetPixelColor($CheckTroop[0], $CheckTroop[1], True), Hex($CheckTroop[2], 6), $CheckTroop[3]) Then
SetLog(" - Conditions met: FULL Queue and Not Full Army")
DeleteQueued("Troops")
If _Sleep(500) Then Return
$ArmyCamp = GetOCRCurrent(48, 160)
Local $ArchToMake = $ArmyCamp[2]
If ISArmyWindow(False, $TrainTroopsTAB) Then TrainIt($eArch, $ArchToMake, $g_iTrainClickDelay)
Setlog("Trained " & $ArchToMake & " archer(s)!")
Else
SetLog(" - Conditions NOT met: FULL queue and Not Full Army")
EndIf
EndIf
EndFunc
Func CheckIsEmptyQueuedAndNotFullArmy()
SetLog(" - Checking: Empty Queue and Not Full Army", $COLOR_ACTION1)
Local $CheckTroop[4] = [820, 220, 0xCFCFC8, 15]
Local $CheckTroop1[4] = [390, 130, 0x78BE2B, 15]
If $g_bRunState = False Then Return
If IsTrainPage() And ISArmyWindow(False, $TrainTroopsTAB) = False Then OpenTrainTabNumber($TrainTroopsTAB, "CheckIsEmptyQueuedAndNotFullArmy()")
If _Sleep(1500) Then Return
If ISArmyWindow(True, $TrainTroopsTAB) = False Then Return
Local $ArmyCamp = GetOCRCurrent(48, 160)
If UBound($ArmyCamp) = 3 And $ArmyCamp[2] > 0 Then
If _ColorCheck(_GetPixelColor($CheckTroop[0], $CheckTroop[1], True), Hex($CheckTroop[2], 6), $CheckTroop[3]) Then
If Not _ColorCheck(_GetPixelColor($CheckTroop1[0], $CheckTroop1[1], True), Hex($CheckTroop1[2], 6), $CheckTroop1[3]) Then
SetLog(" - Conditions met: Empty Queue and Not Full Army")
If _Sleep(500) Then Return
$ArmyCamp = GetOCRCurrent(48, 160)
Local $ArchToMake = $ArmyCamp[2]
If ISArmyWindow(False, $TrainTroopsTAB) Then TrainIt($eArch, $ArchToMake, $g_iTrainClickDelay)
SetLog(" - Trained " & $ArchToMake & " archer(s)!")
Else
SetLog(" - Conditions NOT met: Empty queue and Not Full Army")
EndIf
EndIf
EndIf
EndFunc
Func getReceivedTroops($x_start, $y_start, $skip = False)
If $skip = True Then Return False
Local $result = ""
If $g_bRunState = False Then Return
$result = getOcrAndCapture("coc-DonTroops", $x_start, $y_start, 120, 27, True)
If IsString($result) <> "" Or IsString($result) <> " " Then
If StringInStr($result, "you") Then
Return True
Else
Return False
EndIf
Else
Return False
EndIf
EndFunc
Func TestTrainRevamp2()
$g_bRunState = True
$g_iDebugOcr = 1
Setlog("Start......OpenArmy Window.....")
Local $timer = TimerInit()
CheckExistentArmy("Troops")
Setlog("Imgloc Troops Time: " & Round(TimerDiff($timer) / 1000, 2) & "'s")
Setlog("End......OpenArmy Window.....")
$g_iDebugOcr = 0
$g_bRunState = False
EndFunc
Func IIf($Condition, $IfTrue, $IfFalse)
If $Condition = True Then
Return $IfTrue
Else
Return $IfFalse
EndIf
EndFunc
Func ValidateSearchArmyResult($result, $index = 0)
If IsArray($result) Then
If UBound($result) > 0 Then
If StringLen($result[$index][0]) > 0 Then Return True
EndIf
EndIf
Return False
EndFunc
Func CheckValuesCost($Troop = "Arch", $troopQuantity = 1, $DebugLogs = 0)
Local $TempColorToCheck = ""
Local $nElixirCurrent = 0, $nDarkCurrent = 0, $bLocalDebugOCR = 0
If _sleep(1000) Then Return
If $g_bRunState = False Then Return
If $g_iDebugSetlogTrain = 1 Or $DebugLogs Then
$bLocalDebugOCR = $g_iDebugOcr
$g_iDebugOcr = 1
$TempColorToCheck = _GetPixelColor(223, 594, True)
Setlog("CheckValuesCost|ColorToCheck: " & $TempColorToCheck)
EndIf
If _ColorCheck(_GetPixelColor(223, 594, True), Hex(0xE8E8E0, 6), 20) Then
If ISArmyWindow(False, $TrainTroopsTAB) Or ISArmyWindow(False, $BrewSpellsTAB) Then $nElixirCurrent = getResourcesValueTrainPage(315, 594)
Else
If ISArmyWindow(False, $TrainTroopsTAB) Or ISArmyWindow(False, $BrewSpellsTAB) Then $nElixirCurrent = getResourcesValueTrainPage(230, 594)
If ISArmyWindow(False, $TrainTroopsTAB) Or ISArmyWindow(False, $BrewSpellsTAB) Then $nDarkCurrent = getResourcesValueTrainPage(382, 594)
EndIf
If $g_iDebugSetlogTrain = 1 Or $DebugLogs Then
Setlog(" » Current resources:")
Setlog(" - Elixir: " & _NumberFormat($nElixirCurrent) & " / Dark Elixir: " & _NumberFormat($nDarkCurrent), $COLOR_INFO)
$g_iDebugOcr = $bLocalDebugOCR
EndIf
Local $troopCost = 0
Local $iTroopIndex = TroopIndexLookup($Troop)
If $iTroopIndex >= $eBarb And $iTroopIndex <= $eBowl Then
$troopCost = $g_aiTroopCostPerLevel[$iTroopIndex][$g_aiTrainArmyTroopLevel[$iTroopIndex]]
ElseIf $iTroopIndex >= $eLSpell And $iTroopIndex <= $eSkSpell Then
$troopCost = $g_aiSpellCostPerLevel[$iTroopIndex - $eLSpell][$g_aiTrainArmySpellLevel[$iTroopIndex - $eLSpell]]
EndIf
If $g_iDebugSetlogTrain = 1 Or $DebugLogs Then SetLog("Individual Cost " & $Troop & "= " & $troopCost)
$troopCost *= $troopQuantity
If $g_iDebugSetlogTrain = 1 Or $DebugLogs Then SetLog("Total Cost " & $Troop & "= " & $troopCost)
If IsDarkTroop($Troop) Then
If $g_iDebugSetlogTrain = 1 Or $DebugLogs Then SetLog("Dark Troop " & $Troop & " Is Dark Troop")
If $troopCost <= $nDarkCurrent Then
Return True
EndIf
Return False
ElseIf IsElixirSpell($Troop) Then
If $g_iDebugSetlogTrain = 1 Or $DebugLogs Then SetLog("Spell " & $Troop & " Is Elixir Spell")
If $troopCost <= $nElixirCurrent Then
Return True
EndIf
Return False
ElseIf IsDarkSpell($Troop) Then
If $g_iDebugSetlogTrain = 1 Or $DebugLogs Then SetLog("Dark Spell " & $Troop & " Is Dark Spell")
If $troopCost <= $nDarkCurrent Then
Return True
EndIf
Return False
Else
If $troopCost <= $nElixirCurrent Then
If $g_iDebugSetlogTrain = 1 Or $DebugLogs Then SetLog("Troop " & $Troop & " Is Elixir Troop")
Return True
EndIf
Return False
EndIf
EndFunc
Func ThSnipesSkiptrain()
Local $Temp = 0
If IsSearchModeActive($TS) And $IsFullArmywithHeroesAndSpells Then
For $i = 0 To $eTroopCount - 1
If $g_aiArmyCompTroops[$i] > 0 Then $Temp += 1
Next
If $Temp = 1 Then Return False
If $Temp > 1 Then
Setlog("Skipping Training before Attack due to THSnipes!", $COLOR_INFO)
Return True
EndIf
Else
Return False
EndIf
EndFunc
Func TrainIt($iIndex, $howMuch = 1, $iSleep = 400)
If $g_iDebugSetlogTrain = 1 Then SetLog("Func TrainIt $iIndex=" & $iIndex & " $howMuch=" & $howMuch & " $iSleep=" & $iSleep, $COLOR_DEBUG)
Local $bDark =($iIndex >= $eMini And $iIndex <= $eBowl)
Local $pos = GetTrainPos($iIndex)
If IsArray($pos) And $pos[0] <> -1 Then
If _ColorCheck(_GetPixelColor($pos[0], $pos[1], $g_bCapturePixel), Hex($pos[2], 6), $pos[3]) = True Then
Local $FullName = GetFullName($iIndex, $pos)
If IsArray($FullName) Then
Local $RNDName = GetRNDName($iIndex, $pos)
If IsArray($RNDName) Then
TrainClickP($pos, $howMuch, $g_iTrainClickDelay, $FullName, "#0266", $RNDName)
If _Sleep($iSleep) Then Return False
If $OutOfElixir = 1 Then
Setlog("Not enough " &($bDark ? "Dark " : "") & "Elixir to train position " & GetTroopName($iIndex) & " troops!", $COLOR_ERROR)
Setlog("Switching to Halt Attack, Stay Online Mode...", $COLOR_ERROR)
$g_bChkBotStop = True
$g_iCmbBotCond = 18
If Not($fullarmy = True) Then $g_bRestart = True
Return
EndIf
Return True
Else
Setlog("TrainIt position " & GetTroopName($iIndex) & " - RNDName did not return array?", $COLOR_ERROR)
EndIf
Else
Setlog("TrainIt " & GetTroopName($iIndex) & " - FullName did not return array?", $COLOR_ERROR)
EndIf
Else
Local $badPixelColor = _GetPixelColor($pos[0], $pos[1], $g_bCapturePixel)
If $g_iDebugSetlogTrain Then Setlog("Positon X: " & $pos[0] & "| Y : " & $pos[1] & " |Color get: " & $badPixelColor & " | Need: " & $pos[2])
If StringMid($badPixelColor, 1, 2) = StringMid($badPixelColor, 3, 2) And StringMid($badPixelColor, 1, 2) = StringMid($badPixelColor, 5, 2) Then
Setlog("Troop " & GetTroopName($iIndex) & " is not available due to full queue", $COLOR_DEBUG)
Else
Setlog("Bad pixel check on troop position " & GetTroopName($iIndex), $COLOR_ERROR)
If $g_iDebugSetlogTrain = 1 Then Setlog("Train Pixel Color: " & $badPixelColor, $COLOR_DEBUG)
EndIf
EndIf
Else
Setlog("Impossible happened? TrainIt troop position " & GetTroopName($iIndex) & " did not return array", $COLOR_ERROR)
EndIf
EndFunc
Func GetTrainPos(Const $iIndex)
If $g_iDebugSetlogTrain = 1 Then SetLog("Func GetTrainPos $iIndex=" & $iIndex, $COLOR_DEBUG)
If $iIndex >= $eBarb And $iIndex <= $eBowl Then
Local $sDirectory = @ScriptDir & "\imgxml\Train\Train_Train\"
Local $sFilter = String($g_asTroopShortNames[$iIndex]) & "*"
Local $asImageToUse = _FileListToArray($sDirectory, $sFilter, $FLTA_FILES, True)
If $g_iDebugSetlogTrain Then setlog("$asImageToUse Troops: " & $asImageToUse[1])
Return GetVariable($asImageToUse[1], $iIndex)
EndIf
If $iIndex >= $eLSpell And $iIndex <= $eSkSpell Then
Local $sDirectory = @ScriptDir & "\imgxml\Train\Spell_Train\"
Local $sFilter = String($g_asSpellShortNames[$iIndex - $eLSpell]) & "*"
Local $asImageToUse = _FileListToArray($sDirectory, $sFilter, $FLTA_FILES, True)
If $g_iDebugSetlogTrain Then setlog("$asImageToUse Spell: " & $asImageToUse[1])
Return GetVariable($asImageToUse[1], $iIndex)
EndIf
Return 0
EndFunc
Func GetFullName(Const $iIndex, Const $pos)
If $g_iDebugSetlogTrain = 1 Then SetLog("Func GetFullName $iIndex=" & $iIndex, $COLOR_DEBUG)
If $iIndex >= $eBarb And $iIndex <= $eBowl Then
Local $text =($iIndex >= $eMini ? "Dark" : "Normal")
If $g_iDebugSetlogTrain = 1 Then Setlog("Troop Name: " & $g_asTroopNames[$iIndex])
Return GetFullNameSlot($pos, $text)
EndIf
If $iIndex >= $eLSpell And $iIndex <= $eSkSpell Then
Return GetFullNameSlot($pos, "Spell")
EndIf
SetLog("Don't know how to find the full name of troop with index " & $iIndex & " yet")
Local $slotTemp[4] = [-1, -1, -1, -1]
Return $slotTemp
EndFunc
Func GetRNDName(Const $iIndex, Const $pos)
If $g_iDebugSetlogTrain = 1 Then SetLog("Func GetRNDName $iIndex=" & $iIndex, $COLOR_DEBUG)
Local $aReturn[4]
If $iIndex <> -1 Then
Local $aTempCoord = $pos
$aReturn[0] = $aTempCoord[0] - 5
$aReturn[1] = $aTempCoord[1] - 5
$aReturn[2] = $aTempCoord[0] + 5
$aReturn[3] = $aTempCoord[1] + 5
Return $aReturn
EndIf
SetLog("Don't know how to find the RND name of troop with index " & $iIndex & " yet!", $COLOR_ERROR)
Return 0
EndFunc
Func GetVariable(Const $ImageToUse, Const $iIndex)
Local $FinalVariable[4] = [-1, -1, -1, -1]
_CaptureRegion2(25, 375, 840, 548)
Local $res = DllCall($g_hLibImgLoc, "str", "FindTile", "handle", $hHBitmap2, "str", $ImageToUse, "str", "FV", "int", 1)
If @error Then _logErrorDLLCall($g_sLibImgLocPath, @error)
If IsArray($res) Then
If $g_iDebugSetlog = 1 Then SetLog("DLL Call succeeded " & $res[0], $COLOR_ERROR)
If $res[0] = "0" Then
SetLog("No " & GetTroopName($iIndex) & " Icon found!", $COLOR_ERROR)
ElseIf $res[0] = "-1" Then
SetLog("DLL Error", $COLOR_ERROR)
ElseIf $res[0] = "-2" Then
SetLog("Invalid Resolution", $COLOR_ERROR)
Else
If $g_iDebugSetlogTrain Then Setlog("String: " & $res[0])
Local $expRet = StringSplit($res[0], "|", $STR_NOCOUNT)
Local $posPoint = StringSplit($expRet[1], ",", $STR_NOCOUNT)
Local $ButtonX = 25 + Int($posPoint[0])
Local $ButtonY = 375 + Int($posPoint[1])
Local $Colorcheck = "0x" & _GetPixelColor($ButtonX, $ButtonY, $g_bCapturePixel)
Local $Tolerance = 40
Local $FinalVariable[4] = [$ButtonX, $ButtonY, $Colorcheck, $Tolerance]
SetLog(" - " & GetTroopName($iIndex) & " Icon found!", $COLOR_SUCCESS)
If $g_iDebugSetlogTrain Then SetLog("Found: [" & $ButtonX & "," & $ButtonY & "]", $COLOR_SUCCESS)
If $g_iDebugSetlogTrain Then SetLog("Color check: " & $Colorcheck, $COLOR_SUCCESS)
If $g_iDebugSetlogTrain Then SetLog("$Tolerance: " & $Tolerance, $COLOR_SUCCESS)
Return $FinalVariable
EndIf
Else
SetLog("Don't know how to train the troop with index " & $iIndex & " yet")
EndIf
Return $FinalVariable
EndFunc
Func GetFullNameSlot(Const $iTrainPos, Const $sTroopType)
Local $SlotH, $SlotV
If $g_iDebugSetlogTrain Then Setlog("$iTrainPos[0]: " & $iTrainPos[0])
If $g_iDebugSetlogTrain Then Setlog("$iTrainPos[1]: " & $iTrainPos[1])
If $g_iDebugSetlogTrain Then Setlog("$sTroopType" & $sTroopType)
If $sTroopType = "Spell" Then
If UBound($iTrainPos) < 2 Then Setlog("Issue on $iTrainPos!!!")
Switch $iTrainPos[0]
Case $iTrainPos[0] < 101
$SlotH = 101
Case $iTrainPos[0] > 105 And $iTrainPos[0] < 199
$SlotH = 199
Case $iTrainPos[0] > 203 And $iTrainPos[0] < 297
$SlotH = 297
Case $iTrainPos[0] > 302 And $iTrainPos[0] < 395
$SlotH = 404
Case $iTrainPos[0] > 400 And $iTrainPos[0] < 498
$SlotH = 502
Case $iTrainPos[0] > 498 And $iTrainPos[0] < 597
$SlotH = 597
Case Else
If _ColorCheck(_GetPixelColor($iTrainPos[0], $iTrainPos[1], True), Hex(0xd3d3cb, 6), 5) Then
Setlog(" »» This slot is empty!! | Spells", $COLOR_ERROR)
EndIf
EndSwitch
Switch $iTrainPos[1]
Case $iTrainPos[1] < 445
$SlotV = 387
Case $iTrainPos[1] > 445 And $iTrainPos[1] < 550
$SlotV = 488
EndSwitch
Local $ToReturn[4] = [$SlotH, $SlotV, 0x9d9d9d, 20]
If $g_iDebugSetlogTrain Then SetLog(" » GetFullNameSlot Spell Icon found!", $COLOR_SUCCESS)
If $g_iDebugSetlogTrain Then SetLog("Full Train Found: [" & $SlotH & "," & $SlotV & "]", $COLOR_SUCCESS)
Return $ToReturn
EndIf
If $sTroopType = "Normal" Then
If UBound($iTrainPos) < 2 Then Setlog("Issue on $iTrainPos!!!")
Switch $iTrainPos[0]
Case $iTrainPos[0] < 101
$SlotH = 101
Case $iTrainPos[0] > 105 And $iTrainPos[0] < 199
$SlotH = 199
Case $iTrainPos[0] > 199 And $iTrainPos[0] < 297
$SlotH = 297
Case $iTrainPos[0] > 297 And $iTrainPos[0] < 395
$SlotH = 395
Case $iTrainPos[0] > 395 And $iTrainPos[0] < 494
$SlotH = 494
Case $iTrainPos[0] > 494 And $iTrainPos[0] < 592
$SlotH = 592
Case $iTrainPos[0] > 592 And $iTrainPos[0] < 690
$SlotH = 690
Case Else
If _ColorCheck(_GetPixelColor($iTrainPos[0], $iTrainPos[1], True), Hex(0xd3d3cb, 6), 5) Then
Setlog(" »» This slot is empty!! | Normal Troop", $COLOR_ERROR)
EndIf
EndSwitch
Switch $iTrainPos[1]
Case $iTrainPos[1] < 445
$SlotV = 387
Case $iTrainPos[1] > 445 And $iTrainPos[1] < 550
$SlotV = 488
EndSwitch
Local $ToReturn[4] = [$SlotH, $SlotV, 0x9f9f9f, 20]
If $g_iDebugSetlogTrain Then SetLog(" » GetFullNameSlot Normal Icon found!", $COLOR_SUCCESS)
If $g_iDebugSetlogTrain Then SetLog("Full Train Found: [" & $SlotH & "," & $SlotV & "]", $COLOR_SUCCESS)
Return $ToReturn
EndIf
If $sTroopType = "Dark" Then
If UBound($iTrainPos) < 2 Then Setlog("Issue on $iTrainPos!!!")
Switch $iTrainPos[0]
Case $iTrainPos[0] > 440 And $iTrainPos[0] < 517
$SlotH = 517
Case $iTrainPos[0] > 517 And $iTrainPos[0] < 615
$SlotH = 615
Case $iTrainPos[0] > 615 And $iTrainPos[0] < 714
$SlotH = 714
Case $iTrainPos[0] > 714 And $iTrainPos[0] < 812
$SlotH = 812
Case Else
If _ColorCheck(_GetPixelColor($iTrainPos[0], $iTrainPos[1], True), Hex(0xd3d3cb, 6), 5) Then
Setlog(" »» This slot is empty!! | Dark Troop", $COLOR_ERROR)
EndIf
EndSwitch
Switch $iTrainPos[1]
Case $iTrainPos[1] < 445
$SlotV = 397
Case $iTrainPos[1] > 445 And $iTrainPos[1] < 550
$SlotV = 498
EndSwitch
Local $ToReturn[4] = [$SlotH, $SlotV, 0x9f9f9f, 20]
If $g_iDebugSetlogTrain Then SetLog(" » GetFullNameSlot Dark Icon found!", $COLOR_SUCCESS)
If $g_iDebugSetlogTrain Then SetLog("Full Train Found: [" & $SlotH & "," & $SlotV & "]", $COLOR_SUCCESS)
Return $ToReturn
EndIf
EndFunc
Func _ImageSearch($findImage, $resultPosition, ByRef $x, ByRef $y, $Tolerance)
Return _ImageSearchArea($findImage, $resultPosition, 0, 0, 840, 720, $x, $y, $Tolerance)
EndFunc
Func _ImageSearchArea($findImage, $resultPosition, $x1, $y1, $right, $bottom, ByRef $x, ByRef $y, $Tolerance)
Global $HBMP = $hHBitmap
If $g_bChkBackgroundMode = False Then
$HBMP = 0
$x1 += $g_aiBSpos[0]
$y1 += $g_aiBSpos[1]
$right += $g_aiBSpos[0]
$bottom += $g_aiBSpos[1]
EndIf
Local $result
If IsString($findImage) Then
If $Tolerance > 0 Then $findImage = "*" & $Tolerance & " " & $findImage
If $HBMP = 0 Then
$result = DllCall($g_sLibImageSearchPath, "str", "ImageSearch", "int", $x1, "int", $y1, "int", $right, "int", $bottom, "str", $findImage)
Else
$result = DllCall($g_sLibImageSearchPath, "str", "ImageSearchEx", "int", $x1, "int", $y1, "int", $right, "int", $bottom, "str", $findImage, "ptr", $HBMP)
EndIf
Else
$result = DllCall($g_sLibImageSearchPath, "str", "ImageSearchExt", "int", $x1, "int", $y1, "int", $right, "int", $bottom, "int", $Tolerance, "ptr", $findImage, "ptr", $HBMP)
EndIf
If @error Then _logErrorDLLCall($g_sLibImageSearchPath, @error)
If IsArray($result) Then
If $result[0] = "0" Then Return 0
Else
SetLog("Error: Image Search not working...", $COLOR_ERROR)
Return 1
EndIf
Local $array = StringSplit($result[0], "|")
If(UBound($array) >= 4) Then
$x = Int(Number($array[2]))
$y = Int(Number($array[3]))
If $resultPosition = 1 Then
$x = $x + Int(Number($array[4]) / 2)
$y = $y + Int(Number($array[5]) / 2)
EndIf
$x -= $x1
$y -= $y1
Return 1
EndIf
EndFunc
Func hasElixirStorage($bForceCapture = False)
Local $has = False
Local $sCocDiamond = "ECD"
Local $redLines = $IMGLOCREDLINE
Local $minLevel = 0
Local $maxLevel = 1000
Local $maxReturnPoints = 0
Local $returnProps="objectname,objectpoints,objectlevel"
Local $sDirectory = @ScriptDir & "\imgxml\deadbase\elix\storage\"
Local $result = findMultiple($sDirectory ,$sCocDiamond ,$redLines, $minLevel, $maxLevel, $maxReturnPoints , $returnProps, $bForceCapture)
If IsArray($result) then
For $matchedValues In $result
Local $aPoints = StringSplit($matchedValues[1], "|", $STR_NOCOUNT)
Local $found = Ubound($aPoints)
If $found > 0 Then
$has = True
ExitLoop
EndIf
Next
EndIf
Return $has
EndFunc
Func setZombie($RaidedElixir = -1, $AvailableElixir = -1, $Matched = -1, $SearchIdx = -1, $redline = "", $Timestamp = @YEAR & "-" & @MON & "-" & @MDAY & "_" & StringReplace(_NowTime(5), ":", "-"))
If TestCapture() Then Return ""
If $RaidedElixir = -1 And $AvailableElixir = -1 And $Matched = -1 And $SearchIdx = -1 Then
$g_aZombie[0] = ""
$g_aZombie[1] = 0
$g_aZombie[2] = 0
$g_aZombie[3] = 0
$g_aZombie[4] = 0
$g_aZombie[5] = ""
$g_aZombie[6] = ""
Else
If $RaidedElixir >= 0 Then $g_aZombie[1] = Number($RaidedElixir)
If $AvailableElixir >= 0 Then $g_aZombie[2] = Number($AvailableElixir)
If $Matched >= 0 Then $g_aZombie[3] = Number($Matched)
If $SearchIdx >= 0 Then $g_aZombie[4] = Number($SearchIdx)
If $g_aZombie[5] = "" Then $g_aZombie[5] = $Timestamp
If $g_aZombie[6] = "" Then $g_aZombie[6] = $redline
Local $dbFound = $g_aZombie[3] >= $g_iCollectorMatchesMin
Local $path = $g_sProfileTempDebugPath &(($dbFound) ?("Zombies\") :("SkippedZombies\"))
Local $availK = Round($g_aZombie[2] / 1000)
If $g_aZombie[0] = "" And $g_aZombie[4] > 0 Then
Local $create = $g_aZombie[0] = "" And($dbFound = True Or($g_aZombie[8] = -1 And $g_aZombie[9] = -1) Or($availK >= $g_aZombie[8] And hasElixirStorage() = False) Or $availK >= $g_aZombie[9])
If $create = True Then
Local $ZombieFilename = "DebugDB_" & StringFormat("%04i", $availK) & "k_" & $g_sProfileCurrentName & "_search_" & StringFormat("%03i", $g_aZombie[4]) & "_matched_" & $g_aZombie[3] & "_" & $g_aZombie[5] & ".png"
SetDebugLog("Saving enemy village screenshot for deadbase validation: " & $ZombieFilename)
SetDebugLog("Redline was: " & $g_aZombie[6])
$g_aZombie[0] = $ZombieFilename
Local $hBitmapZombie = _GDIPlus_BitmapCreateFromHBITMAP($hHBitmap2)
_GDIPlus_ImageSaveToFile($hBitmapZombie, $path & $g_aZombie[0])
_GDIPlus_BitmapDispose($hBitmapZombie)
EndIf
ElseIf $g_aZombie[0] <> "" Then
Local $raidPct = 0
If $g_aZombie[2] > 0 And $g_aZombie[2] >= $g_aZombie[1] Then
$raidPct = Round((100 * $g_aZombie[1]) / $g_aZombie[2])
EndIf
If $g_aZombie[7] <> -1 And $raidPct >= $g_aZombie[7] And($g_aZombie[10] = -1 Or $g_aZombie[2] >= $g_aZombie[10]) Then
SetDebugLog("Delete enemy village screenshot as base seems dead: " & $g_aZombie[0])
FileDelete($path & $g_aZombie[0])
Else
Local $ZombieFilename = "DebugDB_" & StringFormat("%03i", $raidPct) & "%_" & $g_sProfileCurrentName & "_search_" & StringFormat("%03i", $g_aZombie[4]) & "_matched_" & $g_aZombie[3] & "_" & StringFormat("%04i", $availK) & "k_" & StringFormat("%04i", Round($g_aZombie[1] / 1000)) & "k_" & $g_aZombie[5] & ".png"
SetDebugLog("Rename enemy village screenshot as base seems live: " & $ZombieFilename)
FileMove($path & $g_aZombie[0], $path & $ZombieFilename)
EndIF
setZombie()
Else
setZombie()
EndIf
EndIf
Return $g_aZombie[0]
EndFunc
Func checkDeadBaseNew()
If $g_bCollectorFilterDisable Then
Return True
EndIf
Local $minCollectorLevel = 0
Local $maxCollectorLevel = 0
Local $anyFillLevel[2] = [False, False]
If $g_iDebugSetlog = 1 Then SetLog("Checking Deadbase With IMGLOC START", $COLOR_WARNING)
For $i = 6 To 12
If $g_abCollectorLevelEnabled[$i] Then
If $minCollectorLevel = 0 Then $minCollectorLevel = $i
If $i > $maxCollectorLevel Then $maxCollectorLevel = $i
$anyFillLevel[$g_aiCollectorLevelFill[$i]] = True
EndIf
Next
If $maxCollectorLevel = 0 Then
Return True
EndIf
If $g_iDebugSetlog = 1 Then SetLog("Checking Deadbase With IMGLOC START", $COLOR_WARNING)
Local $TotalMatched = 0
Local $Matched[2] = [-1, -1]
Local $aPoints[0]
_CaptureRegion2()
If $anyFillLevel[0] = True Then
$Matched[0] = imglocIsDeadBase($aPoints, 50, $minCollectorLevel, $maxCollectorLevel, True, False)
If $Matched[0] > 0 Then $TotalMatched += $Matched[0]
EndIf
If $TotalMatched < $g_iCollectorMatchesMin Then
$Matched[1] = imglocIsDeadBase($aPoints, 100, $minCollectorLevel, $maxCollectorLevel, True, False)
If $Matched[1] > 0 Then $TotalMatched += $Matched[1]
EndIf
Local $dbFound = $TotalMatched >= $g_iCollectorMatchesMin
If $dbFound Then
If $g_iDebugSetlog = 1 Then SetLog("IMGLOC : FOUND DEADBASE !!! Matched: " & $TotalMatched & "/" & $g_iCollectorMatchesMin & ": " & UBound($aPoints), $COLOR_GREEN)
Else
If $g_iDebugSetlog = 1 Then
If $Matched[0] = -1 And $Matched[1] = -1 Then
SetLog("IMGLOC : NOT A DEADBASE!!! ", $COLOR_INFO)
Else
SetLog("IMGLOC : DEADBASE NOT MATCHED Matched: " & $TotalMatched & "/" & $g_iCollectorMatchesMin , $COLOR_WARNING)
EndIf
EndIf
EndIF
$g_aZombie[3] = $TotalMatched
If $g_iDebugDeadBaseImage = 1 Then
setZombie(0, $searchElixir, $TotalMatched, $SearchCount, $IMGLOCREDLINE)
EndIf
Return $dbFound
EndFunc
Func checkDeadBase()
Return checkDeadBaseSuperNew(False)
EndFunc
Func GetCollectorIndexByFillLevel($level)
If Number($level) >= 85 Then Return 1
Return 0
EndFunc
Func imglocIsDeadBase(ByRef $aPos, $FillLevel = 100, $minCollectorLevel = 0, $maxCollectorLevel = 1000, $CheckConfig = False, $bForceCapture = True)
Local $sCocDiamond = "ECD"
Local $redLines = $IMGLOCREDLINE
Local $minLevel = $minCollectorLevel
Local $maxLevel = $maxCollectorLevel
Local $maxReturnPoints = 0
Local $returnProps="objectname,objectpoints,objectlevel"
Local $sDirectory = @ScriptDir & "\imgxml\deadbase\elix\" & $FillLevel & "\"
Local $matchedValues
Local $TotalMatched = 0
Local $fillIndex = GetCollectorIndexByFillLevel($FillLevel)
If $g_iDebugSetlog = 1 Then SetLog("IMGLOC : Searching Deadbase for FillLevel/MinLevel/MaxLevel: " & $FillLevel & "/" & $minLevel & "/" & $maxLevel & " using "& $sDirectory, $COLOR_INFO)
Local $result = findMultiple($sDirectory ,$sCocDiamond ,$redLines, $minLevel, $maxLevel, $maxReturnPoints , $returnProps, $bForceCapture)
If IsArray($result) then
For $matchedValues In $result
Local $aPoints = StringSplit($matchedValues[1], "|", $STR_NOCOUNT)
Local $found = Ubound($aPoints)
If $CheckConfig = True Then
Local $level = Number($matchedValues[2])
If $g_abCollectorLevelEnabled[$level] Then
If $fillIndex < $g_aiCollectorLevelFill[$level] Then
$found = 0
EndIf
Else
$found = 0
EndIf
EndIf
If $found > 0 Then
For $sPoint in $aPoints
Local $aP = StringSplit($sPoint, ",", $STR_NOCOUNT)
Local $bSkipPoint = False
For $bP in $aPos
Local $a = $aP[1] - $bP[1]
Local $b = $aP[0] - $bP[0]
Local $c = Sqrt($a * $a + $b * $b)
If $c < 25 Then
If $g_iDebugSetlog = 1 Then SetLog("IMGLOC : Searching Deadbase ignore duplicate collector " & $matchedValues[0] & " at " & $aP[0] & ", " & $aP[1], $COLOR_INFO)
$bSkipPoint = True
$found -= 1
ExitLoop
EndIf
Next
If $bSkipPoint = False Then
Local $i = UBound($aPos)
ReDim $aPos[$i + 1]
$aPos[$i] = $aP
EndIf
Next
EndIf
$TotalMatched += $found
Next
Else
$TotalMatched = -1
EndIf
Return $TotalMatched
EndFunc
Func checkDeadBaseSuperNew($bForceCapture = True, $sFillDirectory = @ScriptDir & "\imgxml\deadbase\elix\fill\", $sLvlDirectory = @ScriptDir & "\imgxml\deadbase\elix\lvl\")
If $g_bCollectorFilterDisable Then
Return True
EndIf
Local $minCollectorLevel = 0
Local $maxCollectorLevel = 0
Local $anyFillLevel[2] = [False, False]
If $g_iDebugSetlog = 1 Then SetLog("Checking Deadbase With IMGLOC START (super new)", $COLOR_WARNING)
For $i = 6 To 12
If $g_abCollectorLevelEnabled[$i] Then
If $minCollectorLevel = 0 Then $minCollectorLevel = $i
If $i > $maxCollectorLevel Then $maxCollectorLevel = $i
$anyFillLevel[$g_aiCollectorLevelFill[$i]] = True
EndIf
Next
If $maxCollectorLevel = 0 Then
Return True
EndIf
If $g_iDebugSetlog = 1 Then SetLog("Checking Deadbase With IMGLOC START", $COLOR_WARNING)
Local $TotalMatched = 0
Local $aPoints[0]
Local $aPos[0]
Local $sCocDiamond = "ECD"
Local $redLines = $IMGLOCREDLINE
Local $minLevel = 0
Local $maxLevel = 1000
Local $maxReturnPoints = 0
Local $returnProps="objectname,objectpoints,objectlevel,fillLevel"
Local $matchedValues
Local $TotalMatched = 0
Local $x, $y, $lvl, $fill
Local $result = findMultiple($sFillDirectory, $sCocDiamond, $redLines, $minLevel, $maxLevel, $maxReturnPoints, $returnProps, $bForceCapture)
Local $foundFilledCollectors = IsArray($result) = 1
If $foundFilledCollectors = True Then
For $matchedValues In $result
Local $aPoints = StringSplit($matchedValues[1], "|", $STR_NOCOUNT)
Local $found = Ubound($aPoints)
If $found > 0 Then
$lvl = Number($matchedValues[3])
For $sPoint in $aPoints
Local $aP = StringSplit($sPoint, ",", $STR_NOCOUNT)
ReDim $aP[4]
$aP[3] = 0
$aP[2] = $lvl
Local $bSkipPoint = False
For $i = 0 To UBound($aPos) - 1
Local $bP = $aPos[$i]
Local $a = $aP[1] - $bP[1]
Local $b = $aP[0] - $bP[0]
Local $c = Sqrt($a * $a + $b * $b)
If $c < 25 Then
If $aP[2] > $bP[2] Then
$aPos[$i] = $aP
$aP = $bP
EndIf
If $g_iDebugSetlog = 1 Then SetLog("IMGLOC : Searching Deadbase ignore duplicate collector with fill level " & $aP[2] & " at " & $aP[0] & ", " & $aP[1], $COLOR_INFO)
$bSkipPoint = True
$found -= 1
ExitLoop
EndIf
Next
If $bSkipPoint = False Then
Local $i = UBound($aPos)
ReDim $aPos[$i + 1]
$aPos[$i] = $aP
EndIf
Next
EndIf
Next
For $aP in $aPos
$x = $aP[0]
$y = $aP[1]
$fill = $aP[2]
$lvl = $aP[3]
$sCocDiamond =($x - 20) & "," &($y - 25) & "|" &($x + 20) & "," &($y - 25) & "|" &($x + 20) & "," &($y + 15) & "|" &($x - 20) & "," &($y + 15)
$redLines = $sCocDiamond
$result = findMultiple($sLvlDirectory, $sCocDiamond, $redLines, $minLevel, $maxLevel, $maxReturnPoints, $returnProps, $bForceCapture)
$bForceCapture = False
If IsArray($result) then
For $matchedValues In $result
Local $aPoints = StringSplit($matchedValues[1], "|", $STR_NOCOUNT)
If Ubound($aPoints) > 0 Then
$lvl = Number($matchedValues[2])
If $lvl > $aP[3] Then $aP[3] = $lvl
EndIf
Next
EndIf
$lvl = $aP[3]
If $lvl = 0 Then
If $g_iDebugSetlog = 1 Then SetLog("IMGLOC : Searching Deadbase no collector identified with fill level " & $fill & " at " & $x & ", " & $y, $COLOR_INFO)
ContinueLoop
EndIF
If $g_abCollectorLevelEnabled[$lvl] Then
Local $fillIndex = GetCollectorIndexByFillLevel($fill)
If $fillIndex < $g_aiCollectorLevelFill[$lvl] Then
If $g_iDebugSetlog = 1 Then SetLog("IMGLOC : Searching Deadbase collector level " & $lvl & " found but not enough elixir, fill level " & $fill & " at " & $x & ", " & $y, $COLOR_INFO)
ContinueLoop
EndIf
Else
If $g_iDebugSetlog = 1 Then SetLog("IMGLOC : Searching Deadbase collector level " & $lvl & " found but not enabled, fill level " & $fill & " at " & $x & ", " & $y, $COLOR_INFO)
ContinueLoop
EndIf
$TotalMatched += 1
Next
EndIf
Local $dbFound = $TotalMatched >= $g_iCollectorMatchesMin
If $g_iDebugSetlog = 1 Then
If $foundFilledCollectors = False Then
SetLog("IMGLOC : NOT A DEADBASE!!!", $COLOR_INFO)
ElseIf $dbFound = False Then
SetLog("IMGLOC : DEADBASE NOT MATCHED: " & $TotalMatched & "/" & $g_iCollectorMatchesMin , $COLOR_WARNING)
Else
SetLog("IMGLOC : FOUND DEADBASE !!! Matched: " & $TotalMatched & "/" & $g_iCollectorMatchesMin & ": " & UBound($aPoints), $COLOR_GREEN)
EndIf
EndIf
$g_aZombie[3] = $TotalMatched
If $g_iDebugDeadBaseImage = 1 Then
setZombie(0, $searchElixir, $TotalMatched, $SearchCount, $IMGLOCREDLINE)
EndIf
Return $dbFound
EndFunc
Func checkDeadBaseFolder($directory, $executeOldCode = "checkDeadBaseNew()", $executeNewCode = "checkDeadBaseSuperNew()")
Local $aFiles = _FileListToArray($directory, "*.png", $FLTA_FILES)
If IsArray($aFiles) = 0 Then Return False
If $aFiles[0] = 0 Then Return False
Local $wasDebugsetlog = $g_iDebugSetlog
$g_iDebugSetlog = 0
SetLog("Checking " & $aFiles[0] & " village screenshots for dead base...")
DirCreate($directory & "\better")
DirCreate($directory & "\worse")
DirCreate($directory & "\same")
Local $iTotalMsSuperNew = 0
Local $iTotalMsNew = 0
Local $iSuperNewFound = 0
Local $iNewFound = 0
Local $iBetter = 0
Local $iWorse = 0
Local $iSame = 0
For $i = 1 To $aFiles[0]
Local $sFile = $aFiles[$i]
Local $srcFile = $directory & "\" & $sFile
Local $hBMP = _GDIPlus_BitmapCreateFromFile($directory & "\" & $sFile)
Local $hHBMP = _GDIPlus_BitmapCreateDIBFromBitmap($hBMP)
_GDIPlus_BitmapDispose($hBMP)
TestCapture($hHBMP)
$IMGLOCREDLINE = ""
SearchRedLines()
SearchZoomOut(False, True, "checkDeadBaseFolder", False, False)
ConvertInternalExternArea()
For $j = 1 to 2
If Mod($i + $j, 2) = 0 Then
Local $hTimer = TimerInit()
Execute($executeOldCode)
Local $iMsNew = TimerDiff($hTimer)
$iTotalMsNew += $iMsNew
$iMsNew = Round($iMsNew)
Local $new = $g_aZombie[3]
$iNewFound += $new
Else
$hTimer = TimerInit()
Execute($executeNewCode)
Local $iMsSuperNew = TimerDiff($hTimer)
$iTotalMsSuperNew += $iMsSuperNew
$iMsSuperNew = Round($iMsSuperNew)
Local $superNew = $g_aZombie[3]
$iSuperNewFound += $superNew
EndIf
Next
_WinAPI_DeleteObject($hHBMP)
TestCapture(0)
Local $result = ""
If $superNew > $new Then
SetLog(StringFormat("%5i/%5i", $i, $aFiles[0]) & ": Dead base result: BETTER : " & $superNew & " > " & $new & " (" & StringFormat("%4i/%4i", $iMsSuperNew, $iMsNew) & " ms.) " & $srcFile)
$result = "better"
$iBetter += 1
ElseIf $superNew < $new Then
SetLog(StringFormat("%5i/%5i", $i, $aFiles[0]) & ": Dead base result: WORSE  : " & $superNew & " < " & $new & " (" & StringFormat("%4i/%4i", $iMsSuperNew, $iMsNew) & " ms.) " & $srcFile)
$result = "worse"
$iWorse += 1
Else
SetLog(StringFormat("%5i/%5i", $i, $aFiles[0]) & ": Dead base result: SAME   : " & $superNew & " = " & $new & " (" & StringFormat("%4i/%4i", $iMsSuperNew, $iMsNew) & " ms.) " & $srcFile)
$result = "same"
$iSame += 1
EndIf
Local $dstFile = $directory & "\" & $result & "\" & $sFile
FileMove($srcFile, $dstFile)
Next
SetLog("Checking dead base completed")
SetLog("Super new image detection BETTER : " & $iBetter)
SetLog("Super new image detection WORSE  : " & $iWorse)
SetLog("Super new image detection SAME   : " & $iSame)
SetLog("Collectos found (Super new/new)  : " & $iSuperNewFound & " / " & $iNewFound)
SetLog("Duration in ms. (Super new/new)  : " & Round($iTotalMsSuperNew) & " / " & Round($iTotalMsNew))
$g_iDebugSetlog = $wasDebugsetlog
Return True
EndFunc
Func CheckTombs()
If Not TestCapture() Then
If $g_bChkTombstones = False Then Return False
If $NotNeedAllTime[1] = 0 Then Return
EndIf
Local $hTimer = TimerInit()
Local $directory = @ScriptDir & "\imgxml\Resources\Tombs"
Local $return[7] = ["None", "None", 0, 0, 0, "", ""]
Local $TombsXY[2] = [0, 0]
Local $aResult = returnSingleMatchOwnVillage($directory)
If UBound($aResult) > 1 Then
For $i = 1 To UBound($aResult) - 1
If Number($aResult[$i][2]) > Number($return[2]) Then
$return[0] = $aResult[$i][0]
$return[1] = $aResult[$i][1]
$return[4] = $aResult[$i][4]
$return[5] = $aResult[$i][5]
EndIf
Next
$TombsXY = $return[5]
If $g_iDebugSetlog = 1 Then SetLog("Filename :" & $return[0])
If $g_iDebugSetlog = 1 Then SetLog("Type :" & $return[1])
If $g_iDebugSetlog = 1 Then SetLog("Total Objects :" & $return[4])
Local $bRemoved = False
If IsArray($TombsXY) Then
For $j = 0 To UBound($TombsXY) - 1
If isInsideDiamondXY($TombsXY[$j][0], $TombsXY[$j][1]) Then
If $g_iDebugSetlog = 1 Then Setlog("Coords :" & $TombsXY[$j][0] & "," & $TombsXY[$j][1])
If IsMainPage() Then
Click($TombsXY[$j][0], $TombsXY[$j][1], 1, 0, "#0430")
If $bRemoved = False Then $bRemoved = IsMainPage()
EndIf
EndIf
Next
EndIf
If $bRemoved Then
Setlog("Tombs removed!", $COLOR_DEBUG1)
$NotNeedAllTime[1] = 0
Else
Setlog("Tombs not removed, please do manually!", $COLOR_WARNING)
EndIf
Else
Setlog("No Tombs Found!", $COLOR_SUCCESS)
$NotNeedAllTime[1] = 0
EndIf
checkMainScreen(False)
EndFunc
Func CleanYard()
If $g_bChkCleanYard = False And $g_bChkGemsBox = False And Not TestCapture() Then Return
Local $hObstaclesTimer = TimerInit()
If getBuilderCount() = False Then Return
If _Sleep($iDelayRespond) Then Return
Local $directory = @ScriptDir & "\imgxml\Resources\Obstacles"
If $iDetectedImageType = 1 then $directory = @ScriptDir & "\imgxml\Obstacles_Snow"
Local $Filename = ""
Local $Locate = 0
Local $CleanYardXY
Local $sCocDiamond = $CocDiamondECD
Local $redLines = $sCocDiamond
Local $minLevel = 0
Local $maxLevel = 1000
Local $maxReturnPoints = 10
Local $returnProps = "objectname,objectlevel,objectpoints"
Local $bForceCapture = True
Local $NoBuilders = $iFreeBuilderCount < 1
If $iFreeBuilderCount > 0 And $g_bChkCleanYard = True And Number($iElixirCurrent) > 50000 Then
Local $aResult = findMultiple($directory, $sCocDiamond, $redLines, $minLevel, $maxLevel, $maxReturnPoints, $returnProps, $bForceCapture)
If IsArray($aResult) then
For $matchedValues In $aResult
Local $aPoints = decodeMultipleCoords($matchedValues[2])
$Filename = $matchedValues[0]
For $i = 0 To UBound($aPoints) - 1
$CleanYardXY = $aPoints[$i]
If isInsideDiamondXY($CleanYardXY[0], $CleanYardXY[1]) Then
If $g_iDebugSetlog = 1 Then SetLog($Filename & " found (" & $CleanYardXY[0] & "," & $CleanYardXY[1] & ")", $COLOR_SUCCESS)
If IsMainPage() Then Click($CleanYardXY[0], $CleanYardXY[1], 1, 0, "#0430")
$Locate = 1
If _Sleep($iDelayCollect3) Then Return
If IsMainPage() Then GemClick($aCleanYard[0], $aCleanYard[1], 1, 0, "#0431")
If _Sleep($iDelayCheckTombs2) Then Return
ClickP($aAway, 2, 300, "#0329")
If _Sleep($iDelayCheckTombs1) Then Return
If getBuilderCount() = False Then Return
If _Sleep($iDelayRespond) Then Return
If $iFreeBuilderCount = 0 Then
Setlog("No More Builders available")
If _Sleep(2000) Then Return
ExitLoop(2)
EndIf
EndIf
Next
Next
EndIf
EndIf
Local $directoryGemBox = @ScriptDir & "\imgxml\Resources\GemBox"
Local $return[7] = ["None", "None", 0, 0, 0, "", ""]
Local $GemBoxXY[2] = [0, 0]
If($iFreeBuilderCount > 0 And $g_bChkGemsBox = True And Number($iElixirCurrent) > 50000) Or TestCapture() Then
Local $aResult = multiMatches($directoryGemBox, 1, $sCocDiamond, $sCocDiamond)
If UBound($aResult) > 1 Then
For $i = 1 To UBound($aResult) - 1
If Number($aResult[$i][2]) > Number($return[2]) Then
$return[0] = $aResult[$i][0]
$return[1] = $aResult[$i][1]
$return[4] = $aResult[$i][4]
$return[5] = $aResult[$i][5]
EndIf
Next
$GemBoxXY = $return[5]
If $g_iDebugSetlog = 1 Then SetLog("Filename :" & $return[0])
If $g_iDebugSetlog = 1 Then SetLog("Type :" & $return[1])
If $g_iDebugSetlog = 1 Then SetLog("Total Objects :" & $return[4])
If IsArray($GemBoxXY) Then
For $j = 0 To UBound($GemBoxXY) - 1
If $g_iDebugSetlog = 1 Then Setlog("Coords :" & $GemBoxXY[$j][0] & "," & $GemBoxXY[$j][1])
If isInsideDiamondXY($GemBoxXY[$j][0], $GemBoxXY[$j][1]) Then
If IsMainPage() Then Click($GemBoxXY[$j][0], $GemBoxXY[$j][1], 1, 0, "#0430")
If _Sleep($iDelayCheckTombs2) Then Return
$Locate = 1
If _Sleep($iDelayCollect3) Then Return
If IsMainPage() Then Click($aCleanYard[0], $aCleanYard[1], 1, 0, "#0431")
If _Sleep($iDelayCheckTombs2) Then Return
ClickP($aAway, 2, 300, "#0329")
If _Sleep($iDelayCheckTombs1) Then Return
If getBuilderCount() = False Then Return
If _Sleep($iDelayRespond) Then Return
If $iFreeBuilderCount = 0 Then
Setlog("No More Builders available")
If _Sleep(2000) Then Return
ExitLoop
EndIf
EndIf
Next
EndIf
Setlog("GemBox removed!", $COLOR_DEBUG1)
Else
Setlog("No GemBox Found!", $COLOR_SUCCESS)
EndIf
EndIf
If $NoBuilders Then
SetLog("No Builders available to remove Obstacles!")
Else
If $Locate = 0 And $g_bChkCleanYard = True And Number($iElixirCurrent) > 50000 Then SetLog("No Obstacles found, Yard is clean!", $COLOR_SUCCESS)
If $g_iDebugSetlog = 1 Then SetLog("Time: " & Round(TimerDiff($hObstaclesTimer) / 1000, 2) & "'s", $COLOR_SUCCESS)
EndIf
UpdateStats()
ClickP($aAway, 1, 300, "#0329")
EndFunc
Func imglocOpenTrainWindow()
Local $ChatCollapseBtn = isButtonVisible("ChatCollapseBtn",@ScriptDir & "\imgxml\imglocbuttons\chatopen\CollapseChat_0_94.xml","315,330,350,350")
If $ChatCollapseBtn <> "" then ClickP(decodeSingleCoord($ChatCollapseBtn),1,300,"ChatCollapseBtn")
If imglocMainScreenReady() Then
Local $OpenTrainBtn = isButtonVisible("OpenTrainBtn",@ScriptDir & "\imgxml\imglocbuttons\mainwindow\OpenTrainWindow_0_94.xml","15,560,65,610")
If $OpenTrainBtn <> "" then ClickP(decodeSingleCoord($openTrainBtn),1,300,"OpenTrainBtn")
Else
SetLog("Could Not Open Train Window : ", $COLOR_INFO )
EndIf
EndFunc
Func IsScreenOpen($sScreenName, $sDirectory, $sCocDiamond, $NeededRefs )
If $g_iDebugSetlog = 1 Then SetLog("imgloc Searching for : " & $sScreenName & " in " & $sCocDiamond & " using "& $sDirectory, $COLOR_INFO)
Local $redLines = $sCocDiamond
Local $minLevel=0
Local $maxLevel=1000
Local $maxReturnPoints = 1
Local $returnProps="objectname,objectpoints"
Local $bForceCapture = True
Local $FoundRefs=0
If $g_iDebugSetlog = 1 Then SetLog("imgloc MainScreen search Start", $COLOR_DEBUG)
Local $hTimer = TimerInit()
Local $result = findMultiple($sDirectory ,$sCocDiamond ,$redLines, $minLevel, $maxLevel, $maxReturnPoints , $returnProps, $bForceCapture )
If IsArray($result) then
For $fv = 0 to Ubound($result) - 1
Local $propsValues = $result[$fv]
If $g_iDebugSetlog = 1 Then SetLog("imgloc Found: " & $propsValues[0] & " at " & $propsValues[1], $COLOR_INFO)
If $propsValues[0] <> "" And $propsValues[1] <> "" then
$FoundRefs = $FoundRefs + 1
EndIf
Next
Else
If $g_iDebugSetlog = 1 Then SetLog("imgloc Could not find " & $sScreenName & "!", $COLOR_WARNING)
If $g_iDebugSetlog = 1 Then SetLog("imgloc " & $sScreenName & " Calculated  (in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds) :")
Return False
EndIf
If $FoundRefs = $NeededRefs then
Return True
Else
Return False
EndIf
EndFunc
Func isButtonVisible($sBtnName,$sbtnTile,$sBtnPlace)
If $g_iDebugSetlog = 1 Then SetLog("isButtonVisible : looking for " & $sBtnName & " in " & $sBtnPlace & " with " & $sbtnTile, $COLOR_ORANGE)
Local $result
Local $RetunrCoords = ""
$result = FindImageInPlace($sBtnName,$sbtnTile,$sBtnPlace)
If $result<>"" Then
If $g_iDebugSetlog = 1 Or $g_iDebugClick = 1 Then SetLog($sBtnName & " is Visible!", $COLOR_ORANGE)
$RetunrCoords = $result
Return $RetunrCoords
Else
If($g_iDebugSetlog = 1 Or $g_iDebugClick = 1) Then SetLog($sBtnName & " is NOT Visible!", $COLOR_ORANGE)
If $g_iDebugImageSave = 1 Then DebugImageSave("imglocIsMainChatOpenPage")
Return $RetunrCoords
EndIF
EndFunc
Func imglocMainScreenReady()
Local $ChatCollapseBtn = isButtonVisible("ChatCollapseBtn",@ScriptDir & "\imgxml\imglocbuttons\chatopen\CollapseChat_0_94.xml","315,330,350,350")
If $ChatCollapseBtn <> "" then ClickP(decodeSingleCoord($ChatCollapseBtn),1,300,"ChatCollapseBtn")
Local $ObjBtn
Local $ReturnValue = True
$ObjBtn = isButtonVisible("AttackBtn",@ScriptDir & "\imgxml\imglocbuttons\mainwindow\Attack_0_95.xml","10,640,110,715")
If $ObjBtn = "" then
If $g_iDebugSetlog = 1 Then SetLog("Main Screen is NOT Visible  : AttackBtn NOT VISIBLE!" , $COLOR_ORANGE)
$ReturnValue = False
Return False
EndIf
$ObjBtn = isButtonVisible("OpenTrainBtn",@ScriptDir & "\imgxml\imglocbuttons\mainwindow\OpenTrainWindow_0_94.xml","15,560,65,610")
If $ObjBtn = "" then
If $g_iDebugSetlog = 1 Then SetLog("Main Screen is NOT Visible  : OpenTrainBtn NOT VISIBLE!" , $COLOR_ORANGE)
$ReturnValue = False
Return False
EndIf
$ObjBtn = isButtonVisible("ExpandChatBtn",@ScriptDir & "\imgxml\imglocbuttons\mainwindow\ExpandChat_0_91.xml","0,320,40,440")
If $ObjBtn = "" then
If $g_iDebugSetlog = 1 Then SetLog("Main Screen is NOT Visible : ExpandChatBtn NOT VISIBLE!" , $COLOR_ORANGE)
$ReturnValue = False
Return False
EndIf
if $ReturnValue = True then SetLog("Main Screen is Visible!", $COLOR_ORANGE)
Return $ReturnValue
EndFunc
Func imglocTestQuickTrain($quickTrainOption=0)
Local $currentRunState = $g_bRunState
$g_bRunState = true
QuickTrain(1,True,True)
$g_bRunState = $currentRunState
EndFunc
Func QuickTrain($quickTrainOption, $bOpenAndClose = True,$forceDebug=false)
if $g_iDebugImageSave = true then
$forceDebug = true
endif
if $forceDebug = true then SetLog("QUICKTRAINDEBUG : START" , $COLOR_RED)
SetLog("Starting Quick Train", $COLOR_INFO )
Local $retry = 5
If $bOpenAndClose = True Then
imglocOpenTrainWindow()
If _Sleep($g_iQuickTrainButtonRetryDelay) Then Return
EndIf
Local $optBtn
Local $QuickTrainTabArea = "645,110,760,140"
Local $QuickTrainTabBtn
Local $CheckTabBtn
For $rt=0 to $retry
if $forceDebug = true then SetLog("QUICKTRAINDEBUG : Finding QuickTrainTabBtn Retry: " & $rt , $COLOR_RED)
$QuickTrainTabBtn = isButtonVisible("QuickTrainTabBtn",@ScriptDir & "\imgxml\newtrainwindow\QuickTrain_0_0_93.xml",$QuickTrainTabArea)
If $QuickTrainTabBtn <> "" then
if $forceDebug = true then SetLog("QUICKTRAINDEBUG : QuickTrainTabBtn  FOUND Retry: " & $rt & " Clicking Button in: " & $QuickTrainTabBtn, $COLOR_RED)
ClickP(decodeSingleCoord($QuickTrainTabBtn),1,300,"QuickTrainTabBtn")
Else
if $forceDebug = true then SetLog("QUICKTRAINDEBUG : QuickTrainTabBtn  NOT FOUND Retry: " & $rt , $COLOR_RED)
EndIf
If _Sleep($g_iQuickTrainButtonRetryDelay) Then Return
If $QuickTrainTabBtn <> "" then ExitLoop
If $forceDebug = true and $rt = $retry then DebugImageSave("QUICKTRAINDEBUG" , True)
Next
For $rt=0 to $retry
if $forceDebug = true then SetLog("QUICKTRAINDEBUG : Finding CheckTabBtn Retry: " & $rt , $COLOR_RED)
$CheckTabBtn = isButtonVisible("CheckTabBtn",@ScriptDir & "\imgxml\newtrainwindow\CheckTab_0_0_97.xml",$QuickTrainTabArea)
If _Sleep($g_iQuickTrainButtonRetryDelay) Then Return
If $CheckTabBtn <> "" then
if $forceDebug = true then SetLog("QUICKTRAINDEBUG : CheckTabBtn FOUND Retry: " & $rt & " in " & $CheckTabBtn, $COLOR_RED)
ExitLoop
else
if $forceDebug = true then SetLog("QUICKTRAINDEBUG : CheckTabBtn NOT FOUND Retry: " & $rt , $COLOR_RED)
EndIf
if $forceDebug = true and $rt = $retry then DebugImageSave("QUICKTRAINDEBUG" , True)
Next
If $CheckTabBtn = "" Then
SetLog("COULD NOT FIND QUICK TRAIN TAB " , $COLOR_RED)
If $bOpenAndClose = True Then ClickP($aAway, 1, 0, "#0000")
if $forceDebug = true then SetLog("QUICKTRAINDEBUG : END" , $COLOR_RED)
Return
EndIf
if $forceDebug = true then SetLog("QUICKTRAINDEBUG : ALL BUTONS FOUND, CHECKING SELECTED OPTION " & $quickTrainOption , $COLOR_RED)
Local $selBtn="", $region = ""
$optBtn = ""
Switch $quickTrainOption
Case 0
$region = "715,195,835,255"
$optBtn = isButtonVisible("Previous Army",@ScriptDir & "\imgxml\newtrainwindow\TrainPrevious_0_0_92.xml",$region)
$selBtn = "Previous Army"
Case 1
$region = "725,335,840,375"
$optBtn = isButtonVisible("Army1",@ScriptDir & "\imgxml\newtrainwindow\TrainArmy_0_0_92.xml",$region)
$selBtn = "Army1"
Case 2
$region = "725,455,840,495"
$optBtn = isButtonVisible("Army2",@ScriptDir & "\imgxml\newtrainwindow\TrainArmy_0_0_92.xml",$region)
$selBtn = "Army2"
Case 3
$region = "725,570,840,615"
$optBtn = isButtonVisible("Army3",@ScriptDir & "\imgxml\newtrainwindow\TrainArmy_0_0_92.xml",$region)
$selBtn = "Army3"
EndSwitch
if $optBtn <> "" then
if $forceDebug = true then SetLog("QUICKTRAINDEBUG : " & $selBtn & " FOUND , Clicking at " & $optBtn , $COLOR_RED)
ClickP(decodeSingleCoord($optBtn),1,300, $selBtn )
else
if $forceDebug = true then SetLog("QUICKTRAINDEBUG : COULD NOT FIND :" & $selBtn , $COLOR_RED)
if $forceDebug = true then DebugImageSave("QUICKTRAINDEBUG" , True)
if $forceDebug = true then SetLog("QUICKTRAINDEBUG : END" , $COLOR_RED)
endif
SetLog("Quick Train Finished", $COLOR_INFO )
If $bOpenAndClose = True Then ClickP($aAway, 1, 0, "#0000")
EndFunc
Func imglocTrainIfAvailable($nTroopEnum,$iQuantity, $imglocFoundArray)
Local $sTroopName = decodeTroopEnum($nTroopEnum)
If $g_iDebugSetlog = 1 Then SetLog($sTroopName & " / " & $nTroopEnum & " training if available!", $COLOR_DEBUG)
Local $aLineValue
For $iFA = 0 to ubound($imglocFoundArray) -1
$aLineValue = $imglocFoundArray[$iFA]
If $aLineValue[0] = $sTroopName Then
If $g_iDebugSetlog = 1 Then SetLog($sTroopName & " / " & $nTroopEnum & " found. Checking availability!", $COLOR_DEBUG)
Local $tmpRectArea = GetDummyRectangle($aLineValue[1],20)
Local $tmpTileName = $aLineValue[2]
Local $troopBtn = isButtonVisible($aLineValue[1],$tmpTileName,$tmpRectArea)
If $troopBtn <> "" then ClickP(decodeSingleCoord($troopBtn),$iQuantity,300,"$aLineValue[1]")
EndIf
Next
EndFunc
Func imglocFindAvailableToTrain($sTrainType)
Local $sCocDiamond = "15,360|840,365|840,585|15,585"
Local $redLines = $sCocDiamond
Local $minLevel=0
Local $maxLevel=1000
Local $maxReturnPoints = 1
Local $returnProps="objectname,objectpoints,filepath"
Local $sDirectory = @ScriptDir & "\imgxml\newtrainwindow\" & $sTrainType & "\"
If $g_iDebugSetlog = 1 Then SetLog("imgloc Searching Regular Troops :  in " & $sCocDiamond & " using "& $sDirectory, $COLOR_INFO)
Local $bForceCapture = True
If $g_iDebugSetlog = 1 Then SetLog("imgloc train search : " & $sTrainType, $COLOR_DEBUG)
Local $hTimer = TimerInit()
Local $result = findMultiple($sDirectory ,$sCocDiamond ,$redLines, $minLevel, $maxLevel, $maxReturnPoints , $returnProps, $bForceCapture )
Return $result
EndFunc
Func imglocCheckWall()
If _Sleep(500) Then Return
Local $levelWall = $g_iCmbUpgradeWallsLevel + 4
_CaptureRegion2()
SetLog("Searching for Wall(s) level: " & $levelWall & ". Using imgloc: ", $COLOR_SUCCESS)
Local $FoundWalls[1]
$FoundWalls[0] = ""
$FoundWalls = imglocFindWalls($levelWall, "ECD", "ECD", 10)
ClickP($aAway, 1, 0, "#0505")
If($FoundWalls[0] = "") Then
SetLog("No wall(s) level: " & $levelWall & " found.", $COLOR_ERROR)
Else
For $i = 0 To UBound($FoundWalls) - 1
Local $WallCoordsArray = decodeMultipleCoords($FoundWalls[$i])
SetLog("Found: " & UBound($WallCoordsArray) & " possible Wall position: " & $FoundWalls[$i], $COLOR_SUCCESS)
For $fc = 0 To UBound($WallCoordsArray) - 1
Local $aCoord = $WallCoordsArray[$fc]
SetLog("Checking if found position is a Wall and of desired level.", $COLOR_SUCCESS)
GemClick($aCoord[0], $aCoord[1])
If _Sleep(500) Then Return
Local $aResult = BuildingInfo(245, 520 + $g_iBottomOffsetY)
If $aResult[0] = 2 Then
If StringInStr($aResult[1], "wall") = True And Number($aResult[2]) = $levelWall Then
Setlog("Position : " & $aCoord[0] & ", " & $aCoord[1] & " is a Wall Level: " & $levelWall & ".")
Return True
Else
ClickP($aAway, 1, 0, "#0931")
If $g_iDebugSetlog Then
Setlog("Position : " & $aCoord[0] & ", " & $aCoord[1] & " is not a Wall Level: " & $levelWall & ". It was: " & $aResult[1] & ", " & $aResult[2] & " !", $COLOR_DEBUG)
Else
Setlog("Position : " & $aCoord[0] & ", " & $aCoord[1] & " is not a Wall Level: " & $levelWall & ".", $COLOR_ERROR)
SetDebugLog("It was: " & $aResult[1] & ", " & $aResult[2], $COLOR_DEBUG, True)
EndIf
EndIf
Else
ClickP($aAway, 1, 0, "#0932")
EndIf
Next
Next
EndIf
Return False
EndFunc
Func imglocFindWalls($walllevel, $searcharea = "DCD", $redline = "", $maxreturn = 0)
Local $FoundWalls[1] = [""]
Local $directory = @ScriptDir & "\imgxml\Walls"
Local $redLines = $redline
Local $minLevel = $walllevel
Local $maxLevel = $walllevel
Local $maxReturnPoints = $maxreturn
_CaptureRegion2()
Local $result = DllCall($g_sLibImgLocPath, "str", "SearchMultipleTilesBetweenLevels", "handle", $hHBitmap2, "str", $directory, "str", $searcharea, "Int", $maxReturnPoints, "str", $redLines, "Int", $minLevel, "Int", $maxLevel)
Local $error = @error
Local $extError = @extended
If $error Then
_logErrorDLLCall($g_sLibImgLocPath, $error)
SetLog(" imgloc DLL Error imgloc " & $error & " --- " & $extError, $COLOR_RED)
SetError(2, $extError, $error)
Return
EndIf
If checkImglocError($result, "imglocFindWalls") = True Then
Return $FoundWalls
EndIf
If $result[0] <> "" Then
If $g_iDebugSetlog Then SetLog(" imglocFindMyWall search returned : " & $result[0])
Local $aKeys = StringSplit($result[0], "|", $STR_NOCOUNT)
ReDim $FoundWalls[UBound($aKeys)]
For $i = 0 To UBound($aKeys) - 1
Local $aCoords = returnImglocProperty($aKeys[$i], "objectpoints")
$FoundWalls[$i] = $aCoords
Next
EndIf
Return $FoundWalls
EndFunc
Func TestImglocTroopBar()
$g_bRunState = True
$g_iDebugSetlog = 1
$g_iDebugOcr = 1
$g_iDebugImageSave = 1
Setlog("=========== Imgloc ============")
PrepareAttack($DB)
$g_iDebugSetlog = 0
$g_iDebugOcr = 0
$g_iDebugImageSave = 0
$g_bRunState = False
EndFunc
Func AttackBarCheck($Remaining = False)
Local $x = 0, $y = 659, $x1 = 853, $y1 = 698
Static Local $CheckSlot12 = False
Static Local $CheckSlotwHero = False
If Not $Remaining Then
$CheckSlot12 = False
$CheckSlotwHero = False
EndIf
$g_iLSpellLevel = 1
$g_iESpellLevel = 1
Local $aResult[1][6], $aCoordArray[1][2], $aCoords, $aCoordsSplit, $aValue
Local $redLines = "FV"
Local $directory = @ScriptDir & "\imgxml\AttackBar"
If $g_bRunState = False Then Return
_CaptureRegion2($x, $y, $x1, $y1)
Local $strinToReturn = ""
Local $res = DllCall($g_hLibImgLoc, "str", "SearchMultipleTilesBetweenLevels", "handle", $hHBitmap2, "str", $directory, "str", "FV", "Int", 0, "str", $redLines, "Int", 0, "Int", 1000)
If IsArray($res) Then
If $res[0] = "0" Or $res[0] = "" Then
SetLog("Imgloc|AttackBarCheck not found!", $COLOR_RED)
ElseIf StringLeft($res[0], 2) = "-1" Then
SetLog("DLL Error: " & $res[0] & ", AttackBarCheck", $COLOR_RED)
Else
Local $aKeys = StringSplit($res[0], "|", $STR_NOCOUNT)
ReDim $aResult[UBound($aKeys)][6]
For $i = 0 To UBound($aKeys) - 1
If $g_bRunState = False Then Return
$aResult[$i][0] = returnPropertyValue($aKeys[$i], "objectname")
$aValue = returnPropertyValue($aKeys[$i], "objectpoints")
$aCoords = StringSplit($aValue, "|", $STR_NOCOUNT)
$aCoordsSplit = StringSplit($aCoords[0], ",", $STR_NOCOUNT)
If UBound($aCoordsSplit) = 2 Then
$aCoordArray[0][0] = $aCoordsSplit[0]
$aCoordArray[0][1] = $aCoordsSplit[1]
Else
$aCoordArray[0][0] = -1
$aCoordArray[0][1] = -1
EndIf
If $g_iDebugSetlog = 1 Then Setlog($aResult[$i][0] & " | $aCoordArray: " & $aCoordArray[0][0] & "-" & $aCoordArray[0][1])
If UBound($aCoords) > 1 And StringInStr($aResult[$i][0], "Spell") <> 0 Then
If $g_iDebugSetlog = 1 Then Setlog($aResult[$i][0] & " detected twice!")
Local $aCoordsSplit2 = StringSplit($aCoords[1], ",", $STR_NOCOUNT)
If UBound($aCoordsSplit2) = 2 Then
If $aCoordsSplit2[0] < $aCoordsSplit[0] Then
$aCoordArray[0][0] = $aCoordsSplit2[0]
$aCoordArray[0][1] = $aCoordsSplit2[1]
If $g_iDebugSetlog = 1 Then Setlog($aResult[$i][0] & " | $aCoordArray: " & $aCoordArray[0][0] & "-" & $aCoordArray[0][1])
EndIf
Else
$aCoordArray[0][0] = -1
$aCoordArray[0][1] = -1
EndIf
EndIf
$aResult[$i][1] = Number($aCoordArray[0][0])
$aResult[$i][2] = Number($aCoordArray[0][1])
Next
_ArraySort($aResult, 0, 0, 0, 1)
If Not $Remaining Then
$CheckSlot12 = _ColorCheck(_GetPixelColor(17, 643, True), Hex(0x478AC6, 6), 15) Or  _ColorCheck(_GetPixelColor(17, 643, True), Hex(0x434343, 6), 10)
If $g_iDebugSetlog = 1 Then
Setlog(" Slot > 12 _ColorCheck 0x478AC6 at (17," & 643 & "): " & $CheckSlot12, $COLOR_DEBUG)
Local $CheckSlot12Color = _GetPixelColor(17, 643, $g_bCapturePixel)
Setlog(" Slot > 12 _GetPixelColor(17," & 643 & "): " & $CheckSlot12Color, $COLOR_DEBUG)
EndIf
For $i = 0 To UBound($aResult) - 1
If $aResult[$i][0] = "King" Or $aResult[$i][0] = "Queen" Or $aResult[$i][0] = "Warden" Then
$CheckSlotwHero = True
EndIf
Next
EndIf
Local $iSlotCompensation = -6
For $i = 0 To UBound($aResult) - 1
Local $Slottemp
If $aResult[$i][1] > 0 Then
If $g_iDebugSetlog = 1 Then SetLog("SLOT : " & $i, $COLOR_DEBUG)
If $g_iDebugSetlog = 1 Then SetLog("Detection : " & $aResult[$i][0] & "|x" & $aResult[$i][1] & "|y" & $aResult[$i][2], $COLOR_DEBUG)
$Slottemp = SlotAttack(number($aResult[$i][1]), $CheckSlot12, $CheckSlotwHero)
If $g_bRunState = False Then Return
If _Sleep(20) then return
If Ubound($Slottemp) = 2 then
If $g_iDebugSetlog = 1 Then SetLog("OCR : " & $Slottemp[0] & "|SLOT: " & $Slottemp[1], $COLOR_DEBUG)
If $CheckSlotwHero Then $iSlotCompensation = 10
If $aResult[$i][0] = "Castle" Or $aResult[$i][0] = "King" Or $aResult[$i][0] = "Queen" Or $aResult[$i][0] = "Warden" Then
$aResult[$i][3] = 1
$aResult[$i][4] = $Slottemp[1]
Else
$aResult[$i][3] = Number(getTroopCountBig(Number($Slottemp[0]), 636))
$aResult[$i][4] = $Slottemp[1]
If $aResult[$i][3] = "" Or $aResult[$i][3] = 0 Then
$aResult[$i][3] = Number(getTroopCountSmall(Number($Slottemp[0]), 641))
$aResult[$i][4] = $Slottemp[1]
EndIf
If StringInStr($aResult[$i][0], "ESpell") <> 0 and $ichkSmartZap = 1 then
$aResult[$i][5] = getTroopsSpellsLevel(Number($Slottemp[0]) + $iSlotCompensation, 704)
If $aResult[$i][5] <> "" then $g_iESpellLevel = $aResult[$i][5]
If $DebugSmartZap = 1 Then Setlog("EarthQuake Detected with level " & $aResult[$i][5], $COLOR_DEBUG)
EndIf
If StringInStr($aResult[$i][0], "LSpell") <> 0 and $ichkSmartZap = 1 then
$aResult[$i][5] = getTroopsSpellsLevel(Number($Slottemp[0]) + $iSlotCompensation, 704)
If $aResult[$i][5] <> "" then $g_iLSpellLevel = $aResult[$i][5]
If $DebugSmartZap = 1 Then Setlog("Lightning Detected with level " & $aResult[$i][5], $COLOR_DEBUG)
EndIf
EndIf
Else
Setlog("Problem with Attack bar detection!", $COLOR_RED)
SetLog("Detection : " & $aResult[$i][0] & "|x" & $aResult[$i][1] & "|y" & $aResult[$i][2], $COLOR_DEBUG)
$aResult[$i][3] = -1
$aResult[$i][4] = -1
EndIf
$strinToReturn &= "|" & TroopIndexLookup($aResult[$i][0]) & "#" & $aResult[$i][4] & "#" & $aResult[$i][3]
EndIf
Next
EndIf
EndIf
If $g_iDebugImageSave = 1 Then
Local $x = 0, $y = 659, $x1 = 853, $y1 = 698
_CaptureRegion2($x, $y, $x1, $y1)
Local $subDirectory = $g_sProfileTempDebugPath & "AttackBarDetection"
DirCreate($subDirectory)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
Local $filename = String($Date & "_" & $Time & "_.png")
Local $editedImage = _GDIPlus_BitmapCreateFromHBITMAP($hHBitmap2)
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($editedImage)
Local $hPenRED = _GDIPlus_PenCreate(0xFFFF0000, 3)
For $i = 0 To UBound($aResult) - 1
addInfoToDebugImage($hGraphic, $hPenRED, $aResult[$i][0], $aResult[$i][1], $aResult[$i][2])
Next
_GDIPlus_ImageSaveToFile($editedImage, $subDirectory & "\" & $filename)
_GDIPlus_PenDispose($hPenRED)
_GDIPlus_GraphicsDispose($hGraphic)
_GDIPlus_BitmapDispose($EditedImage)
EndIf
$strinToReturn = StringTrimLeft($strinToReturn, 1)
Return $strinToReturn
EndFunc
Func SlotAttack($PosX, $CheckSlot12, $CheckSlotwHero)
Local $Slottemp[2] = [0, 0]
for $i = 0 to 12
If $PosX >= 25 +($i * 73) and $PosX < 98 +($i * 73) then
$Slottemp[0] = 35 +($i * 73)
$Slottemp[1] = $i
If $CheckSlot12 = True Then
$Slottemp[0] -= 13
ElseIf $CheckSlotwHero = False Then
$Slottemp[0] += 8
EndIf
If $g_iDebugSetlog = 1 Then Setlog("Slot: " & $i & " | $x > " & 25 +($i * 73) & " and $x < " & 98 +($i * 73))
If $g_iDebugSetlog = 1 Then Setlog("Slot: " & $i & " | $PosX: " & $PosX & " |  OCR x position: " & $Slottemp[0] & " | OCR Slot: " & $Slottemp[1])
Return $Slottemp
EndIF
If $g_bRunState = False Then Return
next
Return $Slottemp
EndFunc
Func checkMainScreen($Check = True)
Local $iCount, $Result
If $Check = True Then
SetLog("Trying to locate Main Screen")
Else
EndIf
If TestCapture() = False Then
If CheckAndroidRunning(False) = False Then Return
getBSPos()
WinGetAndroidHandle()
If $g_bChkBackgroundMode = False And $HWnD <> 0 Then
AndroidToFront()
EndIf
If $g_bAndroidAdbScreencap = False And _WinAPI_IsIconic($HWnD) Then WinSetState($HWnD, "", @SW_RESTORE)
EndIf
$iCount = 0
While _CheckPixel($aIsMain, $g_bCapturePixel) = False
If TestCapture() Then
SetLog("Main Screen not Located", $COLOR_ERROR)
ExitLoop
EndIf
WinGetAndroidHandle()
If _Sleep($iDelaycheckMainScreen1) Then Return
$Result = checkObstacles()
If $g_iDebugSetlog = 1 Then Setlog("CheckObstacles Result = "&$Result, $COLOR_DEBUG)
If($Result = False And $MinorObstacle = True) Then
$MinorObstacle = False
ElseIf($Result = False And $MinorObstacle = False) Then
RestartAndroidCoC()
Else
$g_bRestart = True
EndIf
waitMainScreen()
If Not $g_bRunState Then Return
If @extended Then Return SetError(1, 1, -1)
If @error Then $iCount += 1
If $iCount > 2 Then
SetLog("Unable to fix the window error", $COLOR_ERROR)
CloseCoC(True)
ExitLoop
EndIf
WEnd
ZoomOut()
If Not $g_bRunState Then Return
If $Check = True Then
SetLog("Main Screen Located", $COLOR_SUCCESS)
Else
EndIf
DisposeWindows()
NotifyPendingActions()
EndFunc
Global $iDPI_Ratio = 1
Func GetDPI_Ratio()
Local $hWnd = 0
Local $hDC = DllCall("user32.dll", "long", "GetDC", "long", $hWnd)
If @error Then Return SetError(1, @extended, 0)
Local $aRet = DllCall("gdi32.dll", "long", "GetDeviceCaps", "long", $hDC[0], "long", 90)
If @error Then Return SetError(2, @extended, 0)
$hDC = DllCall("user32.dll", "long", "ReleaseDC", "long", $hWnd, "long", $hDC)
If @error Then Return SetError(3, @extended, 0)
If $aRet[0] = 0 Then $aRet[0] = 96
Return $aRet[0] / 96
EndFunc
Func GUISetFont_DPI($isize, $iweight = "", $iattribute = "", $sfontname = "")
GUISetFont($isize / $iDPI_Ratio, $iweight, $iattribute, $sfontname)
EndFunc
Func SetDPI()
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 600)
Local $stext = "My Bot needs to change your DPI settinng to continue!" & @CRLF & @CRLF & "You will be required to reboot your PC when done" & @CRLF & @CRLF & "Please close other programs and save you work NOW!" & @CRLF & @CRLF & "Hit OK to change settings and reboot, or cancel to exit bot"
Local $MsgBox = _ExtMsgBox(0, GetTranslated(640,1,"Ok|Cancel"), GetTranslated(640,2,"Display Settings Error"), $stext, 120)
If $MsgBox = 1 Then
Local $aRet = DllCall("syssetup.dll", "int", "SetupChangeFontSize", "int_ptr", 0, "wstr", "96")
If @error Then Return SetError(2, @extended, 0)
If $aRet = 0 Then
Setlog("Your Display DPI has been changed!!  Must logoff or restart to complete the chamge!", $COLOR_WARNING)
_Sleep(5000)
Shutdown($SD_REBOOT)
Else
Setlog("Your DPI has not been changed due some unknown error, Return= " & $aRet, $COLOR_WARNING)
EndIf
EndIf
EndFunc
Func isGemOpen($bNeedCaptureRegion = False)
_Sleep($iDelayisGemOpen1)
If _CheckPixel($aIsGemWindow1, $bNeedCaptureRegion) Then
If $g_iDebugSetlog = 1 Then Setlog("Gemclick Red X detect", $COLOR_DEBUG)
PureClickP($aAway, 1, 0, "#0140")
Return True
ElseIf _CheckPixel($aIsGemWindow2, $bNeedCaptureRegion) And  _CheckPixel($aIsGemWindow3, $bNeedCaptureRegion) And  _CheckPixel($aIsGemWindow4, $bNeedCaptureRegion) Then
If $g_iDebugSetlog = 1 Then Setlog("Gemclick Red Line detect", $COLOR_DEBUG)
PureClickP($aAway, 1, 0, "#0141")
Return True
EndIf
Return False
EndFunc
Func isNoUpgradeLoot($bNeedCaptureRegion = False)
If _ColorCheck(_GetPixelColor(459, 490 + $g_iMidOffsetY, $bNeedCaptureRegion), Hex(0xE70A12, 6), 20) And  _ColorCheck(_GetPixelColor(459, 494 + $g_iMidOffsetY, $bNeedCaptureRegion), Hex(0xE70A12, 6), 20) And  _ColorCheck(_GetPixelColor(459, 498 + $g_iMidOffsetY, $bNeedCaptureRegion), Hex(0xE70A12, 6), 20) Then
If $g_iDebugSetlog = 1 Then Setlog("isNoUpgradeLoot Red Zero found", $COLOR_DEBUG)
PureClickP($aAway, 1, 0, "#0142")
Return True
ElseIf _ColorCheck(_GetPixelColor(691, 523 + $g_iMidOffsetY, $bNeedCaptureRegion), Hex(0xE70A12, 6), 20) And  _ColorCheck(_GetPixelColor(691, 527 + $g_iMidOffsetY, $bNeedCaptureRegion), Hex(0xE70A12, 6), 20) And  _ColorCheck(_GetPixelColor(691, 531 + $g_iMidOffsetY, $bNeedCaptureRegion), Hex(0xE70A12, 6), 20) Then
If $g_iDebugSetlog = 1 Then Setlog("IsNoUpgradeLoot Hero Red Zero Found", $COLOR_DEBUG)
PureClickP($aAway, 1, 0, "#0143")
Return True
EndIf
Return False
EndFunc
Func isProblemAffect($bNeedCaptureRegion = False)
If Not _ColorCheck(_GetPixelColor(253, 395 + $g_iMidOffsetY, $bNeedCaptureRegion), Hex(0x282828, 6), 10) Then
Return False
ElseIf Not _ColorCheck(_GetPixelColor(373, 395 + $g_iMidOffsetY, $bNeedCaptureRegion), Hex(0x282828, 6), 10) Then
Return False
ElseIf Not _ColorCheck(_GetPixelColor(473, 395 + $g_iMidOffsetY, $bNeedCaptureRegion), Hex(0x282828, 6), 10) Then
Return False
ElseIf Not _ColorCheck(_GetPixelColor(283, 395 + $g_iMidOffsetY, $bNeedCaptureRegion), Hex(0x282828, 6), 10) Then
Return False
ElseIf Not _ColorCheck(_GetPixelColor(320, 395 + $g_iMidOffsetY, $bNeedCaptureRegion), Hex(0x282828, 6), 10) Then
Return False
ElseIf Not _ColorCheck(_GetPixelColor(594, 395 + $g_iMidOffsetY, $bNeedCaptureRegion), Hex(0x282828, 6), 10) Then
Return False
ElseIf _ColorCheck(_GetPixelColor(823, 32, $bNeedCaptureRegion), Hex(0xF8FCFF, 6), 10) Then
Return False
Else
Return True
EndIf
EndFunc
Func checkAttackDisable($iSource, $Result = "")
Local $i = 0, $iCount = 0
Local $iModSource
If $bDisableBreakCheck = True Then Return
If $ichkSinglePBTForced And _DateIsValid($sPBStartTime) Then
Local $iTimeTillPBTstartSec = Int(_DateDiff('s', $sPBStartTime, _NowCalc()))
If $g_iDebugSetlog = 1 Then Setlog("PB starts in: " & $iTimeTillPBTstartSec & " Seconds", $COLOR_DEBUG)
If $iTimeTillPBTstartSec >= 0 Then
$iModSource = $iTaBChkTime
Else
Return
EndIf
Else
$iModSource = $iSource
EndIf
Switch $iModSource
Case $iTaBChkAttack
While $Result = "" Or(StringLen($Result) < 3)
$i += 1
If _Sleep($iDelayAttackDisable100) Then Return
$Result = getAttackDisable(346, 182)
If $i >= 3 Then ExitLoop
WEnd
If $g_iDebugSetlog = 1 Then Setlog("Attack Personal Break OCR result = " & $Result, $COLOR_DEBUG)
If $Result <> "" Then
If StringInStr($Result, "disable") <> 0 Or StringInStr($Result, "for") <> 0 Or StringInStr($Result, "after") <> 0 Or StringInStr($Result, "have") <> 0 Then
Setlog("Attacking disabled, Personal Break detected...", $COLOR_ERROR)
If _CheckPixel($aSurrenderButton, $g_bCapturePixel) Then
If TestCapture() Then
SetLog("checkAttackDisable: ReturnHome")
Else
ReturnHome(False, False)
EndIF
Else
If TestCapture() Then
SetLog("checkAttackDisable: CloseCoC")
Else
CloseCoC()
EndIf
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog("wrong text string", $COLOR_DEBUG)
If TestCapture() Then Return "wrong text string"
Return
EndIf
Else
If TestCapture() Then Return "take a break text not found"
Return
EndIf
Case $iTaBChkIdle
If $Result = "" Then $Result = getAttackDisable(180, 156 + $g_iMidOffsetY)
If _Sleep($iDelayAttackDisable500) Then Return
If $Result = "" Or(StringLen($Result) < 3) Then $Result = getAttackDisable(180, 156 + $g_iMidOffsetY)
If $g_iDebugSetlog = 1 Then Setlog("Personal Break OCR result = " & $Result, $COLOR_DEBUG)
If $Result <> "" Then
If StringInStr($Result, "been") <> 0 Or StringInStr($Result, "after") <> 0 Or StringInStr($Result, "have") <> 0 Then
Setlog("Online too long, Personal Break detected....", $COLOR_ERROR)
checkMainScreen()
Else
If $g_iDebugSetlog = 1 Then Setlog("wrong text string", $COLOR_DEBUG)
If TestCapture() Then Return "wrong text string #2"
Return
EndIf
Else
If TestCapture() Then Return "take a break text not found #2"
Return
EndIf
Case $iTaBChkTime
If $iSource = $iTaBChkAttack Then
While _CheckPixel($aIsAttackPage, $g_bCapturePixel) = False
If _Sleep($iDelayAttackDisable500) Then Return
$iCount += 1
If $g_iDebugSetlog = 1 Then setlog("wait end battle button " & $iCount, $COLOR_DEBUG)
If $iCount > 40 Or isProblemAffect(True) Then
checkObstacles()
ExitLoop
EndIf
WEnd
If _CheckPixel($aIsAttackPage, $g_bCapturePixel) Then
If TestCapture() Then
SetLog("checkAttackDisable: ReturnHome #2")
Else
ReturnHome(False, False)
EndIF
EndIf
EndIf
If $iSource = $iTaBChkIdle Then
While _CheckPixel($aIsMain, $g_bCapturePixel) = False
If _Sleep($iDelayAttackDisable500) Then Return
ClickP($aAway, 1, 0, "#0000")
$iCount += 1
If $g_iDebugSetlog = 1 Then setlog("wait main page" & $iCount, $COLOR_DEBUG)
If $iCount > 5 Or isProblemAffect(True) Then
checkObstacles()
ExitLoop
EndIf
WEnd
If _Sleep($iDelayAttackDisable500) Then Return
EndIf
If $aShieldStatus[0] = "guard" Then
Setlog("Unable to Force PB, Guard shield present", $COLOR_INFO)
Else
Setlog("Forcing Early Personal Break Now!!", $COLOR_SUCCESS)
EndIf
Case Else
Setlog("Misformed $sSource parameter, silly programmer made a mistake!", $COLOR_DEBUG)
Return False
EndSwitch
Setlog("Prepare base before Personal Break..", $COLOR_INFO)
CheckBaseQuick(True)
$Is_ClientSyncError = False
$Is_SearchLimit = False
$g_bRestart = True
Setlog("Time for break, exit now..", $COLOR_INFO)
If TestCapture() Then
SetLog("checkAttackDisable: PoliteCloseCoC")
Else
PoliteCloseCoC("AttackDisable_")
EndIf
If _Sleep(1000) Then Return
PushMsg("TakeBreak")
If $iModSource = $iTaBChkTime And $aShieldStatus[0] <> "guard" Then
Setlog("Personal Break Reset log off: " & $iValueSinglePBTimeForced & " Minutes", $COLOR_INFO)
If TestCapture() Then
SetLog("checkAttackDisable: WaitnOpenCoC")
Else
WaitnOpenCoC($iValueSinglePBTimeForced * 60 * 1000, True)
EndIf
Else
If TestCapture() Then
SetLog("checkAttackDisable: WaitnOpenCoC")
Else
WaitnOpenCoC(20000, True)
EndIf
EndIf
$sPBStartTime = ""
For $i = 0 To UBound($aShieldStatus) - 1
$aShieldStatus[$i] = ""
Next
EndFunc
Func RemoveGhostTrayIcons($IconTextPart_notUsedAnymore = "")
Local $iGhostCount = 0
Local $i, $handle, $pid
Local $count = _SysTrayIconCount()
For $i = $count - 1 To 0 Step -1
$handle = _SysTrayIconHandle($i)
$pid = WinGetProcess($handle)
If $pid = -1 Then
$iGhostCount += 1
_SysTrayIconRemove($i)
EndIF
Next
If _FindTrayToolbarWindow(2) <> -1 Then
Local $countwin7 = _SysTrayIconCount(2)
For $i = $countwin7 - 1 To 0 Step -1
$handle = _SysTrayIconHandle($i, 2)
$pid = WinGetProcess($handle)
If $pid = -1 Then
$iGhostCount += 1
_SysTrayIconRemove($i, 2)
EndIf
Next
EndIf
If $iGhostCount > 0 And $g_iDebugSetlog = 1 Then SetLog("Removed " & $iGhostCount & " Ghost icon successfully", $COLOR_SUCCESS)
EndFunc
Func _SysTrayIconCount($iWin = 1)
Local Const $TB_BUTTONCOUNT = 1048
Local $hWnd = _FindTrayToolbarWindow($iWin)
If $hWnd = -1 Then Return -1
Local $count = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hWnd, "uint", $TB_BUTTONCOUNT, "wparam", 0, "lparam", 0)
If @error Then Return -1
Return $count[0]
EndFunc
Func _SysTrayIconTitles($iWin = 1)
Local $count = _SysTrayIconCount($iWin)
If $count <= 0 Then Return -1
Local $titles[$count]
For $i = 0 To $count - 1
$titles[$i] = WinGetTitle(_SysTrayIconHandle($i, $iWin))
Next
Return $titles
EndFunc
Func _SysTrayIconPids($iWin = 1)
Local $count = _SysTrayIconCount($iWin)
If $count <= 0 Then Return -1
Local $processes[$count]
For $i = 0 To $count - 1
$processes[$i] = WinGetProcess(_SysTrayIconHandle($i, $iWin))
Next
Return $processes
EndFunc
Func _SysTrayIconProcesses($iWin = 1)
Local $pids = _SysTrayIconPids($iWin)
If Not IsArray($pids) Then Return -1
Local $processes[UBound($pids)]
Local $list = ProcessList()
For $i = 0 To UBound($pids) - 1
For $j = 1 To $list[0][0]
If $pids[$i] = $list[$j][1] Then
$processes[$i] = $list[$j][0]
ExitLoop
EndIf
Next
Next
Return $processes
EndFunc
Func _SysTrayIconIndex($test, $mode = 0, $iWin = 1)
Local $ret = -1, $compare = -1
If $mode < 0 Or $mode > 2 Or Not IsInt($mode) Then Return -1
Switch $mode
Case 0
$compare = _SysTrayIconProcesses($iWin)
Case 1
$compare = _SysTrayIconTitles($iWin)
Case 2
$compare = _SysTrayIconPids($iWin)
EndSwitch
If Not IsArray($compare) Then Return -1
For $i = 0 To UBound($compare) - 1
If $compare[$i] = $test Then
$ret = $i
ExitLoop
EndIf
Next
Return $ret
EndFunc
Func _SysTrayGetButtonInfo($iIndex, $iWin = 1, $iInfo = 1)
Local Const $TB_GETBUTTON = 1047
Local Const $TB_GETITEMRECT = 1053
Local Const $ACCESS = BitOR(0x0008, 0x0010, 0x0400)
Local $TBBUTTON
If @OSArch = "X86" Then
$TBBUTTON = DllStructCreate("int iBitmap;int idCommand;byte fsState;byte fsStyle;byte bReserved[2];dword dwData;int iString")
Else
$TBBUTTON = DllStructCreate("int iBitmap;int idCommand;byte fsState;byte fsStyle;byte bReserved[6];uint64 dwData;int64 iString")
EndIf
Local $TRAYDATA
If @OSArch = "X86" Then
$TRAYDATA = DllStructCreate("hwnd hwnd;uint uID;uint uCallbackMessage;dword Reserved[2];handle hIcon")
Else
$TRAYDATA = DllStructCreate("uint64 hwnd;uint uID;uint uCallbackMessage;dword Reserved[2];uint64 hIcon")
EndIf
Local $trayHwnd = _FindTrayToolbarWindow($iWin)
If $trayHwnd = -1 Then Return SetError(1, 0, -1)
Local $return, $err = 0
Local $ret = DllCall("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $trayHwnd, "dword*", 0)
If @error Or Not $ret[2] Then SetError(2, 0, -1)
Local $pId = $ret[2]
Local $procHandle = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $ACCESS, "bool", False, "dword", $pId)
If @error Or Not $procHandle[0] Then Return SetError(3, 0, -1)
Local $lpData = DllCall("kernel32.dll", "ptr", "VirtualAllocEx", "handle", $procHandle[0], "ptr", 0, "ulong", DllStructGetSize($TBBUTTON), "dword", 0x1000, "dword", 0x04)
If Not @error And $lpData[0] Then
$ret = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $trayHwnd, "uint", $TB_GETBUTTON, "wparam", $iIndex, "lparam", $lpData[0])
If Not @error And $ret[0] Then
DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $procHandle[0], "ptr", $lpData[0], "struct*", $TBBUTTON, "ulong", DllStructGetSize($TBBUTTON), "ulong*", 0)
Switch $iInfo
Case 2
DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $procHandle[0], "ptr", DllStructGetData($TBBUTTON, 6), "struct*", $TRAYDATA, "ulong", DllStructGetSize($TRAYDATA), "ulong*", 0)
$return = $TRAYDATA
Case 3
$return = ""
If BitShift(DllStructGetData($TBBUTTON, 7), 16) <> 0 Then
Local $intTip = DllStructCreate("wchar[1024]")
DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $procHandle[0], "ptr", DllStructGetData($TBBUTTON, 7), "struct*", $intTip, "ulong", DllStructGetSize($intTip), "ulong*", 0)
$return = DllStructGetData($intTip, 1)
$intTip = 0
EndIf
Case 4
If Not BitAND(DllStructGetData($TBBUTTON, 3), 8) Then
Local $pos[2], $RECT = DllStructCreate("int;int;int;int")
DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $trayHwnd, "uint", $TB_GETITEMRECT, "wparam", $iIndex, "lparam", $lpData[0])
DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $procHandle[0], "ptr", $lpData[0], "struct*", $RECT, "ulong", DllStructGetSize($RECT), "ulong*", 0)
$ret = DllCall("user32.dll", "int", "MapWindowPoints", "hwnd", $trayHwnd, "ptr", 0, "struct*", $RECT, "uint", 2)
$pos[0] = DllStructGetData($RECT, 1)
$pos[1] = DllStructGetData($RECT, 2)
$return = $pos
$RECT = 0
Else
$return = -1
EndIf
Case Else
$return = $TBBUTTON
EndSwitch
Else
$err = 5
EndIf
DllCall("kernel32.dll", "bool", "VirtualFreeEx", "handle", $procHandle[0], "ptr", $lpData[0], "ulong", 0, "dword", 0x8000)
Else
$err = 4
EndIf
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $procHandle[0])
If $err Then
Return SetError($err, 0, -1)
Else
Return $return
EndIf
EndFunc
Func _SysTrayIconHandle($iIndex, $iWin = 1)
Local $TRAYDATA = _SysTrayGetButtonInfo($iIndex, $iWin, 2)
If @error Then
Return SetError(@error, 0, -1)
Else
Return Ptr(DllStructGetData($TRAYDATA, 1))
EndIf
EndFunc
Func _SysTrayIconTooltip($iIndex, $iWin = 1)
Local $ret = _SysTrayGetButtonInfo($iIndex, $iWin, 3)
If @error Then
Return SetError(@error, 0, -1)
Else
Return $ret
EndIf
EndFunc
Func _SysTrayIconPos($iIndex, $iWin = 1)
Local $ret = _SysTrayGetButtonInfo($iIndex, $iWin, 4)
If @error Then
Return SetError(@error, 0, -1)
Else
If $ret = -1 Then
Return SetError(-1, 0, -1)
Else
Return $ret
EndIf
EndIf
EndFunc
Func _SysTrayIconVisible($iIndex, $iWin = 1)
Local $TBBUTTON = _SysTrayGetButtonInfo($iIndex, $iWin, 1)
If @error Then
Return SetError(@error, 0, -1)
Else
Return Not BitAND(DllStructGetData($TBBUTTON, 3), 8)
EndIf
EndFunc
Func _SysTrayIconHide($index, $iFlag, $iWin = 1)
Local $TBBUTTON = _SysTrayGetButtonInfo($index, $iWin, 1)
If @error Then Return SetError(@error, 0, -1)
Local $visible = Not BitAND(DllStructGetData($TBBUTTON, 3), 8)
If($iFlag And Not $visible) Or(Not $iFlag And $visible) Then
Return 0
Else
Local $TRAYDATA = _SysTrayGetButtonInfo($index, $iWin, 2)
If @error Then Return SetError(@error, 0, -1)
Local $NOTIFYICONDATA = DllStructCreate("dword cbSize;hwnd hWnd;uint uID;uint uFlags;uint uCallbackMessage;handle hIcon;wchar szTip[128];" & "dword dwState;dword dwStateMask;wchar szInfo[256];uint uVersion;wchar szInfoTitle[64];dword dwInfoFlags;" & "STRUCT;ulong;ushort;ushort;byte[8];ENDSTRUCT;handle hBalloonIcon")
DllStructSetData($NOTIFYICONDATA, 1, DllStructGetSize($NOTIFYICONDATA))
DllStructSetData($NOTIFYICONDATA, 2, Ptr(DllStructGetData($TRAYDATA, 1)))
DllStructSetData($NOTIFYICONDATA, 3, DllStructGetData($TRAYDATA, 2))
DllStructSetData($NOTIFYICONDATA, 4, 8)
DllStructSetData($NOTIFYICONDATA, 8, $iFlag)
DllStructSetData($NOTIFYICONDATA, 9, 1)
Local $ret = DllCall("shell32.dll", "bool", "Shell_NotifyIconW", "dword", 0x1, "struct*", $NOTIFYICONDATA)
DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", WinGetHandle("[CLASS:Shell_TrayWnd]"), "uint", 0x001A, "wparam", 0, "lparam", 0)
$NOTIFYICONDATA = 0
If IsArray($ret) And $ret[0] Then
Return 1
Else
Return 0
EndIf
EndIf
EndFunc
Func _SysTrayIconMove($curPos, $newPos, $iWin = 1)
Local Const $TB_MOVEBUTTON = 0x0452
Local $iconCount = _SysTrayIconCount($iWin)
If $curPos < 0 Or $newPos < 0 Or $curPos > $iconCount - 1 Or $newPos > $iconCount - 1 Or Not IsInt($curPos) Or Not IsInt($newPos) Then Return SetError(1, 0, -1)
Local $hWnd = _FindTrayToolbarWindow($iWin)
If $hWnd = -1 Then Return SetError(2, 0, -1)
Local $ret = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hWnd, "uint", $TB_MOVEBUTTON, "wparam", $curPos, "lparam", $newPos)
If @error Or Not $ret[0] Then
Return 0
Else
Return 1
EndIf
EndFunc
Func _SysTrayIconRemove($index, $iWin = 1)
Local $TRAYDATA = _SysTrayGetButtonInfo($index, $iWin, 2)
If @error Then Return SetError(@error, 0, -1)
Local $NOTIFYICONDATA = DllStructCreate("dword cbSize;hwnd hWnd;uint uID;uint uFlags;uint uCallbackMessage;handle hIcon;wchar szTip[128];" & "dword dwState;dword dwStateMask;wchar szInfo[256];uint uVersion;wchar szInfoTitle[64];dword dwInfoFlags;" & "STRUCT;ulong;ushort;ushort;byte[8];ENDSTRUCT;handle hBalloonIcon")
DllStructSetData($NOTIFYICONDATA, 1, DllStructGetSize($NOTIFYICONDATA))
DllStructSetData($NOTIFYICONDATA, 2, Ptr(DllStructGetData($TRAYDATA, 1)))
DllStructSetData($NOTIFYICONDATA, 3, DllStructGetData($TRAYDATA, 2))
Local $ret = DllCall("shell32.dll", "bool", "Shell_NotifyIconW", "dword", 0x2, "struct*", $NOTIFYICONDATA)
DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", WinGetHandle("[CLASS:Shell_TrayWnd]"), "uint", 0x001A, "wparam", 0, "lparam", 0)
$NOTIFYICONDATA = 0
If IsArray($ret) And $ret[0] Then
Return 1
Else
Return 0
EndIf
EndFunc
Func _FindTrayToolbarWindow($iWin = 1)
Local $hwnd, $ret = -1
If $iWin = 1 Then
$hWnd = DllCall("user32.dll", "hwnd", "FindWindow", "str", "Shell_TrayWnd", "ptr", 0)
If @error Then Return -1
$hWnd = DllCall("user32.dll", "hwnd", "FindWindowEx", "hwnd", $hWnd[0], "hwnd", 0, "str", "TrayNotifyWnd", "ptr", 0)
If @error Then Return -1
If @OSVersion <> "WIN_2000" Then
$hWnd = DllCall("user32.dll", "hwnd", "FindWindowEx", "hwnd", $hWnd[0], "hwnd", 0, "str", "SysPager", "ptr", 0)
If @error Then Return -1
EndIf
$hWnd = DllCall("user32.dll", "hwnd", "FindWindowEx", "hwnd", $hWnd[0], "hwnd", 0, "str", "ToolbarWindow32", "ptr", 0)
If @error Then Return -1
$ret = $hwnd[0]
ElseIf $iWin = 2 Then
$hWnd = DllCall("user32.dll", "hwnd", "FindWindow", "str", "NotifyIconOverflowWindow", "ptr", 0)
If @error Then Return -1
$hWnd = DllCall("user32.dll", "hwnd", "FindWindowEx", "hwnd", $hWnd[0], "hwnd", 0, "str", "ToolbarWindow32", "ptr", 0)
If @error Then Return -1
$ret = $hwnd[0]
EndIf
Return $ret
EndFunc
Func waitMainScreen()
If Not $g_bRunState Then Return
Local $iCount
SetLog("Waiting for Main Screen")
$iCount = 0
For $i = 0 To 105
If Not $g_bRunState Then Return
If $g_iDebugSetlog = 1 Then Setlog("ChkObstl Loop = " & $i & "ExitLoop = " & $iCount, $COLOR_DEBUG)
$iCount += 1
Local $hWin = $HWnD
If TestCapture() = False Then
If WinGetAndroidHandle() = 0 Then
If $hWin = 0 Then
OpenAndroid(True)
Else
RebootAndroid()
EndIf
Return
EndIf
getBSPos()
EndIf
_CaptureRegion()
If _CheckPixel($aIsMain, $g_bNoCapturePixel) = True Then
If $g_iDebugSetlog = 1 Then Setlog("Screen cleared, WaitMainScreen exit", $COLOR_DEBUG)
Return
ElseIf _CheckPixel($aIsDPI125, $g_bNoCapturePixel) = True Then
ShowDPIHelp(125)
ElseIf _CheckPixel($aIsDPI150, $g_bNoCapturePixel) = True Then
ShowDPIHelp(150)
Else
If TestCapture() = False And _Sleep($iDelaywaitMainScreen1) Then Return
If checkObstacles() Then $i = 0
EndIf
If Mod($i, 5) = 0 Then
If $g_iDebugImageSave = 1 Then DebugImageSave("WaitMainScreen_", False)
EndIf
If($i > 105) Or($iCount > 120) Then ExitLoop
If TestCapture() Then
Return "Main screen not available"
EndIf
Next
CloseCoC(True)
If _CheckPixel($aIsMain, True) Then Return
$iCount = 0
While 1
If Not $g_bRunState Then Return
SetLog("Unable to load CoC, attempt to fix it...", $COLOR_ERROR)
If $g_iDebugSetlog = 1 Then Setlog("Restart Loop = " & $iCount, $COLOR_DEBUG)
CloseAndroid("waitMainScreen")
If _Sleep(1000) Then Return
OpenAndroid(True)
If @extended Then
SetError(1, 1, -1)
Return
EndIf
If _CheckPixel($aIsMain, $g_bCapturePixel) = True Then ExitLoop
CheckObstacles()
$iCount += 1
If $iCount > 2 Then
SetLog("Stuck trying to Restart " & $g_sAndroidEmulator & "...", $COLOR_ERROR)
SetError(1, 0, 0)
Return
EndIf
If _CheckPixel($aIsMain, $g_bCapturePixel) = True Then ExitLoop
WEnd
EndFunc
Func waitMainScreenMini()
If Not $g_bRunState Then Return
Local $iCount = 0
Local $hTimer = TimerInit()
SetDebugLog("waitMainScreenMini")
If TestCapture() = False Then getBSPos()
SetLog("Waiting for Main Screen after " & $g_sAndroidEmulator & " restart", $COLOR_INFO)
For $i = 0 To 60
If Not $g_bRunState Then Return
If TestCapture() = False And WinGetAndroidHandle() = 0 Then ExitLoop
If $g_iDebugSetlog = 1 Then Setlog("ChkObstl Loop = " & $i & "ExitLoop = " & $iCount, $COLOR_DEBUG)
$iCount += 1
_CaptureRegion()
If _CheckPixel($aIsMain, $g_bNoCapturePixel) = False Then
If TestCapture() = False And _Sleep(1000) Then Return
If CheckObstacles() Then $i = 0
Else
SetLog("CoC main window took " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds", $COLOR_SUCCESS)
Return
EndIf
_StatusUpdateTime($hTimer, "Main Screen")
If($i > 60) Or($iCount > 80) Then ExitLoop
If TestCapture() Then
Return "Main screen not available"
EndIf
Next
Return SetError( 1, 0, -1)
EndFunc
Func AndroidBackButton($bCheckRunState = True)
If $bCheckRunState And Not $g_bRunState Then Return False
AndroidAdbSendShellCommand("input keyevent 4", Default, Default, False)
If $g_iDebugSetlog = 1 Then Setlog("Used Adb to press back button", $COLOR_INFO)
Return True
EndFunc
Func AndroidHomeButton()
If Not $g_bRunState Then Return False
AndroidAdbSendShellCommand("input keyevent 3", Default, Default, False)
If $g_iDebugSetlog = 1 Then Setlog("Used Adb to press home button", $COLOR_INFO)
Return True
EndFunc
Func CloseCoC($ReOpenCoC = False)
$g_bSkipFirstZoomout = False
ResumeAndroid()
If Not $g_bRunState Then Return
If $ReOpenCoC Then
SetLog("Please wait for CoC restart......", $COLOR_ERROR)
Else
SetLog("Closing CoC......", $COLOR_ERROR)
EndIf
WinGetAndroidHandle()
AndroidHomeButton()
If Not $g_bRunState Then Return
SendAdbCommand("shell am force-stop " & $g_sAndroidGamePackage)
If Not $g_bRunState Then Return
If $ReOpenCoC Then
OpenCoC()
$g_bRestart = True
EndIf
EndFunc
Func OpenCoC()
ResumeAndroid()
If Not $g_bRunState Then Return
Local $RunApp = "", $iCount = 0
WinGetAndroidHandle()
AndroidHomeButton()
If _Sleep(500) Then Return
If Not StartAndroidCoC() Then Return
If Not $g_bRunState Then Return
While _CheckPixel($aIsMain, True) = False
$iCount += 1
If _Sleep(100) Then Return
If checkObstacles() Then $iCount += 1
If $iCount > 250 Then ExitLoop
WEnd
EndFunc
Func WaitnOpenCoC($iWaitTime, $bFullRestart = False)
ResumeAndroid()
If Not $g_bRunState Then Return
Local $sWaitTime = ""
Local $iMin, $iSec, $iHour, $iWaitSec
WinGetAndroidHandle()
AndroidHomeButton()
$iWaitSec = Round($iWaitTime / 1000)
$iHour = Floor(Floor($iWaitSec / 60) / 60)
$iMin = Floor(Mod(Floor($iWaitSec / 60), 60))
$iSec = Floor(Mod($iWaitSec, 60))
If $iHour > 0 Then $sWaitTime &= $iHour & " hours "
If $iMin > 0 Then $sWaitTime &= $iMin & " minutes "
If $iSec > 0 Then $sWaitTime &= $iSec & " seconds "
SetLog("Waiting " & $sWaitTime & "before starting CoC", $COLOR_SUCCESS)
ReduceBotMemory()
If _SleepStatus($iWaitTime) Then Return False
If Not StartAndroidCoC() Then Return
If Not $g_bRunState Then Return
If $g_iDebugSetlog = 1 Then setlog("CoC Restarted, Waiting for completion", $COLOR_DEBUG)
If $bFullRestart = True Then
checkMainScreen()
$g_bRestart = True
Else
waitMainScreen()
EndIf
EndFunc
Func PoliteCloseCoC($sSource = "Unknown_")
$g_bSkipFirstZoomout = False
If $g_sAndroidGameDistributor = $g_sGoogle Then
Local $i = 0
While 1
checkObstacles()
AndroidBackButton()
If _Sleep($iDelayCloseOpen1000) Then Return
If ClickOkay("ExitOkay_" & $sSource, True) = True Then ExitLoop
If $i > 10 Then
Setlog("Can not find Okay button to exit CoC, Forcefully Closing CoC", $COLOR_ERROR)
If $g_iDebugImageSave = 1 Then DebugImageSave($sSource)
CloseCoC()
ExitLoop
EndIf
$i += 1
WEnd
Else
Local $btnExit
Local $i = 0
While 1
checkObstacles()
AndroidBackButton()
If _Sleep($iDelayCloseOpen1000) Then Return
Switch $g_sAndroidGameDistributor
Case "Kunlun", "Huawei", "Kaopu", "Microvirt", "Yeshen", "Qihoo", "Baidu", "OPPO", "Anzhi", "Lenovo", "Aiyouxi"
$btnExit = FindExitButton($g_sAndroidGameDistributor)
If IsArray($btnExit) Then
Click($btnExit[0], $btnExit[1])
ExitLoop
EndIf
Case "9game"
If _Sleep($iDelayCloseOpen2000) Then Return
$btnExit = FindExitButton($g_sAndroidGameDistributor)
If IsArray($btnExit) Then
Click($btnExit[0] + 71, $btnExit[1] + 64)
If $g_iDebugSetlog Then Setlog($g_sAndroidGameDistributor & " Click offset X|Y = 71|64", $COLOR_DEBUG)
ExitLoop
EndIf
Case "VIVO", "Xiaomi"
$btnExit = FindExitButton($g_sAndroidGameDistributor)
If IsArray($btnExit) Then
Click($btnExit[0], $btnExit[1], 2, $iDelayCloseOpen3000)
ExitLoop
EndIf
Case "Guopan"
$btnExit = FindExitButton($g_sAndroidGameDistributor)
If IsArray($btnExit) Then
Click($btnExit[0], $btnExit[1])
EndIf
If _Sleep($iDelayCloseOpen2000) Then Return
$btnExit = FindExitButton("Kunlun")
If IsArray($btnExit) Then
Click($btnExit[0], $btnExit[1])
ExitLoop
EndIf
Case "Wandoujia/Downjoy", "Haimawan", "Leshi"
ContinueCase
Case Else
Setlog("Polite Close Unsupported - " & $g_sAndroidGameDistributor & ", Forcefully Closing CoC", $COLOR_ERROR)
If $g_iDebugImageSave = 1 Then DebugImageSave($sSource)
CloseCoC()
ExitLoop
EndSwitch
If $i > 10 Then
Setlog("Can not find exit button: " & $g_sAndroidGameDistributor & ", Forcefully Closing CoC", $COLOR_ERROR)
If $g_iDebugImageSave = 1 Then DebugImageSave($sSource)
CloseCoC()
ExitLoop
EndIf
$i += 1
WEnd
EndIf
ReduceBotMemory()
EndFunc
Global $g_aiSearchZoomOutCounter[2] = [0, 1]
Func ZoomOut()
$g_aiSearchZoomOutCounter[0] = 0
$g_aiSearchZoomOutCounter[1] = 1
ResumeAndroid()
WinGetAndroidHandle()
getBSPos()
If Not $g_bRunState Then Return
Local $Result
If $g_bAndroidEmbedded = False Or $g_iAndroidEmbedMode = 1 Then
$Result = Execute("ZoomOut" & $g_sAndroidEmulator & "()")
If $Result = "" And @error <> 0 Then
$Result = AndroidOnlyZoomOut()
EndIf
$g_bSkipFirstZoomout = True
Return $Result
EndIf
AndroidOnlyZoomOut()
$g_bSkipFirstZoomout = True
EndFunc
Func ZoomOutBlueStacks()
Return ZoomOutCtrlClick(False, False, False, False)
EndFunc
Func ZoomOutBlueStacks2()
If $__BlueStacks2Version_2_5_or_later = False Then
Return ZoomOutCtrlClick(False, False, False, False)
Else
Return DefaultZoomOut("{DOWN}", 0)
EndIf
EndFunc
Func ZoomOutMEmu()
Return DefaultZoomOut("{F3}", 0)
EndFunc
Func ZoomOutDroid4X()
Return ZoomOutCtrlWheelScroll(True, True, True)
EndFunc
Func ZoomOutNox()
Return ZoomOutCtrlWheelScroll(True, True, True)
EndFunc
Func DefaultZoomOut($ZoomOutKey = "{DOWN}", $tryCtrlWheelScrollAfterCycles = 40, $AndroidZoomOut = True)
Local $result0, $result1, $i = 0
Local $exitCount = 80
Local $delayCount = 20
ForceCaptureRegion()
Local $aPicture = SearchZoomOut()
If StringInStr($aPicture[0], "zoomou") = 0 Then
SetLog("Zooming Out", $COLOR_BLUE)
If _Sleep($iDelayZoomOut1) Then Return
If $AndroidZoomOut = True Then
AndroidZoomOut(False)
ForceCaptureRegion()
$aPicture = SearchZoomOut()
EndIf
Local $tryCtrlWheelScroll = False
While StringInStr($aPicture[0], "zoomou") = 0 and Not $tryCtrlWheelScroll
AndroidShield("DefaultZoomOut")
If $AndroidZoomOut = True Then
AndroidZoomOut(False, $i)
If @error <> 0 Then $AndroidZoomOut = False
EndIf
If $AndroidZoomOut = False Then
If $g_iDebugSetlog = 1 Then Setlog("Index = "&$i, $COLOR_DEBUG)
If _Sleep($iDelayZoomOut2) Then Return
If $g_bChkBackgroundMode = False And $g_bNoFocusTampering = False Then
$Result0 = ControlFocus($HWnD, "", "")
Else
$Result0 = 1
EndIf
$Result1 = ControlSend($HWnD, "", "", $ZoomOutKey)
If $g_iDebugSetlog = 1 Then Setlog("ControlFocus Result = "&$Result0 & ", ControlSend Result = "&$Result1& "|" & "@error= " & @error, $COLOR_DEBUG)
If $Result1 = 1 Then
$i += 1
Else
Setlog("Warning ControlSend $Result = "&$Result1, $COLOR_DEBUG)
EndIf
EndIF
If $i > $delayCount Then
If _Sleep($iDelayZoomOut3) Then Return
EndIf
If $tryCtrlWheelScrollAfterCycles > 0 And $i > $tryCtrlWheelScrollAfterCycles Then $tryCtrlWheelScroll = True
If $i > $exitCount Then Return
If $g_bRunState = False Then ExitLoop
If IsProblemAffect(True) Then
Setlog($g_sAndroidEmulator & " Error window detected", $COLOR_ERROR)
If checkObstacles() = True Then Setlog("Error window cleared, continue Zoom out", $COLOR_INFO)
EndIf
$i += 1
ForceCaptureRegion()
$aPicture = SearchZoomOut()
WEnd
If $tryCtrlWheelScroll Then
Setlog($g_sAndroidEmulator & " zoom-out with key " & $ZoomOutKey & " didn't work, try now Ctrl+MouseWheel...", $COLOR_INFO)
Return ZoomOutCtrlWheelScroll(False, False, False, False)
EndIf
Return True
EndIf
Return False
EndFunc
Func ZoomOutCtrlWheelScroll($CenterMouseWhileZooming = True, $GlobalMouseWheel = True, $AlwaysControlFocus = False, $AndroidZoomOut = True, $hWin = Default, $ScrollSteps = -5, $ClickDelay = 250)
Local $exitCount = 80
Local $delayCount = 20
Local $result[4], $i = 0, $j
Local $ZoomActions[4] = ["ControlFocus", "Ctrl Down", "Mouse Wheel Scroll Down", "Ctrl Up"]
If $hWin = Default Then $hWin =($g_bAndroidEmbedded = False ? $HWnD : $g_aiAndroidEmbeddedCtrlTarget[1])
ForceCaptureRegion()
Local $aPicture = SearchZoomOut()
If StringInStr($aPicture[0], "zoomou") = 0 Then
SetLog("Zooming Out", $COLOR_BLUE)
AndroidShield("ZoomOutCtrlWheelScroll")
If _Sleep($iDelayZoomOut1) Then Return
If $AndroidZoomOut = True Then
AndroidZoomOut(False)
ForceCaptureRegion()
$aPicture = SearchZoomOut()
EndIf
Local $aMousePos = MouseGetPos()
While StringInStr($aPicture[0], "zoomou") = 0
If $AndroidZoomOut = True Then
AndroidZoomOut(False, $i)
If @error <> 0 Then $AndroidZoomOut = False
EndIf
If $AndroidZoomOut = False Then
If $g_iDebugSetlog = 1 Then Setlog("Index = " & $i, $COLOR_DEBUG)
If _Sleep($iDelayZoomOut2) Then ExitLoop
If($g_bChkBackgroundMode = False And $g_bNoFocusTampering = False) Or $AlwaysControlFocus Then
$Result[0] = ControlFocus($hWin, "", "")
Else
$Result[0] = 1
EndIf
$Result[1] = ControlSend($hWin, "", "", "{CTRLDOWN}")
If $CenterMouseWhileZooming Then MouseMove($g_aiBSpos[0] + Int($g_iDEFAULT_WIDTH / 2), $g_aiBSpos[1] + Int($g_iDEFAULT_HEIGHT / 2), 0)
If $GlobalMouseWheel Then
$Result[2] = MouseWheel(($ScrollSteps < 0 ? "down" : "up"), Abs($ScrollSteps))
Else
Local $WM_WHEELMOUSE = 0x020A, $MK_CONTROL = 0x0008
Local $wParam = BitOR($ScrollSteps * 0x10000, BitAND($MK_CONTROL, 0xFFFF))
Local $lParam = BitOR(($g_aiBSpos[1] + Int($g_iDEFAULT_HEIGHT / 2)) * 0x10000, BitAND(($g_aiBSpos[0] + Int($g_iDEFAULT_WIDTH / 2)), 0xFFFF))
_WinAPI_PostMessage($hWin, $WM_WHEELMOUSE, $wParam, $lParam)
$Result[2] =(@error = 0 ? 1 : 0)
EndIf
If _Sleep($ClickDelay) Then ExitLoop
$Result[3] = ControlSend($hWin, "", "", "{CTRLUP}{SPACE}")
If $g_iDebugSetlog = 1 Then Setlog("ControlFocus Result = " & $Result[0] & ", " & $ZoomActions[1] & " = " & $Result[1] & ", " & $ZoomActions[2] & " = " & $Result[2] & ", " & $ZoomActions[3] & " = " & $Result[3] & " | " & "@error= " & @error, $COLOR_DEBUG)
For $j = 1 To 3
If $Result[$j] = 1 Then
$i += 1
ExitLoop
EndIf
Next
For $j = 1 To 3
If $Result[$j] = 0 Then
Setlog("Warning " & $ZoomActions[$j] & " = " & $Result[1], $COLOR_DEBUG)
EndIf
Next
EndIf
If $i > $delayCount Then
If _Sleep($iDelayZoomOut3) Then ExitLoop
EndIf
If $i > $exitCount Then ExitLoop
If $g_bRunState = False Then ExitLoop
If IsProblemAffect(True) Then
Setlog($g_sAndroidEmulator & " Error window detected", $COLOR_ERROR)
If checkObstacles() = True Then Setlog("Error window cleared, continue Zoom out", $COLOR_INFO)
EndIf
$i += 1
ForceCaptureRegion()
$aPicture = SearchZoomOut()
WEnd
If $CenterMouseWhileZooming And $AndroidZoomOut = False Then MouseMove($aMousePos[0], $aMousePos[1], 0)
Return True
EndIf
Return False
EndFunc
Func ZoomOutCtrlClick($ZoomOutOverWaters = False, $CenterMouseWhileZooming = False, $AlwaysControlFocus = False, $AndroidZoomOut = True, $ClickDelay = 250)
Local $exitCount = 80
Local $delayCount = 20
Local $result[4], $i, $j
Local $SendCtrlUp = False
Local $ZoomActions[4] = ["ControlFocus", "Ctrl Down", "Click", "Ctrl Up"]
ForceCaptureRegion()
Local $aPicture = SearchZoomOut()
If StringInStr($aPicture[0], "zoomou") = 0 Then
SetLog("Zooming Out", $COLOR_INFO)
AndroidShield("ZoomOutCtrlClick")
If $ZoomOutOverWaters = True Then
If $AndroidZoomOut = True Then
AndroidZoomOut(False)
ForceCaptureRegion()
$aPicture = SearchZoomOut()
Else
For $i = 1 To 3
_PostMessage_ClickDrag(100, 600, 600, 100, "left")
Next
EndIf
EndIf
If _Sleep($iDelayZoomOut1) Then Return
Local $aMousePos = MouseGetPos()
$i = 0
While StringInStr($aPicture[0], "zoomou") = 0
If $AndroidZoomOut = True Then
AndroidZoomOut(False, $i)
If @error <> 0 Then $AndroidZoomOut = False
EndIf
If $AndroidZoomOut = False Then
If $g_iDebugSetlog = 1 Then Setlog("Index = " & $i, $COLOR_DEBUG)
If _Sleep($iDelayZoomOut2) Then ExitLoop
If($g_bChkBackgroundMode = False And $g_bNoFocusTampering = False) Or $AlwaysControlFocus Then
$Result[0] = ControlFocus($HWnD, "", "")
Else
$Result[0] = 1
EndIf
$Result[1] = ControlSend($HWnD, "", "", "{CTRLDOWN}")
$SendCtrlUp = True
If $CenterMouseWhileZooming Then MouseMove($g_aiBSpos[0] + Int($g_iDEFAULT_WIDTH / 2), $g_aiBSpos[1] + Int($g_iDEFAULT_HEIGHT / 2), 0)
$Result[2] = _ControlClick(Int($g_iDEFAULT_WIDTH / 2), 600)
If _Sleep($ClickDelay) Then ExitLoop
$Result[3] = ControlSend($HWnD, "", "", "{CTRLUP}{SPACE}")
$SendCtrlUp = False
If $g_iDebugSetlog = 1 Then Setlog("ControlFocus Result = " & $Result[0] & ", " & $ZoomActions[1] & " = " & $Result[1] & ", " & $ZoomActions[2] & " = " & $Result[2] & ", " & $ZoomActions[3] & " = " & $Result[3] & " | " & "@error= " & @error, $COLOR_DEBUG)
For $j = 1 To 3
If $Result[$j] = 1 Then
ExitLoop
EndIf
Next
For $j = 1 To 3
If $Result[$j] = 0 Then
Setlog("Warning " & $ZoomActions[$j] & " = " & $Result[1], $COLOR_DEBUG)
EndIf
Next
EndIf
If $i > $delayCount Then
If _Sleep($iDelayZoomOut3) Then ExitLoop
EndIf
If $i > $exitCount Then ExitLoop
If $g_bRunState = False Then ExitLoop
If IsProblemAffect(True) Then
Setlog($g_sAndroidEmulator & " Error window detected", $COLOR_RED)
If checkObstacles() = True Then Setlog("Error window cleared, continue Zoom out", $COLOR_BLUE)
EndIf
$i += 1
ForceCaptureRegion()
$aPicture = SearchZoomOut()
WEnd
If $SendCtrlUp Then ControlSend($HWnD, "", "", "{CTRLUP}{SPACE}")
If $CenterMouseWhileZooming Then MouseMove($aMousePos[0], $aMousePos[1], 0)
Return True
EndIf
Return False
EndFunc
Func AndroidOnlyZoomOut()
Local $i = 0
Local $exitCount = 80
ForceCaptureRegion()
Local $aPicture = SearchZoomOut()
If StringInStr($aPicture[0], "zoomou") = 0 Then
SetLog("Zooming Out", $COLOR_BLUE)
AndroidZoomOut(False)
ForceCaptureRegion()
$aPicture = SearchZoomOut()
While StringInStr($aPicture[0], "zoomou") = 0
AndroidShield("AndroidOnlyZoomOut")
AndroidZoomOut(False, $i)
If $i > $exitCount Then Return
If $g_bRunState = False Then ExitLoop
If IsProblemAffect(True) Then
Setlog($g_sAndroidEmulator & " Error window detected", $COLOR_ERROR)
If checkObstacles() = True Then Setlog("Error window cleared, continue Zoom out", $COLOR_INFO)
EndIf
$i += 1
ForceCaptureRegion()
$aPicture = SearchZoomOut()
WEnd
Return True
EndIf
Return False
EndFunc
Func SearchZoomOut($CenterVillageBoolOrScrollPos = $aCenterHomeVillageClickDrag, $UpdateMyVillage = True, $sSource = "", $CaptureRegion = True, $DebugLog = True)
If $sSource <> "" Then $sSource = " (" & $sSource & ")"
Local $bCenterVillage = $CenterVillageBoolOrScrollPos
If $bCenterVillage = Default Or $g_iDebugDisableVillageCentering = 1 Then $bCenterVillage =($g_iDebugDisableVillageCentering = 0)
Local $aScrollPos[2] = [0, 0]
If UBound($CenterVillageBoolOrScrollPos) >= 2 Then
$aScrollPos[0] = $CenterVillageBoolOrScrollPos[0]
$aScrollPos[1] = $CenterVillageBoolOrScrollPos[1]
$bCenterVillage =($g_iDebugDisableVillageCentering = 0)
EndIf
Local $x, $y, $z, $stone[2]
Local $villageSize = 0
If $CaptureRegion = True Then _CaptureRegion2()
Local $aResult = ["", 0, 0, 0, 0]
Local $village = GetVillageSize($DebugLog)
If $g_aiSearchZoomOutCounter[0] > 0 Then
If _Sleep(1000) Then Return $aResult
EndIf
If IsArray($village) = 1 Then
$villageSize = $village[0]
If $villageSize < 500 Or $g_iDebugDisableZoomout = 1 Then
$z = $village[1]
$x = $village[2]
$y = $village[3]
$stone[0] = $village[4]
$stone[1] = $village[5]
$aResult[0] = "zoomout:" & $village[6]
$aResult[1] = $x
$aResult[2] = $y
If $bCenterVillage = True And($x <> 0 Or $y <> 0) And($UpdateMyVillage = False Or $x <> $g_iVILLAGE_OFFSET[0] Or $y <> $g_iVILLAGE_OFFSET[1]) Then
If $DebugLog Then SetDebugLog("Center Village" & $sSource & " by: " & $x & ", " & $y)
If $aScrollPos[0] = 0 And $aScrollPos[1] = 0 Then
$aScrollPos[0] = $stone[0]
$aScrollPos[1] = $stone[1]
EndIf
ClickDrag($aScrollPos[0], $aScrollPos[1], $aScrollPos[0] - $x, $aScrollPos[1] - $y)
If _Sleep(250) Then Return $aResult
Local $aResult2 = SearchZoomOut(False, $UpdateMyVillage)
$aResult2[3] = $aResult2[1] - $aResult[1]
$aResult2[4] = $aResult2[2] - $aResult[2]
If $DebugLog Then SetDebugLog("Centered Village Offset" & $sSource & ": " & $aResult2[1] & ", " & $aResult2[2] & ", change: " & $aResult2[3] & ", " & $aResult2[4])
Return $aResult2
EndIf
If $UpdateMyVillage = True Then
If $x <> $g_iVILLAGE_OFFSET[0] Or $y <> $g_iVILLAGE_OFFSET[1] Or $z <> $g_iVILLAGE_OFFSET[2] Then
If $DebugLog Then SetDebugLog("Village Offset" & $sSource & " updated to " & $x & ", " & $y & ", " & $z)
EndIf
setVillageOffset($x, $y, $z)
ConvertInternalExternArea()
EndIf
EndIf
EndIf
If $UpdateMyVillage = True Then
If $aResult[0] = "" Then
If $g_aiSearchZoomOutCounter[0] > 20 Then
$g_aiSearchZoomOutCounter[0] = 0
SetLog("Restart CoC to reset zoom" & $sSource & "...", $COLOR_INFO)
PoliteCloseCoC("Zoomout" & $sSource)
If _Sleep(1000) Then Return $aResult
CloseCoC()
OpenCoC()
Return SearchZoomOut()
Else
$g_aiSearchZoomOutCounter[0] += 1
EndIf
Else
If $g_iDebugDisableZoomout = 0 And $villageSize > 480 Then
If $g_bSkipFirstZoomout = False Then
$aResult[0] = ""
ElseIf $g_aiSearchZoomOutCounter[1] > 0 And $g_aiSearchZoomOutCounter[0] > 0 Then
$g_aiSearchZoomOutCounter[1] -= 1
$aResult[0] = ""
EndIf
EndIf
EndIf
$g_bSkipFirstZoomout = True
EndIf
Return $aResult
EndFunc
Func InitAndroidTimeLag()
$g_aiAndroidTimeLag[0] = 0
$g_aiAndroidTimeLag[1] = 0
$g_aiAndroidTimeLag[2] = 0
$g_aiAndroidTimeLag[3] = 0
EndFunc
Func checkAndroidTimeLag($bRebootAndroid = True)
SetError(0, 0)
If $g_bAndroidCheckTimeLagEnabled = False Then Return SetError(1, 0, False)
Local $androidUTC = $g_aiAndroidTimeLag[1]
Local $hostTimer = $g_aiAndroidTimeLag[2]
If $hostTimer <> 0 And TimerDiff($hostTimer) / 1000 < 60 Then
Return SetError(3, 0, False)
EndIf
Local $s = AndroidAdbSendShellCommand("date +%s")
If @error <> 0 Then Return SetError(4, 0, False)
Local $curr_androidUTC = Number($s)
Local $curr_hostTimer = TimerInit()
If $curr_androidUTC < 1 Then
InitAndroidTimeLag()
Return SetError(5, 0, False)
EndIf
If $androidUTC = 0 Or $hostTimer = 0 Then
$g_aiAndroidTimeLag[1] = $curr_androidUTC
$g_aiAndroidTimeLag[2] = $curr_hostTimer
$g_aiAndroidTimeLag[3] = 0
Return SetError(2, 0, False)
EndIf
Local $hostSeconds = Int(TimerDiff($hostTimer) / 1000)
Local $hostMinutes = $hostSeconds / 60
Local $androidSeconds = $curr_androidUTC - $androidUTC
Local $lagTotal = $hostSeconds - $androidSeconds
Local $lagPerMin = Int($lagTotal / $hostMinutes)
SetDebugLog($g_sAndroidEmulator & " time lag is " &($lagPerMin > 0 ? "> " : "") & $lagPerMin & " sec/min (avg for " & $hostSeconds & " sec)")
If $androidSeconds <= 0 Then
InitAndroidTimeLag()
Return SetError(6, 0, False)
EndIf
If $lagPerMin < 0 Then $lagPerMin = 0
$g_aiAndroidTimeLag[0] = $lagPerMin
$g_aiAndroidTimeLag[1] = $curr_androidUTC
$g_aiAndroidTimeLag[2] = $curr_hostTimer
$g_aiAndroidTimeLag[3] = 0
Local $bRebooted = False
If $lagPerMin > $g_iAndroidTimeLagThreshold Then
If $bRebootAndroid = True Then
SetLog("Rebooting " & $g_sAndroidEmulator & " due to time lag problem of " & $lagPerMin & " sec/min", $COLOR_ERROR)
$bRebooted = True
EndIf
EndIf
Return SetError(0, $lagPerMin, $bRebooted)
EndFunc
Global $g_aiAndroidPageError[2]=[0,0]
Func InitAndroidPageError()
$g_aiAndroidPageError[0] = 0
$g_aiAndroidPageError[1] = 0
EndFunc
Func checkAndroidPageError($bRebootAndroid = True)
If $g_aiAndroidPageError[1] = 0 Then Return False
Local $bResetTimer = TimerDiff($g_aiAndroidPageError[1]) > $g_iAndroidRebootPageErrorPerMinutes * 60 * 1000
If $g_aiAndroidPageError[0] >= $g_iAndroidRebootPageErrorCount And $bResetTimer = False Then
Local $sMin = Round(TimerDiff($g_aiAndroidPageError[1]) /(60 * 1000), 1) & " Minutes"
If $bRebootAndroid = True Then
SetLog("Reboot " & $g_sAndroidEmulator & " due to " & $g_aiAndroidPageError[0] & " page errors in " & $sMin, $COLOR_ERROR)
Else
SetLog($g_sAndroidEmulator & " had " & $g_aiAndroidPageError[0] & " page errors in " & $sMin, $COLOR_ERROR)
EndIf
InitAndroidPageError()
If $bRebootAndroid = True Then
Return True
EndIf
Return False
EndIf
If $bResetTimer = True Then
If $g_aiAndroidPageError[0] > 0 Then
SetDebugLog("Cleared " & $g_aiAndroidPageError[0] & " " & $g_sAndroidEmulator & " page errors")
EndIf
InitAndroidPageError()
EndIf
Return False
EndFunc
Func AndroidPageError($sSource)
$g_aiAndroidPageError[0] += 1
SetDebugLog("Page error count increased to " & $g_aiAndroidPageError[0] & ", source: " & $sSource)
If $g_aiAndroidPageError[1] = 0 Then $g_aiAndroidPageError[1] = TimerInit()
Return $g_aiAndroidPageError[0]
EndFunc
Func OpenBS($bRestart = False)
Return OpenAndroid($bRestart)
EndFunc
Func OpenBlueStacks($bRestart = False)
Local $hTimer, $iCount = 0
Local $PID, $ErrorResult, $connected_to
SetLog("Starting BlueStacks and Clash Of Clans", $COLOR_SUCCESS)
$PID = ShellExecute($__BlueStacks_Path & "HD-Frontend.exe", "Android")
If _Sleep(1000) Then Return False
$ErrorResult = ControlGetHandle("BlueStacks Error", "", "")
If $g_iDebugSetlog = 1 Then Setlog("$PID= "&$PID & ", $ErrorResult = " &$ErrorResult, $COLOR_DEBUG)
If $PID = 0 Or $ErrorResult <> 0 Then
SetLog("Unable to load Clash of Clans, install/reinstall the game.", $COLOR_ERROR)
SetLog("Unable to continue........", $COLOR_WARNING)
btnstop()
SetError(1, 1, -1)
Return False
EndIf
SetLog("Please wait while " & $g_sAndroidEmulator & "/CoC start....", $COLOR_SUCCESS)
WinGetAndroidHandle()
$hTimer = TimerInit()
While IsArray(ControlGetPos($Title, $g_sAppPaneName, $g_sAppClassInstance)) = False
If _Sleep(3000) Then ExitLoop
_StatusUpdateTime($hTimer, $g_sAndroidEmulator & "/CoC Start")
If TimerDiff($hTimer) > $g_iAndroidLaunchWaitSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog("BlueStacks refuses to load, waited " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds", $COLOR_ERROR)
DebugSaveDesktopImage("BSOpenError_")
SetLog("Unable to continue........", $COLOR_WARNING)
btnstop()
SetError(1, 1, -1)
Return False
EndIf
WinGetAndroidHandle()
WEnd
If IsArray(ControlGetPos($Title, $g_sAppPaneName, $g_sAppClassInstance)) Then
$connected_to = ConnectAndroidAdb(False, 3000)
SetLog("BlueStacks Loaded, took " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds to begin.", $COLOR_SUCCESS)
Return True
EndIf
Return False
EndFunc
Func OpenBlueStacks2($bRestart = False)
Local $hTimer, $iCount = 0, $cmdOutput, $process_killed, $i, $connected_to
SetLog("Starting " & $g_sAndroidEmulator & " and Clash Of Clans", $COLOR_SUCCESS)
If Not InitAndroid() Then Return False
SetLog("Please wait while " & $g_sAndroidEmulator & " and CoC start...", $COLOR_SUCCESS)
CloseUnsupportedBlueStacks2()
$hTimer = TimerInit()
WinGetAndroidHandle()
While IsArray(ControlGetPos($Title, $g_sAppPaneName, $g_sAppClassInstance)) = False
If Not $g_bRunState Then Return False
Local $pid = ProcessExists2($g_sAndroidProgramPath)
If $pid <= 0 Then
$pid = ShellExecute($g_sAndroidProgramPath, GetBlueStacks2ProgramParameter())
If _Sleep(1000) Then Return False
EndIf
If $pid > 0 Then $pid = ProcessExists2($g_sAndroidProgramPath)
If $pid <= 0 Then
CloseAndroid("OpenBlueStacks2")
If _Sleep(1000) Then Return False
EndIf
_StatusUpdateTime($hTimer)
If TimerDiff($hTimer) > $g_iAndroidLaunchWaitSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog($g_sAndroidEmulator & " refuses to load, waited " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds", $COLOR_ERROR)
SetError(1, @extended, False)
Return False
EndIf
If _Sleep(3000) Then Return False
_StatusUpdateTime($hTimer, $g_sAndroidEmulator & "/CoC Start")
WinGetAndroidHandle()
WEnd
WinGetAndroidHandle()
Local $lCurStyle = _WinAPI_GetWindowLong($HWnD, $GWL_STYLE)
$lCurStyle = BitOr($lCurStyle, $WS_CAPTION, $WS_SYSMENU)
_WinAPI_SetWindowLong($HWnd, $GWL_STYLE, $lCurStyle)
If IsArray(ControlGetPos($Title, $g_sAppPaneName, $g_sAppClassInstance)) Then
$connected_to = ConnectAndroidAdb(False, 3000)
If WaitForAndroidBootCompleted($g_iAndroidLaunchWaitSec - TimerDiff($hTimer) / 1000, $hTimer) Then Return
If Not $g_bRunState Then Return False
SetLog($g_sAndroidEmulator & " Loaded, took " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds to begin.", $COLOR_SUCCESS)
AndroidAdbLaunchShellInstance()
If Not $g_bRunState Then Return False
ConfigBlueStacks2WindowManager()
Return True
EndIf
Return False
EndFunc
Func InitBlueStacksX($bCheckOnly = False, $bAdjustResolution = False, $bLegacyMode = False)
Local $plusMode = RegRead($g_sHKLM & "\SOFTWARE\BlueStacks\", "Engine") = "plus" And $bLegacyMode = False
Local $frontend_exe = "HD-Frontend.exe"
If $plusMode = True Then $frontend_exe = "HD-Plus-Frontend.exe"
Local $i, $aFiles[3] = [$frontend_exe, "HD-Adb.exe", "HD-Quit.exe"]
Local $Values[4][3] = [ ["Screen Width", $g_iAndroidClientWidth , $g_iAndroidClientWidth], ["Screen Height", $g_iAndroidClientHeight, $g_iAndroidClientHeight], ["Window Width", $g_iAndroidWindowWidth , $g_iAndroidWindowWidth], ["Window Height", $g_iAndroidWindowHeight , $g_iAndroidWindowHeight] ]
Local $bChanged = False
$__BlueStacks_Version = RegRead($g_sHKLM & "\SOFTWARE\BlueStacks\", "Version")
$__BlueStacks_Path = RegRead($g_sHKLM & "\SOFTWARE\BlueStacks\", "InstallDir")
If @error <> 0 Then
$__BlueStacks_Path = @ProgramFilesDir & "\BlueStacks\"
SetError(0, 0, 0)
EndIf
$__BlueStacks_Path = StringReplace($__BlueStacks_Path, "\\", "\")
For $i = 0 To UBound($aFiles) - 1
Local $File = $__BlueStacks_Path & $aFiles[$i]
If Not FileExists($File) Then
If $plusMode And $aFiles[$i] = $frontend_exe Then
SetDebugLog("Cannot find " & $g_sAndroidEmulator & " file:" & $File, $COLOR_ACTION)
SetDebugLog("Try legacy mode", $COLOR_ACTION)
Return InitBlueStacksX($bCheckOnly, $bAdjustResolution, True)
EndIf
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_ERROR)
SetLog($File, $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIf
Next
If Not $bCheckOnly Then
Local $BootParameter = RegRead($g_sHKLM & "\SOFTWARE\BlueStacks\Guests\Android\", "BootParameters")
Local $OEMFeatures
Local $aRegExResult = StringRegExp($BootParameter, "OEMFEATURES=(\d+)", $STR_REGEXPARRAYGLOBALMATCH)
If Not @error Then
$OEMFeatures = $aRegExResult[UBound($aRegExResult) - 1]
$g_bAndroidHasSystemBar = BitAND($OEMFeatures, 0x000001) = 0
EndIf
$g_sAndroidProgramPath = $__BlueStacks_Path & $frontend_exe
$g_sAndroidAdbPath = FindPreferredAdbPath()
If $g_sAndroidAdbPath = "" Then $g_sAndroidAdbPath = $__BlueStacks_Path & "HD-Adb.exe"
$g_sAndroidVersion = $__BlueStacks_Version
For $i = 0 To 5
If RegRead($g_sHKLM & "\SOFTWARE\BlueStacks\Guests\Android\SharedFolder\" & $i & "\", "Name") = "BstSharedFolder" Then
$g_sAndroidPicturesPath = "/storage/sdcard/windows/BstSharedFolder/"
$g_sAndroidPicturesHostPath = RegRead($g_sHKLM & "\SOFTWARE\BlueStacks\Guests\Android\SharedFolder\" & $i & "\", "Path")
ExitLoop
EndIf
Next
SetDebugLog($g_sAndroidEmulator & " Engine 'Plus'-Mode: " & $plusMode)
SetDebugLog($g_sAndroidEmulator & " OEM Features: " & $OEMFeatures)
SetDebugLog($g_sAndroidEmulator & " System Bar is " &($g_bAndroidHasSystemBar ? "" : "not ") & "available")
For $i = 0 To UBound($Values) -1
If $Values[$i][1] <> $Values[$i][2] Then
$bChanged = True
SetDebugLog($g_sAndroidEmulator & " " & $Values[$i][0] & " updated from " & $Values[$i][1] & " to " & $Values[$i][2])
EndIf
Next
WinGetAndroidHandle()
EndIf
Return True
EndFunc
Func InitBlueStacks($bCheckOnly = False)
Local $bInstalled = InitBlueStacksX($bCheckOnly)
If $bInstalled And(GetVersionNormalized($__BlueStacks_Version) < GetVersionNormalized("0.8") Or GetVersionNormalized($__BlueStacks_Version) > GetVersionNormalized("1.x") > 0) Then
If Not $bCheckOnly Then
SetLog("BlueStacks version is " & $__BlueStacks_Version & " but support version 0.8.x - 1.x not found", $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIF
If Not $bCheckOnly Then
$g_bAndroidHasSystemBar = True
EndIF
Return $bInstalled
EndFunc
Func InitBlueStacks2($bCheckOnly = False)
Local $bInstalled = InitBlueStacksX($bCheckOnly, True)
If $bInstalled And StringInStr($__BlueStacks_Version, "2.") <> 1 Then
If Not $bCheckOnly Then
SetLog("BlueStacks supported version 2 not found", $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIF
If Not $bCheckOnly Then
EndIF
Return $bInstalled
EndFunc
Func RestartBlueStacksXCoC()
If Not $g_bRunState Then Return False
Local $cmdOutput, $process_killed
If Not InitAndroid() Then Return False
If WinGetAndroidHandle() = 0 Then Return False
$cmdOutput = LaunchConsole($g_sAndroidAdbPath, "-s " & $g_sAndroidAdbDevice & " shell am start -W -S -n " & $g_sAndroidGamePackage & "/" & $g_sAndroidGameClass, $process_killed)
SetLog("Please wait for CoC restart......", $COLOR_INFO)
Return True
EndFunc
Func RestartBlueStacksCoC()
Return RestartBlueStacksXCoC()
EndFunc
Func RestartBlueStacks2CoC()
Return RestartBlueStacksXCoC()
EndFunc
Func CheckScreenBlueStacksX($bSetLog = True)
Local $REGISTRY_KEY_DIRECTORY = $g_sHKLM & "\SOFTWARE\BlueStacks\Guests\Android\FrameBuffer\0"
Local $aValues[5][2] = [ ["FullScreen", 0], ["GuestHeight", $g_iAndroidClientHeight], ["GuestWidth", $g_iAndroidClientWidth], ["WindowHeight", $g_iAndroidClientHeight], ["WindowWidth", $g_iAndroidClientWidth] ]
Local $i, $Value, $iErrCnt = 0
For $i = 0 To UBound($aValues) -1
$Value = RegRead($REGISTRY_KEY_DIRECTORY, $aValues[$i][0])
If $Value <> $aValues[$i][1] Then
If $iErrCnt = 0 Then
If $bSetLog Then
SetLog("MyBot doesn't work with " & $g_sAndroidEmulator & " screen configuration!", $COLOR_ERROR)
Else
SetDebugLog("MyBot doesn't work with " & $g_sAndroidEmulator & " screen configuration!", $COLOR_ERROR)
EndIf
EndIf
If $bSetLog Then
SetLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_ERROR)
Else
SetDebugLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_ERROR)
EndIf
$iErrCnt += 1
EndIf
Next
If $iErrCnt > 0 Then Return False
Return True
EndFunc
Func CheckScreenBlueStacks($bSetLog = True)
Return CheckScreenBlueStacksX($bSetLog)
EndFunc
Func CheckScreenBlueStacks2($bSetLog = True)
Return CheckScreenBlueStacksX($bSetLog)
EndFunc
Func SetScreenBlueStacks()
Local $REGISTRY_KEY_DIRECTORY = $g_sHKLM & "\SOFTWARE\BlueStacks\Guests\Android\FrameBuffer\0"
RegWrite($REGISTRY_KEY_DIRECTORY, "FullScreen", "REG_DWORD", "0")
RegWrite($REGISTRY_KEY_DIRECTORY, "GuestHeight", "REG_DWORD", $g_iAndroidClientHeight)
RegWrite($REGISTRY_KEY_DIRECTORY, "GuestWidth", "REG_DWORD", $g_iAndroidClientWidth)
RegWrite($REGISTRY_KEY_DIRECTORY, "WindowHeight", "REG_DWORD", $g_iAndroidClientHeight)
RegWrite($REGISTRY_KEY_DIRECTORY, "WindowWidth", "REG_DWORD", $g_iAndroidClientWidth)
EndFunc
Func SetScreenBlueStacks2()
Local $REGISTRY_KEY_DIRECTORY = $g_sHKLM & "\SOFTWARE\BlueStacks\Guests\Android\FrameBuffer\0"
RegWrite($REGISTRY_KEY_DIRECTORY, "FullScreen", "REG_DWORD", "0")
RegWrite($REGISTRY_KEY_DIRECTORY, "GuestHeight", "REG_DWORD", $g_iAndroidClientHeight)
RegWrite($REGISTRY_KEY_DIRECTORY, "GuestWidth", "REG_DWORD", $g_iAndroidClientWidth)
RegWrite($REGISTRY_KEY_DIRECTORY, "WindowHeight", "REG_DWORD", $g_iAndroidClientHeight)
RegWrite($REGISTRY_KEY_DIRECTORY, "WindowWidth", "REG_DWORD", $g_iAndroidClientWidth)
$REGISTRY_KEY_DIRECTORY = $g_sHKLM & "\SOFTWARE\BlueStacks\Guests\Android\Config"
RegWrite($REGISTRY_KEY_DIRECTORY, "FEControlBar", "REG_DWORD", "0")
EndFunc
Func RebootBlueStacksSetScreen()
Return RebootAndroidSetScreenDefault()
EndFunc
Func ConfigBlueStacks2WindowManager()
If Not $g_bRunState Then Return
Local $cmdOutput, $process_killed
$cmdOutput = LaunchConsole($g_sAndroidAdbPath, "-s " & $g_sAndroidAdbDevice & " shell wm size reset", $process_killed)
$cmdOutput = LaunchConsole($g_sAndroidAdbPath, "-s " & $g_sAndroidAdbDevice & " shell wm density 160", $process_killed)
AndroidSetFontSizeNormal()
EndFunc
Func RebootBlueStacks2SetScreen($bOpenAndroid = True)
If Not InitAndroid() Then Return False
ConfigBlueStacks2WindowManager()
CloseAndroid("RebootBlueStacks2SetScreen")
If _Sleep(1000) Then Return False
SetScreenAndroid()
If Not $g_bRunState Then Return False
If $bOpenAndroid Then
OpenAndroid(True)
EndIf
Return True
EndFunc
Func GetBlueStacksRunningInstance($bStrictCheck = True)
WinGetAndroidHandle()
Local $a[2] = [$HWnD, ""]
Return $a
EndFunc
Func GetBlueStacks2RunningInstance($bStrictCheck = True)
WinGetAndroidHandle()
Local $a[2] = [$HWnD, ""]
If $HWnD <> 0 Then Return $a
If $bStrictCheck Then Return False
Local $WinTitleMatchMode = Opt("WinTitleMatchMode", -3)
Local $h = WinGetHandle("Bluestacks App Player", "")
If @error = 0 Then
$a[0] = $h
EndIf
Opt("WinTitleMatchMode", $WinTitleMatchMode)
Return $a
EndFunc
Func GetBlueStacksProgramParameter($bAlternative = False)
Return "Android"
EndFunc
Func GetBlueStacks2ProgramParameter($bAlternative = False)
Return "Android"
EndFunc
Func BlueStacksBotStartEvent()
If $g_bAndroidEmbedded = False Then
SetDebugLog("Disable " & $g_sAndroidEmulator & " minimize/maximize Window Buttons")
DisableBS($HWnD, $SC_MINIMIZE)
DisableBS($HWnD, $SC_MAXIMIZE)
EndIf
Return AndroidCloseSystemBar()
EndFunc
Func BlueStacksBotStopEvent()
If $g_bAndroidEmbedded = False Then
SetDebugLog("Enable " & $g_sAndroidEmulator & " minimize/maximize Window Buttons")
EnableBS($HWnD, $SC_MINIMIZE)
EnableBS($HWnD, $SC_MAXIMIZE)
EndIf
Return AndroidOpenSystemBar()
EndFunc
Func BlueStacks2BotStartEvent()
If $g_bAndroidEmbedded = False Then
SetDebugLog("Disable " & $g_sAndroidEmulator & " minimize/maximize Window Buttons")
DisableBS($HWnD, $SC_MINIMIZE)
DisableBS($HWnD, $SC_MAXIMIZE)
EndIf
If $g_bAndroidHasSystemBar Then Return AndroidCloseSystemBar()
Return False
EndFunc
Func BlueStacks2BotStopEvent()
If $g_bAndroidEmbedded = False Then
SetDebugLog("Enable " & $g_sAndroidEmulator & " minimize/maximize Window Buttons")
EnableBS($HWnD, $SC_MINIMIZE)
EnableBS($HWnD, $SC_MAXIMIZE)
EndIf
If $g_bAndroidHasSystemBar Then Return AndroidOpenSystemBar()
Return False
EndFunc
Func BlueStacksAdjustClickCoordinates(ByRef $x, ByRef $y)
$x = Round(32767.0 / $g_iAndroidClientWidth * $x)
$y = Round(32767.0 / $g_iAndroidClientHeight * $y)
EndFunc
Func BlueStacks2AdjustClickCoordinates(ByRef $x, ByRef $y)
$x = Round(32767.0 / $g_iAndroidClientWidth * $x)
$y = Round(32767.0 / $g_iAndroidClientHeight * $y)
EndFunc
Func DisableBS($HWnD, $iButton)
Local $hSysMenu = _GUICtrlMenu_GetSystemMenu($HWnD, 0)
_GUICtrlMenu_RemoveMenu($hSysMenu, $iButton, False)
_GUICtrlMenu_DrawMenuBar($HWnD)
EndFunc
Func EnableBS($HWnD, $iButton)
Local $hSysMenu = _GUICtrlMenu_GetSystemMenu($HWnD, 1)
_GUICtrlMenu_RemoveMenu($hSysMenu, $iButton, False)
_GUICtrlMenu_DrawMenuBar($HWnD)
EndFunc
Func GetBlueStacksSvcPid()
Local $pid = ProcessExists2("HD-Service.exe")
Return $pid
EndFunc
Func CloseBlueStacks()
Local $iIndex, $bOops = False
Local $aServiceList[4] = ["BstHdAndroidSv", "BstHdLogRotatorSvc", "BstHdUpdaterSvc", "bthserv"]
If Not InitAndroid() Then Return
RunWait($__BlueStacks_Path & "HD-Quit.exe")
If @error <> 0 Then
SetLog($g_sAndroidEmulator & " failed to quit", $COLOR_ERROR)
EndIf
If _Sleep(2000) Then Return
$bOops = ProcessExists("HD-Frontend.exe") <> 0
If $bOops Then
$bOops = False
SetDebugLog("Failed to terminate HD-Frontend.exe with HD-Quit.exe, fallback to taskkill", $COLOR_ERROR)
KillBSProcess()
If _Sleep(1000) Then Return
SetLog("Please wait for full BS shutdown....", $COLOR_SUCCESS)
For $iIndex = 0 To UBound($aServiceList) - 1
ServiceStop($aServiceList[$iIndex])
If @error Then
$bOops = True
If $g_iDebugSetlog = 1 Then Setlog($aServiceList[$iIndex] & "errored trying to stop", $COLOR_WARNING)
EndIf
Next
If $bOops Then
If $g_iDebugSetlog = 1 Then Setlog("Service Stop issues, Stopping BS 2nd time", $COLOR_WARNING)
KillBSProcess()
If _SleepStatus(5000) Then Return
EndIf
EndIf
If $g_iDebugSetlog = 1 And $bOops Then
SetLog("BS Kill Failed to stop service", $COLOR_ERROR)
EndIf
If $bOops Then
SetError(1, @extended, -1)
EndIf
EndFunc
Func CloseBlueStacks2()
Local $bOops = False
If Not InitAndroid() Then Return
RunWait($__BlueStacks_Path & "HD-Quit.exe")
If @error <> 0 Then
SetLog($g_sAndroidEmulator & " failed to quit", $COLOR_ERROR)
EndIf
If _Sleep(2000) Then Return
If $bOops Then
SetError(1, @extended, -1)
EndIf
EndFunc
Func KillBSProcess()
Local $iIndex
Local $aBS_FileNames[8][2] = [['HD-Agent.exe', 0], ['HD-BlockDevice.exe', 0], ['HD-Frontend.exe', 0], ['HD-Network.exe', 0], ['HD-Service.exe', 0], ['HD-SharedFolder.exe', 0], ['HD-UpdaterService.exe', 0], ['HD-Adb.exe', 0]]
For $iIndex = 0 To UBound($aBS_FileNames) - 1
$aBS_FileNames[$iIndex][1] = ProcessExists($aBS_FileNames[$iIndex][0])
If $g_iDebugSetlog = 1 Then Setlog($aBS_FileNames[$iIndex][0] & " PID = " & $aBS_FileNames[$iIndex][1], $COLOR_DEBUG)
If $aBS_FileNames[$iIndex][1] > 0 Then
ShellExecute(@WindowsDir & "\System32\taskkill.exe", " -t -pid " & $aBS_FileNames[$iIndex][1], "", Default, @SW_HIDE)
If _Sleep(1000) Then Return
EndIf
If ProcessExists($aBS_FileNames[$iIndex][1]) Then
If $g_iDebugSetlog = 1 Then Setlog($aBS_FileNames[$iIndex][0] & " 1st Kill failed, trying again", $COLOR_DEBUG)
ShellExecute(@WindowsDir & "\System32\taskkill.exe", "-f -t -pid " & $aBS_FileNames[$iIndex][1], "", Default, @SW_HIDE)
If _Sleep(500) Then Return
EndIf
Next
EndFunc
Func ServiceStop($sServiceName)
Local $ServiceRunning, $svcWaitIterations, $data, $pid, $hTimer, $bFailed, $Result
$hTimer = TimerInit()
$Result = RunWait(@ComSpec & " /c " & 'net stop ' & $sServiceName, "", @SW_HIDE)
If @error Then
Setlog("net stop service failed on " & $sServiceName & ", Result= " & $Result, $COLOR_ERROR)
SetError(1, @extended, -1)
Return
EndIf
$ServiceRunning = True
$svcWaitIterations = 0
While $ServiceRunning
_StatusUpdateTime($hTimer, "BS Service Stop")
$data = ""
$pid = Run(@WindowsDir & '\System32\sc.exe query ' & $sServiceName, '', @SW_HIDE, 2)
Do
$data &= StdoutRead($pid)
Until @error
StdioClose($pid)
$Result = StringInStr($data, "stopped")
$bFailed = StringInStr($data, "failed")
If $Result Then
$ServiceRunning = False
EndIf
$svcWaitIterations = $svcWaitIterations + 1
If $svcWaitIterations > 15 Or $bFailed Then
SetError(1, @extended, -1)
$ServiceRunning = False
EndIf
If _Sleep(1000) Then Return
WEnd
If $g_iDebugSetlog = 1 And $svcWaitIterations > 15 Then
SetLog("Failed to stop service " & $sServiceName, $COLOR_ERROR)
Else
If $g_iDebugSetlog = 1 Then SetLog($sServiceName & "Service stopped successfully", $COLOR_SUCCESS)
EndIf
EndFunc
Func CloseUnsupportedBlueStacks2()
Local $WinTitleMatchMode = Opt("WinTitleMatchMode", -3)
If IsArray(ControlGetPos("Bluestacks App Player", "", "")) Then
Opt("WinTitleMatchMode", $WinTitleMatchMode)
SetLog("MyBot doesn't work with " & $g_sAndroidEmulator & " App Player", $COLOR_ERROR)
SetLog("Please let MyBot start " & $g_sAndroidEmulator & " automatically", $COLOR_INFO)
RebootBlueStacks2SetScreen(False)
Return True
EndIf
Opt("WinTitleMatchMode", $WinTitleMatchMode)
Return False
EndFunc
Func OpenDroid4X($bRestart = False)
Local $PID, $hTimer, $iCount = 0, $process_killed, $cmdOutput, $connected_to, $launchAndroid, $cmdPar
SetLog("Starting " & $g_sAndroidEmulator & " and Clash Of Clans", $COLOR_SUCCESS)
$launchAndroid = WinGetAndroidHandle() = 0
If $launchAndroid Then
$cmdPar = GetAndroidProgramParameter()
SetDebugLog("ShellExecute: " & $g_sAndroidProgramPath & " " & $cmdPar)
$PID = ShellExecute($g_sAndroidProgramPath, $cmdPar)
If _Sleep(1000) Then Return False
If $PID <> 0 Then $PID = ProcessExists($PID)
SetDebugLog("$PID= "&$PID)
If $PID = 0 Then
SetLog("Unable to load " & $g_sAndroidEmulator &($g_sAndroidInstance = "" ? "" : "(" & $g_sAndroidInstance & ")") & ", please check emulator/installation.", $COLOR_ERROR)
SetLog("Unable to continue........", $COLOR_WARNING)
btnStop()
SetError(1, 1, -1)
Return False
EndIf
EndIf
$connected_to = ConnectAndroidAdb(False, 60 * 1000)
If Not $g_bRunState Then Return False
SetLog("Please wait while " & $g_sAndroidEmulator & " and CoC start...", $COLOR_SUCCESS)
$hTimer = TimerInit()
If WaitForAndroidBootCompleted($g_iAndroidLaunchWaitSec - TimerDiff($hTimer) / 1000, $hTimer) Then Return False
If Not $g_bRunState Then Return False
If TimerDiff($hTimer) >= $g_iAndroidLaunchWaitSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog($g_sAndroidEmulator & " refuses to load, waited " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds for window", $COLOR_ERROR)
SetError(1, @extended, False)
Return False
EndIf
SetLog($g_sAndroidEmulator & " Loaded, took " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds to begin.", $COLOR_SUCCESS)
Return True
EndFunc
Func GetDroid4XProgramParameter($bAlternative = False)
If Not $bAlternative Or $g_sAndroidInstance <> $g_avAndroidAppConfig[$g_iAndroidConfig][1] Then
Return "-o " &($g_sAndroidInstance = "" ? $g_avAndroidAppConfig[$g_iAndroidConfig][1] : $g_sAndroidInstance)
EndIf
Return ""
EndFunc
Func GetDroid4XPath()
Local $droid4xPath = RegRead($g_sHKLM & "\SOFTWARE\Droid4X\", "InstallDir")
If @error <> 0 Then
Local $DisplayIcon = RegRead($g_sHKLM & "\SOFTWARE" & $g_sWow6432Node & "\Microsoft\Windows\CurrentVersion\Uninstall\Droid4X\", "DisplayIcon")
If @error = 0 Then
Local $iLastBS = StringInStr($DisplayIcon, "\", 0, -1)
$droid4xPath = StringLeft($DisplayIcon, $iLastBS)
EndIf
EndIf
If @error <> 0 Then
$droid4xPath = @ProgramFilesDir & "\Droid4X\"
SetError(0, 0, 0)
EndIf
Return StringReplace($droid4xPath, "\\", "\")
EndFunc
Func GetDroid4XAdbPath()
Local $adbPath = GetDroid4XPath() & "adb.exe"
If FileExists($adbPath) Then Return $adbPath
Return ""
EndFunc
Func InitDroid4X($bCheckOnly = False)
Local $process_killed, $aRegExResult, $VirtualBox_Path, $g_sAndroidAdbDeviceHost, $g_sAndroidAdbDevicePort, $oops = 0
$__Droid4X_Version = RegRead($g_sHKLM & "\SOFTWARE" & $g_sWow6432Node & "\Microsoft\Windows\CurrentVersion\Uninstall\Droid4X\", "DisplayVersion")
$__Droid4X_Path = GetDroid4XPath()
$VirtualBox_Path = RegRead($g_sHKLM & "\SOFTWARE\Oracle\VirtualBox\", "InstallDir")
If @error <> 0 Then
$VirtualBox_Path = @ProgramFilesDir & "\Oracle\VirtualBox\"
SetError(0, 0, 0)
EndIf
$VirtualBox_Path = StringReplace($VirtualBox_Path, "\\", "\")
If FileExists($__Droid4X_Path & "Droid4X.exe") = False Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_ERROR)
SetLog($__Droid4X_Path & "Droid4X.exe", $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIf
If FileExists($__Droid4X_Path & "adb.exe") = False Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_ERROR)
SetLog($__Droid4X_Path & "adb.exe", $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIf
If FileExists($VirtualBox_Path & "VBoxManage.exe") = False Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find VirtualBox:", $COLOR_ERROR)
SetLog($VirtualBox_Path & "VBoxManage.exe", $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIf
If Not $bCheckOnly Then
InitAndroidConfig(True)
$__VBoxManage_Path = $VirtualBox_Path & "VBoxManage.exe"
$__VBoxVMinfo = LaunchConsole($__VBoxManage_Path, "showvminfo " & $g_sAndroidInstance, $process_killed)
If StringInStr($__VBoxVMinfo, "Could not find a registered machine named") > 0 Then
SetLog("Cannot find " & $g_sAndroidEmulator & " instance " & $g_sAndroidInstance, $COLOR_ERROR)
Return False
EndIf
$aRegExResult = StringRegExp($__VBoxVMinfo, "ADB_PORT.*host ip = ([^,]+),", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidAdbDeviceHost = $aRegExResult[0]
If $g_iDebugSetlog = 1 Then Setlog("Func LaunchConsole: Read $g_sAndroidAdbDeviceHost = " & $g_sAndroidAdbDeviceHost, $COLOR_DEBUG)
Else
$oops = 1
SetLog("Cannot read " & $g_sAndroidEmulator & "(" & $g_sAndroidInstance & ") ADB Device Host", $COLOR_ERROR)
EndIF
$aRegExResult = StringRegExp($__VBoxVMinfo, "ADB_PORT.*host port = (\d{3,5}),", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidAdbDevicePort = $aRegExResult[0]
If $g_iDebugSetlog = 1 Then Setlog("Func LaunchConsole: Read $g_sAndroidAdbDevicePort = " & $g_sAndroidAdbDevicePort, $COLOR_DEBUG)
Else
$oops = 1
SetLog("Cannot read " & $g_sAndroidEmulator & "(" & $g_sAndroidInstance & ") ADB Device Port", $COLOR_ERROR)
EndIF
If $oops = 0 Then
$g_sAndroidAdbDevice = $g_sAndroidAdbDeviceHost & ":" & $g_sAndroidAdbDevicePort
Else
SetLog("Using ADB default device " & $g_sAndroidAdbDevice & " for " & $g_sAndroidEmulator, $COLOR_ERROR)
EndIf
$g_sAndroidProgramPath = $__Droid4X_Path & "Droid4X.exe"
$g_sAndroidAdbPath = FindPreferredAdbPath()
If $g_sAndroidAdbPath = "" Then $g_sAndroidAdbPath = $__Droid4X_Path & "adb.exe"
$g_sAndroidVersion = $__Droid4X_Version
If $g_sAndroidInstance = "" Or StringCompare($g_sAndroidInstance, $g_avAndroidAppConfig[$g_iAndroidConfig][1]) = 0 Then
Else
If $Title = $g_avAndroidAppConfig[$g_iAndroidConfig][2] Then
$Title = StringReplace($g_avAndroidAppConfig[$g_iAndroidConfig][2], "Droid4X", $g_sAndroidInstance)
EndIf
EndIf
$g_sAndroidPicturesPath = "/mnt/shared/picture/"
$aRegExResult = StringRegExp($__VBoxVMinfo, "Name: 'picture', Host path: '(.*)'.*", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidPicturesHostPath = $aRegExResult[0] & "\"
$g_bAndroidSharedFolderAvailable = True
Else
SetLog($g_sAndroidEmulator & " Background Mode is not available", $COLOR_ERROR)
$g_sAndroidPicturesHostPath = ""
$g_bAndroidAdbScreencap = False
$g_bAndroidSharedFolderAvailable = False
EndIf
$__VBoxGuestProperties = LaunchConsole($__VBoxManage_Path, "guestproperty enumerate " & $g_sAndroidInstance, $process_killed)
WinGetAndroidHandle()
UpdateDroid4XConfig()
EndIf
Return True
EndFunc
Func SetScreenDroid4X()
If Not $g_bRunState Then Return False
If Not InitAndroid() Then Return False
Local $cmdOutput, $process_killed
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $g_sAndroidInstance & " vbox_graph_mode " & $g_iAndroidClientWidth & "x" & $g_iAndroidClientHeight & "-16", $process_killed)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $g_sAndroidInstance & " vbox_dpi 160", $process_killed)
AndroidPicturePathAutoConfig()
If $g_bAndroidSharedFolderAvailable = False And $g_bAndroidPicturesPathAutoConfig = True And FileExists($g_sAndroidPicturesHostPath) = 1 Then
Local $path = $g_sAndroidPicturesHostPath
If StringRight($path, 1) = "\" Then $path = StringLeft($path, StringLen($path) - 1)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "sharedfolder add " & $g_sAndroidInstance & " --name picture --hostpath """ & $path & """  --automount", $process_killed)
EndIf
Return True
EndFunc
Func RebootDroid4XSetScreen()
Return RebootAndroidSetScreenDefault()
EndFunc
Func CheckScreenDroid4X($bSetLog = True)
If Not InitAndroid() Then Return False
Local $aValues[2][2] = [ ["vbox_dpi", "160"], ["vbox_graph_mode", $g_iAndroidClientWidth & "x" & $g_iAndroidClientHeight & "-16"] ]
Local $i, $Value, $iErrCnt = 0, $process_killed, $aRegExResult, $properties
For $i = 0 To UBound($aValues) -1
$aRegExResult = StringRegExp($__VBoxGuestProperties, "Name: " & $aValues[$i][0] & ", value: (.+), timestamp:", $STR_REGEXPARRAYMATCH)
If @error = 0 Then $Value = $aRegExResult[0]
If $Value <> $aValues[$i][1] Then
If $iErrCnt = 0 Then
If $bSetLog Then
SetLog("MyBot doesn't work with " & $g_sAndroidEmulator & " screen configuration!", $COLOR_ERROR)
Else
SetDebugLog("MyBot doesn't work with " & $g_sAndroidEmulator & " screen configuration!", $COLOR_ERROR)
EndIf
EndIf
If $bSetLog Then
SetLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_ERROR)
Else
SetDebugLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_ERROR)
EndIf
$iErrCnt += 1
EndIf
Next
If $iErrCnt > 0 Then Return False
If AndroidPicturePathAutoConfig(Default, Default, $bSetLog) Then $iErrCnt += 1
Return True
EndFunc
Func UpdateDroid4XConfig()
Return UpdateDroid4XWindowState()
EndFunc
Func UpdateDroid4XWindowState()
WinGetAndroidHandle()
ControlGetPos($hWnD, $g_sAppPaneName, $g_sAppClassInstance)
If @error = 1 Then
SetError(0, 0, 0)
Return False
EndIf
Local $acw = $g_avAndroidAppConfig[$g_iAndroidConfig][5]
Local $ach = $g_avAndroidAppConfig[$g_iAndroidConfig][6]
Local $aww = $g_avAndroidAppConfig[$g_iAndroidConfig][7]
Local $awh = $g_avAndroidAppConfig[$g_iAndroidConfig][8]
Local $v = GetVersionNormalized($g_sAndroidVersion)
For $i = 0 To UBound($__Droid4X_Window) - 1
Local $v2 = GetVersionNormalized($__Droid4X_Window[$i][0])
If $v >= $v2 Then
SetDebugLog("Using Window sizes of " & $g_sAndroidEmulator & " " & $__Droid4X_Window[$i][0])
$aww = $__Droid4X_Window[$i][1]
$awh = $__Droid4X_Window[$i][2]
ExitLoop
EndIf
Next
Local $i
Local $Values[4][3] = [ ["Screen Width", $g_iAndroidClientWidth , $g_iAndroidClientWidth], ["Screen Height", $g_iAndroidClientHeight, $g_iAndroidClientHeight], ["Window Width", $g_iAndroidWindowWidth , $g_iAndroidWindowWidth], ["Window Height", $g_iAndroidWindowHeight , $g_iAndroidWindowHeight] ]
Local $bChanged = False, $ok = False
$Values[0][2] = $acw
$Values[1][2] = $ach
$Values[2][2] = $aww
$Values[3][2] = $awh
$g_iAndroidClientWidth = $Values[0][2]
$g_iAndroidClientHeight = $Values[1][2]
$g_iAndroidWindowWidth = $Values[2][2]
$g_iAndroidWindowHeight = $Values[3][2]
For $i = 0 To UBound($Values) -1
If $Values[$i][1] <> $Values[$i][2] Then
$bChanged = True
SetDebugLog($g_sAndroidEmulator & " " & $Values[$i][0] & " updated from " & $Values[$i][1] & " to " & $Values[$i][2])
EndIf
Next
Return $bChanged
EndFunc
Func CloseDroid4X()
Return CloseVboxAndroidSvc()
EndFunc
Func OpenMEmu($bRestart = False)
Local $PID, $hTimer, $iCount = 0, $process_killed, $cmdOutput, $connected_to, $cmdPar
SetLog("Starting " & $g_sAndroidEmulator & " and Clash Of Clans", $COLOR_SUCCESS)
Local $launchAndroid =(WinGetAndroidHandle() = 0 ? True : False)
If $launchAndroid Then
$cmdPar = GetAndroidProgramParameter()
SetDebugLog("ShellExecute: " & $g_sAndroidProgramPath & " " & $cmdPar)
$PID = ShellExecute($g_sAndroidProgramPath, $cmdPar, $__MEmu_Path)
If _Sleep(1000) Then Return False
If $PID <> 0 Then $PID = ProcessExists($PID)
SetDebugLog("$PID= "&$PID)
If $PID = 0 Then
SetLog("Unable to load " & $g_sAndroidEmulator &($g_sAndroidInstance = "" ? "" : "(" & $g_sAndroidInstance & ")") & ", please check emulator/installation.", $COLOR_ERROR)
SetLog("Unable to continue........", $COLOR_WARNING)
btnStop()
SetError(1, 1, -1)
Return False
EndIf
EndIf
SetLog("Please wait while " & $g_sAndroidEmulator & " and CoC start...", $COLOR_SUCCESS)
$hTimer = TimerInit()
$connected_to = ConnectAndroidAdb(False, 60 * 1000)
If Not $g_bRunState Then Return False
If WaitForAndroidBootCompleted($g_iAndroidLaunchWaitSec - TimerDiff($hTimer) / 1000, $hTimer) Then Return False
If TimerDiff($hTimer) >= $g_iAndroidLaunchWaitSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog($g_sAndroidEmulator & " refuses to load, waited " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds for window", $COLOR_ERROR)
SetError(1, @extended, False)
Return False
EndIf
SetLog($g_sAndroidEmulator & " Loaded, took " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds to begin.", $COLOR_SUCCESS)
Return True
EndFunc
Func GetMEmuProgramParameter($bAlternative = False)
If Not $bAlternative Or $g_sAndroidInstance <> $g_avAndroidAppConfig[$g_iAndroidConfig][1] Then
Return($g_sAndroidInstance = "" ? $g_avAndroidAppConfig[$g_iAndroidConfig][1] : $g_sAndroidInstance)
EndIf
Return ""
EndFunc
Func GetMEmuPath()
Local $MEmu_Path = EnvGet("MEmu_Path") & "\MEmu\"
If FileExists($MEmu_Path & "MEmu.exe") = 0 Then
Local $InstallLocation = RegRead($g_sHKLM & "\SOFTWARE" & $g_sWow6432Node & "\Microsoft\Windows\CurrentVersion\Uninstall\MEmu\", "InstallLocation")
If @error = 0 And FileExists($InstallLocation & "\MEmu\MEmu.exe") = 1 Then
$MEmu_Path = $InstallLocation & "\MEmu\"
Else
Local $DisplayIcon = RegRead($g_sHKLM & "\SOFTWARE" & $g_sWow6432Node & "\Microsoft\Windows\CurrentVersion\Uninstall\MEmu\", "DisplayIcon")
If @error = 0 Then
Local $iLastBS = StringInStr($DisplayIcon, "\", 0, -1)
$MEmu_Path = StringLeft($DisplayIcon, $iLastBS)
If StringLeft($MEmu_Path, 1) = """" Then $MEmu_Path = StringMid($MEmu_Path, 2)
Else
$MEmu_Path = @ProgramFilesDir & "\Microvirt\MEmu\"
SetError(0, 0, 0)
EndIf
EndIf
EndIf
$MEmu_Path = StringReplace($MEmu_Path, "\\", "\")
Return $MEmu_Path
EndFunc
Func GetMEmuAdbPath()
Local $adbPath = GetMEmuPath() & "adb.exe"
If FileExists($adbPath) Then Return $adbPath
Return ""
EndFunc
Func InitMEmu($bCheckOnly = False)
Local $process_killed, $aRegExResult, $g_sAndroidAdbDeviceHost, $g_sAndroidAdbDevicePort, $oops = 0
Local $MEmuVersion = RegRead($g_sHKLM & "\SOFTWARE" & $g_sWow6432Node & "\Microsoft\Windows\CurrentVersion\Uninstall\MEmu\", "DisplayVersion")
SetError(0, 0, 0)
Local $MEmu_Path = GetMEmuPath()
Local $MEmu_Manage_Path = EnvGet("MEmuHyperv_Path") & "\MEmuManage.exe"
If FileExists($MEmu_Manage_Path) = 0 Then
$MEmu_Manage_Path = $MEmu_Path & "..\MEmuHyperv\MEmuManage.exe"
EndIf
If FileExists($MEmu_Path & "MEmu.exe") = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_ERROR)
SetLog($MEmu_Path & "MEmu.exe", $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIf
If FileExists($MEmu_Path & "adb.exe") = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_ERROR)
SetLog($MEmu_Path & "adb.exe", $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIf
If FileExists($MEmu_Manage_Path) = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find MEmu-Hyperv:", $COLOR_ERROR)
SetLog($MEmu_Manage_Path, $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIf
If Not $bCheckOnly Then
InitAndroidConfig(True)
$__VBoxVMinfo = LaunchConsole($MEmu_Manage_Path, "showvminfo " & $g_sAndroidInstance, $process_killed)
If StringInStr($__VBoxVMinfo, "Could not find a registered machine named") > 0 Then
SetLog("Cannot find " & $g_sAndroidEmulator & " instance " & $g_sAndroidInstance, $COLOR_ERROR)
Return False
EndIf
$g_sAndroidProgramPath = $MEmu_Path & "MEmu.exe"
$g_sAndroidAdbPath = FindPreferredAdbPath()
If $g_sAndroidAdbPath = "" Then $g_sAndroidAdbPath = $MEmu_Path & "adb.exe"
$g_sAndroidVersion = $MEmuVersion
$__MEmu_Path = $MEmu_Path
$__VBoxManage_Path = $MEmu_Manage_Path
$aRegExResult = StringRegExp($__VBoxVMinfo, "name = ADB.*host ip = ([^,]+),", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidAdbDeviceHost = $aRegExResult[0]
If $g_iDebugSetlog = 1 Then Setlog("Func LaunchConsole: Read $g_sAndroidAdbDeviceHost = " & $g_sAndroidAdbDeviceHost, $COLOR_DEBUG)
Else
$oops = 1
SetLog("Cannot read " & $g_sAndroidEmulator & "(" & $g_sAndroidInstance & ") ADB Device Host", $COLOR_ERROR)
EndIF
$aRegExResult = StringRegExp($__VBoxVMinfo, "name = ADB.*host port = (\d{3,5}),", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidAdbDevicePort = $aRegExResult[0]
If $g_iDebugSetlog = 1 Then Setlog("Func LaunchConsole: Read $g_sAndroidAdbDevicePort = " & $g_sAndroidAdbDevicePort, $COLOR_DEBUG)
Else
$oops = 1
SetLog("Cannot read " & $g_sAndroidEmulator & "(" & $g_sAndroidInstance & ") ADB Device Port", $COLOR_ERROR)
EndIF
If $oops = 0 Then
$g_sAndroidAdbDevice = $g_sAndroidAdbDeviceHost & ":" & $g_sAndroidAdbDevicePort
Else
SetLog("Using ADB default device " & $g_sAndroidAdbDevice & " for " & $g_sAndroidEmulator, $COLOR_ERROR)
EndIf
$g_sAndroidPicturesPath = "/mnt/shell/emulated/0/Pictures/"
$aRegExResult = StringRegExp($__VBoxVMinfo, "Name: 'picture', Host path: '(.*)'.*", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidPicturesHostPath = $aRegExResult[0] & "\"
Else
$oops = 1
$g_bAndroidAdbScreencap = False
$g_sAndroidPicturesHostPath = ""
SetLog($g_sAndroidEmulator & " Background Mode is not available", $COLOR_ERROR)
EndIf
$__VBoxGuestProperties = LaunchConsole($__VBoxManage_Path, "guestproperty enumerate " & $g_sAndroidInstance, $process_killed)
UpdateMEmuConfig()
EndIf
Return SetError($oops, 0, True)
EndFunc
Func WaitForAmMEmu($WaitInSec, $hTimer = 0)
Local $cmdOutput, $connected_to, $am_ready, $process_killed, $hMyTimer
$hMyTimer =($hTimer = 0 ? TimerInit() : $hTimer)
While True
If Not $g_bRunState Then Return True
$cmdOutput = LaunchConsole($g_sAndroidAdbPath, "connect " & $g_sAndroidAdbDevice, $process_killed)
$connected_to = StringInStr($cmdOutput, "connected to")
$cmdOutput = LaunchConsole($g_sAndroidAdbPath, "-s " & $g_sAndroidAdbDevice & " shell am display-size reset", $process_killed)
If $hTimer <> 0 Then _StatusUpdateTime($hTimer)
$am_ready = StringLen($cmdOutput) < 4
If $am_ready Then ExitLoop
If TimerDiff($hMyTimer) > $WaitInSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog($g_sAndroidEmulator & " refuses to load, waited " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds for activity manager", $COLOR_ERROR)
SetError(1, @extended, False)
Return True
EndIf
If _Sleep(1000) Then Return True
WEnd
Return False
EndFunc
Func SetScreenMEmu()
If Not InitAndroid() Then Return False
Local $cmdOutput, $process_killed
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $g_sAndroidInstance & " resolution_width " & $g_iAndroidClientWidth, $process_killed)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $g_sAndroidInstance & " resolution_height " & $g_iAndroidClientHeight, $process_killed)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $g_sAndroidInstance & " is_full_screen 0", $process_killed)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $g_sAndroidInstance & " is_customed_resolution 1", $process_killed)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $g_sAndroidInstance & " vbox_dpi 160", $process_killed)
Return True
EndFunc
Func RebootMEmuSetScreen()
Return RebootAndroidSetScreenDefault()
EndFunc
Func CloseMEmu()
Return CloseVboxAndroidSvc()
EndFunc
Func CheckScreenMEmu($bSetLog = True)
If Not InitAndroid() Then Return False
Local $aValues[4][2] = [ ["is_full_screen", "0"], ["vbox_dpi", "160"], ["resolution_height", $g_iAndroidClientHeight], ["resolution_width", $g_iAndroidClientWidth] ]
Local $i, $Value, $iErrCnt = 0, $process_killed, $aRegExResult
For $i = 0 To UBound($aValues) -1
$aRegExResult = StringRegExp($__VBoxGuestProperties, "Name: " & $aValues[$i][0] & ", value: (.+), timestamp:", $STR_REGEXPARRAYMATCH)
If @error = 0 Then $Value = $aRegExResult[0]
If $Value <> $aValues[$i][1] Then
If $iErrCnt = 0 Then
If $bSetLog Then
SetLog("MyBot doesn't work with " & $g_sAndroidEmulator & " screen configuration!", $COLOR_ERROR)
Else
SetDebugLog("MyBot doesn't work with " & $g_sAndroidEmulator & " screen configuration!", $COLOR_ERROR)
EndIf
EndIf
If $bSetLog Then
SetLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_ERROR)
Else
SetDebugLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_ERROR)
EndIf
$iErrCnt += 1
EndIf
Next
If $iErrCnt > 0 Then Return False
Return True
EndFunc
Func UpdateMEmuConfig()
Local $Value, $process_killed, $aRegExResult
$Value = LaunchConsole($__VBoxManage_Path, "guestproperty get " & $g_sAndroidInstance & " phone_layout", $process_killed)
$aRegExResult = StringRegExp($Value, "Value: (.+)", $STR_REGEXPARRAYMATCH)
If @error = 0 Then
$__MEmu_PhoneLayout = $aRegExResult[0]
SetDebugLog($g_sAndroidEmulator & " phone_layout is " & $__MEmu_PhoneLayout, $COLOR_ERROR)
Else
SetDebugLog("Cannot read " & $g_sAndroidEmulator & " guestproperty phone_layout!", $COLOR_ERROR)
EndIF
SetError(0, 0, 0)
Return UpdateMEmuWindowState()
EndFunc
Func UpdateMEmuWindowState()
WinGetAndroidHandle()
ControlGetPos($hWnD, $g_sAppPaneName, $g_sAppClassInstance)
If @error = 1 Then
SetError(0, 0, 0)
EndIf
Local $acw = $g_avAndroidAppConfig[$g_iAndroidConfig][5]
Local $ach = $g_avAndroidAppConfig[$g_iAndroidConfig][6]
Local $aww = $g_avAndroidAppConfig[$g_iAndroidConfig][7]
Local $awh = $g_avAndroidAppConfig[$g_iAndroidConfig][8]
Local $tbw = $__MEmu_ToolBar_Width
Local $v = GetVersionNormalized($g_sAndroidVersion)
For $i = 0 To UBound($__MEmu_Window) - 1
Local $v2 = GetVersionNormalized($__MEmu_Window[$i][0])
If $v >= $v2 Then
SetDebugLog("Using Window sizes of " & $g_sAndroidEmulator & " " & $__MEmu_Window[$i][0])
$aww = $__MEmu_Window[$i][1]
$awh = $__MEmu_Window[$i][2]
$tbw = $__MEmu_Window[$i][3]
ExitLoop
EndIf
Next
Local $bToolBarVisible = True
Local $i
Local $Values[4][3] = [ ["Screen Width", $g_iAndroidClientWidth , $g_iAndroidClientWidth], ["Screen Height", $g_iAndroidClientHeight, $g_iAndroidClientHeight], ["Window Width", $g_iAndroidWindowWidth , $g_iAndroidWindowWidth], ["Window Height", $g_iAndroidWindowHeight , $g_iAndroidWindowHeight] ]
Local $bChanged = False, $ok = False
Local $toolBarPos = ControlGetPos($Title, "", "Qt5QWindowIcon3")
If UBound($toolBarPos) = 4 Then
If $toolBarPos[2] = $tbw Then
$bToolBarVisible = ControlCommand($Title, "", "Qt5QWindowIcon3", "IsVisible", "") = 1
SetDebugLog($g_sAndroidEmulator & " Tool Bar is " &($bToolBarVisible ? "visible" : "hidden"))
$ok = True
EndIf
EndIf
If Not $ok Then
SetDebugLog($g_sAndroidEmulator & " Tool Bar state is undetermined as treated as " &($bToolBarVisible ? "visible" : "hidden"), $COLOR_ERROR)
EndIF
Local $w =($bToolBarVisible ? 0 : $tbw)
Switch $__MEmu_PhoneLayout
Case "0"
$Values[0][2] = $acw
$Values[1][2] = $ach
$Values[2][2] = $aww - $w
$Values[3][2] = $awh
Case "1"
$Values[0][2] = $acw + $__MEmu_SystemBar
$Values[1][2] = $ach - $__MEmu_SystemBar
$Values[2][2] = $aww + $__MEmu_SystemBar - $w
$Values[3][2] = $awh - $__MEmu_SystemBar
Case "2"
$Values[0][2] = $acw
$Values[1][2] = $ach - $__MEmu_SystemBar
$Values[2][2] = $aww - $w
$Values[3][2] = $awh - $__MEmu_SystemBar
Case Else
SetDebugLog("Unsupported " & $g_sAndroidEmulator & " guestproperty phone_layout = " & $__MEmu_PhoneLayout, $COLOR_ERROR)
EndSwitch
$g_iAndroidClientWidth = $Values[0][2]
$g_iAndroidClientHeight = $Values[1][2]
$g_iAndroidWindowWidth = $Values[2][2]
$g_iAndroidWindowHeight = $Values[3][2]
For $i = 0 To UBound($Values) -1
If $Values[$i][1] <> $Values[$i][2] Then
$bChanged = True
SetDebugLog($g_sAndroidEmulator & " " & $Values[$i][0] & " updated from " & $Values[$i][1] & " to " & $Values[$i][2])
EndIf
Next
Return $bChanged
EndFunc
Func OpenLeapDroid($bRestart = False)
Local $PID, $hTimer, $iCount = 0, $process_killed, $cmdOutput, $connected_to, $cmdPar
SetLog("Starting " & $g_sAndroidEmulator & " and Clash Of Clans", $COLOR_SUCCESS)
Local $launchAndroid =(WinGetAndroidHandle() = 0 ? True : False)
If $launchAndroid Then
$cmdPar = GetAndroidProgramParameter()
SetDebugLog("ShellExecute: " & $g_sAndroidProgramPath & " " & $cmdPar)
$PID = ShellExecute($g_sAndroidProgramPath, $cmdPar, $__LeapDroid_Path)
If _Sleep(1000) Then Return False
If $PID <> 0 Then $PID = ProcessExists($PID)
SetDebugLog("$PID= " & $PID)
If $PID = 0 Then
SetLog("Unable to load " & $g_sAndroidEmulator &($g_sAndroidInstance = "" ? "" : "(" & $g_sAndroidInstance & ")") & ", please check emulator/installation.", $COLOR_ERROR)
SetLog("Unable to continue........", $COLOR_WARNING)
btnStop()
SetError(1, 1, -1)
Return False
EndIf
EndIf
SetLog("Please wait while " & $g_sAndroidEmulator & " and CoC start...", $COLOR_SUCCESS)
$hTimer = TimerInit()
$connected_to = ConnectAndroidAdb(False, 60 * 1000)
If Not $g_bRunState Then Return False
If WaitForAndroidBootCompleted($g_iAndroidLaunchWaitSec - TimerDiff($hTimer) / 1000, $hTimer) Then Return False
If TimerDiff($hTimer) >= $g_iAndroidLaunchWaitSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog($g_sAndroidEmulator & " refuses to load, waited " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds for window", $COLOR_ERROR)
SetError(1, @extended, False)
Return False
EndIf
SetLog($g_sAndroidEmulator & " Loaded, took " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds to begin.", $COLOR_SUCCESS)
Return True
EndFunc
Func IsLeapDroidCommandLine($CommandLine)
SetDebugLog("Check LeapDroid command line instance: " & $CommandLine)
Local $sInstance =($g_sAndroidInstance = "" ? $g_avAndroidAppConfig[$g_iAndroidConfig][1] : $g_sAndroidInstance)
$CommandLine = StringReplace($CommandLine, GetLeapDroidPath(), "")
If StringRegExp($CommandLine, "-s " & $sInstance & "\b") = 1 Then Return True
Return False
EndFunc
Func GetLeapDroidProgramParameter($bAlternative = False)
Local $sInstance =($g_sAndroidInstance = "" ? $g_avAndroidAppConfig[$g_iAndroidConfig][1] : $g_sAndroidInstance)
If Not $bAlternative Or $g_sAndroidInstance <> $g_avAndroidAppConfig[$g_iAndroidConfig][1] Then
Return "-vfiber -novtcheck -w " & $g_iAndroidClientWidth & " -h " & $g_iAndroidClientHeight & " -s " & $sInstance
EndIf
Return "-s " & $sInstance
EndFunc
Func GetLeapDroidPath()
Local $LeapDroid_Path = RegRead($g_sHKLM & "\SOFTWARE\Leapdroid\Leapdroid VM\", "InstallDir")
If $LeapDroid_Path <> "" And FileExists($LeapDroid_Path & "\LeapdroidVM.exe") = 0 Then
$LeapDroid_Path = ""
EndIf
Local $InstallLocation = RegRead($g_sHKLM & "\SOFTWARE" & $g_sWow6432Node & "\Microsoft\Windows\CurrentVersion\Uninstall\LeapdroidVM\", "InstallLocation")
If $LeapDroid_Path = "" And FileExists($InstallLocation & "\leapdroidvm.ini") = 1 Then
$LeapDroid_Path = IniRead($InstallLocation & "\leapdroidvm.ini", "main", "install_path", "")
If FileExists($LeapDroid_Path & "\LeapdroidVM.exe") = 0 Then
$LeapDroid_Path = ""
EndIf
EndIf
If $LeapDroid_Path = "" And FileExists($InstallLocation & "\LeapdroidVM.exe") = 1 Then
$LeapDroid_Path = $InstallLocation
EndIf
If $LeapDroid_Path = "" And FileExists(@ProgramFilesDir & "\Leapdroid\VM\LeapdroidVM.exe") = 1 Then
$LeapDroid_Path = @ProgramFilesDir & "\Leapdroid\VM"
EndIf
SetError(0, 0, 0)
If $LeapDroid_Path <> "" And StringRight($LeapDroid_Path, 1) <> "\" Then $LeapDroid_Path &= "\"
Return StringReplace($LeapDroid_Path, "\\", "\")
EndFunc
Func GetLeapDroidAdbPath()
Local $adbPath = GetLeapDroidPath() & "adb.exe"
If FileExists($adbPath) Then Return $adbPath
Return ""
EndFunc
Func InitLeapDroid($bCheckOnly = False)
Local $process_killed, $aRegExResult, $g_sAndroidAdbDeviceHost, $g_sAndroidAdbDevicePort, $oops = 0
Local $LeapDroidVersion = RegRead($g_sHKLM & "\SOFTWARE" & $g_sWow6432Node & "\Microsoft\Windows\CurrentVersion\Uninstall\LeapDroid\", "DisplayVersion")
SetError(0, 0, 0)
Local $LeapDroid_Path = GetLeapDroidPath()
Local $LeapDroid_Manage_Path = GetLeapDroidPath() & "VBoxManage.exe"
If FileExists($LeapDroid_Path) = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator, $COLOR_ERROR)
SetLog("installation directory", $COLOR_ERROR)
SetError(1, @extended, False)
Else
SetDebugLog($g_sAndroidEmulator & ": Cannot find installation directory")
EndIf
Return False
EndIf
If FileExists($LeapDroid_Path & "LeapdroidVM.exe") = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_ERROR)
SetLog($LeapDroid_Path & "LeapdroidVM.exe", $COLOR_ERROR)
Else
SetDebugLog($g_sAndroidEmulator & ": Cannot find " & $LeapDroid_Path & "LeapdroidVM.exe")
SetError(1, @extended, False)
EndIf
Return False
EndIf
If FileExists($LeapDroid_Path & "adb.exe") = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_ERROR)
SetLog($LeapDroid_Path & "adb.exe", $COLOR_ERROR)
SetError(1, @extended, False)
Else
SetDebugLog($g_sAndroidEmulator & ": Cannot find " & $LeapDroid_Path & "adb.exe")
EndIf
Return False
EndIf
If FileExists($LeapDroid_Manage_Path) = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_ERROR)
SetLog($LeapDroid_Manage_Path, $COLOR_ERROR)
SetError(1, @extended, False)
Else
SetDebugLog($g_sAndroidEmulator & ": Cannot find " & $LeapDroid_Manage_Path)
EndIf
Return False
EndIf
If Not $bCheckOnly Then
InitAndroidConfig(True)
$__VBoxVMinfo = LaunchConsole($LeapDroid_Manage_Path, "showvminfo " & $g_sAndroidInstance, $process_killed)
If StringInStr($__VBoxVMinfo, "Could not find a registered machine named") > 0 Then
SetLog("Cannot find " & $g_sAndroidEmulator & " instance " & $g_sAndroidInstance, $COLOR_ERROR)
Return False
EndIf
$__VBoxGuestProperties = LaunchConsole($LeapDroid_Manage_Path, "guestproperty enumerate " & $g_sAndroidInstance, $process_killed)
$g_sAndroidProgramPath = $LeapDroid_Path & "LeapdroidVM.exe"
$g_sAndroidAdbPath = FindPreferredAdbPath()
If $g_sAndroidAdbPath = "" Then $g_sAndroidAdbPath = $LeapDroid_Path & "adb.exe"
$g_sAndroidVersion = $LeapDroidVersion
$__LeapDroid_Path = $LeapDroid_Path
$__VBoxManage_Path = $LeapDroid_Manage_Path
$aRegExResult = StringRegExp($__VBoxGuestProperties, "Name: adb_port, value: (\d{3,5}),", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidAdbDeviceHost = "127.0.0.1"
$g_sAndroidAdbDevicePort = $aRegExResult[0]
If $g_iDebugSetlog = 1 Then Setlog("InitLeapDroid: Read $g_sAndroidAdbDevicePort = " & $g_sAndroidAdbDevicePort, $COLOR_DEBUG)
Else
$oops = 1
SetLog("Cannot read " & $g_sAndroidEmulator & "(" & $g_sAndroidInstance & ") ADB Device Port", $COLOR_ERROR)
EndIf
If $oops = 0 Then
$g_sAndroidAdbDevice = "emulator-" &($g_sAndroidAdbDevicePort - 1)
Else
SetLog("Using ADB default device " & $g_sAndroidAdbDevice & " for " & $g_sAndroidEmulator, $COLOR_ERROR)
EndIf
$g_sAndroidPicturesPath = "/mnt/shared/yw_shared/"
$aRegExResult = StringRegExp($__VBoxVMinfo, "Name: 'yw_shared', Host path: '(.*)'.*", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidPicturesHostPath = $aRegExResult[0] & "\"
Else
$g_sAndroidPicturesPath = "/mnt/shared/LeapDroidShared/"
$aRegExResult = StringRegExp($__VBoxVMinfo, "Name: 'LeapDroidShared', Host path: '(.*)'.*", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidPicturesHostPath = $aRegExResult[0] & "\"
Else
$oops = 1
$g_bAndroidAdbScreencap = False
$g_sAndroidPicturesHostPath = ""
SetLog($g_sAndroidEmulator & " Background Mode is not available", $COLOR_ERROR)
EndIf
EndIf
$g_bUpdateAndroidWindowTitle = True
EndIf
Return SetError($oops, 0, True)
EndFunc
Func UpdateLeapdroidSettings(ByRef $fileContent, $param, $value)
$fileContent = StringRegExpReplace($fileContent, "^(" & $param & "=.*)", $param & "=" & $value)
Return @extended
EndFunc
Func SetScreenLeapDroid()
If Not InitAndroid() Then Return False
Local $files[2] = [@MyDocumentsDir & "\Leapdroid\Leapdroid Emulator\leapdroid.settings", GetLeapDroidPath() & "Leapdroid Emulator\leapdroid.settings"]
Local $f, $p, $h
For $f in $files
$p = StringMid($f, 1, StringInStr($f, "\", 0, -1))
If FileExists($p) Then
If FileExists($f) = 0 Then
$h = FileOpen($f, $FO_OVERWRITE)
If $h = -1 Then
SetLog("Cannot write " & $g_sAndroidEmulator & " config file:" & @CRLF & $f, $COLOR_ERROR)
ContinueLoop
EndIf
FileWrite($h, "RESOLUTION=" & $g_iGAME_WIDTH & "x" & $g_iGAME_HEIGHT & @CRLF & "DPI=160")
FileClose($h)
Else
Local $i
$h = FileOpen($f, $FO_READ)
If $h = -1 Then
SetLog("Cannot read " & $g_sAndroidEmulator & " config file:" & @CRLF & $f, $COLOR_ERROR)
ContinueLoop
EndIf
Local $s = FileRead($h)
FileClose($h)
$i = UpdateLeapdroidSettings($s, "RESOLUTION", $g_iGAME_WIDTH & "x" & $g_iGAME_HEIGHT)
If $i < 1 Then SetDebugLog("Cannot update " & $g_sAndroidEmulator & " screen resolution in file:" & @CRLF & $f, $COLOR_ERROR)
$i = UpdateLeapdroidSettings($s, "DPI", "160")
If $i < 1 Then SetDebugLog("Cannot update " & $g_sAndroidEmulator & " screen DPI in file:" & @CRLF & $f, $COLOR_ERROR)
$h = FileOpen($f, $FO_OVERWRITE)
If $h = -1 Then
SetLog("Cannot write " & $g_sAndroidEmulator & " config file:" & @CRLF & $f, $COLOR_ERROR)
ContinueLoop
EndIf
FileWrite($h, $s)
FileClose($h)
EndIf
EndIf
Next
Return True
EndFunc
Func RebootLeapDroidSetScreen()
Return RebootAndroidSetScreenDefault()
EndFunc
Func CloseLeapDroid()
Return CloseVboxAndroidSvc()
EndFunc
Func CheckScreenLeapDroid($bSetLog = True)
If Not InitAndroid() Then Return False
Return True
EndFunc
Func EmbedLeapDroid($bEmbed = Default)
If $bEmbed = Default Then $bEmbed = $g_bAndroidEmbedded
Local $aWin = _WinAPI_EnumProcessWindows(GetAndroidPid(), False)
Local $i
Local $hQTool = 0
For $i = 1 To UBound($aWin) - 1
Local $h = $aWin[$i][0]
Local $c = $aWin[$i][1]
If $c = "QTool" Then
$hQTool = $h
ExitLoop
EndIf
Next
If $hQTool = 0 Then
SetDebugLog("EmbedLeapDroid(" & $bEmbed & "): QTool Window not found, list of windows:" & $c, Default, True)
For $i = 1 To UBound($aWin) - 1
Local $h = $aWin[$i][0]
Local $c = $aWin[$i][1]
SetDebugLog("EmbedLeapDroid(" & $bEmbed & "): Handle = " & $h & ", Class = " & $c, Default, True)
Next
Else
SetDebugLog("EmbedLeapDroid(" & $bEmbed & "): $hQTool=" & $hQTool, Default, True)
WinMove2($hQTool, "", -1, -1, -1, -1, $HWND_NOTOPMOST, 0, False)
_WinAPI_ShowWindow($hQTool,($bEmbed ? @SW_HIDE : @SW_SHOWNOACTIVATE))
EndIf
EndFunc
Func LeapDroidBotStartEvent()
Return AndroidCloseSystemBar()
EndFunc
Func LeapDroidBotStopEvent()
EndFunc
Func OpenNox($bRestart = False)
Local $PID, $hTimer, $iCount = 0, $process_killed, $cmdOutput, $connected_to, $cmdPar
SetLog("Starting " & $g_sAndroidEmulator & " and Clash Of Clans", $COLOR_SUCCESS)
Local $launchAndroid =(WinGetAndroidHandle() = 0 ? True : False)
If $launchAndroid Then
$cmdPar = GetAndroidProgramParameter()
SetDebugLog("ShellExecute: " & $g_sAndroidProgramPath & " " & $cmdPar)
$PID = ShellExecute($g_sAndroidProgramPath, $cmdPar, $__Nox_Path)
If _Sleep(1000) Then Return False
If $PID <> 0 Then $PID = ProcessExists($PID)
SetDebugLog("$PID= "&$PID)
If $PID = 0 Then
SetLog("Unable to load " & $g_sAndroidEmulator &($g_sAndroidInstance = "" ? "" : "(" & $g_sAndroidInstance & ")") & ", please check emulator/installation.", $COLOR_ERROR)
SetLog("Unable to continue........", $COLOR_WARNING)
btnStop()
SetError(1, 1, -1)
Return False
EndIf
EndIf
SetLog("Please wait while " & $g_sAndroidEmulator & " and CoC start...", $COLOR_SUCCESS)
$hTimer = TimerInit()
If WaitForRunningVMS($g_iAndroidLaunchWaitSec - TimerDiff($hTimer) / 1000, $hTimer) Then Return False
$g_bInitAndroid = True
InitAndroid()
$connected_to = ConnectAndroidAdb(False, 60 * 1000)
If Not $g_bRunState Then Return False
If WaitForAndroidBootCompleted($g_iAndroidLaunchWaitSec - TimerDiff($hTimer) / 1000, $hTimer) Then Return False
If TimerDiff($hTimer) >= $g_iAndroidLaunchWaitSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog($g_sAndroidEmulator & " refuses to load, waited " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds for window", $COLOR_ERROR)
SetError(1, @extended, False)
Return False
EndIf
SetLog($g_sAndroidEmulator & " Loaded, took " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds to begin.", $COLOR_SUCCESS)
Return True
EndFunc
Func IsNoxCommandLine($CommandLine)
SetDebugLog($CommandLine)
$CommandLine = StringReplace($CommandLine, GetNoxRtPath(), "")
$CommandLine = StringReplace($CommandLine, "Nox.exe", "")
Local $param1 = StringReplace(GetNoxProgramParameter(), """", "")
Local $param2 = StringReplace(GetNoxProgramParameter(True), """", "")
If StringInStr($CommandLine, $param1 & " ") > 0 Or StringRight($CommandLine, StringLen($param1)) = $param1 Then Return True
If StringInStr($CommandLine, $param2 & " ") > 0 Or StringRight($CommandLine, StringLen($param2)) = $param2 Then Return True
If StringInStr($CommandLine, "-clone:") = 0 And $param2 = "" Then Return True
Return False
EndFunc
Func GetNoxProgramParameter($bAlternative = False)
Local $customScreen = "-resolution:" & $g_iAndroidClientWidth & "x" & $g_iAndroidClientHeight & " -dpi:160"
Local $clone = """-clone:" &($g_sAndroidInstance = "" ? $g_avAndroidAppConfig[$g_iAndroidConfig][1] : $g_sAndroidInstance) & """"
If $bAlternative = False Then
Return $customScreen & " " & $clone
EndIf
If $g_sAndroidInstance = "" Or $g_sAndroidInstance = $g_avAndroidAppConfig[$g_iAndroidConfig][1] Then Return ""
Return $clone
EndFunc
Func GetNoxRtPath()
Local $path = RegRead($g_sHKLM & "\SOFTWARE\BigNox\VirtualBox\", "InstallDir")
If @error = 0 Then
If StringRight($path, 1) <> "\" Then $path &= "\"
EndIf
If FileExists($path) = 0 Then
$path = @ProgramFilesDir & "\Bignox\BigNoxVM\RT\"
EndIf
If FileExists($path) = 0 Then
$path = EnvGet("ProgramFiles(x86)") & "\Bignox\BigNoxVM\RT\"
EndIf
SetError(0, 0, 0)
Return StringReplace($path, "\\", "\")
EndFunc
Func GetNoxPath()
Local $path = RegRead($g_sHKLM & "\SOFTWARE" & $g_sWow6432Node & "\DuoDianOnline\SetupInfo\", "InstallPath")
If @error = 0 Then
If StringRight($path, 1) <> "\" Then $path &= "\"
$path &= "bin\"
Else
$path = ""
SetError(0, 0, 0)
EndIf
Return StringReplace($path, "\\", "\")
EndFunc
Func GetNoxAdbPath()
Local $adbPath = GetNoxPath() & "nox_adb.exe"
If FileExists($adbPath) Then Return $adbPath
Return ""
EndFunc
Func InitNox($bCheckOnly = False)
Local $process_killed, $aRegExResult, $g_sAndroidAdbDeviceHost, $g_sAndroidAdbDevicePort, $oops = 0
Local $Version = RegRead($g_sHKLM & "\SOFTWARE" & $g_sWow6432Node & "\Microsoft\Windows\CurrentVersion\Uninstall\Nox\", "DisplayVersion")
SetError(0, 0, 0)
Local $Path = GetNoxPath()
Local $RtPath = GetNoxRtPath()
Local $NoxFile = $Path & "Nox.exe"
Local $AdbFile = $Path & "nox_adb.exe"
Local $VBoxFile = $RtPath & "BigNoxVMMgr.exe"
Local $Files[3] = [$NoxFile, $AdbFile, $VBoxFile]
Local $File
For $File in $Files
If FileExists($File) = False Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & " file:", $COLOR_ERROR)
SetLog($File, $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIf
Next
If Not $bCheckOnly Then
InitAndroidConfig(True)
$__VBoxVMinfo = LaunchConsole($VBoxFile, "showvminfo " & $g_sAndroidInstance, $process_killed)
If StringInStr($__VBoxVMinfo, "Could not find a registered machine named") > 0 Then
SetLog("Cannot find " & $g_sAndroidEmulator & " instance " & $g_sAndroidInstance, $COLOR_ERROR)
Return False
EndIf
$g_sAndroidProgramPath = $NoxFile
$g_sAndroidAdbPath = FindPreferredAdbPath()
If $g_sAndroidAdbPath = "" Then $g_sAndroidAdbPath = GetNoxAdbPath()
$g_sAndroidVersion = $Version
$__Nox_Path = $Path
$__VBoxManage_Path = $VBoxFile
$aRegExResult = StringRegExp($__VBoxVMinfo, ".*host ip = ([^,]+), .* guest port = 5555", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidAdbDeviceHost = $aRegExResult[0]
If $g_iDebugSetlog = 1 Then Setlog("Func LaunchConsole: Read $g_sAndroidAdbDeviceHost = " & $g_sAndroidAdbDeviceHost, $COLOR_DEBUG)
Else
$oops = 1
SetLog("Cannot read " & $g_sAndroidEmulator & "(" & $g_sAndroidInstance & ") ADB Device Host", $COLOR_ERROR)
EndIF
$aRegExResult = StringRegExp($__VBoxVMinfo, "name = .*host port = (\d{3,5}), .* guest port = 5555", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidAdbDevicePort = $aRegExResult[0]
If $g_iDebugSetlog = 1 Then Setlog("Func LaunchConsole: Read $g_sAndroidAdbDevicePort = " & $g_sAndroidAdbDevicePort, $COLOR_DEBUG)
Else
$oops = 1
SetLog("Cannot read " & $g_sAndroidEmulator & "(" & $g_sAndroidInstance & ") ADB Device Port", $COLOR_ERROR)
EndIF
If $oops = 0 Then
$g_sAndroidAdbDevice = $g_sAndroidAdbDeviceHost & ":" & $g_sAndroidAdbDevicePort
Else
SetLog("Using ADB default device " & $g_sAndroidAdbDevice & " for " & $g_sAndroidEmulator, $COLOR_ERROR)
EndIf
$g_sAndroidPicturesPath = "(/mnt/shared/Other|/mnt/shell/emulated/0/Download/other)"
$aRegExResult = StringRegExp($__VBoxVMinfo, "Name: 'Other', Host path: '(.*)'.*", $STR_REGEXPARRAYGLOBALMATCH)
If Not @error Then
$g_bAndroidSharedFolderAvailable = True
$g_sAndroidPicturesHostPath = $aRegExResult[UBound($aRegExResult) - 1] & "\"
Else
$g_bAndroidSharedFolderAvailable = False
$g_bAndroidAdbScreencap = False
$g_sAndroidPicturesHostPath = ""
SetLog($g_sAndroidEmulator & " Background Mode is not available", $COLOR_ERROR)
EndIf
$__VBoxGuestProperties = LaunchConsole($__VBoxManage_Path, "guestproperty enumerate " & $g_sAndroidInstance, $process_killed)
EndIf
Return True
EndFunc
Func SetScreenNox()
If Not InitAndroid() Then Return False
Local $cmdOutput, $process_killed
AndroidPicturePathAutoConfig(@MyDocumentsDir, "\Nox_share\Other")
If $g_bAndroidSharedFolderAvailable = False And $g_bAndroidPicturesPathAutoConfig = True And FileExists($g_sAndroidPicturesHostPath) = 1 Then
Local $path = $g_sAndroidPicturesHostPath
If StringRight($path, 1) = "\" Then $path = StringLeft($path, StringLen($path) - 1)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "sharedfolder add " & $g_sAndroidInstance & " --name Other --hostpath """ & $path & """  --automount", $process_killed)
EndIf
Return True
EndFunc
Func RebootNoxSetScreen()
Return RebootAndroidSetScreenDefault()
EndFunc
Func CloseNox()
Return CloseVboxAndroidSvc()
EndFunc
Func CheckScreenNox($bSetLog = True)
If Not InitAndroid() Then Return False
Local $aValues[2][2] = [ ["vbox_dpi", "160"], ["vbox_graph_mode", $g_iAndroidClientWidth & "x" & $g_iAndroidClientHeight & "-16"] ]
Local $i, $Value, $iErrCnt = 0, $process_killed, $aRegExResult
For $i = 0 To UBound($aValues) -1
$aRegExResult = StringRegExp($__VBoxGuestProperties, "Name: " & $aValues[$i][0] & ", value: (.+), timestamp:", $STR_REGEXPARRAYMATCH)
If @error = 0 Then $Value = $aRegExResult[0]
If $Value <> $aValues[$i][1] Then
If $iErrCnt = 0 Then
If $bSetLog Then
SetLog("MyBot doesn't work with " & $g_sAndroidEmulator & " screen configuration!", $COLOR_ERROR)
Else
SetDebugLog("MyBot doesn't work with " & $g_sAndroidEmulator & " screen configuration!", $COLOR_ERROR)
EndIf
EndIf
If $bSetLog Then
SetLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_ERROR)
Else
SetDebugLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_ERROR)
EndIf
$iErrCnt += 1
EndIf
Next
If AndroidPicturePathAutoConfig(@MyDocumentsDir, "\Nox_share\Other", $bSetLog) Then $iErrCnt += 1
If $iErrCnt > 0 Then Return False
Return True
EndFunc
Func GetNoxRunningInstance($bStrictCheck = True)
Local $a[2] = [0, ""]
SetDebugLog("GetAndroidRunningInstance: Try to find """ & $g_sAndroidProgramPath & """")
For $pid In ProcessesExist($g_sAndroidProgramPath, "", 1)
Local $currentInstance = $g_sAndroidInstance
Local $commandLine = ProcessGetCommandLine($pid)
SetDebugLog("GetNoxRunningInstance: Found """ & $commandLine & """ by PID=" & $pid)
Local $aRegExResult = StringRegExp($commandLine, ".*""-clone:([^""]+)"".*|.*-clone:([\S]+).*", $STR_REGEXPARRAYMATCH)
If @error = 0 Then
$g_sAndroidInstance = $aRegExResult[0]
If $g_sAndroidInstance = "" Then $g_sAndroidInstance = $aRegExResult[1]
SetDebugLog("Running " & $g_sAndroidEmulator & " instance is """ & $g_sAndroidInstance & """")
EndIf
If WinGetAndroidHandle() <> 0 Then
$a[0] = $HWnD
$a[1] = $g_sAndroidInstance
Return $a
Else
$g_sAndroidInstance = $currentInstance
EndIf
Next
Return $a
EndFunc
Func RedrawNoxWindow()
Local $aPos = WinGetPos($HWnD)
Local $aMousePos = MouseGetPos()
MouseClickDrag("left", $aPos[0] + Int($aPos[2] / 2), $aPos[1] + 3, $aPos[0] + Int($aPos[2] / 2), $aPos[1] + 53, 0)
MouseClickDrag("left", $aPos[0] + Int($aPos[2] / 2), $aPos[1] + 53, $aPos[0] + Int($aPos[2] / 2), $aPos[1] + 3, 0)
MouseMove($aMousePos[0], $aMousePos[1], 0)
$aPos = WinGetPos($HWnD)
ControlClick($HWnD, "", "", "left", 1, $aPos[2] - 46, 18)
If _Sleep(500) Then Return False
$aPos = WinGetPos($HWnD)
ControlClick($HWnD, "", "", "left", 1, $aPos[2] - 46, 18)
EndFunc
Func HideNoxWindow($bHide = True)
Return EmbedNox($bHide)
EndFunc
Func EmbedNox($bEmbed = Default)
If $bEmbed = Default Then $bEmbed = $g_bAndroidEmbedded
Local $aWin = _WinAPI_EnumProcessWindows(GetAndroidPid(), False)
Local $i
Local $hToolbar = 0
For $i = 1 To UBound($aWin) - 1
Local $h = $aWin[$i][0]
Local $c = $aWin[$i][1]
If $c = "Qt5QWindowToolSaveBits" Then
Local $aPos = WinGetPos($h)
If UBound($aPos) > 2 Then
$hToolbar = $h
EndIF
EndIf
Next
If $hToolbar = 0 Then
SetDebugLog("EmbedNox(" & $bEmbed & "): toolbar Window not found, list of windows:" & $c, Default, True)
For $i = 1 To UBound($aWin) - 1
Local $h = $aWin[$i][0]
Local $c = $aWin[$i][1]
SetDebugLog("EmbedNox(" & $bEmbed & "): Handle = " & $h & ", Class = " & $c, Default, True)
Next
Else
SetDebugLog("EmbedNox(" & $bEmbed & "): $hToolbar=" & $hToolbar, Default, True)
WinMove2($hToolbar, "", -1, -1, -1, -1, $HWND_NOTOPMOST, 0, False)
_WinAPI_ShowWindow($hToolbar,($bEmbed ? @SW_HIDE : @SW_SHOWNOACTIVATE))
EndIf
EndFunc
Func OpenKOPLAYER($bRestart = False)
Local $PID, $hTimer, $iCount = 0, $process_killed, $cmdOutput, $connected_to, $cmdPar
SetLog("Starting " & $g_sAndroidEmulator & " and Clash Of Clans", $COLOR_GREEN)
If Not InitAndroid() Then Return
Local $launchAndroid =(WinGetAndroidHandle() = 0 ? True : False)
If $launchAndroid Then
$cmdPar = GetAndroidProgramParameter() & " -t " & $g_sAndroidInstance
SetDebugLog("ShellExecute: " & $g_sAndroidProgramPath & " " & $cmdPar)
$PID = ShellExecute($g_sAndroidProgramPath, $cmdPar, $__KOPLAYER_Path)
If _Sleep(1000) Then Return
If $PID <> 0 Then $PID = ProcessExists($PID)
SetDebugLog("$PID= "&$PID)
If $PID = 0 Then
SetLog("Unable to load " & $g_sAndroidEmulator &($g_sAndroidInstance = "" ? "" : "(" & $g_sAndroidInstance & ")") & ", please check emulator/installation.", $COLOR_RED)
SetLog("Unable to continue........", $COLOR_MAROON)
btnStop()
SetError(1, 1, -1)
Return
EndIf
EndIf
SetLog("Please wait while " & $g_sAndroidEmulator & " and CoC start...", $COLOR_GREEN)
$hTimer = TimerInit()
$connected_to = ConnectAndroidAdb(False, 60 * 1000)
If Not $g_bRunState Then Return
If WaitForAndroidBootCompleted($g_iAndroidLaunchWaitSec - TimerDiff($hTimer) / 1000, $hTimer) Then Return
If TimerDiff($hTimer) >= $g_iAndroidLaunchWaitSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_RED)
SetLog($g_sAndroidEmulator & " refuses to load, waited " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds for window", $COLOR_RED)
SetError(1, @extended, False)
Return
EndIf
SetLog($g_sAndroidEmulator & " Loaded, took " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds to begin.", $COLOR_GREEN)
EndFunc
Func GetKOPLAYERProgramParameter($bAlternative = False)
If Not $bAlternative Or $g_sAndroidInstance <> $g_avAndroidAppConfig[$g_iAndroidConfig][1] Then
Return "-n " &($g_sAndroidInstance = "" ? $g_avAndroidAppConfig[$g_iAndroidConfig][1] : $g_sAndroidInstance)
EndIf
Return "-n default"
EndFunc
Func IsKOPLAYERCommandLine($CommandLine)
SetDebugLog($CommandLine)
Local $param1 = GetKOPLAYERProgramParameter()
Local $param2 = GetKOPLAYERProgramParameter(True)
If StringInStr($CommandLine, $param1 & " ") > 0 Or StringRight($CommandLine, StringLen($param1)) = $param1 Then Return True
If StringInStr($CommandLine, $param2 & " ") > 0 Or StringRight($CommandLine, StringLen($param2)) = $param2 Then Return True
Return False
EndFunc
Func GetKOPLAYERPath()
Local $KOPLAYER_Path = RegRead($g_sHKLM & "\SOFTWARE\KOPLAYER\SETUP\", "InstallPath")
If $KOPLAYER_Path = "" Then
$KOPLAYER_Path = @ProgramFilesDir & "\KOPLAYER\"
Else
If StringRight($KOPLAYER_Path, 1) <> "\" Then $KOPLAYER_Path &= "\"
EndIf
Return StringReplace($KOPLAYER_Path, "\\", "\")
EndFunc
Func GetKOPLAYERAdbPath()
Local $adbPath = GetKOPLAYERPath() & "Tools\adb.exe"
If FileExists($adbPath) Then Return $adbPath
Return ""
EndFunc
Func InitKOPLAYER($bCheckOnly = False)
Local $process_killed, $aRegExResult, $g_sAndroidAdbDeviceHost, $g_sAndroidAdbDevicePort, $oops = 0
Local $KOPLAYERVersion = RegRead($g_sHKLM & "\SOFTWARE\KOPLAYER\SETUP\", "Version")
SetError(0, 0, 0)
Local $KOPLAYER_Path = GetKOPLAYERPath()
Local $KOPLAYER_Manage_Path = $KOPLAYER_Path & "vbox\VBoxManage.exe"
If FileExists($KOPLAYER_Path & "KOPLAYER.exe") = False Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_RED)
SetLog($KOPLAYER_Path & "KOPLAYER.exe", $COLOR_RED)
SetError(1, @extended, False)
EndIf
Return False
EndIf
If FileExists(GetKOPLAYERAdbPath()) = False Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_RED)
SetLog($KOPLAYER_Path & "adb.exe", $COLOR_RED)
SetError(1, @extended, False)
EndIf
Return False
EndIf
If FileExists($KOPLAYER_Manage_Path) = False Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find KOPLAYER-VBoxManage:", $COLOR_RED)
SetLog($KOPLAYER_Manage_Path, $COLOR_RED)
SetError(1, @extended, False)
EndIf
Return False
EndIf
If Not $bCheckOnly Then
InitAndroidConfig(True)
$__VBoxVMinfo = LaunchConsole($KOPLAYER_Manage_Path, "showvminfo " & $g_sAndroidInstance, $process_killed)
If StringInStr($__VBoxVMinfo, "Could not find a registered machine named") > 0 Then
SetLog("Cannot find " & $g_sAndroidEmulator & " instance " & $g_sAndroidInstance, $COLOR_RED)
Return False
EndIf
$g_sAndroidProgramPath = $KOPLAYER_Path & "KOPLAYER.exe"
$g_sAndroidAdbPath = FindPreferredAdbPath()
If $g_sAndroidAdbPath = "" Then $g_sAndroidAdbPath = GetKOPLAYERAdbPath()
$g_sAndroidVersion = $KOPLAYERVersion
$__KOPLAYER_Path = $KOPLAYER_Path
$__VBoxManage_Path = $KOPLAYER_Manage_Path
$aRegExResult = StringRegExp($__VBoxVMinfo, "name = .*host ip = ([^,]*),.*guest port = 5555", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidAdbDeviceHost = $aRegExResult[0]
If $g_sAndroidAdbDeviceHost = "" Then $g_sAndroidAdbDeviceHost = "127.0.0.1"
If $g_iDebugSetlog = 1 Then Setlog("Func LaunchConsole: Read $g_sAndroidAdbDeviceHost = " & $g_sAndroidAdbDeviceHost, $COLOR_PURPLE)
Else
$oops = 1
SetLog("Cannot read " & $g_sAndroidEmulator & "(" & $g_sAndroidInstance & ") ADB Device Host", $COLOR_RED)
EndIF
$aRegExResult = StringRegExp($__VBoxVMinfo, "name = .*host port = (\d{3,5}),.*guest port = 5555", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidAdbDevicePort = $aRegExResult[0]
If $g_iDebugSetlog = 1 Then Setlog("Func LaunchConsole: Read $g_sAndroidAdbDevicePort = " & $g_sAndroidAdbDevicePort, $COLOR_PURPLE)
Else
$oops = 1
SetLog("Cannot read " & $g_sAndroidEmulator & "(" & $g_sAndroidInstance & ") ADB Device Port", $COLOR_RED)
EndIF
If $oops = 0 Then
$g_sAndroidAdbDevice = $g_sAndroidAdbDeviceHost & ":" & $g_sAndroidAdbDevicePort
Else
SetLog("Using ADB default device " & $g_sAndroidAdbDevice & " for " & $g_sAndroidEmulator, $COLOR_RED)
EndIf
$g_sAndroidPicturesPath = "/mnt/shared/UserData/"
$aRegExResult = StringRegExp($__VBoxVMinfo, "Name: 'UserData', Host path: '(.*)'.*", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidPicturesHostPath = StringReplace($aRegExResult[0], "/", "\") & "\"
Else
$g_bAndroidAdbScreencap = False
$g_sAndroidPicturesHostPath = ""
SetLog($g_sAndroidEmulator & " Background Mode is not available", $COLOR_RED)
EndIf
$__VBoxGuestProperties = LaunchConsole($__VBoxManage_Path, "guestproperty enumerate " & $g_sAndroidInstance, $process_killed)
EndIf
Return True
EndFunc
Func SetScreenKOPLAYER()
If Not InitAndroid() Then Return False
Local $cmdOutput, $process_killed
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $g_sAndroidInstance & " vbox_graph_mode " & $g_iAndroidClientWidth & "x" & $g_iAndroidClientHeight & "-16", $process_killed)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $g_sAndroidInstance & " vbox_dpi 160", $process_killed)
Return True
EndFunc
Func RebootKOPLAYERSetScreen()
Return RebootAndroidSetScreenDefault()
EndFunc
Func CloseKOPLAYER()
Return CloseVboxAndroidSvc()
EndFunc
Func CheckScreenKOPLAYER($bSetLog = True)
If Not InitAndroid() Then Return False
Local $aValues[2][2] = [ ["vbox_dpi", "160"], ["vbox_graph_mode", $g_iAndroidClientWidth & "x" & $g_iAndroidClientHeight & "-16"] ]
Local $i, $Value, $iErrCnt = 0, $process_killed, $aRegExResult
For $i = 0 To UBound($aValues) -1
$aRegExResult = StringRegExp($__VBoxGuestProperties, "Name: " & $aValues[$i][0] & ", value: (.+), timestamp:", $STR_REGEXPARRAYMATCH)
If @error = 0 Then $Value = $aRegExResult[0]
If $Value <> $aValues[$i][1] Then
If $iErrCnt = 0 Then
If $bSetLog Then
SetLog("MyBot doesn't work with " & $g_sAndroidEmulator & " screen configuration!", $COLOR_RED)
Else
SetDebugLog("MyBot doesn't work with " & $g_sAndroidEmulator & " screen configuration!", $COLOR_RED)
EndIf
EndIf
If $bSetLog Then
SetLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_RED)
Else
SetDebugLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_RED)
EndIf
$iErrCnt += 1
EndIf
Next
If $iErrCnt > 0 Then Return False
Return True
EndFunc
Func EmbedKOPLAYER($bEmbed = Default)
If $bEmbed = Default Then $bEmbed = $g_bAndroidEmbedded
Local $aWin = _WinAPI_EnumProcessWindows(GetAndroidPid(), False)
Local $i
Local $hTool = 0
For $i = 1 To UBound($aWin) - 1
Local $h = $aWin[$i][0]
Local $c = $aWin[$i][1]
If $c = "Qt5QWindowToolSaveBits" Then
$hTool = $h
ExitLoop
EndIf
Next
If $hTool = 0 Then
SetDebugLog("EmbedKOPLAYER(" & $bEmbed & "): Qt5QWindowToolSaveBits Window not found, list of windows:" & $c, Default, True)
For $i = 1 To UBound($aWin) - 1
Local $h = $aWin[$i][0]
Local $c = $aWin[$i][1]
SetDebugLog("EmbedKOPLAYER(" & $bEmbed & "): Handle = " & $h & ", Class = " & $c, Default, True)
Next
Else
SetDebugLog("EmbedKOPLAYER(" & $bEmbed & "): $hTool=" & $hTool, Default, True)
WinMove2($hTool, "", -1, -1, -1, -1, $HWND_NOTOPMOST, 0, False)
_WinAPI_ShowWindow($hTool,($bEmbed ? @SW_HIDE : @SW_SHOWNOACTIVATE))
EndIf
EndFunc
Func OpeniTools($bRestart = False)
Local $PID, $hTimer, $iCount = 0, $process_killed, $cmdOutput, $connected_to, $cmdPar
SetLog("Starting " & $g_sAndroidEmulator & " and Clash Of Clans", $COLOR_SUCCESS)
Local $launchAndroid =(WinGetAndroidHandle() = 0 ? True : False)
If $launchAndroid Then
$cmdPar = GetAndroidProgramParameter()
SetDebugLog("ShellExecute: " & $g_sAndroidProgramPath & " " & $cmdPar)
$PID = ShellExecute($g_sAndroidProgramPath, $cmdPar, $__iTools_Path)
If _Sleep(1000) Then Return False
If $PID <> 0 Then $PID = ProcessExists($PID)
SetDebugLog("$PID= " & $PID)
If $PID = 0 Then
SetLog("Unable to load " & $g_sAndroidEmulator &($g_sAndroidInstance = "" ? "" : "(" & $g_sAndroidInstance & ")") & ", please check emulator/installation.", $COLOR_ERROR)
SetLog("Unable to continue........", $COLOR_WARNING)
btnStop()
SetError(1, 1, -1)
Return False
EndIf
EndIf
SetLog("Please wait while " & $g_sAndroidEmulator & " and CoC start...", $COLOR_SUCCESS)
$hTimer = TimerInit()
$connected_to = ConnectAndroidAdb(False, 60 * 1000)
If Not $g_bRunState Then Return False
If WaitForAndroidBootCompleted($g_iAndroidLaunchWaitSec - TimerDiff($hTimer) / 1000, $hTimer) Then Return False
If TimerDiff($hTimer) >= $g_iAndroidLaunchWaitSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog($g_sAndroidEmulator & " refuses to load, waited " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds for window", $COLOR_ERROR)
SetError(1, @extended, False)
Return False
EndIf
SetLog($g_sAndroidEmulator & " Loaded, took " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds to begin.", $COLOR_SUCCESS)
Return True
EndFunc
Func IsiToolsCommandLine($CommandLine)
SetDebugLog("Check iTools command line instance: " & $CommandLine)
Local $sInstance =($g_sAndroidInstance = "" ? $g_avAndroidAppConfig[$g_iAndroidConfig][1] : $g_sAndroidInstance)
$CommandLine = StringReplace($CommandLine, GetiToolsPath(), "")
If StringRegExp($CommandLine, "/start " & $sInstance & "\b") = 1 Then Return True
If StringRegExp($CommandLine, "/restart .*\b" & $sInstance & "\b") = 1 Then Return True
Return False
EndFunc
Func GetiToolsProgramParameter($bAlternative = False)
Local $sInstance =($g_sAndroidInstance = "" ? $g_avAndroidAppConfig[$g_iAndroidConfig][1] : $g_sAndroidInstance)
If Not $bAlternative Or $g_sAndroidInstance <> $g_avAndroidAppConfig[$g_iAndroidConfig][1] Then
Return "/start " & $sInstance
EndIf
Return ""
EndFunc
Func GetiToolsPath()
Local $iTools_Path = ""
If $iTools_Path <> "" And FileExists($iTools_Path & "\iToolsAVM.exe") = 0 Then
$iTools_Path = ""
EndIf
Local $InstallLocation = ""
Local $DisplayIcon = RegRead($g_sHKLM & "\SOFTWARE" & $g_sWow6432Node & "\Microsoft\Windows\CurrentVersion\Uninstall\iToolsAVM\", "DisplayIcon")
If @error = 0 Then
Local $iLastBS = StringInStr($DisplayIcon, "\", 0, -1) - 1
$InstallLocation = StringLeft($DisplayIcon, $iLastBS)
EndIf
If $iTools_Path = "" And FileExists($InstallLocation & "\iToolsAVM.exe") = 1 Then
$iTools_Path = $InstallLocation
EndIf
If $iTools_Path = "" And FileExists(@ProgramFilesDir & "\iToolsAVM\iToolsAVM.exe") = 1 Then
$iTools_Path = @ProgramFilesDir & "\iToolsAVM"
EndIf
SetError(0, 0, 0)
If $iTools_Path <> "" And StringRight($iTools_Path, 1) <> "\" Then $iTools_Path &= "\"
Return StringReplace($iTools_Path, "\\", "\")
EndFunc
Func GetiToolsAdbPath()
Local $adbPath = GetiToolsPath() & "tools\adb.exe"
If FileExists($adbPath) Then Return $adbPath
Return ""
EndFunc
Func InitiTools($bCheckOnly = False)
Local $process_killed, $aRegExResult, $g_sAndroidAdbDeviceHost, $g_sAndroidAdbDevicePort, $oops = 0
SetError(0, 0, 0)
Local $VirtualBox_Path = RegRead($g_sHKLM & "\SOFTWARE\Oracle\VirtualBox\", "InstallDir")
If @error <> 0 And FileExists(@ProgramFilesDir & "\Oracle\VirtualBox\") Then
$VirtualBox_Path = @ProgramFilesDir & "\Oracle\VirtualBox\"
SetError(0, 0, 0)
EndIf
$VirtualBox_Path = StringReplace($VirtualBox_Path, "\\", "\")
Local $iTools_Path = GetiToolsPath()
Local $iTools_Manage_Path = $VirtualBox_Path & "VBoxManage.exe"
If FileExists($iTools_Path) = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator, $COLOR_ERROR)
SetLog("installation directory", $COLOR_ERROR)
SetError(1, @extended, False)
Else
SetDebugLog($g_sAndroidEmulator & ": Cannot find installation directory")
EndIf
Return False
EndIf
If FileExists($iTools_Path & "iToolsAVM.exe") = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_ERROR)
SetLog($iTools_Path & "iToolsAVM.exe", $COLOR_ERROR)
Else
SetDebugLog($g_sAndroidEmulator & ": Cannot find " & $iTools_Path & "iToolsAVM.exe")
SetError(1, @extended, False)
EndIf
Return False
EndIf
If FileExists($iTools_Path & "tools\adb.exe") = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_ERROR)
SetLog($iTools_Path & "tools\adb.exe", $COLOR_ERROR)
SetError(1, @extended, False)
Else
SetDebugLog($g_sAndroidEmulator & ": Cannot find " & $iTools_Path & "tools\adb.exe")
EndIf
Return False
EndIf
If FileExists($iTools_Manage_Path) = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $g_sAndroidEmulator & ":", $COLOR_ERROR)
SetLog($iTools_Manage_Path, $COLOR_ERROR)
SetError(1, @extended, False)
Else
SetDebugLog($g_sAndroidEmulator & ": Cannot find " & $iTools_Manage_Path)
EndIf
Return False
EndIf
If Not $bCheckOnly Then
InitAndroidConfig(True)
$__VBoxVMinfo = LaunchConsole($iTools_Manage_Path, "showvminfo " & $g_sAndroidInstance, $process_killed)
If StringInStr($__VBoxVMinfo, "Could not find a registered machine named") > 0 Then
SetLog("Cannot find " & $g_sAndroidEmulator & " instance " & $g_sAndroidInstance, $COLOR_ERROR)
Return False
EndIf
$__VBoxGuestProperties = LaunchConsole($iTools_Manage_Path, "guestproperty enumerate " & $g_sAndroidInstance, $process_killed)
$g_sAndroidProgramPath = $iTools_Path & "iToolsAVM.exe"
$g_sAndroidAdbPath = FindPreferredAdbPath()
If $g_sAndroidAdbPath = "" Then $g_sAndroidAdbPath = $iTools_Path & "tools\adb.exe"
$g_sAndroidVersion = ""
$__iTools_Path = $iTools_Path
$__VBoxManage_Path = $iTools_Manage_Path
$aRegExResult = StringRegExp($__VBoxVMinfo, "ADB_PORT.*host ip = ([^,]+),", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidAdbDeviceHost = $aRegExResult[0]
If $g_iDebugSetlog = 1 Then Setlog("Func LaunchConsole: Read $g_sAndroidAdbDeviceHost = " & $g_sAndroidAdbDeviceHost, $COLOR_DEBUG)
Else
$oops = 1
SetLog("Cannot read " & $g_sAndroidEmulator & "(" & $g_sAndroidInstance & ") ADB Device Host", $COLOR_ERROR)
EndIf
$aRegExResult = StringRegExp($__VBoxVMinfo, "ADB_PORT.*host port = (\d{3,5}),", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_sAndroidAdbDevicePort = $aRegExResult[0]
If $g_iDebugSetlog = 1 Then Setlog("Func LaunchConsole: Read $g_sAndroidAdbDevicePort = " & $g_sAndroidAdbDevicePort, $COLOR_DEBUG)
Else
$oops = 1
SetLog("Cannot read " & $g_sAndroidEmulator & "(" & $g_sAndroidInstance & ") ADB Device Port", $COLOR_ERROR)
EndIf
If $oops = 0 Then
$g_sAndroidAdbDevice = $g_sAndroidAdbDeviceHost & ":" & $g_sAndroidAdbDevicePort
Else
SetLog("Using ADB default device " & $g_sAndroidAdbDevice & " for " & $g_sAndroidEmulator, $COLOR_ERROR)
EndIf
$g_sAndroidPicturesPath = "/mnt/shared/picture/"
$aRegExResult = StringRegExp($__VBoxVMinfo, "Name: 'picture', Host path: '(.*)'.*", $STR_REGEXPARRAYMATCH)
If Not @error Then
$g_bAndroidSharedFolderAvailable = True
$g_sAndroidPicturesHostPath = $aRegExResult[0] & "\"
Else
$oops = 1
$g_bAndroidAdbScreencap = False
$g_bAndroidSharedFolderAvailable = False
$g_sAndroidPicturesHostPath = ""
SetLog($g_sAndroidEmulator & " shared folder is not available", $COLOR_ERROR)
EndIf
$g_bUpdateAndroidWindowTitle = True
EndIf
Return SetError($oops, 0, True)
EndFunc
Func SetScreeniTools()
If Not $g_bRunState Then Return False
If Not InitAndroid() Then Return False
Local $cmdOutput, $process_killed
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $g_sAndroidInstance & " vbox_graph_mode " & $g_iAndroidClientWidth & "x" & $g_iAndroidClientHeight & "-16", $process_killed)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $g_sAndroidInstance & " vbox_dpi 160", $process_killed)
AndroidPicturePathAutoConfig()
If $g_bAndroidSharedFolderAvailable = False And $g_bAndroidPicturesPathAutoConfig = True And FileExists($g_sAndroidPicturesHostPath) = 1 Then
Local $path = $g_sAndroidPicturesHostPath
If StringRight($path, 1) = "\" Then $path = StringLeft($path, StringLen($path) - 1)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "sharedfolder add " & $g_sAndroidInstance & " --name picture --hostpath """ & $path & """  --automount", $process_killed)
EndIf
Return True
EndFunc
Func RebootiToolsSetScreen()
Return RebootAndroidSetScreenDefault()
EndFunc
Func CloseiTools()
Return CloseVboxAndroidSvc()
EndFunc
Func CheckScreeniTools($bSetLog = True)
If Not InitAndroid() Then Return False
Local $aValues[2][2] = [ ["vbox_dpi", "160"], ["vbox_graph_mode", $g_iAndroidClientWidth & "x" & $g_iAndroidClientHeight & "-16"] ]
Local $i, $Value, $iErrCnt = 0, $process_killed, $aRegExResult, $properties
For $i = 0 To UBound($aValues) - 1
$aRegExResult = StringRegExp($__VBoxGuestProperties, "Name: " & $aValues[$i][0] & ", value: (.+), timestamp:", $STR_REGEXPARRAYMATCH)
If @error = 0 Then $Value = $aRegExResult[0]
If $Value <> $aValues[$i][1] Then
If $iErrCnt = 0 Then
SetGuiLog("MyBot doesn't work with " & $g_sAndroidEmulator & " screen configuration!", $COLOR_ERROR, $bSetLog)
EndIf
SetGuiLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_ERROR, $bSetLog)
$iErrCnt += 1
EndIf
Next
If $iErrCnt > 0 Then Return False
If AndroidPicturePathAutoConfig(Default, Default, $bSetLog) Then $iErrCnt += 1
If $iErrCnt > 0 Then Return False
Return True
EndFunc
Func HideiToolsWindow($bHide = True)
Return EmbediTools($bHide)
EndFunc
Func EmbediTools($bEmbed = Default)
If $bEmbed = Default Then $bEmbed = $g_bAndroidEmbedded
Local $aWin = _WinAPI_EnumProcessWindows(GetAndroidPid(), False)
Local $i
Local $hToolbar = 0
Local $hAddition = []
For $i = 1 To UBound($aWin) - 1
Local $h = $aWin[$i][0]
Local $c = $aWin[$i][1]
If $c = "CHWindow" Then
Local $aPos = WinGetPos($h)
If UBound($aPos) > 2 Then
If($aPos[2] = 38 Or $aPos[2] = 21) Then
$hToolbar = $h
EndIf
If $aPos[2] = 10 Or $aPos[3] = 10 Then
ReDim $hAddition[UBound($hAddition) + 1]
$hAddition[UBound($hAddition) - 1] = $h
EndIf
EndIf
EndIf
Next
If $hToolbar = 0 Then
SetDebugLog("EmbediTools(" & $bEmbed & "): toolbar Window not found, list of windows:" & $c, Default, True)
For $i = 1 To UBound($aWin) - 1
Local $h = $aWin[$i][0]
Local $c = $aWin[$i][1]
SetDebugLog("EmbediTools(" & $bEmbed & "): Handle = " & $h & ", Class = " & $c, Default, True)
Next
Else
SetDebugLog("EmbediTools(" & $bEmbed & "): $hToolbar=" & $hToolbar, Default, True)
WinMove2($hToolbar, "", -1, -1, -1, -1, $HWND_NOTOPMOST, 0, False)
_WinAPI_ShowWindow($hToolbar,($bEmbed ? @SW_HIDE : @SW_SHOWNOACTIVATE))
For $i = 0 To UBound($hAddition) - 1
WinMove2($hAddition[$i], "", -1, -1, -1, -1, $HWND_NOTOPMOST, 0, False)
_WinAPI_ShowWindow($hAddition[$i],($bEmbed ? @SW_HIDE : @SW_SHOWNOACTIVATE))
Next
EndIf
EndFunc
Func getBSPos()
Local $SuspendMode = ResumeAndroid()
Local $Changed = False, $aOldValues[4]
Local $hWin = $HWnD
WinGetAndroidHandle()
If $g_bAndroidBackgroundLaunched = False Then
getAndroidPos(True)
Else
SetError($HWnd = 0 ? 1 : 0)
EndIf
If @error = 1 Then
If Not $g_bRunState Then Return
SetError(0,0,0)
If $hWin = 0 Then
OpenAndroid(True)
Else
RebootAndroid()
EndIf
If $g_bAndroidBackgroundLaunched = False Then
getAndroidPos(True)
Else
SetError($HWnd = 0 ? 1 : 0)
EndIf
If Not $g_bRunState Then Return
If @error = 1 Then
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 600)
Local $stext = @CRLF & GetTranslated(640,17,"MyBot has experienced a serious error") & @CRLF & @CRLF & GetTranslated(640,18,"Unable to find or start up ") & $g_sAndroidEmulator & @CRLF & @CRLF & GetTranslated(640,22,"Reboot PC and try again,") & GetTranslated(640,19,"and search www.mybot.run forums for more help") & @CRLF
Local $MsgBox = _ExtMsgBox(0, GetTranslated(640,20,"Close MyBot!"), GetTranslated(640,21,"Okay - Must Exit Program"), $stext, 15, $g_hFrmBot)
If $MsgBox = 1 Then
BotClose()
EndIf
EndIf
EndIf
If @error = 1 Then
If Not $g_bRunState Then Return
SetError(0,0,0)
If $hWin = 0 Then
OpenAndroid(True)
Else
RebootAndroid()
EndIf
Return
EndIf
If $g_bAndroidBackgroundLaunched = True Then
SuspendAndroid($SuspendMode, False)
Return
EndIf
$aOldValues[0] = $g_aiBSpos[0]
$aOldValues[1] = $g_aiBSpos[1]
$aOldValues[2] = $g_aiBSrpos[0]
$aOldValues[3] = $g_aiBSrpos[1]
Local $aPos = getAndroidPos()
If Not IsArray($aPos) Then
If Not $g_bRunState Then Return
If $hWin = 0 Then
OpenAndroid(True)
Else
RebootAndroid()
EndIf
$aPos = getAndroidPos(True)
If Not $g_bRunState Then Return
If @error = 1 Then
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 600)
$stext = @CRLF & GetTranslated(640,17,"MyBot has experienced a serious error") & @CRLF & @CRLF & GetTranslated(640,18,"Unable to find or start up") & " " & $g_sAndroidEmulator & @CRLF & @CRLF & GetTranslated(640,22,"Reboot PC and try again,") & GetTranslated(640,19,"and search www.mybot.run forums for more help") & @CRLF
$MsgBox = _ExtMsgBox(0, GetTranslated(640,20,"Close MyBot!"), GetTranslated(640,21,"Okay - Must Exit Program"), $stext, 15, $g_hFrmBot)
If $MsgBox = 1 Then
BotClose()
Return
EndIf
EndIf
EndIf
If IsArray($aPos) Then
Local $tPoint = DllStructCreate("int X;int Y")
DllStructSetData($tPoint, "X", $aPos[0])
If @error <> 0 Then
$tPoint = 0
Return SetError(0,0,0)
EndIf
DllStructSetData($tPoint, "Y", $aPos[1])
If @error <> 0 Then
$tPoint = 0
Return SetError(0,0,0)
EndIf
_WinAPI_ClientToScreen(GetCurrentAndroidHWnD(), $tPoint)
If @error <> 0 Then
$tPoint = 0
Return SetError(0,0,0)
EndIf
$g_aiBSpos[0] = DllStructGetData($tPoint, "X")
If @error <> 0 Then
$tPoint = 0
Return SetError(0,0,0)
EndIf
$g_aiBSpos[1] = DllStructGetData($tPoint, "Y")
If @error <> 0 Then
$tPoint = 0
Return SetError(0,0,0)
EndIf
$g_aiBSrpos[0] = $aPos[0]
$g_aiBSrpos[1] = $aPos[1]
$tPoint = 0
$Changed = Not($aOldValues[0] = $g_aiBSpos[0] And $aOldValues[1] = $g_aiBSpos[1] And $aOldValues[2] = $g_aiBSrpos[0] And $aOldValues[3] = $g_aiBSrpos[1])
If $g_iDebugClick = 1 Or $g_iDebugSetlog = 1 And $Changed Then Setlog("$g_aiBSpos X,Y = " & $g_aiBSpos[0] & "," & $g_aiBSpos[1] & "; BSrpos X,Y = " & $g_aiBSrpos[0] & "," & $g_aiBSrpos[1], $COLOR_ERROR, "Verdana", "7.5", 0)
EndIf
SuspendAndroid($SuspendMode, False)
EndFunc
Func getAndroidPos($FastCheck = False, $RetryCount = 0)
Local $BSsize = ControlGetPos(GetCurrentAndroidHWnD(), $g_sAppPaneName, $g_sAppClassInstance)
If $FastCheck Then Return $BSsize
If IsArray($BSsize) Then
Local $BSx = $BSsize[2]
Local $BSy = $BSsize[3]
If $BSx <> $g_iAndroidClientWidth Or $BSy <> $g_iAndroidClientHeight Then
UpdateAndroidWindowState()
EndIf
If $BSx <> $g_iAndroidClientWidth Or $BSy <> $g_iAndroidClientHeight Then
SetDebugLog("Unsupported " & $g_sAndroidEmulator & " screen size of " & $BSx & " x " & $BSy & " !", $COLOR_ACTION)
Local $AndroidWinPos = WinGetPos($HWnD)
Local $WinWidth = $AndroidWinPos[2]
Local $WinHeight = $AndroidWinPos[3]
Local $aWindowClientDiff[2] = [0,0]
Local $aAndroidWindow[2] = [$g_iAndroidWindowWidth, $g_iAndroidWindowHeight]
Local $tRECT = _WinAPI_GetClientRect($HWnD)
If @error = 0 Then
$aWindowClientDiff[0] = $WinWidth -(DllStructGetData($tRECT, "Right") - DllStructGetData($tRECT, "Left"))
$aWindowClientDiff[1] = $WinHeight -(DllStructGetData($tRECT, "Bottom") - DllStructGetData($tRECT, "Top"))
If $g_iDebugSetlog = 1 Then SetLog($title & " Window-Client-Diff: " & $aWindowClientDiff[0] & "," & $aWindowClientDiff[1], $COLOR_INFO)
$aAndroidWindow[0] = $g_iAndroidWindowWidth + $aWindowClientDiff[0]
$aAndroidWindow[1] = $g_iAndroidWindowHeight + $aWindowClientDiff[1]
If $g_iDebugSetlog = 1 Then SetLog($title & " Adjusted Window Size: " & $aAndroidWindow[0] & " x " & $aAndroidWindow[1], $COLOR_INFO)
Else
SetDebugLog("WARNING: Cannot determine " & $g_sAndroidEmulator & " Window Client Area!", $COLOR_ERROR)
EndIf
WinMove($HWnD, "", $AndroidWinPos[0], $AndroidWinPos[1], $aAndroidWindow[0] - 4, $aAndroidWindow[1] - 4)
$AndroidWinPos = WinGetPos($HWnD)
Local $WinWidth = $AndroidWinPos[2]
Local $WinHeight = $AndroidWinPos[3]
If $g_iAndroidWindowWidth > 0 And $g_iAndroidWindowHeight > 0 And($WinWidth <> $aAndroidWindow[0] Or $WinHeight <> $aAndroidWindow[1]) Then
WinMove2($HWnD, "", $AndroidWinPos[0], $AndroidWinPos[1], $aAndroidWindow[0], $aAndroidWindow[1])
If @error = 0 Then
SetDebugLog($g_sAndroidEmulator & " window resized to " & $aAndroidWindow[0] & " x " & $aAndroidWindow[1], $COLOR_SUCCESS)
RedrawAndroidWindow()
Local $hTimer = TimerInit()
Do
Sleep($iDelaySleep)
Local $new_BSsize = getAndroidPos(True)
Until TimerDiff($hTimer) > 5000 Or($BSsize[2] <> $new_BSsize[2] And $BSsize[3] <> $new_BSsize[3])
$BSsize[2] = $new_BSsize[2]
$BSsize[3] = $new_BSsize[3]
$BSx = $BSsize[2]
$BSy = $BSsize[3]
If $BSx <> $g_iAndroidClientWidth Or $BSy <> $g_iAndroidClientHeight Then
SetLog($g_sAndroidEmulator & " window resize didn't work, screen is " & $BSx & " x " & $BSy, $COLOR_ERROR)
Else
SetLog($g_sAndroidEmulator & " window resized to work with MyBot", $COLOR_SUCCESS)
EndIf
Else
SetDebugLog("WARNING: Cannot resize " & $g_sAndroidEmulator & " window to " & $aAndroidWindow[0] & " x " & $aAndroidWindow[1], $COLOR_ERROR)
EndIf
Else
If $RetryCount < 5 Then
Sleep(250)
Return getAndroidPos($FastCheck, $RetryCount + 1)
EndIf
EndIf
EndIf
EndIf
Return $BSsize
EndFunc
Func UniversalCloseWaitOpenCoC($iWaitTime = 0, $sSource = "RudeUnknownProgrammer_", $StopEmulator = False, $bFullRestart = False)
If $g_iDebugSetlog = 1 Then Setlog("Begin UniversalCloseWaitOpenCoC:", $COLOR_DEBUG1)
Local $sWaitTime = ""
Local $iMin, $iSec, $iHour, $iWaitSec, $StopAndroidFlag
If $iWaitTime > 0 Then
$iWaitSec = Round($iWaitTime / 1000)
$iHour = Floor(Floor($iWaitSec / 60) / 60)
$iMin = Floor(Mod(Floor($iWaitSec / 60), 60))
$iSec = Floor(Mod($iWaitSec, 60))
If $iHour > 0 Then $sWaitTime &= $iHour & " hours "
If $iMin > 0 Then $sWaitTime &= $iMin & " minutes "
If $iSec > 0 Then $sWaitTime &= $iSec & " seconds "
EndIf
Local $msg = ""
Select
Case StringInStr($StopEmulator, "rand", $STR_NOCASESENSEBASIC)
$StopAndroidFlag = Random(0, 2, 1)
Switch $StopAndroidFlag
Case 0
$msg = " =Time out"
Case 1
$msg = " =Close CoC"
Case 2
$msg = " =Close Android"
Case Else
$msg = "One Bad Monkey Error!"
EndSwitch
Setlog("Random close option= " & $StopAndroidFlag & $msg, $COLOR_SUCCESS)
Case StringInStr($StopEmulator, "idle", $STR_NOCASESENSEBASIC)
$StopAndroidFlag = 0
Case $StopEmulator = False
$StopAndroidFlag = 1
Case $StopEmulator = True
$StopAndroidFlag = 2
Case Else
$StopAndroidFlag = 1
SetLog("Code Monkey provided bad stop emulator flag value", $COLOR_ERROR)
EndSelect
If $g_iDebugSetlog = 1 Then Setlog("Stop Android flag : Input flag " & $StopAndroidFlag & " : " & $StopEmulator, $COLOR_DEBUG)
If _Sleep($iDelayRespond) Then Return False
Switch $StopAndroidFlag
Case 0
If $iWaitTime > 0 Then
SetLog("Going idle for " & $sWaitTime & "before starting CoC", $COLOR_SUCCESS)
If _SleepStatus($iWaitTime) Then Return False
Else
If _SleepStatus($iDelayWaitnOpenCoC10000) Then Return False
EndIf
If _Sleep($iDelayRespond) Then Return False
OpenCoC()
Case 1
PoliteCloseCoC($sSource)
If _Sleep(3000) Then Return False
If $iWaitTime > 0 Then
If $iWaitTime > 30000 Then
AndroidShieldForceDown(True)
EnableGuiControls()
SetLog("Enabled bot controls due to long wait time", $COLOR_SUCCESS)
EndIf
WaitnOpenCoC($iWaitTime, $bFullRestart)
AndroidShieldForceDown(False)
If $g_bRunState = False Then Return False
Else
WaitnOpenCoC($iDelayWaitnOpenCoC10000, $bFullRestart)
EndIf
If _Sleep($iDelayRespond) Then Return False
If $iWaitTime > 30000 Then
SaveConfig()
readConfig()
applyConfig()
DisableGuiControls()
EndIf
Case 2
PoliteCloseCoC($sSource)
If _Sleep(3000) Then Return False
CloseAndroid("UniversalCloseWaitOpenCoC")
ReduceBotMemory()
If $iWaitTime > 0 Then
SetLog("Waiting " & $sWaitTime & "before starting CoC", $COLOR_SUCCESS)
If $iWaitTime > 30000 Then
EnableGuiControls()
SetLog("Enabled bot controls due to long wait time", $COLOR_SUCCESS)
EndIf
If _SleepStatus($iWaitTime) Then Return False
If $iWaitTime > 30000 Then
SaveConfig()
readConfig()
applyConfig()
DisableGuiControls()
EndIf
Else
If _SleepStatus($iDelayWaitnOpenCoC10000) Then Return False
EndIf
StartAndroidCoC()
Case Else
SetLog("Code Monkey is drinking banana liqueur again!", $COLOR_ERROR)
EndSwitch
EndFunc
Global $g_aiAndroidEmbeddedGraphics[0][2]
Func GetCurrentAndroidHWnD()
Local $h =(($g_bAndroidEmbedded = False Or $g_iAndroidEmbedMode = 1) ? $HWnD : $g_hFrmBot)
Return $h
EndFunc
Func GetAndroidDisplayHWnD()
Local $h =(($g_bAndroidEmbedded = False) ? $HWnD : $g_hFrmBot)
Return $h
EndFunc
Func AndroidEmbed($Embed = True, $CallWinGetAndroidHandle = True, $bForceEmbed = False)
If $g_bAndroidEmbed = False Then Return False
Local $hMutex = AcquireMutex("AndroidEmbed", Default, 1000)
If $hMutex <> 0 Then
Return ReleaseMutex($hMutex, _AndroidEmbed($Embed, $CallWinGetAndroidHandle, $bForceEmbed))
EndIf
Return False
EndFunc
Func _AndroidEmbed($Embed = True, $CallWinGetAndroidHandle = True, $bForceEmbed = False)
If($CallWinGetAndroidHandle = False And $HWnD = 0) Or($CallWinGetAndroidHandle = True And WinGetAndroidHandle() = 0) Then
SetDebugLog("Android Emulator not launched", $COLOR_ERROR)
If $g_bAndroidEmbedded = False Then
updateBtnEmbed()
Return False
Else
If $Embed = True Then
SetDebugLog("Docked Android Window not available, force undock", $COLOR_ERROR)
$Embed = False
EndIf
EndIf
EndIf
If $g_bAndroidBackgroundLaunched = True Then
If $g_bAndroidEmbedded = False Then
SetDebugLog("Android Emulator launched in background mode", $COLOR_ERROR)
updateBtnEmbed()
Return False
Else
If $Embed = True Then
SetDebugLog("Android Emulator launched in background mode, force undock", $COLOR_ERROR)
$Embed = False
EndIf
EndIf
EndIf
Local $aPos = WinGetPos($HWnD)
If IsArray($aPos) = 0 Or @error <> 0 Then
If $g_bAndroidEmbedded = False Then
SetDebugLog("Android Window not available", $COLOR_ERROR)
updateBtnEmbed()
Return False
Else
If $Embed = True Then
SetDebugLog("Android Window not accessible, force undock", $COLOR_ERROR)
$Embed = False
EndIf
EndIf
EndIf
Local $hCtrl = ControlGetHandle(GetCurrentAndroidHWnD(), $g_sAppPaneName, $g_sAppClassInstance)
Local $aPosFrmBotEx, $aPosLog
Local $hCtrlTarget = $g_aiAndroidEmbeddedCtrlTarget[0]
Local $hCtrlTargetParent = $g_aiAndroidEmbeddedCtrlTarget[1]
Local $HWnDParent = $g_aiAndroidEmbeddedCtrlTarget[2]
Local $HWnD2 = $g_aiAndroidEmbeddedCtrlTarget[3]
Local $lCurStyle = $g_aiAndroidEmbeddedCtrlTarget[4]
Local $lCurExStyle = $g_aiAndroidEmbeddedCtrlTarget[5]
Local $aPosCtl = $g_aiAndroidEmbeddedCtrlTarget[6]
Local $lCurStyleTarget = $g_aiAndroidEmbeddedCtrlTarget[8]
Local $hThumbnail = $g_aiAndroidEmbeddedCtrlTarget[9]
Local $targetIsHWnD = $hCtrlTarget = $HWnD
Local $activeHWnD = WinGetHandle("")
Local $HWnD_available = WinGetHandle($HWnD) = $HWnD
If $Embed = False Then
If $g_bAndroidEmbedded = True Then
SetDebugLog("Undocking Android Control...")
If _WinAPI_IsIconic($g_hFrmBot) Then BotMinimize("_AndroidEmbed (1)", True)
If $g_bAndroidShieldEnabled = True Then
AndroidShield("AndroidEmbed undock", False, $CallWinGetAndroidHandle, 100)
GUIDelete($g_hFrmBotEmbeddedShield)
$g_hFrmBotEmbeddedShield = 0
If $g_hFrmBotEmbeddedMouse Then
GUIDelete($g_hFrmBotEmbeddedMouse)
$g_hFrmBotEmbeddedMouse = 0
EndIf
$g_avAndroidShieldStatus[0] = Default
EndIf
SetRedrawBotWindow(False, Default, Default, Default, "_AndroidEmbed")
If $hThumbnail <> 0 Then
_WinAPI_DwmUnregisterThumbnail($hThumbnail)
$g_aiAndroidEmbeddedCtrlTarget[9] = 0
EndIf
$aPos = $g_aiAndroidEmbeddedCtrlTarget[7]
$g_hProcShieldInput[3] = True
If $HWnD_available Then
Switch $g_iAndroidEmbedMode
Case 0
If $targetIsHWnD = False Then
_WinAPI_SetParent($hCtrlTarget, $hCtrlTargetParent)
_WinAPI_SetWindowLong($hCtrlTarget, $GWL_HWNDPARENT, $hCtrlTargetParent)
EndIf
_WinAPI_SetWindowLong($HWnD, $GWL_EXSTYLE, $lCurExStyle)
_WinAPI_SetParent($HWnD, $HWnDParent)
_WinAPI_SetWindowLong($HWnD, $GWL_HWNDPARENT, $HWnDParent)
_WinAPI_SetWindowLong($HWnD, $GWL_STYLE, $lCurStyle)
WinMove($HWnD, "", $aPos[0], $aPos[1], $aPos[2], $aPos[3] - 1)
WinMove2($HWnD, "", $aPos[0], $aPos[1], $aPos[2], $aPos[3])
Case 1
_WinAPI_SetWindowLong($HWnD, $GWL_EXSTYLE, $lCurExStyle)
_WinAPI_SetWindowLong($HWnD, $GWL_STYLE, $lCurStyle)
WinMove($HWnD, "", $aPos[0], $aPos[1], $aPos[2], $aPos[3] - 1)
WinMove($HWnD, "", $aPos[0], $aPos[1], $aPos[2], $aPos[3])
EndSwitch
EndIf
WinMove(($targetIsHWnD ? $hCtrl : $hCtrlTarget), "", $aPosCtl[0], $aPosCtl[1], $aPosCtl[2], $aPosCtl[3])
WinMove2(($targetIsHWnD ? $hCtrl : $hCtrlTarget), "", $aPosCtl[0], $aPosCtl[1], $aPosCtl[2], $aPosCtl[3], 0, 0, False)
If $g_iDebugAndroidEmbedded Then SetDebugLog("Placed Android Control at " & $aPosCtl[0] & "," & $aPosCtl[1])
ControlHide($g_hGUI_LOG, "", $g_hDivider)
$aPosFrmBotEx = ControlGetPos($g_hFrmBot, "", $g_hFrmBotEx)
If UBound($aPosFrmBotEx) < 4 Then
SetLog("Bot Window not available", $COLOR_ERROR)
$g_hProcShieldInput[3] = False
Return False
EndIf
ControlMove($g_hFrmBot, "", $g_hFrmBotEx, 0, 0, $aPosFrmBotEx[2], $aPosFrmBotEx[3] - $frmBotAddH)
ControlMove($g_hFrmBot, "", $g_hFrmBotBottom, 0, $_GUI_MAIN_HEIGHT - $_GUI_BOTTOM_HEIGHT + $_GUI_MAIN_TOP)
WinSetTrans($g_hFrmBotBottom, "", 255)
$aPosLog = ControlGetPos($g_hFrmBotEx, "", $g_hGUI_LOG)
ControlMove($g_hFrmBotEx, "", $g_hGUI_LOG, Default, Default, $aPosLog[2], $aPosLog[3] - $frmBotAddH)
$g_bAndroidEmbedded = False
WinMove2($g_hFrmBot, "", $frmBotPosX, $frmBotPosY, $g_aFrmBotPosInit[2], $g_aFrmBotPosInit[3], 0, 0, False)
updateBtnEmbed()
$g_iLogDividerY -= $frmBotAddH
$frmBotAddH = 0
cmbLog()
SetRedrawBotWindow(True, Default, Default, Default, "_AndroidEmbed")
If $HWnD_available Then
_SendMessage($HWnD, $WM_SETREDRAW, False, 0)
_WinAPI_ShowWindow($HWnD, @SW_HIDE)
_WinAPI_SetWindowLong($HWnD, $GWL_EXSTYLE, BitOR($lCurExStyle, $WS_EX_APPWINDOW))
_WinAPI_ShowWindow($HWnD, @SW_SHOWNOACTIVATE)
_SendMessage($HWnD, $WM_SETREDRAW, True, 0)
_WinAPI_UpdateWindow($HWnD)
_WinAPI_SetWindowLong($HWnD, $GWL_EXSTYLE, $lCurExStyle)
_WinAPI_EnableWindow($HWnD, True)
_WinAPI_EnableWindow($hCtrlTarget, True)
WinMove2(($targetIsHWnD ? $hCtrl : $hCtrlTarget), "", $aPosCtl[0], $aPosCtl[1], $aPosCtl[2], $aPosCtl[3], 0, 0, False)
Execute("Embed" & $g_sAndroidEmulator & "(False)")
If $g_iAndroidEmbedMode = 1 Then
WinMove2($HWnD, "", $aPos[0], $aPos[1], $aPos[2], $aPos[3], $HWND_TOPMOST)
WinMove2($HWnD, "", $aPos[0], $aPos[1], $aPos[2], $aPos[3], $HWND_NOTOPMOST, 0, False)
EndIf
getAndroidPos()
getBSPos()
EndIf
SetDebugLog("Undocked Android Window")
$g_hProcShieldInput[3] = False
Return True
EndIf
updateBtnEmbed()
Return False
EndIf
If $g_bAndroidEmbedded = True And $bForceEmbed = False Then
If $HWnD = $HWnD2 Then
If $targetIsHWnD = False Then
WinMove2($HWnD, "", $aPosCtl[2] + 2, $g_aFrmBotPosInit[5], -1, -1, $HWND_BOTTOM)
EndIf
Return False
EndIf
SetDebugLog("Docked Android Window gone", $COLOR_ERROR)
Return _AndroidEmbed(False)
EndIf
Local $bAlreadyEmbedded = $g_bAndroidEmbedded = True
SetDebugLog("Docking Android Control...")
If _WinAPI_DwmEnableComposition(True) = 1 Then
SetDebugLog("Desktop Window Manager available", $COLOR_SUCCESS)
Else
SetDebugLog("Desktop Window Manager not available!", $COLOR_ERROR)
SetDebugLog("Android Shield will be invisible!", $COLOR_ERROR)
EndIf
If _WinAPI_IsIconic($g_hFrmBot) Then BotMinimize("_AndroidEmbed (2)", True)
If _WinAPI_IsIconic($HWnD) Then WinSetState($HWnD, "", @SW_RESTORE)
getAndroidPos()
$aPos = WinGetPos($HWnD)
If IsArray($aPos) = 0 Then
updateBtnEmbed()
Return False
EndIf
If $g_iDebugAndroidEmbedded Then SetDebugLog("AndroidEmbed: $aPos[] = " & $aPos[0] & ", " & $aPos[1] & ", " & $aPos[2] & ", " & $aPos[3], Default, True)
$lCurStyle = _WinAPI_GetWindowLong($HWnD, $GWL_STYLE)
$lCurExStyle = _WinAPI_GetWindowLong($HWnD, $GWL_EXSTYLE)
$HWnDParent = _WinAPI_GetParent($HWnD)
$hCtrlTarget = _WinAPI_GetParent($hCtrl)
If $hCtrlTarget = 0 Then
updateBtnEmbed()
Return False
EndIf
$lCurStyleTarget = _WinAPI_GetWindowLong($hCtrlTarget, $GWL_STYLE)
$hCtrlTargetParent = _WinAPI_GetParent($hCtrlTarget)
If $g_iDebugAndroidEmbedded Then SetDebugLog("AndroidEmbed: $hCtrl=" & $hCtrl & ", $hCtrlTarget=" & $hCtrlTarget & ", $hCtrlTargetParent=" & $hCtrlTargetParent & ", $HWnD=" & $HWnD, Default, True)
$targetIsHWnD = $hCtrlTarget = $HWnD
Local $adjustPosCtrl = False
If $bAlreadyEmbedded = True Then
$g_hProcShieldInput[3] = True
Else
$aPosCtl = ControlGetPos($HWnD, "",($targetIsHWnD ? $hCtrl : $hCtrlTarget))
If IsArray($aPosCtl) = 0 Or @error <> 0 Then
updateBtnEmbed()
Return False
EndIf
If $g_iDebugAndroidEmbedded Then SetDebugLog("AndroidEmbed: $aPosCtl[] = " & $aPosCtl[0] & ", " & $aPosCtl[1] & ", " & $aPosCtl[2] & ", " & $aPosCtl[3], Default, True)
If $targetIsHWnD Then
Local $aPosParentCtl = $aPosCtl
$hCtrlTargetParent = $hCtrlTarget
ElseIf $hCtrlTargetParent = $HWnD Then
Local $aPosParentCtl = $aPosCtl
Else
$adjustPosCtrl = True
Local $aPosParentCtl = ControlGetPos($HWnD, "", $hCtrlTargetParent)
If $hCtrlTargetParent = 0 Or IsArray($aPosParentCtl) = 0 Or @error <> 0 Then
SetDebugLog("Android Parent Control not available", $COLOR_ERROR)
updateBtnEmbed()
Return False
EndIf
EndIf
If $g_iDebugAndroidEmbedded Then SetDebugLog("AndroidEmbed: $aPosParentCtl[] = " & $aPosParentCtl[0] & ", " & $aPosParentCtl[1] & ", " & $aPosParentCtl[2] & ", " & $aPosParentCtl[3], Default, True)
Local $botClientHeight = $g_aFrmBotPosInit[5]
$frmBotAddH = $aPosCtl[3] - $botClientHeight
If $g_iDebugAndroidEmbedded Then SetDebugLog("AndroidEmbed: $frmBotAddH = " & $frmBotAddH, Default, True)
If $frmBotAddH < 0 Then $frmBotAddH = 0
Local $g_hFrmBotWidth = $g_aFrmBotPosInit[2] + $aPosCtl[2] + 2
Local $g_hFrmBotHeight = $g_aFrmBotPosInit[3] + $frmBotAddH
$g_hProcShieldInput[3] = True
$g_bAndroidEmbedded = True
If $frmBotDockedPosX = -1 And $frmBotDockedPosY = -1 Then
If $frmBotPosX < $AndroidPosX Then
$frmBotDockedPosX = $frmBotPosX
$frmBotDockedPosY = $frmBotPosY
Else
$frmBotDockedPosX = $AndroidPosX
$frmBotDockedPosY = $AndroidPosY
EndIf
EndIf
WinMove2($g_hFrmBot, "", $frmBotDockedPosX, $frmBotDockedPosY, -1, -1, 0, 0, False)
$aPosFrmBotEx = ControlGetPos($g_hFrmBot, "", $g_hFrmBotEx)
$aPosFrmBotEx[3] = $g_aFrmBotPosInit[6]
If $g_iDebugAndroidEmbedded Then SetDebugLog("AndroidEmbed: $aPosFrmBotEx[] = " & $aPosFrmBotEx[0] & ", " & $aPosFrmBotEx[1] & ", " & $aPosFrmBotEx[2] & ", " & $aPosFrmBotEx[3], Default, True)
WinMove($g_hFrmBotEx, "", $aPosCtl[2] + 2, 0, $aPosFrmBotEx[2], $aPosFrmBotEx[3] + $frmBotAddH)
WinMove($g_hFrmBotBottom, "", $aPosCtl[2] + 2, $_GUI_MAIN_HEIGHT - $_GUI_BOTTOM_HEIGHT + $_GUI_MAIN_TOP + $frmBotAddH)
If $g_iAndroidEmbedMode = 0 Then
WinMove2($hCtrlTarget, "", 0, 0, $aPosCtl[2], $aPosCtl[3], $HWND_BOTTOM)
EndIf
_SendMessage($g_hFrmBot, $WM_SETREDRAW, False, 0)
Local $a = ControlGetRelativePos($g_hFrmBotEx, "", $g_hTabMain)
If UBound($a) > 3 Then
Local $ctrlResult = WinMove(GUICtrlGetHandle($g_hTabMain), "", $a[0], $a[1], $a[2], $a[3] + $frmBotAddH)
If $g_iDebugAndroidEmbedded Then SetDebugLog("Move $g_hTabMain Pos: " & $a[0] & ", " & $a[1] & ", " & $a[2] & ", " & $a[3] + $frmBotAddH & ": " & $ctrlResult)
EndIf
$aPosLog = ControlGetPos($g_hFrmBotEx, "", $g_hGUI_LOG)
If $g_iDebugAndroidEmbedded Then SetDebugLog("AndroidEmbed: $aPosLog[] = " & $aPosLog[0] & ", " & $aPosLog[1] & ", " & $aPosLog[2] & ", " & $aPosLog[3], Default, True)
WinMove($g_hGUI_LOG, "", $_GUI_CHILD_LEFT, $_GUI_CHILD_TOP, $aPosLog[2], $aPosLog[3] + $frmBotAddH)
WinMove2($g_hFrmBot, "", $frmBotDockedPosX, $frmBotDockedPosY, $g_hFrmBotWidth, $g_hFrmBotHeight, 0, 0, False)
$g_aiAndroidEmbeddedCtrlTarget[0] = $hCtrlTarget
$g_aiAndroidEmbeddedCtrlTarget[1] = $hCtrlTargetParent
$g_aiAndroidEmbeddedCtrlTarget[2] = $HWnDParent
$g_aiAndroidEmbeddedCtrlTarget[3] = $HWnD
$g_aiAndroidEmbeddedCtrlTarget[4] = $lCurStyle
$g_aiAndroidEmbeddedCtrlTarget[5] = $lCurExStyle
If $adjustPosCtrl = True Then
$aPosCtl[0] = $aPosParentCtl[0] - $aPosCtl[0]
$aPosCtl[1] = $aPosParentCtl[1] - $aPosCtl[1]
EndIf
$g_aiAndroidEmbeddedCtrlTarget[6] = $aPosCtl
$g_aiAndroidEmbeddedCtrlTarget[7] = $aPos
$g_aiAndroidEmbeddedCtrlTarget[8] = $lCurStyleTarget
EndIf
Local $newStyle = AndroidEmbed_GWL_STYLE()
SetDebugLog("AndroidEmbed_GWL_STYLE=" & Get_GWL_STYLE_Text($newStyle))
Local $a = AndroidEmbed_HWnD_Position()
Switch $g_iAndroidEmbedMode
Case 0
_WinAPI_SetWindowLong($HWnD, $GWL_EXSTYLE, $WS_EX_MDICHILD)
_WinAPI_SetWindowLong($HWnD, $GWL_HWNDPARENT, $g_hFrmBot)
_WinAPI_SetWindowLong($HWnD, $GWL_STYLE, $newStyle)
_WinAPI_SetParent($HWnD, $g_hFrmBot)
If $targetIsHWnD = False Then
_WinAPI_SetWindowLong($hCtrlTarget, $GWL_HWNDPARENT, $g_hFrmBot)
_WinAPI_SetParent($hCtrlTarget, $g_hFrmBot)
EndIf
_WinAPI_SetWindowLong($HWnD, $GWL_STYLE, $newStyle)
If $targetIsHWnD = False Then
WinMove2($HWnD, "", $a[0], $a[1], -1, -1, $HWND_BOTTOM, 0, False)
EndIf
Case 1
_WinAPI_SetWindowLong($HWnD, $GWL_STYLE, $newStyle)
WinMove2($HWnD, "", -1, -1, -1, -1, 0, $SWP_HIDEWINDOW, False)
_WinAPI_ShowWindow($HWnD, @SW_HIDE)
_WinAPI_SetWindowLong($HWnD, $GWL_EXSTYLE, BitOR(_WinAPI_GetWindowLong($HWnD, $GWL_EXSTYLE), $WS_EX_TOOLWINDOW, $WS_EX_NOACTIVATE))
_WinAPI_ShowWindow($HWnD, @SW_SHOWNOACTIVATE)
_SendMessage($HWnD, $WM_SETREDRAW, True, 0)
_WinAPI_UpdateWindow($HWnD)
_WinAPI_SetWindowLong($HWnD, $GWL_EXSTYLE, BitOR(_WinAPI_GetWindowLong($HWnD, $GWL_EXSTYLE), $WS_EX_TOOLWINDOW, $WS_EX_NOACTIVATE))
WinMove($HWnD, "", $a[0], $a[1], $aPosCtl[2], $aPosCtl[3] - 1)
WinMove($HWnD, "", $a[0], $a[1], $aPosCtl[2], $aPosCtl[3])
If $targetIsHWnD = False Then
WinMove2($hCtrlTarget, "", 0, 0, $aPosCtl[2], $aPosCtl[3], 0, 0, False)
EndIf
If _WinAPI_DwmIsCompositionEnabled() And $hThumbnail = 0 Then
$hThumbnail = _WinAPI_DwmRegisterThumbnail($g_hFrmBot, $HWnD)
Local $tSIZE = _WinAPI_DwmQueryThumbnailSourceSize($hThumbnail)
Local $iWidth = DllStructGetData($tSIZE, 1)
Local $iHeight = DllStructGetData($tSIZE, 2)
Local $tDestRect = _WinAPI_CreateRectEx(0, 0, $iWidth, $iHeight)
Local $tSrcRect = _WinAPI_CreateRectEx(0, 0, $iWidth, $iHeight)
_WinAPI_DwmUpdateThumbnailProperties($hThumbnail, 1, 0, 255, $tDestRect, $tSrcRect)
$g_aiAndroidEmbeddedCtrlTarget[9] = $hThumbnail
EndIf
WinMove2($HWnD, "", $a[0], $a[1], $aPosCtl[2], $aPosCtl[3], $HWND_BOTTOM, $SWP_SHOWWINDOW, False)
EndSwitch
Execute("Embed" & $g_sAndroidEmulator & "(True)")
updateBtnEmbed()
$g_iLogDividerY += $frmBotAddH
cmbLog()
_WinAPI_EnableWindow($hCtrlTarget, False)
_WinAPI_EnableWindow($HWnD, False)
Local $aCheck = WinGetPos($HWnD)
If IsArray($aCheck) Then
If $g_iDebugAndroidEmbedded Then SetDebugLog("AndroidEmbed: Android Window Pos: " & $aCheck[0] & ", " & $aCheck[1] & ", " & $aCheck[2] & ", " & $aCheck[3], Default, True)
Else
SetDebugLog("AndroidEmbed: Android Window not found", $COLOR_ERROR)
EndIf
Local $aCheck = ControlGetPos(GetCurrentAndroidHWnD(), $g_sAppPaneName, $g_sAppClassInstance)
If IsArray($aCheck) Then
If $g_iDebugAndroidEmbedded Then SetDebugLog("AndroidEmbed: Android Control Pos: " & $aCheck[0] & ", " & $aCheck[1] & ", " & $aCheck[2] & ", " & $aCheck[3], Default, True)
Else
SetDebugLog("AndroidEmbed: Android Control not found", $COLOR_ERROR)
EndIf
getBSPos()
_SendMessage($g_hFrmBot, $WM_SETREDRAW, True, 0)
_WinAPI_RedrawWindow($g_hFrmBot, 0, 0, $RDW_INVALIDATE + $RDW_ALLCHILDREN + $RDW_ERASE)
_WinAPI_RedrawWindow($g_hFrmBotBottom, 0, 0, $RDW_INVALIDATE + $RDW_ALLCHILDREN + $RDW_ERASE)
_WinAPI_UpdateWindow($g_hFrmBot)
_WinAPI_UpdateWindow($g_hFrmBotBottom)
If $g_iAndroidEmbedMode = 0 Then
WinMove2($hCtrlTarget, "", 0, 0, $aPosCtl[2], $aPosCtl[3] - 1, $HWND_BOTTOM, 0, False)
WinMove2($hCtrlTarget, "", 0, 0, $aPosCtl[2], $aPosCtl[3], $HWND_BOTTOM, 0, False)
EndIf
SetDebugLog("Android Window docked")
$g_hProcShieldInput[3] = False
$g_hProcShieldInput[4] = 0
AndroidShield("AndroidEmbed dock", Default, $CallWinGetAndroidHandle, 100)
Return True
EndFunc
Func Get_GWL_STYLE_Text($iGWL_STYLE)
Local $s = ""
Local $a[20][2] = [[$WS_MAXIMIZEBOX, "$WS_MAXIMIZEBOX"] , [$WS_MINIMIZEBOX, "$WS_MINIMIZEBOX"] , [$WS_TABSTOP, "$WS_TABSTOP"] , [$WS_GROUP, "$WS_GROUP"] , [$WS_SIZEBOX, "$WS_SIZEBOX"] , [$WS_SYSMENU, "$WS_SYSMENU"] , [$WS_HSCROLL, "$WS_HSCROLL"] , [$WS_VSCROLL, "$WS_VSCROLL"] , [$WS_DLGFRAME, "$WS_DLGFRAME"] , [$WS_BORDER, "$WS_BORDER"] , [$WS_CAPTION, "$WS_CAPTION"] , [$WS_MAXIMIZE, "$WS_MAXIMIZE"] , [$WS_CLIPCHILDREN, "$WS_CLIPCHILDREN"] , [$WS_CLIPSIBLINGS, "$WS_CLIPSIBLINGS"] , [$WS_DISABLED, "$WS_DISABLED"] , [$WS_VISIBLE, "$WS_VISIBLE"] , [$WS_MINIMIZE, "$WS_MINIMIZE"] , [$WS_CHILD, "$WS_CHILD"] , [$WS_POPUP, "$WS_POPUP"] , [$WS_POPUPWINDOW, "$WS_POPUPWINDOW"] ]
Local $i
For $i = 0 To UBound($a) - 1
If BitAND($iGWL_STYLE, $a[$i][0]) > 0 Then
If $s <> "" Then $s &= ", "
$s &= $a[$i][1]
$iGWL_STYLE -= $a[$i][0]
EndIf
Next
If $iGWL_STYLE > 0 Then
If $s <> "" Then $s &= ","
$s &= Hex($iGWL_STYLE, 8)
EndIf
Return $s
EndFunc
Func AndroidEmbed_GWL_STYLE()
If $g_bAndroidEmbedded = True Then
Local $lCurStyle = $g_aiAndroidEmbeddedCtrlTarget[4]
Local $newStyle = BitOR($WS_CHILD, BitAND($lCurStyle, BitNOT(BitOR($WS_POPUP, $WS_CAPTION, $WS_SYSMENU, $WS_MINIMIZEBOX, $WS_MAXIMIZEBOX, $WS_SIZEBOX, $WS_BORDER, $WS_THICKFRAME))))
If $g_iAndroidEmbedMode = 1 Then
$newStyle = BitOR($WS_POPUP, BitAND($newStyle, BitNOT($WS_CHILD)))
EndIf
Return $newStyle
EndIf
Return ""
EndFunc
Func AndroidEmbed_HWnD_Position($bForShield = False, $bDetachedShield = Default, $hCtrlTarget = Default, $aPosCtl = Default)
Local $aPos[2]
If $bDetachedShield = Default Then
$bDetachedShield = $g_avAndroidShieldStatus[4]
EndIf
If $g_iAndroidEmbedMode = 1 Or($bForShield = True And $bDetachedShield = True) Then
Local $tPoint = DllStructCreate("int X;int Y")
DllStructSetData($tPoint, "X", 0)
DllStructSetData($tPoint, "Y", 0)
_WinAPI_ClientToScreen($g_hFrmBot, $tPoint)
$aPos[0] = DllStructGetData($tPoint, "X")
$aPos[1] = DllStructGetData($tPoint, "Y")
$tPoint = 0
ElseIf $g_iAndroidEmbedMode = 0 And $bForShield = False Then
If $hCtrlTarget = Default Then
$hCtrlTarget = $g_aiAndroidEmbeddedCtrlTarget[0]
EndIf
If $aPosCtl = Default Then
$aPosCtl = $g_aiAndroidEmbeddedCtrlTarget[6]
EndIf
Local $targetIsHWnD = $hCtrlTarget = $HWnD
If $targetIsHWnD = False Then
$aPos[0] = $aPosCtl[2] + 2
$aPos[1] = $g_aFrmBotPosInit[5]
Else
$aPos[0] = 0
$aPos[1] = 0
EndIf
ElseIf $bForShield = True And($bDetachedShield = False Or $bDetachedShield = Default) Then
$aPos[0] = 0
$aPos[1] = 0
Else
SetDebugLog("AndroidEmbed_HWnD_Position: Wrong window state:" & @CRLF & "$bForShield=" & $bForShield & @CRLF & "$g_iAndroidEmbedMode=" & $g_iAndroidEmbedMode & @CRLF & "$bDetachedShield=" & $bDetachedShield)
EndIf
Return $aPos
EndFunc
Func AndroidEmbedCheck($bTestIfRequired = Default, $bHasFocus = Default, $iAction = 6)
If $bHasFocus = Default Then $bHasFocus = WinActive($g_hFrmBot) <> 0
If $bTestIfRequired = Default Then
$iAction = AndroidEmbedCheck(True, $bHasFocus)
If $iAction > 0 Then
Return AndroidEmbedCheck(False, $bHasFocus, $iAction)
EndIf
EndIf
If $g_bAndroidEmbedded = True And AndroidEmbedArrangeActive() = False Then
Local $aPosCtl = $g_aiAndroidEmbeddedCtrlTarget[6]
Local $aPos = AndroidEmbed_HWnD_Position()
Local $aPosShield = AndroidEmbed_HWnD_Position(True)
Local $newStyle = AndroidEmbed_GWL_STYLE()
Local $bDetachedShield = $g_avAndroidShieldStatus[4]
If $bTestIfRequired = False Then
SetDebugLog("AndroidEmbedCheck: $iAction=" & $iAction, Default, True)
If BitAND($iAction, 2) > 0 Then
AndroidEmbedArrangeActive(True)
_WinAPI_SetWindowLong($HWnD, $GWL_STYLE, $newStyle)
AndroidEmbed(True, False, True)
EndIf
If BitAND($iAction, 1) Or BitAND($iAction, 4) > 0 Then
WinMove2($HWnD, "", $aPos[0], $aPos[1], -1, -1, $HWND_BOTTOM, 0, True)
EndIf
If $g_bAndroidShieldEnabled = True And $bDetachedShield = True Then
If BitAND($iAction, 1) > 0 Or BitAND($iAction, 4) > 0 Then
If BitAND($iAction, 4) > 0 Then
WinMove2($g_hFrmBotEmbeddedShield, "", $aPosShield[0], $aPosShield[1], $aPosCtl[2], $aPosCtl[3],($bHasFocus ? $HWND_TOPMOST : $HWND_NOTOPMOST), 0, False)
If $g_hFrmBotEmbeddedGraphics Then
WinMove2($g_hFrmBotEmbeddedGraphics, "", $aPosShield[0], $aPosShield[1], $aPosCtl[2], $aPosCtl[3],($bHasFocus ? $HWND_TOPMOST : $HWND_NOTOPMOST), 0, False)
EndIf
EndIf
If $bHasFocus = False Then
WinMove2($g_hFrmBotEmbeddedShield, "", -1, -1, -1, -1, $g_hFrmBot, 0, False)
WinMove2($g_hFrmBot, "", -1, -1, -1, -1, $g_hFrmBotEmbeddedShield, 0, False)
EndIf
EndIf
EndIf
Return True
EndIf
Local $iZorder = 0
If $g_bAndroidShieldEnabled = True And $bDetachedShield = True And $bHasFocus = False Then
If $g_bAndroidShieldEnabled = True Then
Local $h = _WinAPI_GetWindow($g_hFrmBotEmbeddedShield, $GW_HWNDNEXT)
If $h <> $g_hFrmBot Then $iZorder = 1
EndIf
EndIf
Local $style = _WinAPI_GetWindowLong($HWnD, $GWL_STYLE)
If BitAND($style, $WS_DISABLED) > 0 Then $newStyle = BitOR($newStyle, $WS_DISABLED)
If BitAND($style, $WS_MAXIMIZEBOX) > 0 Then $newStyle = BitOR($newStyle, $WS_MAXIMIZEBOX)
Local $iStyle =(($style <> $newStyle) ? 2 : 0)
If $iStyle > 0 Then
SetDebugLog("AndroidEmbedCheck: Android Window GWL_STYLE changed: " & Get_GWL_STYLE_Text($newStyle) & " to " & Get_GWL_STYLE_Text($style), Default, True)
EndIf
Local $a1[2] = [$aPos[0], $aPos[1]]
Local $a2 = $aPos
Switch $g_iAndroidEmbedMode
Case 0
Local $a1 = ControlGetPos($g_hFrmBot, "", $HWnD)
Case 1
Local $a1 = WinGetPos($HWnD)
EndSwitch
Local $iPos =((IsArray($a1) And($a1[0] <> $a2[0] Or $a1[1] <> $a2[1])) ? 4 : 0)
If $iPos > 0 Then
SetDebugLog("AndroidEmbedCheck: Android Window Position changed: X: " & $a1[0] & " <> " & $a2[0] & ", Y: " & $a1[1] & " <> " & $a2[1], Default, True)
EndIf
If $iPos = 0 And $bDetachedShield = True Then
$a1 = WinGetPos($g_hFrmBotEmbeddedShield)
$a2 = $aPosShield
$iPos =((IsArray($a1) And($a1[0] <> $a2[0] Or $a1[1] <> $a2[1])) ? 4 : 0)
If $iPos > 0 Then
SetDebugLog("AndroidEmbedCheck: Android Shield Position changed: X: " & $a1[0] & " <> " & $a2[0] & ", Y: " & $a1[1] & " <> " & $a2[1], Default, True)
EndIf
EndIf
Return BitOR($iZorder, $iStyle, $iPos)
EndIf
Return 0
EndFunc
Func AndroidEmbedded()
Return $g_bAndroidEmbedded
EndFunc
Func AndroidEmbedArrangeActive($bActive = Default)
If $bActive = Default Then Return $g_hProcShieldInput[3]
Local $bWasActive = $g_hProcShieldInput[3]
$g_hProcShieldInput[3] = $bActive
Return $bWasActive
EndFunc
Func AndroidShieldStartup()
_OnAutoItErrorRegister()
EndFunc
Func AndroidShieldDestroy()
_OnAutoItErrorUnRegister()
EndFunc
Func AndroidShieldForceDown($bForceDown = True, $AndroidHasFocus = False)
Local $wasDown = $g_bAndroidShieldForceDown
$g_bAndroidShieldForceDown = $bForceDown
AndroidShield("AndroidShieldForceDown", Default, True, 0, $AndroidHasFocus)
Return $wasDown
EndFunc
Func AndroidShieldForcedDown()
Return $g_bAndroidShieldForceDown
EndFunc
Func AndroidShieldHasFocus()
Return $g_hProcShieldInput[2] = True
EndFunc
Func AndroidShielded()
Return $g_avAndroidShieldStatus[0] = True
EndFunc
Func AndroidShieldActiveDelay($bIsStillWaiting = False)
Return $g_avAndroidShieldDelay[0] <> 0 And $g_avAndroidShieldDelay[1] > 0 And($bIsStillWaiting = False Or TimerDiff($g_avAndroidShieldDelay[0]) < $g_avAndroidShieldDelay[1])
EndFunc
Func AndroidShieldCheck()
If AndroidShieldActiveDelay(True) = True Then Return False
Return AndroidShield("AndroidShieldCheck")
EndFunc
Func AndroidShieldLock($Lock = Default)
If $Lock = Default Then Return $g_hProcShieldInput[3]
Local $wasLock = $g_hProcShieldInput[3]
$g_hProcShieldInput[3] = $Lock
Return $wasLock
EndFunc
Func AndroidShield($sCaller, $Enable = Default, $CallWinGetAndroidHandle = True, $iDelay = 0, $AndroidHasFocus = Default, $AndroidUpdateFocus = True)
If $g_bAndroidShieldEnabled = False Or $g_hProcShieldInput[3] = True Then Return False
If $iDelay > 0 Then
Return _AndroidShield($sCaller, $Enable, $CallWinGetAndroidHandle, $iDelay, $AndroidHasFocus, $AndroidUpdateFocus)
EndIf
Local $hMutex = AcquireMutex("AndroidShield", Default, 1000)
If $hMutex <> 0 Then
Local $Result = _AndroidShield($sCaller, $Enable, $CallWinGetAndroidHandle, $iDelay, $AndroidHasFocus, $AndroidUpdateFocus)
ReleaseMutex($hMutex)
Return $Result
Else
SetDebugLog("AndroidShield, failed acquire mutex, caller: " & $sCaller, Default, True)
EndIf
Return False
EndFunc
Func _AndroidShield($sCaller, $Enable = Default, $CallWinGetAndroidHandle = True, $iDelay = 0, $AndroidHasFocus = Default, $AndroidUpdateFocus = True)
Local $bForceUpdate = False
If AndroidShieldActiveDelay() Then
If AndroidShieldActiveDelay(True) = False Then
If $Enable = Default Then $Enable = $g_avAndroidShieldDelay[2]
If $AndroidHasFocus = Default Then $AndroidHasFocus = $g_avAndroidShieldDelay[3]
Else
If $iDelay = 0 Then
If $Enable <> Default Then $g_avAndroidShieldDelay[2] = $Enable
If $AndroidHasFocus <> Default Then $g_avAndroidShieldDelay[3] = $AndroidHasFocus
Return False
EndIf
EndIf
EndIf
If $iDelay > 0 Then
$g_avAndroidShieldDelay[0] = TimerInit()
$g_avAndroidShieldDelay[1] = $iDelay
$g_avAndroidShieldDelay[2] = $Enable
$g_avAndroidShieldDelay[3] = $AndroidHasFocus
SetDebugLog("ShieldAndroid: Delayed update $iDelay=" & $iDelay & ", $Enable=" & $Enable & ", $AndroidHasFocus=" & $AndroidHasFocus & ", caller: " & $sCaller, Default, True)
Return False
EndIf
$g_avAndroidShieldDelay[0] = 0
$g_avAndroidShieldDelay[1] = 0
$g_avAndroidShieldDelay[2] = Default
$g_avAndroidShieldDelay[3] = Default
If $Enable = Default Then
$Enable = $g_bRunState And $g_bBotPaused = False
If $g_bAndroidShieldForceDown Then $Enable = False
EndIf
If $AndroidHasFocus = Default Then
$AndroidHasFocus = AndroidShieldHasFocus()
Else
If $AndroidUpdateFocus Then $g_hProcShieldInput[2] = $AndroidHasFocus
EndIf
Local $shieldState = "active"
Local $color = $g_iAndroidShieldColor
Local $trans = $g_iAndroidShieldTransparency
If $Enable = False Or $g_bBotPaused = True Then
If _WinAPI_GetActiveWindow() = $g_hFrmBot And $AndroidHasFocus Then
$shieldState = "disabled-focus"
$color = $g_iAndroidActiveColor
$trans = $g_iAndroidActiveTransparency
SetAccelerators(True)
Else
$shieldState = "disabled-nofocus"
$color = $g_iAndroidInactiveColor
$trans = $g_iAndroidInactiveTransparency
SetAccelerators(False)
EndIf
Else
SetAccelerators(False)
EndIf
Local $bNoVisibleShield = $g_bChkBackgroundMode = False
Local $bDetachedShield = $bNoVisibleShield = False And($g_bAndroidShieldPreWin8 = True Or $g_iAndroidEmbedMode = 1)
If $g_bAndroidEmbedded = False Then
Return False
EndIf
If $g_bAndroidBackgroundLaunched = True Then
Return False
EndIf
If $bForceUpdate = False And $g_avAndroidShieldStatus[0] = $Enable And $g_avAndroidShieldStatus[1] = $color And $g_avAndroidShieldStatus[2] = $trans And $g_avAndroidShieldStatus[3] = $bNoVisibleShield And $g_avAndroidShieldStatus[4] = $bDetachedShield Then
Return False
EndIf
If($CallWinGetAndroidHandle = False And $HWnD = 0) Or($CallWinGetAndroidHandle = True And WinGetAndroidHandle() = 0) Then
Return False
EndIf
Local $aPos = WinGetPos($HWnD)
If IsArray($aPos) = 0 Or @error <> 0 Then
Return False
EndIf
Local $hCtrlTarget = $g_aiAndroidEmbeddedCtrlTarget[0]
Local $aPosCtl = $g_aiAndroidEmbeddedCtrlTarget[6]
If $g_hFrmBotEmbeddedShield <> 0 And($g_avAndroidShieldStatus[3] <> $bNoVisibleShield Or $g_avAndroidShieldStatus[4] <> $bDetachedShield) Then
GUIDelete($g_hFrmBotEmbeddedShield)
$g_hFrmBotEmbeddedShield = 0
EndIf
$g_hProcShieldInput[3] = True
Local $show_shield = @SW_SHOWNOACTIVATE
If $Enable <> $g_avAndroidShieldStatus[0] Or $g_hFrmBotEmbeddedShield = 0 Then
If $Enable = True Then
SetDebugLog("Shield Android Control (" & $aPosCtl[2] & "x" & $aPosCtl[3] & ")", Default, True)
Else
SetDebugLog("Unshield Android Control", Default, True)
EndIf
If $bDetachedShield = False Then
If $g_hFrmBotEmbeddedShield = 0 Then
$g_hFrmBotEmbeddedShield = GUICreate("", $aPosCtl[2], $aPosCtl[3], 0, 0, BitOR($WS_CHILD, $WS_TABSTOP), BitOR($WS_EX_TOPMOST,($bNoVisibleShield ? $WS_EX_TRANSPARENT : 0)), $g_hFrmBot)
Else
WinMove($g_hFrmBotEmbeddedShield, "", 0, 0, $aPosCtl[2], $aPosCtl[3])
EndIf
WinMove2($hCtrlTarget, "", -1, -1, -1, -1, $HWND_BOTTOM)
Else
Local $bHasFocus = WinActive($g_hFrmBot) <> 0
Local $a = AndroidEmbed_HWnD_Position(True, $bDetachedShield)
If $g_hFrmBotEmbeddedShield = 0 Then
$g_hFrmBotEmbeddedShield = GUICreate("", $aPosCtl[2], $aPosCtl[3], $a[0], $a[1], BitOR($WS_POPUP, $WS_TABSTOP), BitOR($WS_EX_TOOLWINDOW, $WS_EX_NOACTIVATE, $WS_EX_TOPMOST, $WS_EX_TRANSPARENT), $g_hFrmBot)
_WinAPI_EnableWindow($g_hFrmBotEmbeddedShield, False)
$g_hFrmBotEmbeddedMouse = GUICreate("", $aPosCtl[2], $aPosCtl[3], 0, 0, BitOR($WS_CHILD, $WS_TABSTOP), BitOR($WS_EX_TOPMOST, $WS_EX_TRANSPARENT), $g_hFrmBot)
EndIf
WinMove2($g_hFrmBotEmbeddedShield, "", $a[0], $a[1], $aPosCtl[2], $aPosCtl[3],($bHasFocus ? $HWND_TOPMOST : $HWND_BOTTOM), 0, False)
WinMove2($g_hFrmBotEmbeddedMouse, "", 0, 0, $aPosCtl[2], $aPosCtl[3],($bHasFocus ? $HWND_TOPMOST : $HWND_BOTTOM), 0, False)
WinMove2($hCtrlTarget, "", -1, -1, -1, -1, $HWND_BOTTOM)
SetDebugLog("$g_hFrmBotEmbeddedShield Position: " & $a[0] & ", " & $a[1] & ", " & $aPosCtl[2] & ", " & $aPosCtl[3], Default, True)
EndIf
EndIf
If $bNoVisibleShield = False Then
WinSetTrans($g_hFrmBotEmbeddedShield, "", $trans)
GUISetBkColor($color, $g_hFrmBotEmbeddedShield)
EndIf
GUISetState($show_shield, $g_hFrmBotEmbeddedShield)
GUISetState($show_shield, $g_hFrmBotEmbeddedMouse)
$g_hProcShieldInput[3] = False
$g_avAndroidShieldStatus[0] = $Enable
$g_avAndroidShieldStatus[1] = $color
$g_avAndroidShieldStatus[2] = $trans
$g_avAndroidShieldStatus[3] = $bNoVisibleShield
$g_avAndroidShieldStatus[4] = $bDetachedShield
AndroidShieldStartup()
HandleWndProc($shieldState = "disabled-focus")
SetDebugLog("AndroidShield updated to " & $shieldState & "(handle=" & $g_hFrmBotEmbeddedShield & ", color=" & Hex($color, 6) & "), caller: " & $sCaller, Default, True)
Return True
EndFunc
Func AndroidGraphicsGdiBegin()
If $g_bAndroidEmbedded = False Then Return 0
AndroidGraphicsGdiEnd()
Local $wasDown = AndroidShieldForcedDown()
AndroidShieldForceDown(False)
AndroidShield("AndroidGraphicsGdiBegin", True, True, 0, False)
Local $iL = 0
Local $iT = 0
Local $iW = $g_iAndroidClientWidth
Local $iH = $g_iAndroidClientHeight
Local $iOpacity = 255
Local $aPosCtl = $g_aiAndroidEmbeddedCtrlTarget[6]
If IsArray($aPosCtl) = 1 Then
$iW = $aPosCtl[2]
$iH = $aPosCtl[3]
EndIf
Local $a = [0, 0]
If $g_hFrmBotEmbeddedGraphics = 0 Then
Local $bDetachedShield = $g_avAndroidShieldStatus[4]
If $bDetachedShield = True Then
Local $a = AndroidEmbed_HWnD_Position(True, $bDetachedShield)
$iL = $a[0]
$iT = $a[1]
EndIf
$g_hFrmBotEmbeddedGraphics = GUICreate("", $iW, $iH, $iL, $iT, $WS_CHILD, BitOR($WS_EX_TOOLWINDOW, $WS_EX_NOACTIVATE, $WS_EX_LAYERED, $WS_EX_TOPMOST), $g_hFrmBot)
EndIf
WinMove2($g_hFrmBotEmbeddedGraphics, "", $iW, $iH, $iL, $iT, $HWND_NOTOPMOST, 0, False)
GUISetState(@SW_SHOWNOACTIVATE, $g_hFrmBotEmbeddedGraphics)
Local $hDC = _WinAPI_GetDC($g_hFrmBotEmbeddedGraphics)
Local $hMDC = AndroidGraphicsGdiAddObject("hMDC", _WinAPI_CreateCompatibleDC($hDC))
Local $hBitmap = AndroidGraphicsGdiAddObject("hBitmap", _WinAPI_CreateCompatibleBitmap($hDC, $iW, $iH))
_WinAPI_SelectObject($hMDC, $hBitmap)
AndroidGraphicsGdiAddObject("hDC", $hDC)
Local $hGraphics = AndroidGraphicsGdiAddObject("Graphics", _GDIPlus_GraphicsCreateFromHDC($hMDC))
_GDIPlus_GraphicsSetSmoothingMode($hGraphics, $GDIP_SMOOTHINGMODE_HIGHQUALITY)
_GDIPlus_GraphicsClear($hGraphics)
Local $tSIZE = DllStructCreate($tagSIZE)
AndroidGraphicsGdiAddObject("DllStruct", $tSIZE)
Local $pSize = DllStructGetPtr($tSIZE)
DllStructSetData($tSIZE, "X", $iW)
DllStructSetData($tSIZE, "Y", $iH)
Local $tSource = DllStructCreate($tagPOINT)
AndroidGraphicsGdiAddObject("DllStruct", $tSource)
Local $pSource = DllStructGetPtr($tSource)
Local $tBlend = DllStructCreate($tagBLENDFUNCTION)
AndroidGraphicsGdiAddObject("DllStruct", $tBlend)
Local $pBlend = DllStructGetPtr($tBlend)
DllStructSetData($tBlend, "Alpha", $iOpacity)
DllStructSetData($tBlend, "Format", 1)
Local $tPoint = DllStructCreate($tagPOINT)
AndroidGraphicsGdiAddObject("DllStruct", $tPoint)
Local $pPoint = DllStructGetPtr($tPoint)
DllStructSetData($tPoint, "X", $a[0])
DllStructSetData($tPoint, "Y", $a[1])
AndroidGraphicsGdiUpdate()
SetDebugLog("AndroidGraphicsGdiBegin: Graphics " & $hGraphics)
AndroidShieldForceDown($wasDown)
Return $hGraphics
EndFunc
Func AndroidGraphicsGdiUpdate()
If $g_bAndroidEmbedded = False Then Return 0
Local $hMDC = $g_aiAndroidEmbeddedGraphics[0][1]
Local $hDC = $g_aiAndroidEmbeddedGraphics[2][1]
Local $pSize = DllStructGetPtr($g_aiAndroidEmbeddedGraphics[4][1])
Local $pSource = DllStructGetPtr($g_aiAndroidEmbeddedGraphics[5][1])
Local $pBlend = DllStructGetPtr($g_aiAndroidEmbeddedGraphics[6][1])
Local $pPoint = DllStructGetPtr($g_aiAndroidEmbeddedGraphics[7][1])
Local $tPoint = DllStructCreate($tagPOINT, $pPoint)
Local $bDetachedShield = $g_avAndroidShieldStatus[4]
Local $a = AndroidEmbed_HWnD_Position(True, $bDetachedShield)
DllStructSetData($tPoint, "X", $a[0])
DllStructSetData($tPoint, "Y", $a[1])
_WinAPI_UpdateLayeredWindow($g_hFrmBotEmbeddedGraphics, $hDC, $pPoint, $pSize, $hMDC, $pSource, 0, $pBlend, $ULW_ALPHA)
EndFunc
Func AndroidGraphicsGdiAddObject($sType, $hHandle)
If $g_bAndroidEmbedded = False Then Return 0
Local $i = UBound($g_aiAndroidEmbeddedGraphics)
ReDim $g_aiAndroidEmbeddedGraphics[$i + 1][2]
$g_aiAndroidEmbeddedGraphics[$i][0] = $sType
$g_aiAndroidEmbeddedGraphics[$i][1] = $hHandle
SetDebugLog("AndroidGraphicsGdiAddObject: " & $sType & " " & $hHandle)
Return $hHandle
EndFunc
Func AndroidGraphicsGdiEnd($Result = Default, $bClear = True)
If UBound($g_aiAndroidEmbeddedGraphics) > 0 Then
Local $i
For $i = UBound($g_aiAndroidEmbeddedGraphics) - 1 To 0 Step -1
Local $sType = $g_aiAndroidEmbeddedGraphics[$i][0]
Local $hHandle = $g_aiAndroidEmbeddedGraphics[$i][1]
If $hHandle <> 0 Then
SetDebugLog("AndroidGraphicsGdiEnd: Dispose/release/delete " & $sType & " " & $hHandle)
Switch $sType
Case "Pen"
_GDIPlus_PenDispose($hHandle)
Case "DllStruct"
Case "Graphics"
_GDIPlus_GraphicsClear($hHandle)
AndroidGraphicsGdiUpdate()
_GDIPlus_GraphicsDispose($hHandle)
Case "hDC"
_WinAPI_ReleaseDC($g_hFrmBotEmbeddedGraphics, $hHandle)
Case "hBitmap"
_WinAPI_DeleteObject($hHandle)
Case "hMDC"
_WinAPI_DeleteDC($hHandle)
Case Else
SetDebugLog("Unknown GDI Type: " & $sType)
EndSwitch
EndIf
Next
ReDim $g_aiAndroidEmbeddedGraphics[0][2]
If $g_hFrmBotEmbeddedGraphics <> 0 Then
GUIDelete($g_hFrmBotEmbeddedGraphics)
$g_hFrmBotEmbeddedGraphics = 0
EndIf
EndIf
Return $Result
EndFunc
Func WerFaultClose($programFile, $tryCountMax = 10, $tryCount = 0)
Local $WinTitleMatchMode = Opt("WinTitleMatchMode", -3)
Local $title = $programFile
Local $iLastBS = StringInStr($title, "\", 0, -1)
If $iLastBS > 0 Then $title = StringMid($title, $iLastBS + 1)
Local $aList = WinList($title)
Opt("WinTitleMatchMode", $WinTitleMatchMode)
Local $closed = 0
Local $i
SetDebugLog("Found " & $aList[0][0] & " WerFault Windows with title '" & $title & "'")
If $aList[0][0] > 0 Then
For $i = 1 To $aList[0][0]
Local $HWnD = $aList[$i][1]
Local $pid = WinGetProcess($HWnD)
Local $process = ProcessGetWmiProcess($pid)
If IsObj($process) Then
Local $werfault = $process.ExecutablePath
$iLastBS = StringInStr($werfault, "\", 0, -1)
$werfault = StringMid($werfault, $iLastBS + 1)
If $werfault = "WerFault.exe" Then
SetDebugLog("Found WerFault Process " & $pid)
If WinClose($HWnD) Then
SetDebugLog("Closed " & $werfault & " Window " & $HWnD)
$closed += 1
Else
If WinKill($HWnD) Then
SetDebugLog("Killed " & $werfault & " Window " & $HWnD)
$closed += 1
Else
SetDebugLog("Cannot close " & $werfault & " Window " & $HWnD, $COLOR_ERROR)
EndIf
EndIf
Else
SetDebugLog("Process " & $pid & " is not WerFault, " & $process.CommandLine, $COLOR_ERROR)
EndIf
ELse
SetDebugLog("Wmi Object for process " & $pid & " not found")
EndIF
Next
ElseIf FileExists($programFile) = 1 Then
Local $pFileVersionInfo
If _WinAPI_GetFileVersionInfo($programFile, $pFileVersionInfo) Then
Local $FileDescription = _WinAPI_VerQueryValue($pFileVersionInfo, $FV_FILEDESCRIPTION)
If $FileDescription <> "" Then Return WerFaultClose($FileDescription, $tryCountMax, $tryCount)
EndIf
EndIf
If $closed > 0 And $tryCount < $tryCountMax Then
If _Sleep(1000) = False Then
$closed += WerFaultClose($programFile, $tryCountMax, $tryCount + 1)
EndIF
EndIf
Return $closed
EndFunc
Func _NumberFormat($Number, $NullToZero = False)
If $Number = "" Then
If $NullToZero = False Then
Return ""
Else
Return "0"
EndIf
EndIf
If StringLeft($Number, 1) = "-" Then
Return "- " & StringRegExpReplace(StringTrimLeft($Number, 1), "(\A\d{1,3}(?=(\d{3})+\z)|\d{3}(?=\d))", "\1 ")
Else
Return StringRegExpReplace($Number, "(\A\d{1,3}(?=(\d{3})+\z)|\d{3}(?=\d))", "\1 ")
EndIf
EndFunc
Func _PadStringCenter($String = "", $Width = 50, $PadChar = "=")
If $String = "" Then Return ""
Local $Odd = Mod(($Width - StringLen($String)), 2)
Local $Count =($Width - StringLen($String)) / 2
Local $Pad = ""
For $i = 0 To $Count - 1
$Pad &= $PadChar
Next
Local $Out = ""
If $Odd Then
$Out = $Pad & $String & $Pad & $PadChar
Else
$Out = $Pad & $String & $Pad
EndIf
Return $Out
EndFunc
Func _ReduceMemory($PID)
Local $dll = DllOpen("kernel32.dll")
Local $ai_Handle = DllCall($dll, 'int', 'OpenProcess', 'int', 0x1f0fff, 'int', False, 'int', $PID)
Local $ai_Return = DllCall("psapi.dll", 'int', 'EmptyWorkingSet', 'long', $ai_Handle[0])
DllCall($dll, 'int', 'CloseHandle', 'int', $ai_Handle[0])
DllClose($dll)
Return $ai_Return[0]
EndFunc
Func _ProcessSuspendResume($iPIDorName, $iSuspend = True)
If IsString($iPIDorName) Then $iPIDorName = ProcessExists($iPIDorName)
If Not $iPIDorName Then Return SetError(2, 0, 0)
Local $ai_Handle = _WinAPI_OpenProcess( $PROCESS_ALL_ACCESS, False, $iPIDorName )
Local $i_sucess = DllCall("ntdll.dll","int","Nt" &($iSuspend ? "Suspend" : "Resume") & "Process","int",$ai_Handle)
_WinAPI_CloseHandle($ai_Handle)
If IsArray($i_sucess) Then Return 1
Return SetError(1, 0, 0)
EndFunc
Func _ProcessSuspendResume2($iPIDorName, $iSuspend = True)
If IsString($iPIDorName) Then $iPIDorName = ProcessExists($iPIDorName)
If Not $iPIDorName Then Return SetError(2, 0, 0)
If $iSuspend Then
DllCall('kernel32.dll', 'ptr', 'DebugActiveProcess', 'int', $iPIDorName)
DllCall('kernel32.dll', 'ptr', 'DebugSetProcessKillOnExit', 'int', False)
Else
DllCall('kernel32.dll', 'ptr', 'DebugActiveProcessStop', 'int', $iPIDorName)
EndIf
EndFunc
Func _Sleep($iDelay, $iSleep = True, $CheckRunState = True, $SleepWhenPaused = True)
Static $hTimer_SetTime = 0
Static $hTimer_PBRemoteControlInterval = 0
Static $hTimer_PBDeleteOldPushesInterval = 0
Static $hTimer_EmptyWorkingSetAndroid = 0
Static $hTimer_EmptyWorkingSetBot = 0
Local $iBegin = TimerInit()
debugGdiHandle("_Sleep")
If SetCriticalMessageProcessing() = False Then
If $g_bMoveDivider Then
MoveDivider()
$g_bMoveDivider = False
EndIf
If $iDelay > 0 And TimerDiff($g_hTxtLogTimer) >= $g_iTxtLogTimerTimeout Then
If $g_bNotifyDeleteAllPushesNow = True Then PushMsg("DeleteAllPBMessages")
If TimerDiff($hTimer_PBRemoteControlInterval) >= $g_iPBRemoteControlInterval Then
PushBulletRemoteControl()
$hTimer_PBRemoteControlInterval = TimerInit()
EndIf
If TimerDiff($hTimer_PBDeleteOldPushesInterval) >= $g_iPBDeleteOldPushesInterval Then
PushBulletDeleteOldPushes()
$hTimer_PBDeleteOldPushesInterval = TimerInit()
EndIf
If $g_bRunState And TestCapture() = False And TimerDiff($hTimer_EmptyWorkingSetAndroid) >= $g_iEmptyWorkingSetAndroid Then
If IsArray(getAndroidPos(True)) = 1 Then _WinAPI_EmptyWorkingSet(GetAndroidPid())
$hTimer_EmptyWorkingSetAndroid = TimerInit()
EndIf
If TimerDiff($hTimer_EmptyWorkingSetBot) >= $g_iEmptyWorkingSetBot Then
ReduceBotMemory()
$hTimer_EmptyWorkingSetBot = TimerInit()
EndIF
CheckPostponedLog()
EndIf
EndIf
If $CheckRunState = True And $g_bRunState = False Then
ResumeAndroid()
Return True
EndIf
Local $iRemaining = $iDelay - TimerDiff($iBegin)
While $iRemaining > 0
DllCall($g_hLibNTDLL, "dword", "ZwYieldExecution")
If $CheckRunState = True And $g_bRunState = False Then
ResumeAndroid()
Return True
EndIf
If SetCriticalMessageProcessing() = False Then
If $g_bBotPaused And $SleepWhenPaused And $g_bTogglePauseAllowed Then TogglePauseSleep()
If $g_bTogglePauseUpdateState Then TogglePauseUpdateState("_Sleep")
If $g_bMakeScreenshotNow = True Then
If $iScreenshotType = 0 Then
MakeScreenshot($g_sProfileTempPath, "jpg")
Else
MakeScreenshot($g_sProfileTempPath, "png")
EndIf
EndIf
If TimerDiff($g_hTxtLogTimer) >= $g_iTxtLogTimerTimeout Then
If $g_bRunState And Not $bSearchMode And Not $g_bBotPaused And($hTimer_SetTime = 0 Or TimerDiff($hTimer_SetTime) >= 750) Then
SetTime()
$hTimer_SetTime = TimerInit()
EndIf
AndroidEmbedCheck()
AndroidShieldCheck()
CheckPostponedLog()
EndIf
EndIf
$iRemaining = $iDelay - TimerDiff($iBegin)
If $iRemaining >= $iDelaySleep Then
_SleepMilli($iDelaySleep)
Else
_SleepMilli($iRemaining)
EndIf
WEnd
Return False
EndFunc
Func _SleepMicro($iMicroSec)
DllStructSetData($hStruct_SleepMicro, "time", $iMicroSec * -10)
DllCall($g_hLibNTDLL, "dword", "ZwDelayExecution", "int", 0, "ptr", $pStruct_SleepMicro)
EndFunc
Func _SleepMilli($iMilliSec)
_SleepMicro(Int($iMilliSec * 1000))
EndFunc
Func _SleepStatus($iDelay, $iSleep = True, $bDirection = True, $CheckRunState = True)
Local $iDay = 0, $iHour = 0, $iMin = 0, $iSec = 0
Local $iBegin, $iCurTime, $iTime
Local $bUpdate = True, $hLastUpdate
Local $iDayCalc = 0, $iHourCalc = 0, $iMinCalc = 0, $iSecCalc = 0
Local $sTimeWait, $sTimeLeftLapse = ",  Time Lapse = "
$iBegin = TimerInit()
_TicksToDay($iDelay, $iDay, $iHour, $iMin, $iSec)
While TimerDiff($iBegin) < $iDelay
If $g_bRunState = False And $CheckRunState = True Then Return True
If $bUpdate Then
$iCurTime = TimerDiff($iBegin)
$iTime = $iCurTime
If $bDirection = True Then
$iTime = $iDelay - $iCurTime
$sTimeLeftLapse = ",  Time Left = "
EndIf
_TicksToDay($iTime, $iDayCalc, $iHourCalc, $iMinCalc, $iSecCalc)
$sTimeWait = "Waiting Time = "
Select
Case $iDay > 0
$sTimeWait &= StringFormat("%2u Day(s) ", $iDay)
$sTimeLeftLapse &= StringFormat("%2u Day(s) ", $iDayCalc)
ContinueCase
Case $iHour > 0
$sTimeWait &= StringFormat("%02u:", $iHour)
$sTimeLeftLapse &= StringFormat("%02u:", $iHourCalc)
ContinueCase
Case Else
$sTimeWait &= StringFormat("%02u:%02u", $iMin, $iSec)
$sTimeLeftLapse &= StringFormat("%02u:%02u", $iMinCalc, $iSecCalc)
EndSelect
$hLastUpdate = TimerInit()
_GUICtrlStatusBar_SetText($g_hStatusBar, " Status: " & $sTimeWait & $sTimeLeftLapse)
EndIf
_Sleep($iDelaySleep)
$bUpdate = TimerDiff($hLastUpdate) > 750
WEnd
If $g_bRunState = False And $CheckRunState = True Then Return True
Return False
EndFunc
Func _StatusUpdateTime($hTimer, $sWhyWait = "")
Local $iCurTime = TimerDiff($hTimer)
Local $iMinCalc = Int($iCurTime /(60 * 1000))
Local $iSecCalc = Int(($iCurTime -($iMinCalc * 60 * 1000)) / 1000)
Local $sString = $sWhyWait & " Wait Time = " & StringFormat("%02u" & ":" & "%02u", $iMinCalc, $iSecCalc)
_GUICtrlStatusBar_SetText($g_hStatusBar, " Status: " & $sString)
EndFunc
Func _TicksToDay($iTicks, ByRef $iDays, ByRef $iHours, ByRef $iMins, ByRef $iSecs)
_TicksToTime($iTicks, $iHours, $iMins, $iSecs)
If @error Then Return SetError(1, 0, 0)
$iDays = int($iHours/24)
$iHours = Mod($iHours,24)
Return 1
EndFunc
Global Const $MAPVK_VK_TO_CHAR = 2
Func _WinAPI_GetActiveWindow()
Local $aRet = DllCall('user32.dll', 'hwnd', 'GetActiveWindow')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetVersion()
Return BitAND(BitShift($__WINVER, 8), 0xFF) & '.' & BitAND($__WINVER, 0xFF)
EndFunc
Func _WinAPI_IsIconic($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'IsIconic', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_MapVirtualKey($iCode, $iType, $hLocale = 0)
Local $aRet = DllCall('user32.dll', 'INT', 'MapVirtualKeyExW', 'uint', $iCode, 'uint', $iType, 'uint_ptr', $hLocale)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetActiveWindow($hWnd)
Local $aRet = DllCall('user32.dll', 'int', 'SetActiveWindow', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func __EnumDefaultProc($pData, $lParam)
#forceref $lParam
Local $iLength = _WinAPI_StrLen($pData)
__Inc($__g_vEnum)
If $iLength Then
$__g_vEnum[$__g_vEnum[0]] = DllStructGetData(DllStructCreate('wchar[' &($iLength + 1) & ']', $pData), 1)
Else
$__g_vEnum[$__g_vEnum[0]] = ''
EndIf
Return 1
EndFunc
Func __EnumPageFilesProc($iSize, $pInfo, $pFile)
Local $tEPFI = DllStructCreate('dword;dword;ulong_ptr;ulong_ptr;ulong_ptr', $pInfo)
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0][0]][0] = DllStructGetData(DllStructCreate('wchar[' &(_WinAPI_StrLen($pFile) + 1) & ']', $pFile), 1)
For $i = 1 To 3
$__g_vEnum[$__g_vEnum[0][0]][$i] = DllStructGetData($tEPFI, $i + 2) * $iSize
Next
Return 1
EndFunc
Func FClick($x, $y, $times = 1, $speed = 0, $debugtxt = "")
If $g_iDebugClick = 1 Or TestCapture() Then
Local $txt = _DecodeDebug($debugtxt)
SetLog("Click " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_ACTION, "Verdana", "7.5", 0)
EndIf
If TestCapture() Then Return
If $g_bAndroidAdbClick = True Then
AndroidClick($x, $y, $times, $speed)
EndIf
If $g_bAndroidAdbClick = True Then
Return
EndIf
Local $SuspendMode = ResumeAndroid()
If $times <> 1 Then
For $i = 0 To($times - 1)
If isProblemAffectBeforeClick($i) Then
If $g_iDebugClick = 1 Then Setlog("VOIDED Click " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_ERROR, "Verdana", "7.5", 0)
checkMainScreen(False)
SuspendAndroid($SuspendMode)
Return
EndIf
MoveMouseOutBS()
_ControlClick($x, $y)
If _Sleep($speed, False) Then ExitLoop
Next
Else
If isProblemAffectBeforeClick() Then
If $g_iDebugClick = 1 Then Setlog("VOIDED Click " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_ERROR, "Verdana", "7.5", 0)
checkMainScreen(False)
SuspendAndroid($SuspendMode)
Return
EndIf
MoveMouseOutBS()
_ControlClick($x, $y)
EndIf
SuspendAndroid($SuspendMode)
EndFunc
Func _ControlClick($x, $y)
Local $useHWnD = $g_iAndroidControlClickWindow = 1 And $g_bAndroidEmbedded = False
Local $hWin =(($useHWnD) ?($HWnD) :($HWnDCtrl))
$x = Int($x)
$y = Int($y)
If $hWin = $HWnD Then
$x += $g_aiBSrpos[0]
$y += $g_aiBSrpos[1]
EndIf
If $g_iAndroidControlClickMode = 0 Then
Return ControlClick($hWin, "", "", "left", "1", $x, $y)
EndIf
Local $WM_LBUTTONDOWN = 0x0201, $WM_LBUTTONUP = 0x0202
Local $lParam = BitOR(Int($y) * 0x10000, BitAND(Int($x), 0xFFFF))
_SendMessage($hWin, $WM_LBUTTONDOWN, 0x0001, $lParam)
_SendMessage($hWin, $WM_LBUTTONUP, 0x0000, $lParam)
_SleepMicro(25000)
Return 1
EndFunc
Func isProblemAffectBeforeClick($iCount = 0)
If NeedCaptureRegion($iCount) = True Then Return isProblemAffect(True)
Return False
EndFunc
Func ClickP($point, $howMuch = 1, $speed = 0, $debugtxt = "")
Click($point[0], $point[1], $howMuch, $speed, $debugtxt)
EndFunc
Func BuildingClick($x, $y, $debugtxt = "")
Local $point[2] = [$x, $y]
ConvertToVillagePos($x, $y)
If $g_iDebugClick = 1 Then
Local $txt = _DecodeDebug($debugtxt)
SetLog("BuildingClick " & $point[0] & "," & $point[1] & " converted to " & $x & "," & $y & " " & $debugtxt & $txt, $COLOR_ACTION)
EndIf
Return Click($x, $y, 1, 0, $debugtxt)
EndFunc
Func BuildingClickP($point, $debugtxt = "")
Local $x = $point[0]
Local $y = $point[1]
Return BuildingClick($x, $y, $debugtxt)
EndFunc
Func FPureClick($x, $y, $times = 1, $speed = 0, $debugtxt = "")
If $g_iDebugClick = 1 Then
Local $txt = _DecodeDebug($debugtxt)
SetLog("PureClick " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_ACTION, "Verdana", "7.5", 0)
EndIf
If TestCapture() Then Return
If $g_bAndroidAdbClick = True Then
AndroidClick($x, $y, $times, $speed, False)
EndIf
If $g_bAndroidAdbClick = True Then
Return
EndIf
Local $SuspendMode = ResumeAndroid()
If $times <> 1 Then
For $i = 0 To($times - 1)
MoveMouseOutBS()
_ControlClick($x, $y)
If _Sleep($speed, False) Then ExitLoop
Next
Else
MoveMouseOutBS()
_ControlClick($x, $y)
EndIf
SuspendAndroid($SuspendMode)
EndFunc
Func PureClickP($point, $howMuch = 1, $speed = 0, $debugtxt = "")
PureClick($point[0], $point[1], $howMuch, $speed, $debugtxt)
EndFunc
Func FGemClick($x, $y, $times = 1, $speed = 0, $debugtxt = "")
If $g_iDebugClick = 1 Then
Local $txt = _DecodeDebug($debugtxt)
SetLog("GemClick " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_ACTION, "Verdana", "7.5", 0)
EndIf
If TestCapture() Then Return
If $g_bAndroidAdbClick = True Then
If isGemOpen(True) Then
Return False
EndIf
AndroidClick($x, $y, $times, $speed)
EndIf
If $g_bAndroidAdbClick = True Then
Return
EndIf
Local $SuspendMode = ResumeAndroid()
Local $i
If $times <> 1 Then
For $i = 0 To($times - 1)
If isGemOpen(True) Then
SuspendAndroid($SuspendMode)
Return False
EndIf
If isProblemAffectBeforeClick($i) Then
If $g_iDebugClick = 1 Then Setlog("VOIDED GemClick " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_ERROR, "Verdana", "7.5", 0)
checkMainScreen(False)
SuspendAndroid($SuspendMode)
Return
EndIf
MoveMouseOutBS()
_ControlClick($x, $y)
If isGemOpen(True) Then
SuspendAndroid($SuspendMode)
Return False
EndIf
If _Sleep($speed, False) Then ExitLoop
Next
Else
If isGemOpen(True) Then
SuspendAndroid($SuspendMode)
Return False
EndIf
If isProblemAffectBeforeClick() Then
If $g_iDebugClick = 1 Then Setlog("VOIDED GemClick " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_ERROR, "Verdana", "7.5", 0)
checkMainScreen(False)
SuspendAndroid($SuspendMode)
Return
EndIf
MoveMouseOutBS()
_ControlClick($x, $y)
If isGemOpen(True) Then
SuspendAndroid($SuspendMode)
Return False
EndIf
EndIf
SuspendAndroid($SuspendMode)
EndFunc
Func GemClickP($point, $howMuch = 1, $speed = 0, $debugtxt = "")
Return GemClick($point[0], $point[1], $howMuch, $speed, $debugtxt = "")
EndFunc
Func AttackClick($x, $y, $times = 1, $speed = 0, $afterDelay = 0, $debugtxt = "")
Local $timer = TimerInit()
Local $result = PureClick($x, $y, $times, $speed, $debugtxt)
Local $delay = $times * $speed + $afterDelay - TimerDiff($timer)
If IsKeepClicksActive() = False And $delay > 0 Then _Sleep($delay, False)
Return $result
EndFunc
Func _DecodeDebug($message)
Local $separator = " | "
Switch $message
Case "#0112", "#0115", "#0140", "#0141", "#0142", "#0143", "#0199", "#0328", "#0201", "#0204", "#0205", "#0206", "#0327", "#0207", "#0208", "#0209", "#0210", "#0211"
Return $separator & "Away"
Case "#0214", "#0215", "#0216", "#0217", "#0218", "#0219", "#0220", "#0221", "#0235", "#0242", "#0268", "#0291", "#0292", "#0295", "#0298", "#0300", "#0301", "#0302"
Return $separator & "Away"
Case "#0303", "#0306", "#0308", "#0309", "#0310", "#0311", "#0312", "#0319", "#0333", "#0257", "#0139", "#0125", "#0251", "#0335", "#0313", "#0314", "#0332", "#0329"
Return $separator & "Away"
Case "#0121", "#0124", "#0133", "#0157", "#0161", "#0165", "#0166", "#0167", "#0170", "#0171", "#0176", "#0224", "#0234", "#0265", "#0346", "#0348", "#0350", "#0351"
Return $separator & "Away"
Case "#0352", "#0353", "#0354", "#0355", "#0356", "#0357", "#0358", "#0359", "#0360", "#0361", "#0362", "#0363", "#0364", "#0365", "#0366", "#0367", "#0368", "#0369"
Return $separator & "Away"
Case "#0370", "#0371", "#0373", "#0374", "#0375", "#0376", "#0377", "#0378", "#0379", "#0380", "#0381", "#0382", "#0383", "#0384", "#0385", "#0386", "#0387", "#0388"
Return $separator & "Away"
Case "#0389", "#0390", "#0391", "#0392", "#0393", "#0394", "#0395", "#0501", "#0502", "#0503", "#0504", "#0467", "#0505", "#0931", "#0932", "#0933"
Return $separator & "Away"
Case "#0001"
Return $separator & "AtkTH - Select Barbarian"
Case "#0002", "#0006"
Return $separator & "AtkTH - Barbarian Bottom Left"
Case "#0003", "#0007"
Return $separator & "AtkTH - Barbarian Bottom Right"
Case "#0004", "#0008"
Return $separator & "AtkTH - Barbarian Top Right"
Case "#0005", "#0009"
Return $separator & "AtkTH - Barbarian Top Left"
Case "#0010"
Return $separator & "AtkTH - Select Archer"
Case "#0011", "#0015"
Return $separator & "AtkTH - Arcer Bottom Left"
Case "#0012", "#0016"
Return $separator & "AtkTH - Arcer Bottom Right"
Case "#0013", "#0017"
Return $separator & "AtkTH - Arcer Top Right"
Case "#0014", "#0018"
Return $separator & "AtkTH - Arcer Top Left"
Case "#0155"
Return $separator & "Attack - Next Button"
Case "#0331"
Return $separator & "Collect resources"
Case "#0330"
Return $separator & "Collect resources*"
Case "#0432"
Return $separator & "Clean tombs*"
Case "#0431"
Return $separator & "Clean yard"
Case "#0430"
Return $separator & "Clean yard*"
Case "#0266"
Return $separator & "Train - TrainIT Selected Troop"
Case "#0269"
Return $separator & "Train - Open Barrack"
Case "#0270"
Return $separator & "Train - Train Troops button"
Case "#0271"
Return $separator & "Train - Next Button "
Case "#0272", "#0286", "#0289", "#0325"
Return $separator & "Train - Prev Button "
Case "#0273", "#0284", "#0285", "#0287", "#0288"
Return $separator & "Train - Remove Troops"
Case "#0274"
Return $separator & "Train - Train Barbarian"
Case "#0275"
Return $separator & "Train - Train Archer"
Case "#0276"
Return $separator & "Train - Train Giant"
Case "#0277"
Return $separator & "Train - Train Goblin"
Case "#0278"
Return $separator & "Train - Train Wall Breaker"
Case "#0279"
Return $separator & "Train - Train Balloon"
Case "#0280"
Return $separator & "Train - Train Wizard"
Case "#0281"
Return $separator & "Train - Train Healer"
Case "#0282"
Return $separator & "Train - Train Dragon"
Case "#0283"
Return $separator & "Train - Train P.E.K.K.A."
Case "#0290"
Return $separator & "Train - GemClick Spell"
Case "#0293"
Return $separator & "Train - Click Army Camp"
Case "#0294"
Return $separator & "Train - Open Info Army Camp"
Case "#0336"
Return $separator & "Train - Go to first barrack"
Case "#0337"
Return $separator & "Train - Click Prev Button*"
Case "#0338"
Return $separator & "Train - Click Next Button*"
Case "#0339"
Return $separator & "Train - Select Prev Barrack/SP"
Case "#0340"
Return $separator & "Train - Click Next Barrack/SP"
Case "#0341"
Return $separator & "Train - Train Bowler"
Case "#0342"
Return $separator & "Train - Train Baby Dragon"
Case "#0343"
Return $separator & "Train - Train Miner"
Case "#0168"
Return $separator & "Donate - Open Chat"
Case "#0169"
Return $separator & "Donate - Select Clan Tab"
Case "#0172"
Return $separator & "Donate - Scroll"
Case "#0173"
Return $separator & "Donate - Click Chat"
Case "#0174"
Return $separator & "Donate - Click Donate Button"
Case "#0175"
Return $separator & "Donate - Donate Selected Troop first row"
Case "#0600"
Return $separator & "Donate - Donate Selected Troop second row"
Case "#0601"
Return $separator & "Donate - Donate Selected Troop spell"
Case "#0144"
Return $separator & "ChkLang - Config Button"
Case "#0145", "#0146", "#0147", "#0148"
Return $separator & "ChkLang - Close Page"
Case "#0222"
Return $separator & "Profile - Profile Button"
Case "#0223"
Return $separator & "Profile - Close Page"
Case "#0225"
Return $separator & "Rearm - Click Town Hall"
Case "#0326", "#0228"
Return $separator & "Rearm - Click Rearm Button"
Case "#0226", "#0229"
Return $separator & "Rearm - Click Rearm"
Case "#0227", "#0230", "#0233"
Return $separator & "Rearm - Close Gem Spend Window"
Case "#0231"
Return $separator & "Rearm - Click Inferno Button"
Case "#0232"
Return $separator & "Rearm - Inferno Button"
Case "#0250"
Return $separator & "Request - Click Castle Clan"
Case "#0253"
Return $separator & "Request - Click Request Button"
Case "#0254", "#0255"
Return $separator & "Request - Click Select Text For Request"
Case "#0256"
Return $separator & "Request - Click Send Request"
Case "#0334"
Return $separator & "Request - Click Train Button"
Case "#0099"
Return $separator & "Return Home - End Battle"
Case "#0100"
Return $separator & "Return Home - Surrender, Confirm"
Case "#0101"
Return $separator & "Return Home - Return Home Button"
Case "#0396"
Return $separator & "Reach Limit - Return home, Press End Battle "
Case "#0468"
Return $separator & "Clan Level - Open Chat"
Case "#0469"
Return $separator & "Clan Level - Open Chat Clan Tab "
Case "#0470"
Return $separator & "Clan Level - Click Info Clan Button"
Case "#071", "#0472"
Return $separator & "Clan Level - Close Chat"
Case "#0473"
Return $separator & "Clan Level - Close Clan Info Page"
Case "#0149"
Return $separator & "Prepare Search - Press Attack Button"
Case "#0150"
Return $separator & "Prepare Search - Press Find a Match Button"
Case "#0030"
Return $separator & "Attack - press surrender"
Case "#0031"
Return $separator & "Attack - press confirm surrender"
Case "#0510"
Return $separator & "Attack Search - Open chat tab"
Case "#0511"
Return $separator & "Attack Search - close chat tab"
Case "#0512"
Return $separator & "Attack Search - Press retry search button"
Case "#0513"
Return $separator & "Attack Search - Return Home button"
Case "#0000"
Return $separator & " "
Case Else
Return ""
EndSwitch
EndFunc
Func SendText($sText)
Local $Result = 1
Local $error = 0
If $g_bAndroidAdbInput = True Then
AndroidSendText($sText)
$error = @error
EndIf
If $g_bAndroidAdbInput = False Or $error <> 0 Then
Local $SuspendMode = ResumeAndroid()
Local $ascText = ""
Local $r, $i, $vk, $shiftBits, $char
Local $c = 0
For $i = 1 To StringLen($sText)
$char = StringMid($sText, $i, 1)
$vk = _VkKeyScan($char)
$shiftBits = @extended
If $vk = -1 And $shiftBits = -1 Then
SetDebugLog("SendText cannot send character: " & $char)
$c += 1
Else
If BitAND($shiftBits, 1) > 0 Then $ascText &= "{LSHIFT down}"
If BitAND($shiftBits, 2) > 0 Then $ascText &= "{LCTRL down}"
If BitAND($shiftBits, 4) > 0 Then $ascText &= "{LALT down}"
$ascText &= "{ASC " & _WinAPI_MapVirtualKey($vk, $MAPVK_VK_TO_CHAR) & "}"
If BitAND($shiftBits, 4) > 0 Then $ascText &= "{LALT up}"
If BitAND($shiftBits, 2) > 0 Then $ascText &= "{LCTRL up}"
If BitAND($shiftBits, 1) > 0 Then $ascText &= "{LSHIFT up}"
$r = ControlSend($HWnD, "", "", $ascText, 0)
$ascText = ""
If $r = 1 Then
$c += 1
EndIf
EndIf
Next
$Result = 0
If $c = StringLen($sText) Then $Result = 1
SuspendAndroid($SuspendMode)
EndIf
Return $Result
EndFunc
Func _VkKeyScan($s_Char)
Local $a_Ret = DllCall("user32.dll", "short", "VkKeyScanW", "ushort", AscW($s_Char))
If @error Then Return SetError(@error, @extended, -1)
Return SetExtended(BitShift($a_Ret[0], 8), BitAnd($a_Ret[0], 0xFF))
EndFunc
Func ClickOkay($FeatureName = "Okay", $bCheckOneTime = False)
Local $i = 0
If _Sleep($iSpecialClick1) Then Return False
While 1
Local $offColors[3][3] = [[0x000000, 144, 0], [0xFFFFFF, 54, 17], [0xCBE870, 54, 10]]
Global $ButtonPixel = _MultiPixelSearch(438, 372 + $g_iMidOffsetY, 590, 404 + $g_iMidOffsetY, 1, 1, Hex(0x000000, 6), $offColors, 20)
If $g_iDebugSetlog = 1 Then Setlog($FeatureName & " btn chk-#1: " & _GetPixelColor(441, 374 + $g_iMidOffsetY, True) & ", #2: " & _GetPixelColor(441 + 144, 374 + $g_iMidOffsetY, True) & ", #3: " & _GetPixelColor(441 + 54, 374 + 17 + $g_iMidOffsetY, True) & ", #4: " & _GetPixelColor(441 + 54, 374 + 10 + $g_iMidOffsetY, True), $COLOR_DEBUG)
If IsArray($ButtonPixel) Then
If $g_iDebugSetlog = 1 Then
Setlog("ButtonPixelLocation = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("Pixel color found #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 144, $ButtonPixel[1], True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 54, $ButtonPixel[1] + 17, True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 54, $ButtonPixel[1] + 10, True), $COLOR_DEBUG)
EndIf
PureClick($ButtonPixel[0] + 75, $ButtonPixel[1] + 25, 2, 50, "#0117")
ExitLoop
EndIf
If $bCheckOneTime = True Then Return False
If $i > 5 Then
Setlog("Can not find button for " & $FeatureName & ", giving up", $COLOR_ERROR)
If $g_iDebugImageSave = 1 Then DebugImageSave($FeatureName & "_ButtonCheck_")
SetError(1, @extended, False)
Return
EndIf
$i += 1
If _Sleep($iSpecialClick2) Then Return False
WEnd
Return True
EndFunc
Func ClickRemove($FeatureName = "Remove")
If _CheckPixel($aIsShieldInfo, $g_bCapturePixel) Then
Local $i = 0
While 1
Local $offColors[3][3] = [[0x111111, 109, 0], [0xFFFFFF, 65, 10], [0xC00000, 55, 20]]
Global $ButtonPixel = _MultiPixelSearch(472, 251, 588, 278, 1, 1, Hex(0x090908, 6), $offColors, 20)
If $g_iDebugSetlog = 1 Then Setlog($FeatureName & " btn chk-#1: " & _GetPixelColor(475, 255, True) & ", #2: " & _GetPixelColor(475 + 109, 255, True) & ", #3: " & _GetPixelColor(475 + 65, 255 + 10, True) & ", #4: " & _GetPixelColor(475 + 55, 255 + 20, True), $COLOR_DEBUG)
If IsArray($ButtonPixel) Then
If $g_iDebugSetlog = 1 Then
Setlog("ButtonPixelLocation = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("Pixel color found #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 109, $ButtonPixel[1], True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 65, $ButtonPixel[1] + 10, True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 55, $ButtonPixel[1] + 20, True), $COLOR_DEBUG)
EndIf
PureClick($ButtonPixel[0] + 55, $ButtonPixel[1] + 10, 1, 0)
ExitLoop
EndIf
If $i > 15 Then
Setlog("Can not find button for " & $FeatureName & ", giving up", $COLOR_ERROR)
If $g_iDebugImageSave = 1 Then DebugImageSave($FeatureName & "_ButtonCheck_")
SetError(1, @extended, False)
Return
EndIf
$i += 1
If _Sleep($iSpecialClick1) Then Return False
WEnd
Return True
Else
If $g_iDebugSetlog = 1 Then Setlog($FeatureName & " remove button found", $COLOR_INFO)
Return False
EndIf
EndFunc
Func CreateLogFile()
If $g_hLogFile <> 0 Then
FileClose($g_hLogFile)
$g_hLogFile = 0
EndIf
$g_sLogFileName = @YEAR & "-" & @MON & "-" & @MDAY & "_" & @HOUR & "." & @MIN & "." & @SEC & ".log"
Local $sLogPath = $g_sProfileLogsPath & $g_sLogFileName
$g_hLogFile = FileOpen($sLogPath, $FO_APPEND)
EndFunc
Func CreateAttackLogFile()
If $g_hAttackLogFile <> 0 Then
FileClose($g_hAttackLogFile)
$g_hAttackLogFile = 0
EndIf
Local $sAttackLogFName = "AttackLog" & "-" & @YEAR & "-" & @MON & ".log"
Local $sAttackLogPath = $g_sProfileLogsPath & $sAttackLogFName
$g_hAttackLogFile = FileOpen($sAttackLogPath, $FO_APPEND)
EndFunc
Func DebugImageSave($TxtName = "Unknown", $capturenew = True, $extensionpng = "png", $makesubfolder = True)
Local $Date = @MDAY & "." & @MON & "." & @YEAR
Local $Time = @HOUR & "." & @MIN & "." & @SEC
Local $savefolder = $g_sProfileTempDebugPath
If $makesubfolder = True Then
$savefolder = $g_sProfileTempDebugPath & $TxtName & "\"
DirCreate($savefolder)
EndIf
Local $extension
If $extensionpng = "png" then
$extension = "png"
Else
$extension = "jpg"
EndIf
Local $exist = true
local $i = 1
Local $first = True
Local $filename = ""
While $exist
If $first Then
$first = False
$filename = $savefolder & $TxtName & $Date & " at " & $Time & "." & $extension
If FileExists($filename) = 1 Then
$exist = True
Else
$exist = False
EndIf
Else
$filename = $savefolder & $TxtName & $Date & " at " & $Time & " (" & $i & ")." & $extension
If FileExists($filename) = 1 Then
$i +=1
Else
$exist = False
EndIf
EndIf
WEnd
If $capturenew Then _CaptureRegion2()
Local $EditedImage = _GDIPlus_BitmapCreateFromHBITMAP($hHBitmap2)
_GDIPlus_ImageSaveToFile($EditedImage, $filename)
_GDIPlus_BitmapDispose($EditedImage)
If $g_iDebugSetlog = 1 Then Setlog($filename, $COLOR_DEBUG)
If _Sleep($iDelayDebugImageSave1) Then Return
EndFunc
Func DebugSaveDesktopImage($sName = "Unknown_")
Local $iDesktopLeft = 0, $iDesktopTop = 0
Local $iDesktopWidth = @DesktopWidth, $iDesktopHeight = @DesktopHeight
Local $hDesktopBitmap = _ScreenCapture_Capture("", $iDesktopLeft, $iDesktopTop, $iDesktopWidth, $iDesktopHeight, False)
SetLog("Saving desktop snapshot in TEMP folder for developer review", $COLOR_INFO)
Local $Date = @MDAY & "." & @MON & "." & @YEAR
Local $Time = @HOUR & "." & @MIN & "." & @SEC
Local $SaveFileName = $sName & $Date & "_at_" & $Time & ".png"
_ScreenCapture_SaveImage($g_sProfileTempDebugPath & $SaveFileName, $hDesktopBitmap)
_WinAPI_DeleteObject($hDesktopBitmap)
EndFunc
Func _logErrorDLLCall($sDllName, $ErrorCode)
Local $sEmsg
If $ErrorCode > 0 Then
Switch $ErrorCode
Case 1
$sEmsg = "unable to use DLL file"
Case 2
$sEmsg = "unknown return type"
Case 3
$sEmsg = "function not found in the DLL file"
Case 4
$sEmsg = "bad number of parameters"
Case 5
$sEmsg = "bad parameter"
Case Else
$sEmsg = "Unknown Error Code?"
EndSwitch
SetLog($sDllName & " DLLCall Error, @error code: " & $sEmsg, $COLOR_ERROR)
EndIf
EndFunc
Func _logErrorDateDiff($ErrorCode)
Local $sEmsg
Switch $ErrorCode
Case 1
$sEmsg = "1| Invalid $sType"
Case 2
$sEmsg = "2| Invalid $iNumber"
Case 3
$sEmsg = "3| Invalid $sEndDate"
EndSwitch
Setlog("_DateDiff error code = " & $sEmsg, $COLOR_ERROR)
EndFunc
Func _logErrorDateAdd($ErrorCode)
Local $sEmsg
Switch $ErrorCode
Case 1
$sEmsg = "1| Invalid $sType"
Case 2
$sEmsg = "2| Invalid $sStartDate"
Case 3
$sEmsg = "3| Invalid $sEndDate"
EndSwitch
Setlog("_DateAdd error code = " & $sEmsg, $COLOR_ERROR)
EndFunc
Func FindPos()
getBSPos()
AndroidToFront()
Local $wasDown = AndroidShieldForceDown(True, True)
While 1
If _IsPressed("01") Or _IsPressed("02") Then
Local $Pos = MouseGetPos()
$Pos[0] -= $g_aiBSpos[0]
$Pos[1] -= $g_aiBSpos[1]
ConvertFromVillagePos($Pos[0], $Pos[1])
While _IsPressed("01") Or _IsPressed("02")
Sleep(10)
WEnd
AndroidShieldForceDown($wasDown, True)
Return $Pos
EndIf
Sleep(10)
WEnd
EndFunc
Func Tab($a, $b)
Local $Tab = ""
For $i = StringLen($a) To $b Step 1
$Tab &= " "
Next
Return $Tab
EndFunc
Func Time()
Return "[" & _NowTime(3) & "] "
EndFunc
Func TimeDebug()
Return "[" & @YEAR & "-" & @MON & "-" & @MDAY & " " & _NowTime(5) & "." & @MSEC & "] "
EndFunc
If @AutoItVersion >= '3.3.2.0' Then
Execute('OnAutoItExitRegister("__BlockInputEx_OnAutoItExit")')
Else
Execute('Assign("i_OptOEF", Opt("OnExitFunc", "__BlockInputEx_OnAutoItExit"), 2)')
EndIf
Global $ah_MouseKeyboard_WinHooks[8]
Global $s_KeyboardKeys_Buffer
Global $i_MouseHookGetAncestorHwnd = 1
Func _BlockInputEx($iBlockMode = -1, $sExclude = "", $sInclude = "", $hWindows = "", $iBlockAllInput = 0)
If $iBlockMode < -1 Or $iBlockMode > 3 Then Return SetError(1, 0, 0)
If $iBlockMode <= 0 Then Return __BlockInputEx_UnhookWinHooks_Proc()
Local $pStub_KeyProc = 0, $pStub_MouseProc = 0, $hHook_Keyboard = 0, $hHook_Mouse = 0
Local $hHook_Module = _WinAPI_GetModuleHandle(0)
For $i = 0 To 3
If $ah_MouseKeyboard_WinHooks[$i] > 0 Then
__BlockInputEx_UnhookWinHooks_Proc()
ExitLoop
EndIf
Next
If $iBlockMode = 1 Or $iBlockMode = 2 Then
$pStub_MouseProc = DllCallbackRegister("__BlockInputEx_MouseHook_Proc", "int", "int;ptr;ptr")
$hHook_Mouse = _WinAPI_SetWindowsHookEx($WH_MOUSE_LL, DllCallbackGetPtr($pStub_MouseProc), $hHook_Module, 0)
EndIf
If $iBlockMode = 1 Or $iBlockMode = 3 Then
$pStub_KeyProc = DllCallbackRegister("__BlockInputEx_KeyBoardHook_Proc", "int", "int;ptr;ptr")
$hHook_Keyboard = _WinAPI_SetWindowsHookEx($WH_KEYBOARD_LL, DllCallbackGetPtr($pStub_KeyProc), $hHook_Module, 0)
EndIf
$ah_MouseKeyboard_WinHooks[0] = $pStub_KeyProc
$ah_MouseKeyboard_WinHooks[1] = $pStub_MouseProc
$ah_MouseKeyboard_WinHooks[2] = $hHook_Keyboard
$ah_MouseKeyboard_WinHooks[3] = $hHook_Mouse
$ah_MouseKeyboard_WinHooks[4] = "|" & __BlockInputEx_Parse_vmCodesList_CLASSes(__BlockInputEx_Parse_vkCodesList_CLASSes($sInclude)) & "|"
$ah_MouseKeyboard_WinHooks[5] = "|" & __BlockInputEx_Parse_vmCodesList_CLASSes(__BlockInputEx_Parse_vkCodesList_CLASSes($sExclude)) & "|"
$ah_MouseKeyboard_WinHooks[6] = "|" & $hWindows & "|"
$ah_MouseKeyboard_WinHooks[7] = $iBlockAllInput
Return 1
EndFunc
Func __BlockInputEx_KeyBoardHook_Proc($nCode, $wParam, $lParam)
If $nCode < 0 Then
Return _WinAPI_CallNextHookEx($ah_MouseKeyboard_WinHooks[2], $nCode, $wParam, $lParam)
EndIf
Local $KBDLLHOOKSTRUCT = DllStructCreate("dword vkCode;dword scanCode;dword flags;dword time;ptr dwExtraInfo", $lParam)
Local $iFlags = DllStructGetData($KBDLLHOOKSTRUCT, "flags")
Local $iDec_vkCode = DllStructGetData($KBDLLHOOKSTRUCT, "vkCode")
Local $vkCode = "0x" & Hex($iDec_vkCode, 2)
$KBDLLHOOKSTRUCT = 0
If Not StringInStr($s_KeyboardKeys_Buffer, $iDec_vkCode & '|') Then
$s_KeyboardKeys_Buffer &= $iDec_vkCode & '|'
EndIf
Local $sInclude = $ah_MouseKeyboard_WinHooks[4]
Local $sExclude = $ah_MouseKeyboard_WinHooks[5]
Local $hWnds = $ah_MouseKeyboard_WinHooks[6]
Local $iBlockAllInput = $ah_MouseKeyboard_WinHooks[7]
If $iBlockAllInput = 0 And BitAND($iFlags, 16) Then
Return _WinAPI_CallNextHookEx($ah_MouseKeyboard_WinHooks[2], $nCode, $wParam, $lParam)
EndIf
If(StringInStr($s_KeyboardKeys_Buffer, '165|') And StringInStr($s_KeyboardKeys_Buffer, '163|') And StringInStr($s_KeyboardKeys_Buffer, '46|')) Or(StringInStr($s_KeyboardKeys_Buffer, '164|') And StringInStr($s_KeyboardKeys_Buffer, '162|') And StringInStr($s_KeyboardKeys_Buffer, '46|')) Then
Sleep($iDelayBlockInput1)
$s_KeyboardKeys_Buffer = ""
Return _WinAPI_CallNextHookEx($ah_MouseKeyboard_WinHooks[2], $nCode, $wParam, $lParam)
EndIf
If $sInclude <> "||" Then
If StringInStr($sInclude, "|" & $vkCode & "|") And($hWnds = "||" Or StringInStr($hWnds, "|" & WinGetHandle("[ACTIVE]") & "|")) Then
Return 1
EndIf
Else
If Not StringInStr($sExclude, "|" & $vkCode & "|") And($hWnds = "||" Or StringInStr($hWnds, "|" & WinGetHandle("[ACTIVE]") & "|")) Then
Return 1
EndIf
EndIf
Return _WinAPI_CallNextHookEx($ah_MouseKeyboard_WinHooks[2], $nCode, $wParam, $lParam)
EndFunc
Func __BlockInputEx_MouseHook_Proc($nCode, $wParam, $lParam)
If $nCode < 0 Then Return _WinAPI_CallNextHookEx($ah_MouseKeyboard_WinHooks[3], $nCode, $wParam, $lParam)
Local $MOUSEHOOKSTRUCT = DllStructCreate("ptr pt;hwnd hwnd;uint wHitTestCode;ulong_ptr dwExtraInfo", $lParam)
Local $iExtraInfo = DllStructGetData($MOUSEHOOKSTRUCT, "dwExtraInfo")
Local $iMouse_Event = BitAND($wParam, 0xFFFF)
$MOUSEHOOKSTRUCT = 0
Local $sInclude = $ah_MouseKeyboard_WinHooks[4]
Local $sExclude = $ah_MouseKeyboard_WinHooks[5]
Local $hWnds = $ah_MouseKeyboard_WinHooks[6]
Local $iBlockAllInput = $ah_MouseKeyboard_WinHooks[7]
If $iBlockAllInput = 0 And $iExtraInfo <> 0 Then
Return _WinAPI_CallNextHookEx($ah_MouseKeyboard_WinHooks[3], $nCode, $wParam, $lParam)
EndIf
If $sInclude <> "||" Then
If StringInStr($sInclude, "|" & $iMouse_Event & "|") And($hWnds = "||" Or StringInStr($hWnds, "|" & __BlockInputEx_WinGetHovered() & "|")) Then
Return 1
EndIf
Else
If Not StringInStr($sExclude, "|" & $iMouse_Event & "|") And($hWnds = "||" Or StringInStr($hWnds, "|" & __BlockInputEx_WinGetHovered() & "|")) Then
Return 1
EndIf
EndIf
Return _WinAPI_CallNextHookEx($ah_MouseKeyboard_WinHooks[3], $nCode, $wParam, $lParam)
EndFunc
Func __BlockInputEx_UnhookWinHooks_Proc()
If $ah_MouseKeyboard_WinHooks[0] > 0 Then
DllCallbackFree($ah_MouseKeyboard_WinHooks[0])
$ah_MouseKeyboard_WinHooks[0] = 0
EndIf
If $ah_MouseKeyboard_WinHooks[1] > 0 Then
DllCallbackFree($ah_MouseKeyboard_WinHooks[1])
$ah_MouseKeyboard_WinHooks[1] = 0
EndIf
If IsPtr($ah_MouseKeyboard_WinHooks[2]) Then
_WinAPI_UnhookWindowsHookEx($ah_MouseKeyboard_WinHooks[2])
$ah_MouseKeyboard_WinHooks[2] = 0
EndIf
If IsPtr($ah_MouseKeyboard_WinHooks[3]) Then
_WinAPI_UnhookWindowsHookEx($ah_MouseKeyboard_WinHooks[3])
$ah_MouseKeyboard_WinHooks[3] = 0
EndIf
Return 1
EndFunc
Func __BlockInputEx_Parse_vkCodesList_CLASSes($sList)
$sList = StringRegExpReplace($sList, "(?i)\{(Ctrl|Shift|Alt)\}", "{L$1}|{R$1}")
Local $a_vkCode_List = StringSplit($sList, "|")
Local $sRet_Keys = ""
For $i = 1 To $a_vkCode_List[0]
Switch $a_vkCode_List[$i]
Case "[:FUNC:]"
$a_vkCode_List[$i] = "0x70|0x71|0x72|0x73|0x74|0x75|0x76|0x77|0x78|0x79|0x7A|0x7B|0x7C|0x7D|0x7E|0x7F|0x80H|0x81H|0x82H|0x83H|0x84H|0x85H|0x86H|0x87H"
Case "[:ALPHA:]"
$a_vkCode_List[$i] = "0x41|0x42|0x43|0x44|0x45|0x46|0x47|0x48|0x49|0x4A|0x4B|0x4C|0x4D|0x4E|0x4F|0x50|0x51|0x52|0x53|0x54|0x55|0x56|0x57|0x58|0x59|0x5A"
Case "[:NUMBER:]"
$a_vkCode_List[$i] = "0x30|0x31|0x32|0x33|0x34|0x35|0x36|0x37|0x38|0x39|0x60|0x61|0x62|0x63|0x64|0x65|0x66|0x67|0x68|0x69"
Case "[:ARROWS:]"
$a_vkCode_List[$i] = "0x25|0x26|0x27|0x28"
Case "[:SPECIAL:]"
$a_vkCode_List[$i] = "0x08|0x09|0x0C|0x0D|0x10|0x11|0x12|0x13|0x14|0x1B|0x20|0x21|0x22|" & "0x23|0x24|0x29|0x2A|0x2B|0x2C|0x2D|0x2E|0x5B|0x5C|0x6A|0x6B|0x6C|" & "0x6D|0x6E|0x6F|0x90|0x91|0xA0|0xA1|0xA2|0xA3|0xA4|0xA5|0xBA|0xBB|" & "0xBC|0xBD|0xBE|0xBF|0xC0|0xDB|0xDC|0xDD"
Case Else
$a_vkCode_List[$i] = __BlockInputEx_KeyStr_To_vkCode($a_vkCode_List[$i])
EndSwitch
$sRet_Keys &= $a_vkCode_List[$i] & "|"
Next
Return StringRegExpReplace($sRet_Keys, "\|+$", "")
EndFunc
Func __BlockInputEx_Parse_vmCodesList_CLASSes($sList)
Local Const $MOUSE_MOVE_EVENT = 512
Local Const $MOUSE_PRIMARYDOWN_EVENT = 513
Local Const $MOUSE_PRIMARYUP_EVENT = 514
Local Const $MOUSE_SECONDARYDOWN_EVENT = 516
Local Const $MOUSE_SECONDARYUP_EVENT = 517
Local Const $MOUSE_WHEELDOWN_EVENT = 519
Local Const $MOUSE_WHEELUP_EVENT = 520
Local Const $MOUSE_WHEELSCROLL_EVENT = 522
Local Const $MOUSE_SPECIALBUTTONDOWN_EVENT = 523
Local Const $MOUSE_SPECIALBUTTONUP_EVENT = 524
Local $a_vmCode_List = StringSplit($sList, "|")
Local $sRet_Keys = ""
For $i = 1 To $a_vmCode_List[0]
Switch $a_vmCode_List[$i]
Case "{MMOVE}"
$a_vmCode_List[$i] = $MOUSE_MOVE_EVENT
Case "{MPDOWN}"
$a_vmCode_List[$i] = $MOUSE_PRIMARYDOWN_EVENT
Case "{MPUP}"
$a_vmCode_List[$i] = $MOUSE_PRIMARYUP_EVENT
Case "{MSDOWN}"
$a_vmCode_List[$i] = $MOUSE_SECONDARYDOWN_EVENT
Case "{MSUP}"
$a_vmCode_List[$i] = $MOUSE_SECONDARYUP_EVENT
Case "{MWDOWN}"
$a_vmCode_List[$i] = $MOUSE_WHEELDOWN_EVENT
Case "{MWUP}"
$a_vmCode_List[$i] = $MOUSE_WHEELUP_EVENT
Case "{MWSCROLL}"
$a_vmCode_List[$i] = $MOUSE_WHEELSCROLL_EVENT
Case "{MSPDOWN}"
$a_vmCode_List[$i] = $MOUSE_SPECIALBUTTONDOWN_EVENT
Case "{MSPUP}"
$a_vmCode_List[$i] = $MOUSE_SPECIALBUTTONUP_EVENT
EndSwitch
$sRet_Keys &= $a_vmCode_List[$i] & "|"
Next
Return StringRegExpReplace($sRet_Keys, "\|+$", "")
EndFunc
Func __BlockInputEx_KeyStr_To_vkCode($sKeyStr)
Local $sRet_Keys = "", $aDelim_Keys[1]
Local $aKeys = StringSplit("{LMouse}|{RMouse}|{}|(MMouse}|{}|{}|{}|{BACKSPACE}|{TAB}|{}|{}|{}|{ENTER}|{}|{}|{SHIFT}|{CTRL}|{ALT}|{PAUSE}|{CAPSLOCK}|{}|{}|{}|{}|{}|{}|{ESC}|{}|{}|{}|{]|{SPACE}|{PGUP}|{PGDN}|{END}|{HOME}|{LEFT}|{UP}|{RIGHT}|{DOWN}|{SELECT}|{PRINTSCREEN}|{}|{PRINTSCREEN}|{INSERT}|{DEL}|{}|0|1|2|3|4|5|6|7|8|9|{}|{}|{}|{}|{}|{}|{}|a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z|{LWIN}|{RWIN}|{APPSKEY}|{}|{SLEEP}|{numpad0}|{numpad1}|{numpad2}|{numpad3}|{numpad4}|{numpad5}|{numpad6}|{numpad7}|{numpad8}|{numpad9}|{NUMPADMULT}|{NUMPADADD}|{}|{NUMPADSUB}|{NUMPADDOT}|{NUMPADDIV}|{F1}|{F2}|{F3}|{F4}|{F5}|{F6}|{F7}|{F8}|{F9}|{F10}|{F11}|{F12}|{F13}|{F14}|{F15}|{F16}|{F17}|{F18}|{F19}|{F20}|{F21}|{F22}|{F23}|{F24}|{}|{}|{}|{}|{}|{}|{}|{}|{NUMLOCK}|{}|{}|{}|{}|{}|{}|{}|{}|{}|{}|{}|{}|{}|{}|{}|{LSHIFT}|{RSHIFT}|{LCTRL}|{RCTRL}|{LALT}|{RALT}|{BROWSER_BACK}|{BROWSER_FORWARD}|{BROWSER_REFRESH}|{BROWSER_STOP}|{BROWSER_SEARCH}|{BROWSER_FAVORITES}|{BROWSER_HOME}|{VOLUME_MUTE}|{VOLUME_DOWN}|{VOLUME_UP}|{MEDIA_NEXT}|{MEDIA_PREV}|{MEDIA_STOP}|{MEDIA_PLAY_PAUSE}|{LAUNCH_MAIL}|{LAUNCH_MEDIA}|{LAUNCH_APP1}|{LAUNCH_APP2}|{}|{}|;|{+}|,|{-}|.|/|`|{}|{}|{}|{}|{}|{}|{}|{}|{}|{}|{}|{}|{}|{}|{}|{}|{}|{}|{}|{}|{}|{}|{}|{}|{}|{}|[|\|]|'", "|")
If StringRegExp($sKeyStr, "\A\[|\]\z") Then
$sKeyStr = StringRegExpReplace($sKeyStr, "\A\[|\]\z", "")
$sKeyStr = StringRegExpReplace($sKeyStr, "(.)", "\1|")
$sKeyStr = StringRegExpReplace($sKeyStr, "\|+$", "")
$aDelim_Keys = StringSplit($sKeyStr, "")
EndIf
For $i = 1 To $aKeys[0]
If $aDelim_Keys[0] > 1 Then
For $j = 1 To $aDelim_Keys[0]
If $aKeys[$i] = $aDelim_Keys[$j] Then $sRet_Keys &= "0x" & Hex($i, 2) & "|"
Next
Else
If $aKeys[$i] = $sKeyStr Then Return "0x" & Hex($i, 2)
EndIf
Next
If $sRet_Keys = "" Then Return $sKeyStr
Return StringRegExpReplace($sRet_Keys, "\|+$", "")
EndFunc
Func __BlockInputEx_WinGetHovered()
Local $iOld_Opt_MCM = Opt("MouseCoordMode", 1)
Local $aRet = DllCall("user32.dll", "int", "WindowFromPoint", "long", MouseGetPos(0), "long", MouseGetPos(1))
Opt("MouseCoordMode", $iOld_Opt_MCM)
If $i_MouseHookGetAncestorHwnd Then
$aRet = DllCall("User32.dll", "hwnd", "GetAncestor", "hwnd", $aRet[0], "uint", 2)
EndIf
Return HWnd($aRet[0])
EndFunc
Func __BlockInputEx_OnAutoItExit()
_BlockInputEx(0)
EndFunc
Func TogglePause()
TogglePauseImpl("Button")
EndFunc
Func TogglePauseImpl($Source)
If Not $g_bRunState Then Return
ResumeAndroid()
$g_bBotPaused = Not $g_bBotPaused
If $g_bTogglePauseAllowed = False Then
$g_bTogglePauseUpdateState = True
Return
EndIf
TogglePauseUpdateState($Source)
TogglePauseSleep()
EndFunc
Func TogglePauseUpdateState($Source)
$actual_train_skip = 0
$g_bTogglePauseUpdateState = False
If $g_bBotPaused Then
AndroidShield("TogglePauseImpl paused", False)
TrayTip($g_sBotTitle, "", 1)
TrayTip($g_sBotTitle, "was Paused!", 1, $TIP_ICONEXCLAMATION)
Setlog("Bot was Paused!", $COLOR_ERROR)
If Not $bSearchMode Then
$g_iTimePassed += Int(TimerDiff($g_hTimerSinceStarted))
EndIf
PushMsg("Pause", $Source)
GUICtrlSetState($g_hBtnPause, $GUI_HIDE)
GUICtrlSetState($g_hBtnResume, $GUI_SHOW)
Else
AndroidShield("TogglePauseImpl resumed")
TrayTip($g_sBotTitle, "", 1)
TrayTip($g_sBotTitle, "was Resumed.", 1, $TIP_ICONASTERISK)
Setlog("Bot was Resumed.", $COLOR_SUCCESS)
If Not $bSearchMode Then
$g_hTimerSinceStarted = TimerInit()
EndIf
PushMsg("Resume", $Source)
GUICtrlSetState($g_hBtnPause, $GUI_SHOW)
GUICtrlSetState($g_hBtnResume, $GUI_HIDE)
EndIf
SetRedrawBotWindow(True, Default, Default, Default, "TogglePauseUpdateState")
EndFunc
Func TogglePauseSleep()
Local $counter = 0
Local $hTimerAutoResume = TimerInit()
While $g_bBotPaused
If _Sleep($iDelayTogglePause1, True, True, False) Then ExitLoop
If $iChkAutoResume = 1 And TimerDiff($hTimerAutoResume) >=($iAutoResumeTime * 60000) Then
SetLog("Auto resume bot after " & $iAutoResumeTime & " minutes of waiting", $COLOR_INFO)
TogglePause()
EndIf
$counter = $counter + 1
If($g_bNotifyPBEnable = True Or $g_bNotifyTGEnable = True) And $g_bNotifyRemoteEnable = True And $counter = 200 Then
NotifyRemoteControl()
$counter = 0
EndIf
WEnd
$g_bSkipFirstZoomout = False
If _Sleep($iDelayTogglePause2, True, True, False) Then Return
EndFunc
Func AutoStart()
If $ichkAutoStart = 1 Or $g_bRestarted = True Then
Local $iDelay = $ichkAutoStartDelay
If $g_bRestarted = True Then $iDelay = 0
SetLog("Bot Auto Starting in " & $iDelay & " seconds", $COLOR_ERROR)
FlushGuiLog($g_hTxtLog, $aTxtLogInitText, True)
Sleep($iDelay * 1000)
btnStart()
EndIf
EndFunc
Func WindowsArrange($position, $offsetX = 0, $offsetY = 0)
WinGetAndroidHandle()
Local $AndroidPos = WinGetPos($HWnD)
Local $BotPos = WinGetPos($g_hFrmBot)
If IsArray($AndroidPos) And IsArray($BotPos) Then
Local $hTimer = TimerInit()
WinSetState($HWnD, "", @SW_RESTORE)
While IsArray($AndroidPos) And TimerDiff($hTimer) < 3000 And $AndroidPos[0] < -30000 And $AndroidPos[1] < -30000
$AndroidPos = WinGetPos($HWnD)
If _Sleep($iDelaySleep) Then Return False
WEnd
Local $x = $offsetX
Local $y = $offsetY
Local $AndroidX = $AndroidPos[0]
Local $AndroidY = $AndroidPos[1]
Local $AndroidW = $AndroidPos[2]
Local $AndroidH = $AndroidPos[3]
Local $BotX = $BotPos[0]
Local $BotY = $BotPos[1]
Local $BotW = $BotPos[2]
Local $BotH = $BotPos[3]
If Number($AndroidX) > -30000 And Number($AndroidY) > -30000 Then
Local $bAdjusted = False
If $position = "EMBED" Then
AndroidEmbed(True)
If Not($offsetX == "" Or $offsetY == "") Then
$bAdjusted = $BotX <> $offsetX Or $BotY <> $offsetY
If $bAdjusted = True Then WinMove2($g_hFrmBot, "", $offsetX, $offsetY)
EndIf
Else
If $g_bAndroidEmbedded = True Then
Return
EndIf
Switch $position
Case "BS-BOT"
If $offsetX == "" Then
$x = $AndroidX
$offsetX = 0
EndIf
If $offsetY == "" Then
$y = $AndroidY
$offsetY = 0
EndIf
$bAdjusted = $AndroidX <> $x Or $AndroidY <> $y
If $bAdjusted Then
WinMove2($HWnD, "", $x, $y)
_Sleep($iDelayWindowsArrange1, True, False)
EndIf
$bAdjusted = $bAdjusted = True Or $BotX <> $AndroidW + $offsetX * 2 Or $BotY <> $y
If $bAdjusted Then WinMove2($g_hFrmBot, "", $x + $AndroidW + $offsetX, $y)
Case "BOT-BS"
If $offsetX == "" Then
$x = $BotX
$offsetX = 0
EndIf
If $offsetY == "" Then
$y = $BotY
$offsetY = 0
EndIf
$bAdjusted = $BotX <> $x Or $BotY <> $y
If $bAdjusted Then
WinMove2($g_hFrmBot, "", $x, $y)
_Sleep($iDelayWindowsArrange1, True, False)
EndIf
$bAdjusted = $bAdjusted Or $AndroidX <> $x + $BotW + $offsetX Or $AndroidY <> $y
If $bAdjusted Then WinMove2($HWnD, "", $x + $BotW + $offsetX, $y)
Case "SNAP-TR"
If $offsetX == "" Then $offsetX = 0
If $offsetY == "" Then $offsetY = 0
$bAdjusted = $BotX <> $AndroidX + $AndroidW + $offsetX Or $BotY <> $AndroidY + $offsetY
If $bAdjusted Then WinMove2($g_hFrmBot, "", $AndroidX + $AndroidW + $offsetX, $AndroidY + $offsetY)
Case "SNAP-BR"
If $offsetX == "" Then $offsetX = 0
If $offsetY == "" Then $offsetY = 0
$bAdjusted = $AndroidX <> $AndroidX + $AndroidW + $offsetX Or $AndroidY <> $AndroidY +($AndroidH - $BotH) + $offsetY
If $bAdjusted Then WinMove2($g_hFrmBot, "", $AndroidX + $AndroidW + $offsetX, $AndroidY +($AndroidH - $BotH) + $offsetY)
Case "SNAP-TL"
If $offsetX == "" Then $offsetX = 0
If $offsetY == "" Then $offsetY = 0
$bAdjusted = $BotX <> $AndroidX - $BotW - $offsetX Or $BotY <> $AndroidY + $offsetY
If $bAdjusted Then WinMove2($g_hFrmBot, "", $AndroidX - $BotW - $offsetX, $AndroidY + $offsetY)
Case "SNAP-BL"
If $offsetX == "" Then $offsetX = 0
If $offsetY == "" Then $offsetY = 0
$bAdjusted = $BotX <> $AndroidX - $BotW - $offsetX Or $BotY <> $AndroidY +($AndroidH - $BotH) + $offsetY
If $bAdjusted Then WinMove2($g_hFrmBot, "", $AndroidX - $BotW - $offsetX, $AndroidY +($AndroidH - $BotH) + $offsetY)
EndSwitch
EndIf
If $bAdjusted = True Then
SetDebugLog("WindowsArrange: " & $position & ", offsetX=" & $offsetX & ", offsetY=" & $offsetY & ", X=" & $x & ", Y=" & $y)
_Sleep($iDelayWindowsArrange1, True, False)
EndIf
EndIf
EndIf
EndFunc
Func DisposeWindows()
updateBtnEmbed()
Local $aPos = WinGetPos($g_hFrmBot)
If IsArray($aPos) Then
If _CheckWindowVisibility($g_hFrmBot, $aPos) Then
SetDebugLog("Bot Window '" & $Title & "' not visible, moving to position: " & $aPos[0] & ", " & $aPos[1])
WinMove2($g_hFrmBot, "", $aPos[0], $aPos[1])
EndIf
EndIf
If $iDisposeWindows = 1 Then
Switch $icmbDisposeWindowsPos
Case 0
WindowsArrange("BS-BOT", $iWAOffsetX, $iWAOffsetY)
Case 1
WindowsArrange("BOT-BS", $iWAOffsetX, $iWAOffsetY)
Case 2
WindowsArrange("SNAP-TR", $iWAOffsetX, $iWAOffsetY)
Case 3
WindowsArrange("SNAP-TL", $iWAOffsetX, $iWAOffsetY)
Case 4
WindowsArrange("SNAP-BR", $iWAOffsetX, $iWAOffsetY)
Case 5
WindowsArrange("SNAP-BL", $iWAOffsetX, $iWAOffsetY)
Case 6
WindowsArrange("EMBED", $iWAOffsetX, $iWAOffsetY)
EndSwitch
EndIf
EndFunc
Func WinMove2($WinTitle, $WinText, $x = -1, $y = -1, $w = -1, $h = -1, $hAfter = 0, $iFlags = 0, $bCheckAfterPos = True)
Local $hWin = WinGetHandle($WinTitle, $WinText)
If _WinAPI_IsIconic($hWin) Then
SetDebugLog("Window " & $WinTitle &(($WinTitle <> $hWin) ? "(" & $hWin & ")" : "") & " restored", $COLOR_ACTION)
WinSetState($hWin, "", @SW_RESTORE)
EndIf
Local $aPos = WinGetPos($hWin)
If @error <> 0 Or Not IsArray($aPos) Then
SetError(1, @extended, -1)
Return 0
EndIf
Local $aPPos = WinGetClientPos(_WinAPI_GetParent($hWin))
If IsArray($aPPos) Then
$aPos[0] -= $aPPos[0]
$aPos[1] -= $aPPos[1]
EndIf
Local $NoMove = $x = -1 And $y = -1
Local $NoResize = $w = -1 And $h = -1
Local $NOZORDER =($hAfter = 0 ? $SWP_NOZORDER : 0)
If $x = -1 Or $y = -1 Or $w = -1 Or $h = -1 Then
If $x = -1 Then $x = $aPos[0]
If $y = -1 Then $y = $aPos[1]
If $w = -1 Then $w = $aPos[2]
If $h = -1 Then $h = $aPos[3]
EndIf
$NoMove = $NoMove Or($x = $aPos[0] And $y = $aPos[1])
$NoResize = $NoResize Or($w = $aPos[2] And $h = $aPos[3])
_WinAPI_SetWindowPos($hWin, $hAfter, $x, $y, $w, $h, BitOR(($NoMove ? BitOR($SWP_NOMOVE, $SWP_NOREPOSITION) : 0), $SWP_NOACTIVATE, $SWP_NOSENDCHANGING, $NOZORDER, $iFlags))
If $bCheckAfterPos Then
$aPos = WinGetPos($hWin)
If @error <> 0 Or Not IsArray($aPos) Then
SetError(1, @extended, -1)
Return 0
EndIf
Local $aPPos = WinGetClientPos(_WinAPI_GetParent($hWin))
If IsArray($aPPos) Then
$aPos[0] -= $aPPos[0]
$aPos[1] -= $aPPos[1]
EndIf
If $x <> $aPos[0] Or $y <> $aPos[1] Or $w <> $aPos[2] Or $h <> $aPos[3] Then
SetDebugLog("Window " & $WinTitle &(($WinTitle <> $hWin) ? "(" & $hWin & ")" : "") & " got resized/moved again to " & $aPos[0] & "/" & $aPos[1] & " " & $aPos[2] & "x" & $aPos[3] & ", restore now " & $x & "/" & $y & " " & $w & "x" & $h, $COLOR_ACTION)
WinMove($hWin, "", $x, $y, $w, $h - 1)
_WinAPI_SetWindowPos($hWin, $hAfter, $x, $y, $w, $h, BitOR($SWP_NOMOVE, $SWP_NOREPOSITION, $SWP_NOACTIVATE, $SWP_NOSENDCHANGING, $NOZORDER, $iFlags))
EndIf
EndIf
Return $hWin
EndFunc
Func WinGetClientPos($hWin, $x = 0, $y = 0)
Local $tPoint = DllStructCreate("int x;int y")
DllStructSetData($tPoint, "x", $x)
DllStructSetData($tPoint, "y", $y)
_WinAPI_ClientToScreen($hWin, $tPoint)
If @error Then Return SetError(1, 0, 0)
Local $a[2] = [DllStructGetData($tPoint, "x"), DllStructGetData($tPoint, "y")]
$tPoint = 0
Return $a
EndFunc
Func WinGetPos2($title, $text = "")
Local $aPos = 0
If IsHWnd($title) = 0 Then $title = WinGetHandle($title, $text)
While IsHWnd($title) And(IsArray($aPos) = 0 Or $aPos[2] < 200)
If _WinAPI_IsIconic($title) Then WinSetState($title, "", @SW_RESTORE)
If _WinAPI_IsIconic($title) = False Then $aPos = WinGetPos($title)
WEnd
Return $aPos
EndFunc
Func ControlGetPos2($title, $text, $controlID)
Local $aPos = 0
If IsHWnd($title) = 0 Then $title = WinGetHandle($title, $text)
While IsHWnd($title) And(IsArray($aPos) = 0 Or $aPos[2] < 200)
If _WinAPI_IsIconic($title) Then WinSetState($title, "", @SW_RESTORE)
If _WinAPI_IsIconic($title) = False Then $aPos = ControlGetPos($title, $text, $controlID)
WEnd
Return $aPos
EndFunc
Func ControlGetRelativePos($title, $text, $controlID)
Local $a = ControlGetPos($title, $text, $controlID)
If UBound($a) < 4 Then Return SetError(1)
Local $hCtrl =((IsHWnd($controlID)) ?($controlID) :(GUICtrlGetHandle($controlID)))
Local $hWinParent = _WinAPI_GetParent($hCtrl)
Local $aParent = ControlGetPos($title, "", $hWinParent)
If IsArray($aParent) = 1 Then
$a[0] -= $aParent[0]
$a[1] -= $aParent[1]
EndIf
Return $a
EndFunc
Func _CheckWindowVisibility(Const $hWnd, ByRef $p)
If $p[0] < -30000 And $p[1] < -30000 Then Return False
Local $monitorHandle = _MonitorFromWindow($hWnd, 0)
If $monitorHandle <> 0 Then
Return False
EndIf
$monitorHandle = _MonitorFromWindow($hWnd, 2)
Local $monitorInfo = _MonitorGetInfo($monitorHandle)
If UBound($monitorInfo) > 1 Then
$p[0] = $monitorInfo[0]
$p[1] = $monitorInfo[1]
EndIf
Return True
EndFunc
Func _GraphicsCreateDC($sDriver="DISPLAY",$sDevice=0,$pInitData=0)
If Not IsString($sDriver) Then Return SetError(1,0,False)
Local $aRet,$sDeviceType
If $sDevice="" Or Not IsString($sDevice) Then
$sDeviceType="ptr"
$sDevice=0
Else
$sDeviceType="wstr"
EndIf
$aRet=DllCall('gdi32.dll',"handle","CreateDCW","wstr",$sDriver,$sDeviceType,$sDevice,"ptr",0,"ptr",$pInitData)
If @error Then Return SetError(2,@error,0)
If $aRet[0]=0 Then Return SetError(3,0,0)
Return $aRet[0]
EndFunc
Func _MonitorGetInfo($hMonitor,$hMonitorDC=0)
If Not IsPtr($hMonitor) Or $hMonitor=0 Then Return SetError(1,0,'')
Local $aRet, $stMonInfoEx=DllStructCreate('dword;long[8];dword;wchar[32]'), $bMonDCCreated=0
DllStructSetData($stMonInfoEx,1,DllStructGetSize($stMonInfoEx))
$aRet=DllCall('user32.dll','bool','GetMonitorInfoW','handle',$hMonitor,'ptr',DllStructGetPtr($stMonInfoEx))
If @error Then
$stMonInfoEx = 0
Return SetError(2,0,'')
EndIf
If Not $aRet[0] Then
$stMonInfoEx = 0
Return SetError(3,0,'')
EndIf
Dim $aRet[12]
For $i=0 To 7
$aRet[$i]=DllStructGetData($stMonInfoEx,2,$i+1)
Next
$aRet[8]=DllStructGetData($stMonInfoEx,3)
$aRet[9]=DllStructGetData($stMonInfoEx,4)
If $hMonitorDC=0 Then
$hMonitorDC=_GraphicsCreateDC($aRet[9],$aRet[9])
$bMonDCCreated=1
EndIf
$aRet[10]=_WinAPI_GetDeviceCaps($hMonitorDC,12)
$aRet[11]=_WinAPI_GetDeviceCaps($hMonitorDC,116)
If $bMonDCCreated Then _WinAPI_DeleteDC($hMonitorDC)
$stMonInfoEx = 0
Return $aRet
EndFunc
Func _MonitorFromWindow($hWnd, $iFlags=2)
If Not IsHWnd($hWnd) Or $iFlags<0 Or $iFlags>2 Then Return SetError(1,0,0)
Local $aRet=DllCall('user32.dll', 'handle', 'MonitorFromWindow', 'hwnd', $hWnd, 'dword', $iFlags)
If @error Then Return SetError(2,@error,0)
If $aRet[0]=0 Then Return SetError(3,0,0)
Return $aRet[0]
EndFunc
Func MakeScreenshot($TargetDir, $type = "jpg")
If WinGetAndroidHandle() <> 0 Then
Local $iLeft = 0, $iTop = 0, $iRight = $g_iAndroidClientWidth, $iBottom = $g_iAndroidClientHeight
Local $iW = Number($iRight) - Number($iLeft)
Local $iH = Number($iBottom) - Number($iTop)
Local $hBitmapScreenshot
Local $hGraphic, $hBrush
Local $hHBitmapScreenshot = _CaptureRegion($iLeft, $iTop, $iRight, $iBottom, True)
$hBitmapScreenshot = _GDIPlus_BitmapCreateFromHBITMAP($hHBitmapScreenshot)
$hGraphic = _GDIPlus_ImageGetGraphicsContext($hBitmapScreenshot)
$hBrush = _GDIPlus_BrushCreateSolid(0xFF000029)
If $ichkScreenshotHideName = 1 Then
If $aCCPos[0] = -1 Or $aCCPos[1] = -1 Then
Setlog("Screenshot warning: Locate the Clan Castle to hide the clanname!", $COLOR_ERROR)
EndIf
_GDIPlus_GraphicsFillRect($hGraphic, 0, 0, 250, 50, $hBrush)
If $aCCPos[0] <> -1 Then
Local $xCC = $aCCPos[0]
Local $yCC = $aCCPos[1]
ConvertToVillagePos($xCC, $yCC)
_GDIPlus_GraphicsFillRect($hGraphic, $xCC - 33, $yCC - 2, 66, 18, $hBrush)
EndIf
EndIf
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
Local $filename = $Date & "_" & $Time & "." & $type
_GDIPlus_ImageSaveToFile($hBitmapScreenshot, $TargetDir & $filename)
If FileExists($TargetDir & $filename) = 1 Then
If $g_sProfileTempPath = $TargetDir Then
SetLog("Screenshot saved: .\Profiles\" & $g_sProfileCurrentName & "\Temp\" & $filename)
Else
SetLog("Screenshot saved: " & $TargetDir & $filename)
EndIf
Else
SetLog("Screenshot file not created!", $COLOR_ERROR)
EndIf
$g_bMakeScreenshotNow = False
_GDIPlus_BrushDispose($hBrush)
_GDIPlus_GraphicsDispose($hGraphic)
_GDIPlus_BitmapDispose($hBitmapScreenshot)
_WinAPI_DeleteObject($hHBitmapScreenshot)
Else
SetLog("Not in game", $COLOR_ERROR)
EndIf
EndFunc
Func _PostMessage_ClickDrag($X1, $Y1, $X2, $Y2, $Button = "left", $Delay = 50)
Local $hWin = $HWnDCtrl
$X1 = Int($X1)
$Y1 = Int($Y1)
$X2 = Int($X2)
$Y2 = Int($Y2)
If $hWin = $HWnD Then
$X1 += $g_aiBSrpos[0]
$Y1 += $g_aiBSrpos[1]
$X2 += $g_aiBSrpos[0]
$Y2 += $g_aiBSrpos[1]
EndIf
WinGetAndroidHandle()
If Not IsHWnd($HWnD) Then
Return SetError(1, "", False)
EndIf
Local $Pressed = 0
If StringLower($Button) == "left" Then
$Button = $WM_LBUTTONDOWN
$Pressed = 1
ElseIf StringLower($Button) == "right" Then
$Button = $WM_RBUTTONDOWN
$Pressed = 2
ElseIf StringLower($Button) == "middle" Then
$Button = $WM_MBUTTONDOWN
$Pressed = 10
If $Delay == 10 Then $Delay = 100
EndIf
Local $User32 = DllOpen("User32.dll")
If @error Then Return SetError(4, "", False)
MoveMouseOutBS()
DllCall($User32, "bool", "PostMessage", "hwnd", $HWnD, "int", $Button, "int", "0", "long", _MakeLong($X1, $Y1))
If @error Then
DllClose($User32)
Return SetError(5, "", False)
EndIf
If _Sleep($Delay / 2) Then Return SetError(-1, "", False)
DllCall($User32, "bool", "PostMessage", "hwnd", $HWnD, "int", $WM_MOUSEMOVE, "int", $Pressed, "long", _MakeLong($X2, $Y2))
If @error Then
DllClose($User32)
Return SetError(6, "", False)
EndIf
If _Sleep($Delay / 2) Then Return SetError(-1, "", False)
DllCall($User32, "bool", "PostMessage", "hwnd", $HWnD, "int", $Button + 1, "int", "0", "long", _MakeLong($X2, $Y2))
If @error Then
DllClose($User32)
Return SetError(7, "", False)
EndIf
DllClose($User32)
Return SetError(0, 0, True)
EndFunc
Func _MakeLong($LowWORD, $HiWORD)
Return BitOR($HiWORD * 0x10000, BitAND($LowWORD, 0xFFFF))
EndFunc
Func ClickDrag($X1, $Y1, $X2, $Y2, $Delay = 50)
If TestCapture() Then Return
Local $error = 0
If $g_bAndroidAdbClickDrag = True Then
AndroidClickDrag($X1, $Y1, $X2, $Y2, $g_bRunState)
$error = @error
If _Sleep($Delay / 5) Then Return SetError(-1, "", False)
EndIf
If $g_bAndroidAdbClickDrag = False Or $error <> 0 Then
Return _PostMessage_ClickDrag($X1, $Y1, $X2, $Y2, "left", $Delay)
EndIf
Return SetError(0, 0,($error = 0 ? True : False))
EndFunc
Func TestLanguage()
If $g_bRunState Then
If getOcrLanguage($aDetectLang[0], $aDetectLang[1]) = "english" Then
Setlog("Language setting is English: Correct.", $COLOR_INFO)
Else
SetLog("Language setting is Wrong: Change CoC language to English!", $COLOR_ERROR)
btnStop()
EndIf
EndIf
EndFunc
Func Deletefiles($Folder, $Filter, $daydiff = 120, $type = 0)
Local $FileListName = _FileListToArray($Folder, $Filter, 1)
Local $x, $t, $tmin = 0
If Not((Not IsArray($FileListName)) Or(@error = 1)) Then
For $x = $FileListName[0] To 1 Step -1
Local $FileDate = FileGetTime($Folder & $FileListName[$x])
If IsArray($FileDate) Then
Local $Date = $FileDate[0] & '/' & $FileDate[1] & '/' & $FileDate[2] & ' ' & $FileDate[3] & ':' & $FileDate[4] & ':' & $FileDate[5]
If _DateDiff('D', $Date, _NowCalc()) < $daydiff Then ContinueLoop
If $type = 0 Then
FileDelete($Folder & $FileListName[$x])
Else
FileRecycle($Folder & $FileListName[$x])
EndIf
Else
Return False
EndIf
Next
Else
Return False
EndIf
Return True
EndFunc
Func CloseRunningBot($sBotWindowTitle)
Local $param = ""
For $i = 1 To $g_asCmdLine[0]
If $param <> "" Then $param &= " "
$param &= $g_asCmdLine[$i]
Next
Local $otherPID = 0
Local $otherPIDs = 0
If $param <> "" Then
$otherPIDs = ProcessesExist(@AutoItExe, $param, 1, 1, Default, True)
EndIf
Local $otherHWnD = WinGetHandle($g_sBotTitle)
If @error = 0 Or UBound($otherPIDs) > 0 Then
If $otherHWnD <> 0 Then
$otherPID = WinGetProcess($otherHWnD)
Else
For $aProcess In $otherPIDs
Local $pid = $aProcess[0]
Local $sCommandLine = $aProcess[2]
If $pid <> @AutoItPID And StringInStr($sCommandLine, "AutoIt3Wrapper.au3") = 0 Then
$otherPID = $pid
ExitLoop
EndIf
Next
EndIf
If $otherPID > 0 And $otherPID <> @AutoItPID Then
SetDebugLog("Found existing " & $g_sBotTitle & " instance to close, PID " & $otherPID & ", HWnD " & $otherHWnD)
WerFaultClose("AutoIt v3 Script")
WerFaultClose(@AutoItExe)
If WinClose($otherHWnD) = 1 Then
SetDebugLog("Existing bot window closed")
EndIf
If ProcessWaitClose($otherPID, 30) = 0 Then
SetDebugLog("Existing bot window still there...")
WinKill($otherHWnD)
SetDebugLog("Existing bot window killed")
EndIf
If ProcessExists($otherPID) = $otherPID Then
SetDebugLog("Existing bot process still there...")
If KillProcess($otherPID, "CloseRunningBot") = True Then
SetDebugLog("Existing bot process now closed")
Return True
EndIf
Return False
EndIf
Return True
EndIf
EndIf
Return False
EndFunc
Func RestartBot($bCloseAndroid = True, $bAutostart = True)
SetDebugLog("Restart " & $g_sBotTitle)
Local $sCmdLine = ProcessGetCommandLine(@AutoItPID)
If @error <> 0 Then
SetLog("Cannot prepare to restart " & $g_sBotTitle & ", error code " & @error, $COLOR_RED)
Return SetError(1, 0, 0)
EndIf
If $bAutostart = True Then
IniWrite($g_sProfileConfigPath, "general", "Restarted", 1)
EndIf
If StringInStr($sCmdLine, " /restart") = 0 Then
$sCmdLine &= " /restart"
EndIf
If $bCloseAndroid = True Then
CloseAndroid("RestartBot")
_Sleep(1000)
EndIf
Local $pid = Run("cmd.exe /c start """" " & $sCmdLine, $g_sWorkingDir, @SW_HIDE)
If @error = 0 Then
SetLog("Restarting " & $g_sBotTitle)
_SleepStatus(60 * 1000)
Else
SetLog("Cannot restart " & $g_sBotTitle, $COLOR_RED)
EndIf
Return SetError(2, 0, 0)
EndFunc
Func WindowSystemMenu($HWnD, $iButton, $Action = Default, $DebugInfo = "")
Local $hSysMenu = _GUICtrlMenu_GetSystemMenu($HWnD, False)
If $Action = Default Then
Return _GUICtrlMenu_GetItemID($hSysMenu, $iButton, False) <> 0
EndIf
Local $enabled = WindowSystemMenu($HWnD, $iButton)
If $Action <> $enabled Then
Local $i, $c = _GUICtrlMenu_GetItemCount($hSysMenu)
Local $aVisible[$c]
For $i = 0 To $c - 1
$aVisible[$i] = _GUICtrlMenu_GetItemID($hSysMenu, $i)
Next
_GUICtrlMenu_GetSystemMenu($HWnD, True)
$hSysMenu = _GUICtrlMenu_GetSystemMenu($HWnD, False)
_GUICtrlMenu_DrawMenuBar($HWnD)
$c = _GUICtrlMenu_GetItemCount($hSysMenu)
If $DebugInfo = "" Then $DebugInfo = $iButton
For $i = 0 To $c - 1
Local $id = _GUICtrlMenu_GetItemID($hSysMenu, $i)
If $id = $iButton Then
If $Action = False Then
SetDebugLog("Hide SystemMenu Item: " & $DebugInfo)
_GUICtrlMenu_RemoveMenu($hSysMenu, $i)
Else
SetDebugLog("Show SystemMenu Item: " & $DebugInfo)
EndIf
ElseIf  _ArraySearch($aVisible, $id) = -1 Then
_GUICtrlMenu_RemoveMenu($hSysMenu, $i)
EndIf
Next
EndIf
EndFunc
Global $oMyError = ObjEvent("AutoIt.Error", "BotComError")
Func BotComError()
SetError(0, 0, 0)
If $g_iDebugSetlog = 1 Then
Setlog("We intercepted a COM Error !", $COLOR_ERROR)
Setlog("err.description is: " & $oMyError.description, $COLOR_ERROR)
Setlog("err.windescription:" & $oMyError.windescription, $COLOR_ERROR)
Setlog("err.number is: " & Hex($oMyError.number, 8), $COLOR_ERROR)
Setlog("err.lastdllerror is: " & $oMyError.lastdllerror, $COLOR_ERROR)
Setlog("err.scriptline is: " & $oMyError.scriptline, $COLOR_ERROR)
Setlog("err.source is: " & $oMyError.source, $COLOR_ERROR)
Setlog("err.helpfile is: " & $oMyError.helpfile, $COLOR_ERROR)
Setlog("err.helpcontext is: " & $oMyError.helpcontext, $COLOR_ERROR)
EndIf
SetError(0, 0, 0)
EndFunc
Func IsPageLoop($aCheckPixel, $iLoop = 30)
Local $IsPage = False
Local $i = 0
While $i < $iLoop
ForceCaptureRegion()
If _CheckPixel($aCheckPixel, $g_bCapturePixel) Then
$IsPage = True
ExitLoop
EndIf
If _Sleep($iDelayIsTrainPage1) Then ExitLoop
$i += 1
WEnd
Return $IsPage
EndFunc
Func IsTrainPage($writelogs = True, $iLoop = 30)
If IsPageLoop($aIsTrainPgChk1, $iLoop) Then
If($g_iDebugSetlog = 1 Or $g_iDebugClick = 1) And $writelogs = True Then Setlog("**Train Window OK**", $COLOR_ACTION)
Return True
EndIf
If $writelogs = True Then SetLog("Cannot find train Window...", $COLOR_ERROR)
If $g_iDebugImageSave = 1 Then DebugImageSave("IsTrainPage_")
If $iLoop > 1 Then AndroidPageError("IsTrainPage")
Return False
EndFunc
Func IsAttackPage()
If IsPageLoop($aIsAttackPage, 1) Then
If $g_iDebugSetlog = 1 Or $g_iDebugClick = 1 Then SetLog("**Attack Window OK**", $COLOR_ACTION)
Return True
EndIf
If $g_iDebugSetlog = 1 Or $g_iDebugClick = 1 Then
Local $colorRead = _GetPixelColor($aIsAttackPage[0], $aIsAttackPage[1], True)
SetLog("**Attack Window FAIL**", $COLOR_ACTION)
SetLog("expected in (" & $aIsAttackPage[0] & "," & $aIsAttackPage[1] & ")  = " & Hex($aIsAttackPage[2], 6) & " - Found " & $colorRead, $COLOR_ACTION)
EndIf
If $g_iDebugImageSave = 1 Then DebugImageSave("IsAttackPage_")
Return False
EndFunc
Func IsAttackWhileShieldPage($makeDebugImageSave = True)
If IsPageLoop($aIsAttackShield, 1) Then
If $g_iDebugSetlog = 1 Or $g_iDebugClick = 1 Then SetLog("**Attack Shield Window Open**", $COLOR_ACTION)
Return True
EndIf
If $g_iDebugSetlog = 1 Or $g_iDebugClick = 1 Then SetLog("**Attack Shield Window not open**", $COLOR_ACTION)
If $g_iDebugImageSave = 1 And $makeDebugImageSave = True Then DebugImageSave("IsAttackWhileShieldPage_")
Return False
EndFunc
Func IsMainPage($iLoop = 30)
If IsPageLoop($aIsMain, $iLoop) Then
If $g_iDebugSetlog = 1 Or $g_iDebugClick = 1 Then SetLog("**Main Window OK**", $COLOR_ACTION)
Return True
EndIf
If $g_iDebugSetlog = 1 Or $g_iDebugClick = 1 Then SetLog("**Main Window FAIL**", $COLOR_ACTION)
If $g_iDebugImageSave = 1 Then DebugImageSave("IsMainPage_")
If $iLoop > 1 Then AndroidPageError("IsMainPage")
Return False
EndFunc
Func IsMainChatOpenPage()
If IsPageLoop($aChatTab, 1) Then
If $g_iDebugSetlog = 1 Or $g_iDebugClick = 1 Then SetLog("**Chat Open Window OK**", $COLOR_ACTION)
Return True
EndIf
If $g_iDebugSetlog = 1 Or $g_iDebugClick = 1 Then SetLog("**Chat Open Window FAIL** " & $aChatTab[0] & "," & $aChatTab[1] & " " & _GetPixelColor($aChatTab[0], $aChatTab[1], True), $COLOR_ACTION)
If $g_iDebugImageSave = 1 Then DebugImageSave("IsMainChatOpenPage_")
Return False
EndFunc
Func IsClanInfoPage()
If IsPageLoop($aPerkBtn, 1) Then
If $g_iDebugSetlog = 1 Or $g_iDebugClick = 1 Then SetLog("**Clan Info Window OK**", $COLOR_ACTION)
Return True
EndIf
Local $result = _ColorCheck(_GetPixelColor(214, 106, True), Hex(0xFFFFFF, 6), 1) And _ColorCheck(_GetPixelColor(815, 58, True), Hex(0xD80402, 6), 5)
If $result Then
If $g_iDebugSetlog = 1 Or $g_iDebugClick = 1 Then SetLog("**Clan Info Window OK**", $COLOR_ACTION)
SetLog("Join a Clan to donate and receive troops!", $COLOR_ACTION)
Return True
Else
If $g_iDebugSetlog = 1 Or $g_iDebugClick = 1 Then SetLog("**Clan Info Window FAIL**", $COLOR_ACTION)
If $g_iDebugImageSave = 1 Then DebugImageSave("IsClanInfoPage_")
Return False
EndIf
EndFunc
Func IsLaunchAttackPage()
Local $resultnoshield = IsPageLoop($aFindMatchButton, 1)
Local $resultwithshield = IsPageLoop($aFindMatchButton2, 1)
If $resultnoshield Or $resultwithshield Then
If $g_iDebugSetlog = 1 Or $g_iDebugClick = 1 Then SetLog("**Launch Attack Window OK**", $COLOR_ACTION)
Return True
EndIf
If $g_iDebugSetlog = 1 Or $g_iDebugClick = 1 Then
Local $colorReadnoshield = _GetPixelColor($aFindMatchButton[0], $aFindMatchButton[1], True)
Local $colorReadwithshield = _GetPixelColor($aFindMatchButton2[0], $aFindMatchButton2[1], True)
SetLog("**Launch Attack Window FAIL**", $COLOR_ACTION)
SetLog("expected in (" & $aFindMatchButton[0] & "," & $aFindMatchButton[1] & ")  = " & Hex($aFindMatchButton[2], 6) & " or " & Hex($aFindMatchButton2[2], 6) & " - Found " & $colorReadnoshield & " or " & $colorReadwithshield, $COLOR_ACTION)
EndIf
If $g_iDebugImageSave = 1 Then DebugImageSave("IsLaunchAttackPage_")
Return False
EndFunc
Func IsEndBattlePage($writelog = True)
If IsPageLoop($aConfirmSurrender, 1) Then
If($g_iDebugSetlog = 1 Or $g_iDebugClick = 1) And $writelog = True Then SetLog("**End Battle Window OK**", $COLOR_ACTION)
Return True
Else
If($g_iDebugSetlog = 1 Or $g_iDebugClick = 1) And $writelog = True Then
Local $colorRead = _GetPixelColor($aConfirmSurrender[0], $aConfirmSurrender[1], True)
SetLog("**End Battle Window FAIL**", $COLOR_ACTION)
SetLog("expected in (" & $aConfirmSurrender[0] & "," & $aConfirmSurrender[1] & ")  = " & Hex($aConfirmSurrender[2], 6) & " - Found " & $colorRead, $COLOR_ACTION)
EndIf
If $g_iDebugImageSave = 1 And $writelog = True Then DebugImageSave("IsEndBattlePage_")
Return False
EndIf
EndFunc
Func IsReturnHomeBattlePage($useReturnValue = False, $makeDebugImageScreenshot = True)
If IsPageLoop($aReturnHomeButton, 1) Then
If $g_iDebugSetlog = 1 Or $g_iDebugClick = 1 Then SetLog("**Return Home Battle Window OK**", $COLOR_ACTION)
Return True
EndIf
If($g_iDebugSetlog = 1 Or $g_iDebugClick = 1) And($makeDebugImageScreenshot = True) Then SetLog("**Return Home Battle Window FAIL**", $COLOR_ACTION)
If $g_iDebugImageSave = 1 And $makeDebugImageScreenshot = True Then DebugImageSave("IsReturnHomeBattlePage_")
If $useReturnValue = True Then
Return False
Else
Return True
EndIf
EndFunc
Func IsPostDefenseSummaryPage()
Local $result
Local $GoldSpot = _GetPixelColor(330, 201 + $g_iMidOffsetY, $g_bCapturePixel)
Local $ElixirSpot = _GetPixelColor(334, 233 + $g_iMidOffsetY, $g_bCapturePixel)
$result = _ColorCheck($GoldSpot, Hex(0xF6E851, 6), 20) And _ColorCheck($ElixirSpot, Hex(0xE835E8, 6), 20)
If $result Then
If $g_iDebugSetlog = 1 Or $g_iDebugClick = 1 Then SetLog("**Post Defense Page visible**", $COLOR_ACTION)
Return True
Else
If $g_iDebugSetlog = 1 Or $g_iDebugClick = 1 Then SetLog("**Post Defense Page not visible**", $COLOR_ACTION)
If $g_iDebugImageSave = 1 Then
DebugImageSave("IsPostDefenseSummaryPage_")
EndIf
Return False
EndIf
EndFunc
Func MoveMouseOutBS()
If $g_bMoveMouseOutBS = False Then Return
Local $hWindow, $txtTitleW, $hControl, $aMousePos
$aMousePos = MouseGetPos()
If IsArray($aMousePos) Then
$hControl = _WindowFromPoint($aMousePos[0], $aMousePos[1])
If $hControl <> 0 Then
$hWindow = _WinAPI_GetAncestor($hControl, 2)
$txtTitleW = WinGetTitle($hWindow)
If $hWindow = $HWnD And $txtTitleW == $Title Then
MouseMove(@DesktopWidth + 100, Round(@DesktopHeight / 2), 0)
SetLog("Keep Your Mouse Out of BlueStacks Window while bot is running", $COLOR_ERROR)
EndIf
EndIf
EndIf
EndFunc
Func _WindowFromPoint($iX, $iY)
Local $aRet, $stPoint = DllStructCreate("long;long")
DllStructSetData($stPoint, 1, $iX)
DllStructSetData($stPoint, 2, $iY)
Local $stInt64 = DllStructCreate("int64", DllStructGetPtr($stPoint))
$aRet = DllCall("user32.dll", "hwnd", "WindowFromPoint", "int64", DllStructGetData($stInt64, 1))
$stPoint = 0
$stInt64 = 0
If @error Then Return SetError(0, 0, 0)
If $aRet[0] = 0 Then Return SetError(0, 0, 0)
Return $aRet[0]
EndFunc
Func KillProcess($pid, $process_info = "", $attempts = 3)
Local $iCount = 0
If $process_info <> "" Then $process_info = ", " & $process_info
While ProcessExists($pid) And $iCount < $attempts
If ProcessClose($pid) = 1 Then
SetDebugLog("KillProcess(" & $iCount & "): PID = " & $pid & " closed" & $process_info)
Else
Switch @error
Case 1
SetDebugLog("Process close error: OpenProcess failed")
Case 2
SetDebugLog("Process close error: AdjustTokenPrivileges Failed")
Case 3
SetDebugLog("Process close error: TerminateProcess Failed")
Case 4
SetDebugLog("Process close error: Cannot verify if process exists")
EndSwitch
EndIf
If ProcessExists($pid) Then
ShellExecute(@WindowsDir & "\System32\taskkill.exe", " -pid " & $pid, "", Default, @SW_HIDE)
If _Sleep(1000) Then Return False
If ProcessExists($pid) = 0 Then
SetDebugLog("KillProcess(" & $iCount & "): PID = " & $pid & " killed (using taskkill)" & $process_info)
EndIf
EndIf
If ProcessExists($pid) Then
ShellExecute(@WindowsDir & "\System32\taskkill.exe", "-f -t -pid " & $pid, "", Default, @SW_HIDE)
If _Sleep(1000) Then Return False
If ProcessExists($pid) = 0 Then
SetDebugLog("KillProcess(" & $iCount & "): PID = " & $pid & " killed (using taskkill -f -t)" & $process_info)
EndIf
EndIf
$iCount += 1
WEnd
If ProcessExists($pid) Then
SetDebugLog("KillProcess(" & $iCount & "): PID = " & $pid & " failed to kill" & $process_info, $COLOR_ERROR)
Return False
EndIf
Return True
EndFunc
Global $g_oWMI = ObjGet("winmgmts:{impersonationLevel=impersonate}!\\.\root\cimv2")
Func LaunchConsole($cmd, $param, ByRef $process_killed, $timeout = 10000, $bUseSemaphore = False)
If $bUseSemaphore = True Then
WaitForSemaphore(StringReplace($cmd, "\", "/"))
EndIf
Local $data, $pid, $hTimer
If StringLen($param) > 0 Then $cmd &= " " & $param
$hTimer = TimerInit()
$process_killed = False
If $g_iDebugSetlog = 1 Then Setlog("Func LaunchConsole: " & $cmd, $COLOR_DEBUG)
$pid = Run($cmd, "", @SW_HIDE, $STDERR_MERGED)
If $g_iDebugSetlog = 1 Then Setlog("Func LaunchConsole: command launched", $COLOR_DEBUG)
If $pid = 0 Then
SetLog("Launch faild: " & $cmd, $COLOR_ERROR)
Return
EndIf
Local $hProcess
If _WinAPI_GetVersion() >= 6.0 Then
$hProcess = _WinAPI_OpenProcess($PROCESS_QUERY_LIMITED_INFORMATION, 0, $pid)
Else
$hProcess = _WinAPI_OpenProcess($PROCESS_QUERY_INFORMATION, 0, $pid)
EndIf
$data = ""
Local $timeout_sec = Round($timeout / 1000)
While True
If $hProcess Then
_WinAPI_WaitForSingleObject($hProcess, $iDelaySleep)
Else
Sleep($iDelaySleep)
EndIf
$data &= StdoutRead($pid)
If @error Then ExitLoop
If($timeout > 0 And TimerDiff($hTimer) > $timeout) Then ExitLoop
WEnd
StdioClose($pid)
If $hProcess Then
_WinAPI_CloseHandle($hProcess)
$hProcess = 0
EndIf
CleanLaunchOutput($data)
If ProcessExists($pid) Then
If ProcessClose($pid) = 1 Then
If $g_iDebugSetlog = 1 Then SetLog("Process killed: " & $cmd, $COLOR_ERROR)
$process_killed = True
EndIf
EndIf
StdioClose($pid)
If $g_iDebugSetlog = 1 Then Setlog("Func LaunchConsole Output: " & $data, $COLOR_DEBUG)
Return $data
EndFunc
Func ProcessExists2($ProgramPath, $ProgramParameter = Default, $CompareMode = Default, $SearchMode = 0, $CompareCommandLineFunc = "", $strComputer = ".")
If IsNumber($ProgramPath) Then
Local $hProcess, $pid = $ProgramPath
If _WinAPI_GetVersion() >= 6.0 Then
$hProcess = _WinAPI_OpenProcess($PROCESS_QUERY_LIMITED_INFORMATION, 0, $pid)
Else
$hProcess = _WinAPI_OpenProcess($PROCESS_QUERY_INFORMATION, 0, $pid)
EndIf
If $hProcess Then
_WinAPI_CloseHandle($hProcess)
EndIf
Return(($hProcess) ? $pid : 0)
EndIf
If $ProgramParameter = Default Then
$ProgramParameter = ""
If $CompareMode = Default Then $CompareMode = 1
EndIf
If $CompareMode = Default Then
$CompareMode = 0
EndIf
SetDebugLog("ObjGet(""winmgmts:\\" & $strComputer & "\root\cimv2"")")
If @error <> 0 Then
SetDebugLog("Cannot create ObjGet(""winmgmts:\\" & $strComputer & "\root\cimv2")
Return 0
EndIf
Local $exe = $ProgramPath
Local $iLastBS = StringInStr($exe, "\", 0, -1)
If $iLastBS > 0 Then $exe = StringMid($exe, $iLastBS + 1)
Local $commandLine =($ProgramPath <> "" ?('"' & $ProgramPath & '"' &($ProgramParameter = "" ? "" : " " & $ProgramParameter)) : $ProgramParameter)
Local $commandLineCompare = StringReplace(StringReplace(StringReplace(StringReplace($commandLine, ".exe", "" , 1), " ", ""), '"', ""), "'", "")
Local $query = "Select * from Win32_Process"
If StringLen($commandLine) > 0 Then
$query &= " where "
If StringLen($ProgramPath) > 0 Then
$query &= "ExecutablePath like ""%" & StringReplace($ProgramPath,"\","\\") & "%"""
If $SearchMode = 1 And StringLen($ProgramParameter) > 0 Then $query &= " And "
EndIf
If $SearchMode = 1 And StringLen($ProgramParameter) > 0 Then $query &= "CommandLine like ""%" & StringReplace($ProgramParameter,"\","\\") & "%"""
EndIf
SetDebugLog("WMI Query: " & $query)
Local $oProcessColl = $g_oWMI.ExecQuery($query)
Local $Process, $PID = 0, $i = 0
For $Process In $oProcessColl
SetDebugLog($Process.Handle & " = " & $Process.ExecutablePath & " (" & $Process.CommandLine & ")")
If $PID = 0 Then
Local $processCommandLineCompare = StringReplace(StringReplace(StringReplace(StringReplace($Process.CommandLine, ".exe", "" , 1), " ", ""), '"', ""), "'", "")
If($CompareMode = 0 And $commandLineCompare = $processCommandLineCompare) Or($CompareMode = 0 And StringRight($commandLineCompare, StringLen($processCommandLineCompare)) = $processCommandLineCompare) Or($CompareMode = 0 And $CompareCommandLineFunc <> "" and Execute($CompareCommandLineFunc & "(""" & StringReplace($Process.CommandLine,"""","") & """)") = True) Or $CompareMode = 1 Then
$PID = Number($Process.Handle)
EndIf
EndIf
$i += 1
$Process = 0
Next
If $PID = 0 Then
SetDebugLog("Process by CommandLine not found: " & $ProgramPath &($ProgramParameter = "" ? "" :($ProgramPath <> "" ? " " : "") & $ProgramParameter))
Else
SetDebugLog("Found Process " & $PID & " by CommandLine: " & $ProgramPath &($ProgramParameter = "" ? "" :($ProgramPath <> "" ? " " : "") & $ProgramParameter))
EndIf
Return $PID
EndFunc
Func ProcessesExist($ProgramPath, $ProgramParameter = Default, $CompareMode = Default, $SearchMode = Default, $CompareCommandLineFunc = Default, $bReturnDetailedArray = Default, $strComputer=".")
If $ProgramParameter = Default Then $ProgramParameter = ""
If $CompareMode = Default Then $CompareMode = 0
If $SearchMode = Default Then $SearchMode = 0
If $CompareCommandLineFunc = Default Then $CompareCommandLineFunc = ""
If $bReturnDetailedArray = Default Then $bReturnDetailedArray = False
If IsNumber($ProgramPath) Then
Local $a[1] = [ProcessExists($ProgramPath)]
Return $a
EndIf
SetDebugLog("ObjGet(""winmgmts:\\" & $strComputer & "\root\cimv2"")")
If @error <> 0 Then
SetDebugLog("Cannot create ObjGet(""winmgmts:\\" & $strComputer & "\root\cimv2")
Local $a[0]
Return $a
EndIf
Local $exe = $ProgramPath
Local $iLastBS = StringInStr($exe, "\", 0, -1)
If $iLastBS > 0 Then $exe = StringMid($exe, $iLastBS + 1)
Local $commandLine =($ProgramPath <> "" ?('"' & $ProgramPath & '"' &($ProgramParameter = "" ? "" : " " & $ProgramParameter)) : $ProgramParameter)
Local $commandLineCompare = StringReplace(StringReplace(StringReplace(StringReplace($commandLine, ".exe", "" , 1), " ", ""), '"', ""), "'", "")
Local $query = "Select * from Win32_Process"
If StringLen($commandLine) > 0 Then
$query &= " where "
If StringLen($ProgramPath) > 0 Then
$query &= "ExecutablePath like ""%" & StringReplace($ProgramPath,"\","\\") & "%"""
If $SearchMode = 1 And StringLen($ProgramParameter) > 0 Then $query &= " And "
EndIf
If $SearchMode = 1 And StringLen($ProgramParameter) > 0 Then $query &= "CommandLine like ""%" & StringReplace($ProgramParameter,"\","\\") & "%"""
EndIf
SetDebugLog("WMI Query: " & $query)
Local $oProcessColl = $g_oWMI.ExecQuery($query)
Local $Process, $PID = 0, $i = 0
Local $PIDs[0]
For $Process In $oProcessColl
SetDebugLog($Process.Handle & " = " & $Process.ExecutablePath)
Local $processCommandLineCompare = StringReplace(StringReplace(StringReplace(StringReplace($Process.CommandLine, ".exe", "" , 1), " ", ""), '"', ""), "'", "")
If($CompareMode = 0 And $commandLineCompare = $processCommandLineCompare) Or($CompareMode = 0 And StringRight($commandLineCompare, StringLen($processCommandLineCompare)) = $processCommandLineCompare) Or($CompareMode = 0 And $CompareCommandLineFunc <> "" and Execute($CompareCommandLineFunc & "(""" & StringReplace($Process.CommandLine,"""","") & """)") = True) Or $CompareMode = 1 Then
$PID = Number($Process.Handle)
ReDim $PIDs[$i + 1]
Local $a = $PID
If $bReturnDetailedArray Then
Local $a = [$PID, $Process.ExecutablePath, $Process.CommandLine]
EndIf
$PIDs[$i] = $a
$i += 1
$Process = 0
EndIf
Next
If $i = 0 Then
SetDebugLog("No process found by CommandLine: " & $ProgramPath &($ProgramParameter = "" ? "" : " " & $ProgramParameter))
Else
SetDebugLog("Found " & $i & " process(es) with " & $ProgramPath &($ProgramParameter = "" ? "" : " " & $ProgramParameter))
EndIf
$oProcessColl = 0
Return $PIDs
EndFunc
Func ProcessGetCommandLine($PID, $strComputer = ".")
If Not IsNumber($PID) Then Return SetError(2, 0, -1)
SetDebugLog("ObjGet(""winmgmts:\\" & $strComputer & "\root\cimv2"")")
If @error <> 0 Then
SetDebugLog("Cannot create ObjGet(""winmgmts:\\" & $strComputer & "\root\cimv2")
Return SetError(3, 0, -1)
EndIf
Local $query = "Select * from Win32_Process where Handle = " & $PID
SetDebugLog("WMI Query: " & $query)
Local $oProcessColl = $g_oWMI.ExecQuery($query)
Local $Process, $i = 0
For $Process In $oProcessColl
SetDebugLog($Process.Handle & " = " & $Process.CommandLine)
SetError(0, 0, 0)
Local $sProcessCommandLine = $Process.CommandLine
$Process = 0
$oProcessColl = 0
Return $sProcessCommandLine
Next
SetDebugLog("Process not found with PID " & $PID)
$Process = 0
$oProcessColl = 0
Return SetError(1, 0, -1)
EndFunc
Func ProcessGetWmiProcess($PID, $strComputer = ".")
If Not IsNumber($PID) Then Return SetError(2, 0, -1)
SetDebugLog("ObjGet(""winmgmts:\\" & $strComputer & "\root\cimv2"")")
If @error <> 0 Then
SetDebugLog("Cannot create ObjGet(""winmgmts:\\" & $strComputer & "\root\cimv2")
Return SetError(3, 0, -1)
EndIf
Local $query = "Select * from Win32_Process where Handle = " & $PID
SetDebugLog("WMI Query: " & $query)
Local $oProcessColl = $g_oWMI.ExecQuery($query)
Local $Process, $i = 0
For $Process In $oProcessColl
SetDebugLog($Process.Handle & " = " & $Process.CommandLine)
SetError(0, 0, 0)
$Process = 0
$oProcessColl = 0
Return $Process
Next
SetDebugLog("Process not found with PID " & $PID)
$Process = 0
$oProcessColl = 0
Return SetError(1, 0, -1)
EndFunc
Func CleanLaunchOutput(ByRef $output)
$output = StringReplace($output, @CR & @CR, "")
$output = StringReplace($output, @CRLF & @CRLF, "")
If StringRight($output, 1) = @LF Then $output = StringLeft($output, StringLen($output) - 1)
If StringRight($output, 1) = @CR Then $output = StringLeft($output, StringLen($output) - 1)
EndFunc
Func SendAdbCommand($cmd, $EnsureConnected = True)
Local $process_killed, $connected_to, $pid, $i
Local $data = LaunchConsole($g_sAndroidAdbPath, "-s " & $g_sAndroidAdbDevice & " " & $cmd, $process_killed)
Local $error_device_not_found =(StringInStr($data, "device not found") > 0) Or $process_killed
If $error_device_not_found Then
SetDebugLog("ADB connection error, device " & $g_sAndroidAdbDevice & " not available")
If Not $EnsureConnected Then
SetDebugLog("Connect will not be initiated")
SetLog("ADB command not executed or interrupted: " & $cmd, $COLOR_ERROR)
Return False
EndIf
If ConnectAndroidAdb() Then
$data = LaunchConsole($g_sAndroidAdbPath, "-s " & $g_sAndroidAdbDevice & " " & $cmd, $process_killed)
$error_device_not_found =(StringInStr($data, "device not found") > 0) Or $process_killed
EndIf
If $error_device_not_found Then
SetLog("ADB command not executed: " & $cmd, $COLOR_ERROR)
Return False
EndIf
EndIf
Return True
EndFunc
Func FindExitButton($sButtonName)
Local $aCoor
Local $sDirectory = "exitbutton-bundle"
Local $sReturnProps = "objectpoints"
Local $result = ""
Local $aPosXY = ""
$aCoor = StringSplit(GetButtonRectangle($sButtonName), ",", $STR_NOCOUNT)
_CaptureRegion2($aCoor[0], $aCoor[1], $aCoor[2], $aCoor[3])
$result = findMultiple($sDirectory ,"FV" ,"FV", 0, 0, 1 , $sReturnProps, False)
If IsArray($result) then
$aPosXY = StringSplit(($result[0])[0], ",", $STR_NOCOUNT)
$aPosXY[0] += $aCoor[0]
$aPosXY[1] += $aCoor[1]
If $g_iDebugSetlog = 1 Then Setlog("FindExitButton: " & $sButtonName & " Button X|Y = " & $aPosXY[0] & "|" & $aPosXY[1], $COLOR_DEBUG)
Return $aPosXY
EndIf
If $g_iDebugSetlog = 1 Then SetLog("FindExitButton: " & $sButtonName & " NOT Found" , $COLOR_DEBUG)
Return $aPosXY
EndFunc
Func FindAdsXButton()
Local $sCoor
Local $sDirectory = "adsxbutton-bundle"
Local $sReturnProps = "objectpoints"
Local $result = ""
Local $aPosXY = ""
$sCoor = GetDiamondFromRect(GetButtonRectangle("AdsX"))
$result = findMultiple($sDirectory, $sCoor, "FV", 0, 0, 1, $sReturnProps, False)
If IsArray($result) then
$aPosXY = StringSplit(($result[0])[0], ",", $STR_NOCOUNT)
If $g_iDebugSetlog = 1 Then Setlog("FindAdsXButton: " & $g_sAndroidGameDistributor & " AdsX Button X|Y = " & $aPosXY[0] & "|" & $aPosXY[1], $COLOR_DEBUG)
Return $aPosXY
EndIf
If $g_iDebugSetlog = 1 Then Setlog("FindAdsXButton: " & $g_sAndroidGameDistributor & " NOT Found", $COLOR_DEBUG)
Return $aPosXY
EndFunc
Func GetButtonRectangle($sButtonName)
Local $btnRectangle = "0,0," & $g_iDEFAULT_WIDTH & "," & $g_iDEFAULT_HEIGHT
Switch $sButtonName
Case "Kunlun", "Huawei", "Kaopu", "Microvirt", "Yeshen"
$btnRectangle = GetDummyRectangle("345,394", 10)
Case "Qihoo"
$btnRectangle = GetDummyRectangle("302,456", 10)
Case "Baidu"
$btnRectangle = GetDummyRectangle("464,426", 10)
Case "OPPO"
$btnRectangle = GetDummyRectangle("476,412", 10)
Case "Anzhi"
$btnRectangle = GetDummyRectangle("328,371", 10)
Case "Lenovo"
$btnRectangle = GetDummyRectangle("477,476", 10)
Case "Aiyouxi"
$btnRectangle = GetDummyRectangle("468,392", 10)
Case "9game"
$btnRectangle = "349,352,369,436"
Case "VIVO", "Xiaomi"
$btnRectangle = GetDummyRectangle("353,387", 10)
Case "Guopan"
$btnRectangle = GetDummyRectangle("409,440", 10)
Case "AdsX"
$btnRectangle =($g_iDEFAULT_WIDTH / 2) & ",0," & $g_iDEFAULT_WIDTH & "," &($g_iDEFAULT_HEIGHT / 2)
Case Else
$btnRectangle = "0,0," & $g_iDEFAULT_WIDTH & "," & $g_iDEFAULT_HEIGHT
EndSwitch
Return $btnRectangle
EndFunc
Func _CaptureRegion(Const $iLeft = 0, Const $iTop = 0, Const $iRight = $g_iGAME_WIDTH, Const $iBottom = $g_iGAME_HEIGHT, Const $ReturnLocal_hHBitmap = False)
If $ReturnLocal_hHBitmap Then
Local $_hHBitmap
_CaptureGameScreen($_hHBitmap, $iLeft, $iTop, $iRight, $iBottom)
Return $_hHBitmap
EndIf
If $hHBitmap <> 0 And $hHBitmap <> $g_hHBitmapTest And $hHBitmap2 <> $hHBitmap Then
GdiDeleteHBitmap($hHBitmap)
EndIf
_CaptureGameScreen($hHBitmap, $iLeft, $iTop, $iRight, $iBottom)
If $hBitmap <> 0 Then
GdiDeleteBitmap($hBitmap)
EndIf
$hBitmap = _GDIPlus_BitmapCreateFromHBITMAP($hHBitmap)
GdiAddBitmap($hBitmap)
Return $hHBitmap
EndFunc
Func _CaptureRegion2(Const $iLeft = 0, Const $iTop = 0, Const $iRight = $g_iGAME_WIDTH, Const $iBottom = $g_iGAME_HEIGHT)
If $hHBitmap2 <> 0 And $hHBitmap2 <> $g_hHBitmapTest And $hHBitmap2 <> $hHBitmap Then
GdiDeleteHBitmap($hHBitmap2)
EndIf
_CaptureGameScreen($hHBitmap2, $iLeft, $iTop, $iRight, $iBottom)
EndFunc
Func _CaptureGameScreen(ByRef $_hHBitmap, Const $iLeft = 0, Const $iTop = 0, Const $iRight = $g_iGAME_WIDTH, Const $iBottom = $g_iGAME_HEIGHT)
Local $SuspendMode
If $g_hHBitmapTest = 0 Then
If $g_bRunState Then CheckAndroidRunning()
If $g_bChkBackgroundMode = True Then
Local $iW = Number($iRight) - Number($iLeft), $iH = Number($iBottom) - Number($iTop)
If $g_bAndroidAdbScreencap = True Then
$_hHBitmap = AndroidScreencap($iLeft, $iTop, $iW, $iH)
Else
$SuspendMode = ResumeAndroid(False)
Local $hCtrl = ControlGetHandle(GetCurrentAndroidHWnD(), $g_sAppPaneName, $g_sAppClassInstance)
If $hCtrl = 0 Then SetLog("AndroidHandle not found, contact support", $COLOR_ERROR)
Local $hDC_Capture = _WinAPI_GetDC($hCtrl)
Local $hMemDC = _WinAPI_CreateCompatibleDC($hDC_Capture)
$_hHBitmap = _WinAPI_CreateCompatibleBitmap($hDC_Capture, $iW, $iH)
Local $hObjectOld = _WinAPI_SelectObject($hMemDC, $_hHBitmap)
Local $flags = 0
DllCall("user32.dll", "int", "PrintWindow", "hwnd", $hCtrl, "handle", $hMemDC, "int", $flags)
_WinAPI_SelectObject($hMemDC, $_hHBitmap)
_WinAPI_BitBlt($hMemDC, 0, 0, $iW, $iH, $hDC_Capture, $iLeft, $iTop, $SRCCOPY)
_WinAPI_DeleteDC($hMemDC)
_WinAPI_SelectObject($hMemDC, $hObjectOld)
_WinAPI_ReleaseDC($hCtrl, $hDC_Capture)
SuspendAndroid($SuspendMode, False)
EndIf
Else
getBSPos()
$SuspendMode = ResumeAndroid(False)
$_hHBitmap = _ScreenCapture_Capture("", $iLeft + $g_aiBSpos[0], $iTop + $g_aiBSpos[1], $iRight + $g_aiBSpos[0] - 1, $iBottom + $g_aiBSpos[1] - 1, False)
SuspendAndroid($SuspendMode, False)
EndIf
ElseIf $iLeft > 0 Or $iTop > 0 Or $iRight < $g_iGAME_WIDTH Or $iBottom < $g_iGAME_HEIGHT Then
$_hHBitmap = GetHHBitmapArea($g_hHBitmapTest, $iLeft, $iTop, $iRight, $iBottom)
Else
$_hHBitmap = $g_hHBitmapTest
EndIf
GdiAddHBitmap($_hHBitmap)
$g_bForceCapture = False
EndFunc
Func _CaptureDispose()
If $hBitmap <> 0 Then GdiDeleteBitmap($hBitmap)
If $hHBitmap <> 0 Then GdiDeleteHBitmap($hHBitmap)
If $hHBitmap2 <> 0 Then GdiDeleteHBitmap($hHBitmap2)
If $g_hHBitmapTest <> 0 Then GdiDeleteHBitmap($g_hHBitmapTest)
$hBitmap = 0
$hHBitmap = 0
$hHBitmap2 = 0
$g_hHBitmapTest = 0
EndFunc
Func _CaptureRegion2Sync()
If $hHBitmap2 <> 0 And $hHBitmap2 <> $g_hHBitmapTest And $hHBitmap2 <> $hHBitmap Then
GdiDeleteHBitmap($hHBitmap2)
EndIf
$hHBitmap2 = GetHHBitmapArea($hHBitmap)
EndFunc
Func GetHHBitmapArea(Const $_hHBitmap, Const $iLeft = 0, Const $iTop = 0, Const $iRight = $g_iGAME_WIDTH, Const $iBottom = $g_iGAME_HEIGHT)
Local $iW = Number($iRight) - Number($iLeft), $iH = Number($iBottom) - Number($iTop)
Local $hDC = _WinAPI_GetDC($g_hFrmBot)
Local $hMemDC_src = _WinAPI_CreateCompatibleDC($hDC)
Local $hMemDC_dst = _WinAPI_CreateCompatibleDC($hDC)
Local $_hHBitmapArea = _WinAPI_CreateCompatibleBitmap($hDC, $iW, $iH)
Local $hObjectOld_src = _WinAPI_SelectObject($hMemDC_src, $_hHBitmap)
Local $hObjectOld_dst = _WinAPI_SelectObject($hMemDC_dst, $_hHBitmapArea)
_WinAPI_BitBlt($hMemDC_dst, 0, 0, $iW, $iH, $hMemDC_src, $iLeft, $iTop, $SRCCOPY)
_WinAPI_SelectObject($hMemDC_src, $hObjectOld_src)
_WinAPI_SelectObject($hMemDC_dst, $hObjectOld_dst)
_WinAPI_ReleaseDC($g_hFrmBot, $hDC)
_WinAPI_DeleteDC($hMemDC_src)
_WinAPI_DeleteDC($hMemDC_dst)
GdiAddHBitmap($_hHBitmapArea)
Return $_hHBitmapArea
EndFunc
Func FastCaptureRegion()
Return $g_bChkBackgroundMode = True And $g_bAndroidAdbScreencap = False
EndFunc
Func NeedCaptureRegion(Const $iCount)
Local $bNeedCaptureRegion = FastCaptureRegion() Or Mod($iCount, 10) = 0
Return $bNeedCaptureRegion
EndFunc
Func ForceCaptureRegion(Const $bForceCapture = True)
$g_bForceCapture = $bForceCapture
EndFunc
Func TestCapture(Const $hHBitmap = Default)
If $hHBitmap = Default Then Return $g_hHBitmapTest <> 0
If $g_hHBitmapTest <> 0 Then _WinAPI_DeleteObject($g_hHBitmapTest)
$g_hHBitmapTest = $hHBitmap
Return $hHBitmap
EndFunc
Func debugGdiHandle(Const $sSource, Const $bLogAlways = False)
If $g_iDebugGDICount <> 0 Then
Local $iCount = _WinAPI_GetGuiResources()
If $iCount <> $g_iDebugGDICount Or $bLogAlways Then
Local $sMsg = "GDI Handle Count: " & $iCount & " / " &($iCount - $g_iDebugGDICount) & ", active: " & $g_oDebugGDIHandles.Count & " (" & $sSource & ")"
$g_iDebugGDICount = $iCount
If $g_iDebugGDICount > $g_iDebugGDICountMax Then
$g_iDebugGDICountMax = $g_iDebugGDICount
$sMsg &= " NEW MAX!"
EndIf
SetDebugLog($sMsg)
EndIf
EndIf
EndFunc
Func GdiAddBitmap(Const $_hBitmap)
If $g_iDebugGDICount <> 0 Then
$g_oDebugGDIHandles("Bitmap:" & $_hBitmap) = Time()
SetDebugLog("GdiAddBitmap " & $_hBitmap)
EndIf
EndFunc
Func GdiDeleteBitmap(ByRef $_hBitmap)
Local $Result = _GDIPlus_BitmapDispose($_hBitmap)
If $Result <> True Or @error Then SetDebugLog("GdiDeleteBitmap not deleted: " & $_hBitmap)
If $g_iDebugGDICount <> 0 Then
$g_oDebugGDIHandles.Remove("Bitmap:" & $_hBitmap)
SetDebugLog("GdiDeleteBitmap " & $_hBitmap)
EndIf
$_hBitmap = 0
EndFunc
Func GdiAddHBitmap(Const $_hHBitmap)
If $g_iDebugGDICount <> 0 Then
$g_oDebugGDIHandles("HBitmap:" & $_hHBitmap) = Time()
SetDebugLog("GdiAddHBitmap " & $_hHBitmap)
EndIf
EndFunc
Func GdiDeleteHBitmap(ByRef $_hHBitmap)
Local $Result = _WinAPI_DeleteObject($_hHBitmap)
If $Result <> True Then SetDebugLog("GdiDeleteHBitmap not deleted: " & $_hHBitmap)
If $g_iDebugGDICount <> 0 Then
$g_oDebugGDIHandles.Remove("HBitmap:" & $_hHBitmap)
SetDebugLog("GdiDeleteHBitmap " & $_hHBitmap)
EndIf
$_hHBitmap = 0
EndFunc
Func __GDIPlus_Startup()
_GDIPlus_Startup()
$g_iDebugGDICountMax = _WinAPI_GetGuiResources()
debugGdiHandle("__GDIPlus_Startup", True)
EndFunc
Func __GDIPlus_Shutdown()
_CaptureDispose()
_GDIPlus_Shutdown()
debugGdiHandle("__GDIPlus_Shutdown", True)
EndFunc
Func _ColorCheck($nColor1, $nColor2, $sVari = 5, $Ignore = Default)
Local $Red1, $Red2, $Blue1, $Blue2, $Green1, $Green2
$Red1 = Dec(StringMid(String($nColor1), 1, 2))
$Blue1 = Dec(StringMid(String($nColor1), 3, 2))
$Green1 = Dec(StringMid(String($nColor1), 5, 2))
$Red2 = Dec(StringMid(String($nColor2), 1, 2))
$Blue2 = Dec(StringMid(String($nColor2), 3, 2))
$Green2 = Dec(StringMid(String($nColor2), 5, 2))
Switch $Ignore
Case "Red"
If Abs($Blue1 - $Blue2) > $sVari Then Return False
If Abs($Green1 - $Green2) > $sVari Then Return False
Case "Heroes"
If Abs($Blue1 - $Blue2) > $sVari Then Return False
If Abs($Red1 - $Red2) > $sVari Then Return False
Case Else
If Abs($Blue1 - $Blue2) > $sVari Then Return False
If Abs($Green1 - $Green2) > $sVari Then Return False
If Abs($Red1 - $Red2) > $sVari Then Return False
EndSwitch
Return True
EndFunc
Func _CheckPixel($aScreenCode, $bNeedCapture = Default, $Ignore = Default, $sLogText = Default, $LogTextColor = Default, $bSilentSetLog = Default)
If $bNeedCapture = Default Then $bNeedCapture = False
If $g_iDebugSetlog = 1 And $sLogText <> Default And IsString($sLogText) Then
$sLogText &= ", Expected: " & Hex($aScreenCode[2], 6) & ", Tolerance: " & $aScreenCode[3]
Else
$sLogText = Default
EndIf
If _ColorCheck(  _GetPixelColor($aScreenCode[0], $aScreenCode[1], $bNeedCapture, $sLogText, $LogTextColor, $bSilentSetLog), Hex($aScreenCode[2], 6), $aScreenCode[3], $Ignore) Then
Return True
EndIf
Return False
EndFunc
Func GetListPixel($listPixel, $sDelim = "-", $sName = "")
If $sName <> "" Then debugAttackCSV("GetListPixel for " & $sName & ": " & $listPixel)
Local $listPixelSideStr = StringSplit($listPixel, "|")
If($listPixelSideStr[0] > 1) Then
Local $listPixelSide[UBound($listPixelSideStr) - 1]
For $i = 0 To UBound($listPixelSide) - 1
Local $pixel = GetPixel($listPixelSideStr[$i + 1], $sDelim)
If UBound($pixel) > 1 Then
$listPixelSide[$i] = $pixel
EndIf
Next
Return $listPixelSide
Else
If StringInStr($listPixel, $sDelim) > 0 Then
Local $pixel = GetPixel($listPixel, $sDelim)
Local $listPixelHere = [$pixel]
Return $listPixelHere
EndIf
Return -1
EndIf
EndFunc
Func GetPixel($sPixel, $sDelim = "-")
Local $pixel = StringSplit($sPixel, $sDelim, $STR_NOCOUNT)
If UBound($pixel) < 2 Then Return $pixel
$pixel[0] = Int($pixel[0])
$pixel[1] = Int($pixel[1])
Return $pixel
EndFunc
Func GetPixelDistance(Const ByRef $Pixel0, Const ByRef $Pixel1)
Local $a = $Pixel0[0] - $Pixel1[0]
Local $b = $Pixel0[1] - $Pixel1[1]
Local $d = Sqrt($a * $a + $b * $b)
Return $d
EndFunc
Func GetPixelListDistance(Const $PixelArray, Const $iMaxAllowedPixelDistance)
Local $dTotal = 0
Local $i
Local $iMax = UBound($PixelArray) - 1
If $iMax < 1 Then Return $dTotal
Local $prePixel = $PixelArray[0]
Local $curPixel
Local $d
For $i = 1 To $iMax
$curPixel = $PixelArray[$i]
If UBound($prePixel) > 1 And UBound($curPixel) > 1 Then
$d = GetPixelDistance($prePixel, $curPixel)
If $d <= $iMaxAllowedPixelDistance Then $dTotal += $d
EndIf
$prePixel = $curPixel
Next
Return $dTotal
EndFunc
Func GetLocationItem($functionName)
If $g_iDebugSetlog = 1 Or $g_iDebugBuildingPos = 1 Then
Local $hTimer = TimerInit()
Setlog("GetLocationItem(" & $functionName & ")", $COLOR_DEBUG)
EndIf
Local $resultHere = DllCall($g_hLibFunctions, "str", $functionName, "ptr", $hHBitmap2)
If UBound($resultHere) > 0 Then
If $g_iDebugBuildingPos = 1 Then Setlog("#*# " & $functionName & ": " & $resultHere[0] & "calc in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds ", $COLOR_DEBUG1)
Return GetListPixel($resultHere[0])
Else
If $g_iDebugBuildingPos = 1 Then Setlog("#*# " & $functionName & ": NONE calc in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds ", $COLOR_DEBUG1)
EndIf
EndFunc
Func _GetPixelColor($iX, $iY, $bNeedCapture = False, $sLogText = Default, $LogTextColor = Default, $bSilentSetLog = Default)
Local $aPixelColor = 0
If $bNeedCapture = False Or $g_bRunState = False Then
$aPixelColor = _GDIPlus_BitmapGetPixel($hBitmap, $iX, $iY)
Else
_CaptureRegion($iX - 1, $iY - 1, $iX + 1, $iY + 1)
$aPixelColor = _GDIPlus_BitmapGetPixel($hBitmap, 1, 1)
EndIf
If $sLogText <> Default And IsString($sLogText) Then
Local $String = $sLogText & " at X,Y: " & $iX & "," & $iY & " Found: " & Hex($aPixelColor, 6)
SetDebugLog($String, $LogTextColor, $bSilentSetLog)
EndIf
Return Hex($aPixelColor, 6)
EndFunc
Func IsPixelColorGray($sPixelColorRgbHex)
If StringLen($sPixelColorRgbHex) <> 6 Then Return False
Local $sRed = StringLeft($sPixelColorRgbHex, 2)
Local $sBlue = StringRight($sPixelColorRgbHex, 2)
Return $sRed = $sBlue And $sRed = StringMid($sPixelColorRgbHex, 3, 2)
EndFunc
Func _PixelSearch($iLeft, $iTop, $iRight, $iBottom, $iColor, $iColorVariation, $bNeedCapture = True)
Local $x1, $x2, $y1, $y2
If $bNeedCapture = True Then
_CaptureRegion($iLeft, $iTop, $iRight, $iBottom)
$x1 = $iRight - $iLeft
$x2 = 0
$y1 = 0
$y2 = $iBottom - $iTop
Else
$x1 = $iRight
$x2 = $iLeft
$y1 = $iTop
$y2 = $iBottom
EndIf
For $x = $x1 To $x2 Step -1
For $y = $y1 To $y2
If _ColorCheck(_GetPixelColor($x, $y), $iColor, $iColorVariation) Then
Local $Pos[2] = [$iLeft + $x - $x2, $iTop + $y - $y1]
Return $Pos
EndIf
Next
Next
Return 0
EndFunc
Func _MultiPixelSearch($iLeft, $iTop, $iRight, $iBottom, $xSkip, $ySkip, $firstColor, $offColor, $iColorVariation)
_CaptureRegion($iLeft, $iTop, $iRight, $iBottom)
Local $offColorVariation = UBound($offColor, 2) > 3
For $x = 0 To $iRight - $iLeft Step $xSkip
For $y = 0 To $iBottom - $iTop Step $ySkip
If _ColorCheck(_GetPixelColor($x, $y), $firstColor, $iColorVariation) Then
Local $allchecked = True
Local $iCV = $iColorVariation
For $i = 0 To UBound($offColor) - 1
If $offColorVariation = True Then $iCV = $offColor[$i][3]
If _ColorCheck(_GetPixelColor($x + $offColor[$i][1], $y + $offColor[$i][2]), Hex($offColor[$i][0], 6), $iCV) = False Then
$allchecked = False
ExitLoop
EndIf
Next
If $allchecked Then
Local $Pos[2] = [$iLeft + $x, $iTop + $y]
Return $Pos
EndIf
EndIf
Next
Next
Return 0
EndFunc
Func _MultiPixelSearch2($iLeft, $iTop, $iRight, $iBottom, $xSkip, $ySkip, $firstColor, $offColor, $iColorVariation)
_CaptureRegion($iLeft, $iTop, $iRight, $iBottom)
Local $offColorVariation = UBound($offColor, 2) > 3
For $y = 0 To $iBottom - $iTop Step $ySkip
For $x = 0 To $iRight - $iLeft Step $xSkip
If _ColorCheck(_GetPixelColor($x, $y), $firstColor, $iColorVariation) Then
Local $allchecked = True
Local $iCV = $iColorVariation
For $i = 0 To UBound($offColor) - 1
If $offColorVariation = True Then $iCV = $offColor[$i][3]
If _ColorCheck(_GetPixelColor($x + $offColor[$i][1], $y + $offColor[$i][2]), Hex($offColor[$i][0], 6), $iCV) = False Then
$allchecked = False
ExitLoop
EndIf
Next
If $allchecked Then
Local $Pos[2] = [$iLeft + $x, $iTop + $y]
Return $Pos
EndIf
EndIf
Next
Next
Return 0
EndFunc
Func WaitforPixel($iLeft, $iTop, $iRight, $iBottom, $firstColor, $iColorVariation, $maxDelay = 10)
For $i = 1 To $maxDelay * 10
Local $result = _PixelSearch($iLeft, $iTop, $iRight, $iBottom, $firstColor, $iColorVariation)
If IsArray($result) Then Return True
If _Sleep(50) Then Return
Next
Return False
EndFunc
Func boolPixelSearch($pixel1, $pixel2, $pixel3, $variation = 10)
If _ColorCheck(_GetPixelColor($pixel1[0], $pixel1[1]), $pixel1[2], $variation) And _ColorCheck(_GetPixelColor($pixel2[0], $pixel2[1]), $pixel2[2], $variation) And _ColorCheck(_GetPixelColor($pixel3[0], $pixel3[1]), $pixel3[2], $variation) Then Return True
Return False
EndFunc
Func isInsideDiamondXY($Coordx, $Coordy)
Local $aCoords = [$Coordx, $Coordy]
Return isInsideDiamond($aCoords)
EndFunc
Func isInsideDiamond($aCoords)
Local $x = $aCoords[0], $y = $aCoords[1], $xD, $yD
Local $Left = 0, $Right = 855, $Top = 20, $Bottom = 675
Local $aDiamond[2][2] = [[$Left, $Top], [$Right, $Bottom]]
Local $aMiddle = [($aDiamond[0][0] + $aDiamond[1][0]) / 2,($aDiamond[0][1] + $aDiamond[1][1]) / 2]
$xD = $aMiddle[0]
$yD = $Top
ConvertToVillagePos($xD, $yD)
$Top = $yD
$xD = $aMiddle[0]
$yD = $Bottom
ConvertToVillagePos($xD, $yD)
$Bottom = $yD
$xD = $Left
$yD = $aMiddle[1]
ConvertToVillagePos($xD, $yD)
$Left = $xD
$xD = $Right
$yD = $aMiddle[1]
ConvertToVillagePos($xD, $yD)
$Right = $xD
Local $aDiamond[2][2] = [[$Left, $Top], [$Right, $Bottom]]
Local $aMiddle = [($aDiamond[0][0] + $aDiamond[1][0]) / 2,($aDiamond[0][1] + $aDiamond[1][1]) / 2]
Local $aSize = [$aMiddle[0] - $aDiamond[0][0], $aMiddle[1] - $aDiamond[0][1]]
Local $DX = Abs($x - $aMiddle[0])
Local $DY = Abs($y - $aMiddle[1])
If($DX / $aSize[0] + $DY / $aSize[1] <= 1) Then
If $x < 68 And $y > 316 Then
If $g_iDebugSetlog = 1 Then SetDebuglog("Coordinate Inside Village, but Exclude CHAT")
Return False
ElseIf $y < 63 Then
If $g_iDebugSetlog = 1 Then SetDebuglog("Coordinate Inside Village, but Exclude BUILDER")
Return False
ElseIf $x > 692 And $y > 156 And $y < 210 Then
If $g_iDebugSetlog = 1 Then SetDebuglog("Coordinate Inside Village, but Exclude GEMS")
Return False
EndIf
Return True
Else
If $g_iDebugSetlog = 1 Then SetDebuglog("Coordinate Outside Village")
Return False
EndIf
EndFunc
Func getBuilderCount($bSuppressLog = False)
Local $sBuilderInfo, $aGetBuilders
If IsMainPage() = True Then
$sBuilderInfo = getBuilders($aBuildersDigits[0], $aBuildersDigits[1])
If StringInStr($sBuilderInfo, "#") > 0 Then
$aGetBuilders = StringSplit($sBuilderInfo, "#", $STR_NOCOUNT)
$iFreeBuilderCount = Int($aGetBuilders[0])
If $iTestFreeBuilderCount <> -1 Then $iFreeBuilderCount = $iTestFreeBuilderCount
$iTotalBuilderCount = Int($aGetBuilders[1])
If $g_iDebugSetlog = 1 And $bSuppressLog = False Then Setlog("No. of Free/Total Builders: " & $iFreeBuilderCount & "/" & $iTotalBuilderCount, $COLOR_DEBUG)
Return True
Else
SetLog("Bad OCR read Free/Total Builders", $COLOR_ERROR)
EndIf
Else
SetLog("Unable to read Builders info at this time", $COLOR_ERROR)
EndIf
If $g_iDebugSetlog = 1 Or $g_iDebugImageSave = 1 Then Debugimagesave("getBuilderCount_")
If checkObstacles() Then checkMainScreen()
Return False
EndFunc
Func BuildingInfo($iXstart, $iYstart)
Local $sBldgText, $sBldgLevel, $aString
Local $aResult[3] = ["", "", ""]
$sBldgText = getNameBuilding($iXstart, $iYstart)
If $sBldgText = "" Then
If _Sleep($iDelayBuildingInfo1) Then Return
$sBldgText = getNameBuilding($iXstart, $iYstart)
EndIf
If $g_iDebugSetlog = 1 Then Setlog("Read building Name String = " & $sBldgText, $COLOR_DEBUG)
If StringInStr($sBldgText, "Cart") Then $sBldgText &= " (FakeLevel 100)"
If StringInStr($sBldgText, "Tree") Then $sBldgText &= " (FakeLevel 99)"
If StringInStr($sBldgText, "Mush") Then $sBldgText &= " (FakeLevel 98)"
If StringInStr($sBldgText, "Trunk") Then $sBldgText &= " (FakeLevel 97)"
If StringInStr($sBldgText, "Bush") Then $sBldgText &= " (FakeLevel 96)"
If StringInStr($sBldgText, "Bark") Then $sBldgText &= " (FakeLevel 95)"
If StringInStr($sBldgText, "Gem") Then $sBldgText &= " (FakeLevel 94)"
$aString = StringSplit($sBldgText, "(")
If $aString[0] = 2 Then
If $g_iDebugSetlog = 1 Then Setlog("1st $aString = " & $aString[0] & ", " & $aString[1] & ", " & $aString[2], $COLOR_DEBUG)
If $aString[1] <> "" Then $aResult[1] = StringStripWS($aString[1], 7)
If $aString[2] <> "" Then
$sBldgLevel = $aString[2]
$aString = StringSplit($sBldgLevel, ")")
If $aString[0] = 2 Then
If StringInStr($aString[1], "Broken") Then $aString[1] &= " 200"
If $g_iDebugSetlog = 1 Then Setlog("2nd $aString = " & $aString[0] & ", " & $aString[1] & ", " & $aString[2], $COLOR_DEBUG)
If $aString[1] <> "" Then $sBldgLevel = $aString[1]
EndIf
$aString = StringSplit($sBldgLevel, " ")
If $aString[0] = 2 Then
If $g_iDebugSetlog = 1 Then Setlog("3rd $aString = " & $aString[0] & ", " & $aString[1] & ", " & $aString[2], $COLOR_DEBUG)
If $aString[2] <> "" Then $aResult[2] = Number($aString[2])
EndIf
EndIf
EndIf
If $aResult[1] <> "" Then $aResult[0] = 1
If $aResult[2] <> "" Then $aResult[0] += 1
If $aResult[2] > 90 Then
If $aResult[2] = 200 Then
$aResult[2] = "Broken"
Else
$aResult[2] = ""
EndIf
EndIf
Return $aResult
EndFunc
Func getNameBuilding($x_start, $y_start)
Return getOcrAndCapture("coc-build", $x_start, $y_start, 377, 27)
EndFunc
Func getGoldVillageSearch($x_start, $y_start)
Return getOcrAndCapture("coc-v-g", $x_start, $y_start, 90, 16, True)
EndFunc
Func getRemainTrainTimer($x_start, $y_start)
Return getOcrAndCapture("coc-RemainTrain", $x_start, $y_start, 70, 12, True)
EndFunc
Func getElixirVillageSearch($x_start, $y_start)
Return getOcrAndCapture("coc-v-e", $x_start, $y_start, 90, 16, True)
EndFunc
Func getResourcesValueTrainPage($x_start, $y_start)
Return getOcrAndCapture("coc-ms", $x_start, $y_start, 100, 18, True)
EndFunc
Func getDarkElixirVillageSearch($x_start, $y_start)
Return getOcrAndCapture("coc-v-de", $x_start, $y_start, 75, 18, True)
EndFunc
Func getTrophyVillageSearch($x_start, $y_start)
Return getOcrAndCapture("coc-v-t", $x_start, $y_start, 75, 18, True)
EndFunc
Func getTrophyMainScreen($x_start, $y_start)
Return getOcrAndCapture("coc-ms", $x_start, $y_start, 50, 16, True)
EndFunc
Func getTrophyLossAttackScreen($x_start, $y_start)
Return getOcrAndCapture("coc-t-p", $x_start, $y_start, 50, 16, True)
EndFunc
Func getUpgradeResource($x_start, $y_start)
Return getOcrAndCapture("coc-u-r", $x_start, $y_start, 98, 16, True)
EndFunc
Func getResourcesMainScreen($x_start, $y_start)
Return getOcrAndCapture("coc-ms", $x_start, $y_start, 110, 16, True)
EndFunc
Func getResourcesLoot($x_start, $y_start)
Return getOcrAndCapture("coc-loot", $x_start, $y_start, 107, 22, True)
EndFunc
Func getResourcesLootDE($x_start, $y_start)
Return getOcrAndCapture("coc-loot", $x_start, $y_start, 75, 22, True)
EndFunc
Func getResourcesLootT($x_start, $y_start)
Return getOcrAndCapture("coc-loot", $x_start, $y_start, 37, 22, True)
EndFunc
Func getResourcesBonus($x_start, $y_start)
Return getOcrAndCapture("coc-bonus", $x_start, $y_start, 98, 16, True)
EndFunc
Func getResourcesBonusPerc($x_start, $y_start)
Return getOcrAndCapture("coc-bonus", $x_start, $y_start, 48, 16, True)
EndFunc
Func getLabUpgrdResourceWht($x_start, $y_start)
Return getOcrAndCapture("coc-lab-w", $x_start, $y_start, 60, 14, True)
EndFunc
Func getLabUpgrdResourceRed($x_start, $y_start)
Return getOcrAndCapture("coc-lab-r", $x_start, $y_start, 60, 14, True)
EndFunc
Func getBldgUpgradeTime($x_start, $y_start)
Return getOcrAndCapture("coc-uptime", $x_start, $y_start, 42, 18)
EndFunc
Func getLabUpgradeTime($x_start, $y_start)
Return getOcrAndCapture("coc-uptime2", $x_start, $y_start, 40, 20)
EndFunc
Func getHeroUpgradeTime($x_start, $y_start)
Return getOcrAndCapture("coc-uptime2", $x_start, $y_start, 68, 20)
EndFunc
Func getChatString($x_start, $y_start, $language)
Return getOcrAndCapture($language, $x_start, $y_start, 280, 16)
EndFunc
Func getBuilders($x_start, $y_start)
Return getOcrAndCapture("coc-Builders", $x_start, $y_start, 40, 18, True)
EndFunc
Func getProfile($x_start, $y_start)
Return getOcrAndCapture("coc-profile", $x_start, $y_start, 46, 11, True)
EndFunc
Func getTroopCountSmall($x_start, $y_start, $bNeedNewCapture = Default)
Return getOcrAndCapture("coc-t-s", $x_start, $y_start, 53, 15, True, Default, $bNeedNewCapture)
EndFunc
Func getTroopCountBig($x_start, $y_start, $bNeedNewCapture = Default)
Return getOcrAndCapture("coc-t-b", $x_start, $y_start, 53, 16, True, Default, $bNeedNewCapture)
EndFunc
Func getTroopsSpellsLevel($x_start, $y_start)
Return getOcrAndCapture("coc-spellslevel", $x_start, $y_start, 20, 14, True)
EndFunc
Func getArmyTroopQuantity($x_start, $y_start)
Return getOcrAndCapture("coc-train-quant", $x_start, $y_start, 45, 12, True)
EndFunc
Func getArmyTroopKind($x_start, $y_start)
Return getOcrAndCapture("coc-train-t-kind", $x_start, $y_start, 59, 11, True)
EndFunc
Func getArmyCampCap($x_start, $y_start)
Return getOcrAndCapture("coc-ms", $x_start, $y_start, 82, 16, True)
EndFunc
Func getCastleDonateCap($x_start, $y_start)
Return getOcrAndCapture("coc-army", $x_start, $y_start, 30, 14, True)
EndFunc
Func getBarracksTroopQuantity($x_start, $y_start)
Return getOcrAndCapture("coc-train", $x_start, $y_start, 52, 16, True)
EndFunc
Func getAttackDisable($x_start, $y_start)
Return getOcrAndCapture("coc-dis", $x_start, $y_start, 118, 24, True)
EndFunc
Func getOcrLanguage($x_start, $y_start)
Return getOcrAndCapture("coc-ms-testl", $x_start, $y_start, 93, 16, True)
EndFunc
Func getOcrSpellDetection($x_start, $y_start)
Local $result = getOcrAndCapture("coc-t-spells2", $x_start, $y_start, 50, 30, True)
Local $PositionSpecialCaracter = 0
$PositionSpecialCaracter = StringInStr($result, "§")
If $PositionSpecialCaracter > 0 Then
Return StringLeft($result, $PositionSpecialCaracter - 1)
Else
Return $result
EndIf
EndFunc
Func getOcrSpellQuantity($x_start, $y_start)
Return getOcrAndCapture("coc-t-t", $x_start, $y_start, 25, 12, True)
EndFunc
Func getOcrClanLevel($x_start, $y_start)
Return getOcrAndCapture("coc-clanlevel", $x_start, $y_start, 20, 19, True)
EndFunc
Func getOcrSpaceCastleDonate($x_start, $y_start)
Return getOcrAndCapture("coc-totalreq", $x_start, $y_start, 45, 12, True)
EndFunc
Func getOcrDonationTroopsDetection($x_start, $y_start)
Local $result = getOcrAndCapture("coc-donationtroop", $x_start, $y_start, 45, 30, True)
Local $PositionSpecialCaracter = 0
$PositionSpecialCaracter = StringInStr($result, "§")
If $PositionSpecialCaracter > 0 Then
Return StringLeft($result, $PositionSpecialCaracter - 1)
Else
Return $result
EndIf
EndFunc
Func getOcrOverAllDamage($x_start, $y_start)
Return getOcrAndCapture("coc-overalldamage", $x_start, $y_start, 50, 20, True)
EndFunc
Func getOcrGuardShield($x_start, $y_start)
Return getOcrAndCapture("coc-guardshield", $x_start, $y_start, 68, 15)
EndFunc
Func getOcrPBTtime($x_start, $y_start)
Return getOcrAndCapture("coc-pbttime", $x_start, $y_start, 59, 15)
EndFunc
Func getOcrMaintenanceTime($x_start, $y_start, $sLogText = Default, $LogTextColor = Default, $bSilentSetLog = Default)
Local $result = getOcrAndCapture("coc-reloadmsg", $x_start, $y_start, 116, 19, True)
Local $String = ""
If $sLogText = Default Then
$String = "getOcrMaintenanceTime: " & $result
Else
$String = $sLogText & " " & $result
EndIf
If $g_iDebugSetlog = 1 Then
SetDebugLog($String, $LogTextColor, $bSilentSetLog)
ElseIf $result <> "" Then
SetDebugLog($String, $LogTextColor, True)
EndIF
Return $result
EndFunc
Func getOcrRateCoc($x_start, $y_start, $sLogText = Default, $LogTextColor = Default, $bSilentSetLog = Default)
Local $result = getOcrAndCapture("coc-ratecoc", $x_start, $y_start, 42, 28, True)
Local $String = ""
If $sLogText = Default Then
$String = "getOcrRateCoc: " & $result
Else
$String = $sLogText & " " & $result
EndIf
If $g_iDebugSetlog = 1 Then
SetDebugLog($String, $LogTextColor, $bSilentSetLog)
ElseIf $result <> "" Then
SetDebugLog($String, $LogTextColor, True)
EndIf
Return $result
EndFunc
Func getRemainTLaboratory($x_start, $y_start)
Return getOcrAndCapture("coc-RemainLaboratory", $x_start, $y_start, 192, 24)
EndFunc
Func getRemainTHero($x_start, $y_start)
Return getOcrAndCapture("coc-remainhero", $x_start, $y_start, 55, 12, True)
EndFunc
Func getHeroStatus($x_start, $y_start)
Return getOcrAndCapture("coc-herostatus", $x_start, $y_start, 20, 20)
EndFunc
Func getRequestRemainTime($x_start, $y_start)
Return getOcrAndCapture("coc-CCremainTime", $x_start, $y_start, 30, 14)
EndFunc
Func getCloudTextShort($x_start, $y_start, $sLogText = Default, $LogTextColor = Default, $bSilentSetLog = Default)
Local $result = getOcrAndCapture("coc-cloudsearch", $x_start, $y_start, 51, 27)
If $g_iDebugSetlog = 1 And $sLogText <> Default And IsString($sLogText) Then
Local $String = $sLogText & $result
SetDebugLog($String, $LogTextColor, $bSilentSetLog)
EndIf
Return $result
EndFunc
Func getCloudFailShort($x_start, $y_start, $sLogText = Default, $LogTextColor = Default, $bSilentSetLog = Default)
Local $result = getOcrAndCapture("coc-cloudfail", $x_start, $y_start, 72, 24)
If $g_iDebugSetlog = 1 And $sLogText <> Default And IsString($sLogText) Then
Local $String = $sLogText & $result
SetDebugLog($String, $LogTextColor, $bSilentSetLog)
EndIf
Return $result
EndFunc
Func getBarracksNewTroopQuantity($x_start, $y_start)
Return getOcrAndCapture("coc-newarmy", $x_start, $y_start, 45, 18, True)
EndFunc
Func getArmyCapacityOnTrainTroops($x_start, $y_start)
Return getOcrAndCapture("coc-NewCapacity", $x_start, $y_start, 67, 14, True)
EndFunc
Func getQueueTroopsQuantity($x_start, $y_start)
Return StringReplace(getOcrAndCapture("coc-qqtroop", $x_start, $y_start, 71, 22, True), "b", "")
EndFunc
Func getChatStringChinese($x_start, $y_start)
Local $bUseOcrImgLoc = True
Return getOcrAndCapture("chinese-bundle", $x_start, $y_start, 160, 14, Default, $bUseOcrImgLoc)
EndFunc
Func getChatStringKorean($x_start, $y_start)
Local $bUseOcrImgLoc = True
Return getOcrAndCapture("korean-bundle", $x_start, $y_start, 160, 14, Default, $bUseOcrImgLoc)
EndFunc
Func OcrForceCaptureRegion($bForce = Default)
If $bForce = Default Then Return $g_bOcrForceCaptureRegion
Local $wasForce = $g_bOcrForceCaptureRegion
$g_bOcrForceCaptureRegion = $bForce
Return $wasForce
EndFunc
Func getOcrAndCapture($language, $x_start, $y_start, $width, $height, $removeSpace = Default, $bImgLoc = Default, $bForceCaptureRegion = Default)
If $removeSpace = Default Then $removeSpace = False
If $bImgLoc = Default Then $bImgLoc = False
If $bForceCaptureRegion = Default Then $bForceCaptureRegion = $g_bOcrForceCaptureRegion
Local $bDelete_hHBitmap = False
If $bForceCaptureRegion = True Then
_CaptureRegion2($x_start, $y_start, $x_start + $width, $y_start + $height)
Local $_hHBitmap = $hHBitmap2
Else
$bDelete_hHBitmap = True
Local $_hHBitmap = GetHHBitmapArea($hHBitmap2, $x_start, $y_start, $x_start + $width, $y_start + $height)
EndIf
Local $result
If $bImgLoc Then
$result = getOcrImgLoc($_hHBitmap, $language)
Else
$result = getOcr($_hHBitmap, $language)
EndIf
If $bDelete_hHBitmap Then
GdiDeleteHBitmap($_hHBitmap)
$_hHBitmap = 0
EndIf
If($removeSpace) Then
$result = StringReplace($result, " ", "")
Else
$result = StringStripWS($result, BitOR($STR_STRIPLEADING, $STR_STRIPTRAILING, $STR_STRIPSPACES))
EndIf
Return $result
EndFunc
Func getOcr(ByRef Const $_hHBitmap, $language)
Local $result = DllCall($g_hLibFunctions, "str", "ocr", "ptr", $_hHBitmap, "str", $language, "int", $g_iDebugOcr)
If IsArray($result) Then
Return $result[0]
Else
Return ""
EndIf
EndFunc
Func getOcrImgLoc(ByRef Const $_hHBitmap, $sLanguage)
Local $result = DllCall($g_sLibImgLocPath, "str", "DoOCR", "handle", $_hHBitmap, "str", $sLanguage)
Local $error = @error
Local $extError = @extended
If $error Then
_logErrorDLLCall($g_sLibImgLocPath, $error)
If $g_iDebugSetlog = 1 Then SetLog(" imgloc DLL Error : " & $error & " --- " & $extError)
Return SetError(2, $extError , "")
EndIF
If $g_iDebugImageSave = 1 Then DebugImageSave($sLanguage, False)
If IsArray($result) Then
Return $result[0]
Else
Return ""
EndIf
EndFunc
Func getPBTime()
Local $sTimeResult = ""
Local $aString[3]
Local $bPBTStart = False
Local $iPBTSeconds, $Result
Local $iHour = 0, $iMin = 0, $iSec = 0
Local $sPBTReturnResult = ""
If IsMainPage() = False Then
Setlog("Not on Main page to read PB information", $COLOR_ERROR)
Return
EndIf
ClickP($aShieldInfoButton)
If _Sleep($iPersonalShield3) Then Return
Local $iCount = 0
While _CheckPixel($aIsShieldInfo, $g_bCapturePixel) = False
If _Sleep($iPersonalShield2) Then Return
$Result = getAttackDisable(180, 156 + $g_iMidOffsetY)
If $g_iDebugSetlog = 1 Then Setlog("OCR PBT early warning= " & $Result, $COLOR_DEBUG)
If(StringLen($Result) > 3) And StringRegExp($Result, "[a-w]", $STR_REGEXPMATCH) Then
Setlog("Personal Break Warning found!", $COLOR_INFO)
$bPBTStart = True
ExitLoop
EndIf
$iCount += 1
If $iCount > 20 Then
Setlog("PBT information window failed to open", $COLOR_DEBUG)
If $g_iDebugImageSave = 1 Then DebugImageSave("PBTInfo_", $g_bCapturePixel, "png", False)
ClickP($aAway, 1, 0, "#9999")
If _Sleep($iPersonalShield2) Then Return
Return
EndIf
WEnd
If _CheckPixel($aIsShieldInfo, $g_bCapturePixel) Or $bPBTStart Then
$sTimeResult = getOcrPBTtime(555, 499 + $g_iMidOffsetY)
If $g_iDebugSetlog = 1 Then Setlog("OCR PBT Time= " & $sTimeResult, $COLOR_DEBUG)
If $sTimeResult = "" Then
If _Sleep($iPersonalShield2) Then Return
$sTimeResult = getOcrPBTtime(555, 499 + $g_iMidOffsetY)
If $g_iDebugSetlog = 1 Then Setlog("OCR2 PBT Time= " & $sTimeResult, $COLOR_DEBUG)
If $sTimeResult = "" And $bPBTStart = False Then
Setlog("strange error, no PBT value found?", $COLOR_ERROR)
SetError(1, "Bad OCR of PB time value ")
ClickP($aAway, 1, 0, "#9999")
If _Sleep($iPersonalShield2) Then Return
Return
EndIf
EndIf
If _Sleep($iDelayRespond) Then Return
$aString = StringSplit($sTimeResult, " ")
Switch $aString[0]
Case 1
Select
Case StringInStr($aString[1], "s", $STR_NOCASESENSEBASIC)
$iSec = Number($aString[1])
Case StringInStr($aString[1], "m", $STR_NOCASESENSEBASIC)
$iMin = Number($aString[2])
Case StringInStr($aString[1], "h", $STR_NOCASESENSEBASIC)
$iHour = Number($aString[1])
Case Else
Setlog("strange error, unexpected PBT value? |" & $aString[1], $COLOR_ERROR)
SetError(2, "Error processing time string")
ClickP($aAway, 1, 0, "#9999")
If _Sleep($iPersonalShield2) Then Return
Return
EndSelect
Case 2
Select
Case StringInStr($aString[1], "h", $STR_NOCASESENSEBASIC)
$iHour = Number($aString[1])
If StringInStr($aString[2], "m", $STR_NOCASESENSEBASIC) Then
$iMin = Number($aString[2])
EndIf
Case StringInStr($aString[1], "m", $STR_NOCASESENSEBASIC)
$iMin = Number($aString[1])
If StringInStr($aString[2], "s", $STR_NOCASESENSEBASIC) Then
$iSec = Number($aString[2])
EndIf
Case Else
Setlog("strange error, unexpected PBT value? |" & $aString[1] & "|" & $aString[2], $COLOR_ERROR)
SetError(3, "Error processing time string")
ClickP($aAway, 1, 0, "#9999")
If _Sleep($iPersonalShield2) Then Return
Return
EndSelect
Case Else
If $bPBTStart = False Then
Setlog("Error processing PBT time string: " & $sTimeResult, $COLOR_ERROR)
SetError(4, "Error processing time string")
ClickP($aAway, 1, 0, "#9999")
If _Sleep($iPersonalShield2) Then Return
Return
Else
Setlog("Error processing PBT time string: " & $sTimeResult, $COLOR_INFO)
Setlog("Continue due PB starting now", $COLOR_SUCCESS)
EndIf
EndSwitch
$iPBTSeconds =($iHour * 3600) +($iMin * 60) + $iSec
If $g_iDebugSetlog = 1 Then Setlog("Computed PBT Seconds = " & $iPBTSeconds, $COLOR_DEBUG)
If $bPBTStart Then
$sPBTReturnResult = _DateAdd('s', -10, _NowCalc())
Else
$sPBTReturnResult = _DateAdd('s', $iPBTSeconds, _NowCalc())
EndIf
If @error Then Setlog("_DateAdd error= " & @error, $COLOR_ERROR)
If $g_iDebugSetlog = 1 Then Setlog("PBT starts: " & $sPBTReturnResult, $COLOR_DEBUG)
If _Sleep($iPersonalShield1) Then Return
ClickP($aAway, 1, 0, "#9999")
If _Sleep($iPersonalShield2) Then Return
Return $sPBTReturnResult
Else
If $g_iDebugSetlog = 1 Then SetLog("PB Info window failed to open for PB Time OCR", $COLOR_ERROR)
EndIf
EndFunc
Func getShieldInfo()
Local $sTimeResult = ""
Local $aString[3]
Local $iShieldSeconds
Local $iDay = 0, $iHour = 0, $iMin = 0, $iSec = 0
Local $aPBReturnResult[3] = ["", "", ""]
$aPBReturnResult[1] = StringFormat("%02s",($iDay * 24) + $iHour) & ":" & StringFormat("%02s", $iMin) & ":" & StringFormat("%02s", $iSec)
If IsMainPage() = False Then
Setlog("unable to read shield information", $COLOR_ERROR)
Return
EndIf
Select
Case _CheckPixel($aNoShield, $g_bCapturePixel)
$aPBReturnResult[0] = "none"
If $g_iDebugSetlog = 1 Then Setlog("No shield active", $COLOR_DEBUG)
Return $aPBReturnResult
Case _CheckPixel($aHaveShield, $g_bCapturePixel)
$aPBReturnResult[0] = "shield"
If $g_iDebugSetlog = 1 Then Setlog("Shield Active", $COLOR_DEBUG)
Case _CheckPixel($aHavePerGuard, $g_bCapturePixel)
$aPBReturnResult[0] = "guard"
If $g_iDebugSetlog = 1 Then Setlog("Guard Active", $COLOR_DEBUG)
Case Else
Setlog("Sorry, Monkey needs more bananas to read shield type", $COLOR_ERROR)
SetError(1, "Bad shield pixel read")
Return
EndSelect
$sTimeResult = getOcrGuardShield(484, 21)
If $g_iDebugSetlog = 1 Then Setlog("OCR Shield Time= " & $sTimeResult, $COLOR_DEBUG)
If $sTimeResult = "" Then
If _Sleep($iPersonalShield2) Then Return
$sTimeResult = getOcrGuardShield(484, 21)
If $g_iDebugSetlog = 1 Then Setlog("OCR2 Shield Time= " & $sTimeResult, $COLOR_DEBUG)
If $sTimeResult = "" Then
$aPBReturnResult[1] = '00:00:00'
Setlog("strange error, no shield value found?", $COLOR_ERROR)
SetError(2, "Bad time value OCR")
Return $aPBReturnResult
EndIf
EndIf
If _Sleep($iPersonalShield3) Then Return
$aString = StringSplit($sTimeResult, " ")
Switch $aString[0]
Case 1
If StringInStr($aString[1], "s", $STR_NOCASESENSEBASIC) Then $iSec = Number($aString[1])
Case 2
Select
Case StringInStr($aString[1], "d", $STR_NOCASESENSEBASIC)
$iDay = Number($aString[1])
If StringInStr($aString[2], "h", $STR_NOCASESENSEBASIC) Then
$iHour = Number($aString[2])
EndIf
Case StringInStr($aString[1], "h", $STR_NOCASESENSEBASIC)
$iHour = Number($aString[1])
If StringInStr($aString[2], "m", $STR_NOCASESENSEBASIC) Then
$iMin = Number($aString[2])
EndIf
Case StringInStr($aString[1], "m", $STR_NOCASESENSEBASIC)
$iMin = Number($aString[1])
If StringInStr($aString[2], "s", $STR_NOCASESENSEBASIC) Then
$iSec = Number($aString[2])
EndIf
Case Else
Setlog("strange error, unexpected shield value?", $COLOR_ERROR)
SetError(3, "Error processing time string")
Return $aPBReturnResult
EndSelect
Case Else
Setlog("Error processing time string: " & $sTimeResult, $COLOR_ERROR)
SetError(4, "Error processing time string")
Return $aPBReturnResult
EndSwitch
$aPBReturnResult[1] = StringFormat("%02s",($iDay * 24) + $iHour) & ":" & StringFormat("%02s", $iMin) & ":" & StringFormat("%02s", $iSec)
If $g_iDebugSetlog = 1 Then Setlog("Shield Time String = " & $aPBReturnResult[1], $COLOR_DEBUG)
$iShieldSeconds =($iDay * 86400) +($iHour * 3600) +($iMin * 60) + $iSec
If $g_iDebugSetlog = 1 Then Setlog("Computed Shield Seconds = " & $iShieldSeconds, $COLOR_DEBUG)
$aPBReturnResult[2] = _DateAdd('s', $iShieldSeconds, _NowCalc())
If @error Then Setlog("_DateAdd error= " & @error, $COLOR_ERROR)
If $g_iDebugSetlog = 1 Then Setlog("Shield expires at: " & $aPBReturnResult[2], $COLOR_INFO)
Return $aPBReturnResult
EndFunc
Func updateMultiSearchStats($aResult, $statFile = "")
Switch $statFile
Case $g_sProfileWeakBasePath
updateWeakBaseStats($aResult)
Case Else
EndSwitch
EndFunc
Func addInfoToDebugImage(ByRef $hGraphic, ByRef $hPen, $fileName, $x, $y)
_GDIPlus_GraphicsDrawRect($hGraphic, $x - 5, $y - 5, 10, 10, $hPen)
Local $hBrush = _GDIPlus_BrushCreateSolid(0xFFFFFFFF)
Local $hFormat = _GDIPlus_StringFormatCreate()
Local $hFamily = _GDIPlus_FontFamilyCreate("Tahoma")
Local $hFont = _GDIPlus_FontCreate($hFamily, 12, 2)
Local $tLayout = _GDIPlus_RectFCreate($x + 10, $y, 0, 0)
Local $sString = String($fileName)
Local $aInfo = _GDIPlus_GraphicsMeasureString($hGraphic, $sString, $hFont, $tLayout, $hFormat)
_GDIPlus_GraphicsDrawStringEx($hGraphic, $sString, $hFont, $aInfo[0], $hFormat, $hBrush)
$tLayout = 0
_GDIPlus_FontDispose($hFont)
_GDIPlus_FontFamilyDispose($hFamily)
_GDIPlus_StringFormatDispose($hFormat)
_GDIPlus_BrushDispose($hBrush)
EndFunc
Func captureDebugImage($aResult, $subDirectory)
Local $coords
If IsArray($aResult) Then
DirCreate($g_sProfileTempDebugPath & $subDirectory)
Local $editedImage = _GDIPlus_BitmapCreateFromHBITMAP($hHBitmap2)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
Local $fileName = String($Date & "_" & $Time & ".png")
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($editedImage)
Local $hPen = _GDIPlus_PenCreate(0xFFFF0000, 2)
For $i = 1 To UBound($aResult) - 1
If Number($aResult[$i][4]) > 0 Then
$coords = $aResult[$i][5]
If IsArray($coords) Then
For $j = 0 To UBound($coords) - 1
addInfoToDebugImage($hGraphic, $hPen, $aResult[$i][0], $coords[$j][0], $coords[$j][1])
Next
EndIf
EndIf
Next
_GDIPlus_GraphicsDrawString($hGraphic, "Time Taken:" & $aResult[0][2] & " " & $aResult[0][3], 350, 50, "Verdana", 20)
_GDIPlus_ImageSaveToFile($editedImage, $g_sProfileTempDebugPath & $subDirectory & "\" & $fileName)
_GDIPlus_PenDispose($hPen)
_GDIPlus_GraphicsDispose($hGraphic)
_GDIPlus_BitmapDispose($editedImage)
EndIf
EndFunc
Func returnPropertyValue($key, $property)
Local $aValue = DllCall($g_hLibImgLoc, "str", "GetProperty", "str", $key, "str", $property)
If @error Then _logErrorDLLCall($g_sLibImgLocPath, @error)
Return $aValue[0]
EndFunc
Func updateResultsRow(ByRef $aResult, $redLines = "")
Local $numberFound = 0
If IsArray($aResult) Then
If UBound($aResult) > 1 Then
For $j = 1 To UBound($aResult) - 1
$numberFound += Number($aResult[$j][4])
Next
EndIf
$aResult[0][0] = $redLines
$aResult[0][1] = $numberFound
Else
EndIf
EndFunc
Func multiMatches($directory, $maxReturnPoints = 0, $fullCocAreas = "DCD", $redLines = "DCD", $statFile = "", $minLevel = 0, $maxLevel = 1000, $forceCaptureRegion = True)
Local $aResult[1][6] = [["", 0, 0, "Seconds", "", ""]], $aCoordArray[0][0], $aCoords, $aCoordsSplit, $aValue
If $forceCaptureRegion = True Then _CaptureRegion2()
Local $res = DllCall($g_hLibImgLoc, "str", "SearchMultipleTilesBetweenLevels", "handle", $hHBitmap2, "str", $directory, "str", $fullCocAreas, "Int", $maxReturnPoints, "str", $redLines, "Int", $minLevel, "Int", $maxLevel)
If @error Then _logErrorDLLCall($g_sLibImgLocPath, @error)
$aValue = DllCall($g_hLibImgLoc, "str", "GetProperty", "str", "redline", "str", "")
If @error Then _logErrorDLLCall($g_sLibImgLocPath, @error)
$redLines = $aValue[0]
If $res[0] <> "" Then
Local $aKeys = StringSplit($res[0], "|", $STR_NOCOUNT)
ReDim $aResult[UBound($aKeys) + 1][6]
For $i = 0 To UBound($aKeys) - 1
$aResult[$i + 1][0] = returnPropertyValue($aKeys[$i], "filename")
$aResult[$i + 1][1] = returnPropertyValue($aKeys[$i], "objectname")
$aResult[$i + 1][2] = returnPropertyValue($aKeys[$i], "objectlevel")
$aResult[$i + 1][3] = returnPropertyValue($aKeys[$i], "fillLevel")
$aResult[$i + 1][4] = returnPropertyValue($aKeys[$i], "totalobjects")
$aValue = returnPropertyValue($aKeys[$i], "objectpoints")
$aCoords = StringSplit($aValue, "|", $STR_NOCOUNT)
ReDim $aCoordArray[UBound($aCoords)][2]
For $j = 0 To UBound($aCoords) - 1
$aCoordsSplit = StringSplit($aCoords[$j], ",", $STR_NOCOUNT)
If UBound($aCoordsSplit) = 2 Then
$aCoordArray[$j][0] = $aCoordsSplit[0]
$aCoordArray[$j][1] = $aCoordsSplit[1]
EndIf
Next
$aResult[$i + 1][5] = $aCoordArray
Next
EndIf
updateResultsRow($aResult, $redLines)
updateMultiSearchStats($aResult, $statFile)
Return $aResult
EndFunc
Func returnMultipleMatchesOwnVillage($directory, $maxReturnPoints = 0, $statFile = "", $minLevel = 0, $maxLevel = 1000, $forceCaptureRegion = True)
Local $aResult = multiMatches($directory, $maxReturnPoints, "ECD", "ECD", $statFile, $minLevel, $maxLevel, $forceCaptureRegion)
Return $aResult
EndFunc
Func returnSingleMatchOwnVillage($directory, $statFile = "", $minLevel = 0, $maxLevel = 1000, $forceCaptureRegion = True)
Local $aResult = multiMatches($directory, 1, "ECD", "ECD", $statFile, $minLevel, $maxLevel, $forceCaptureRegion)
Return $aResult
EndFunc
Func returnAllMatches($directory, $redLines = "DCD", $statFile = "", $minLevel = 0, $maxLevel = 1000, $forceCaptureRegion = True)
Local $aResult = multiMatches($directory, 0, "DCD", $redLines, $statFile, $minLevel, $maxLevel, $forceCaptureRegion)
Return $aResult
EndFunc
Func returnHighestLevelSingleMatch($directory, $redLines = "DCD", $statFile = "", $minLevel = 0, $maxLevel = 1000, $forceCaptureRegion = True)
Local $defaultCoords[1][2] = [[0, 0]]
Local $return[7] = ["None", "None", 0, 0, 0, $defaultCoords, ""]
Local $aResult = multiMatches($directory, 1, "DCD", $redLines, $statFile, $minLevel, $maxLevel, $forceCaptureRegion)
If UBound($aResult) > 1 Then
For $i = 1 To UBound($aResult) - 1
If Number($aResult[$i][2]) > Number($return[2]) Then
$return[0] = $aResult[$i][0]
$return[1] = $aResult[$i][1]
$return[2] = $aResult[$i][2]
$return[3] = $aResult[$i][3]
$return[4] = $aResult[$i][4]
$return[5] = $aResult[$i][5]
EndIf
Next
EndIf
$return[6] = $aResult[0][0]
Return $return
EndFunc
Func returnLowestLevelSingleMatch($directory, $returnMax = 100, $redLines = "DCD", $statFile = "", $minLevel = 0, $maxLevel = 1000, $forceCaptureRegion = True)
Local $defaultCoords[1][2] = [[0, 0]]
Local $return[7] = ["None", "None", $returnMax + 1, 0, 0, $defaultCoords, ""]
Local $aResult = multiMatches($directory, 1, "DCD", $redLines, $statFile, $minLevel, $maxLevel, $forceCaptureRegion)
If UBound($aResult) > 1 Then
For $i = 1 To UBound($aResult) - 1
If Number($aResult[$i][2]) < Number($return[2]) Then
$return[0] = $aResult[$i][0]
$return[1] = $aResult[$i][1]
$return[2] = $aResult[$i][2]
$return[3] = $aResult[$i][3]
$return[4] = $aResult[$i][4]
$return[5] = $aResult[$i][5]
EndIf
Next
EndIf
$return[6] = $aResult[0][0]
Return $return
EndFunc
Func returnMultipleMatches($directory, $maxReturnPoints = 0, $redLines = "DCD", $statFile = "", $minLevel = 0, $maxLevel = 1000, $forceCaptureRegion = True)
Local $aResult = multiMatches($directory, $maxReturnPoints, "DCD", $redLines, $statFile, $minLevel, $maxLevel)
Return $aResult
EndFunc
Func returnSingleMatch($directory, $redLines = "DCD", $statFile = "", $minLevel = 0, $maxLevel = 1000, $forceCaptureRegion = True)
Local $aResult = multiMatches($directory, 1, "DCD", $redLines, $statFile, $minLevel, $maxLevel, $forceCaptureRegion)
Return $aResult
EndFunc
Func returnAllMatchesDefense($directory, $statFile = "", $minLevel = 0, $maxLevel = 1000, $x1 = 0, $y1 = 0, $x2 = $g_iGAME_WIDTH, $y2 = $g_iGAME_HEIGHT, $bCaptureNew = True, $xDiff = Default, $yDiff = Default)
Local $aResult = multiMatchesPixelOnly($directory, 0, $DCD, $CurBaseRedLine, $statFile, $minLevel, $maxLevel, $x1, $y1, $x2, $y2, $bCaptureNew, $xDiff, $yDiff, True, False)
Return $aResult
EndFunc
Func VerifyMMPOResult($Result)
If StringLen($Result) > 2 And StringInStr($Result, ",") > 0 Then Return True
Return False
EndFunc
Global Enum $eWeakEagle = 1, $eWeakInferno, $eWeakXBow, $eWeakWizard, $eWeakMortar, $eWeakAirDefense
Global $weakDefenseNames = ["None", "Eagle Artillery", "Inferno Tower", "XBow", "Wizard Tower", "Mortar", "Air Defense"]
Global $weakDefenseMaxLevels = [0, 2, 4, 4, 9, 9, 8]
Func createWeakBaseStats()
Local $aKeys = _FileListToArrayRec(@ScriptDir & "\imgxml\WeakBase", "*.xml", $FLTAR_FILES, $FLTAR_RECUR, $FLTAR_SORT, $FLTAR_NOPATH)
Local $return[UBound($aKeys) - 1][2]
If Not FileExists($g_sProfileWeakBasePath) Then _FileCreate($g_sProfileWeakBasePath)
For $i = 1 To UBound($aKeys) - 1
$return[$i - 1][0] = $aKeys[$i]
$return[$i - 1][1] = 0
IniWrite($g_sProfileWeakBasePath, "WeakBase", $aKeys[$i], "0")
Next
Return $return
EndFunc
Func readWeakBaseStats()
Local $aKeys = _FileListToArrayRec(@ScriptDir & "\imgxml\WeakBase", "*.xml", $FLTAR_FILES, $FLTAR_RECUR, $FLTAR_SORT, $FLTAR_NOPATH)
Local $return[UBound($aKeys) - 1][2]
If FileExists($g_sProfileWeakBasePath) Then
For $i = 1 To UBound($aKeys) - 1
$return[$i - 1][0] = $aKeys[$i]
$return[$i - 1][1] = IniRead($g_sProfileWeakBasePath, "WeakBase", $aKeys[$i], "0")
Next
Else
$return = createWeakBaseStats()
EndIf
Return $return
EndFunc
Func saveWeakBaseStats()
Local $hFile = FileOpen($g_sProfileWeakBasePath, $FO_OVERWRITE)
For $j = 0 To UBound($aWeakBaseStats) - 1
IniWrite($g_sProfileWeakBasePath, "WeakBase", $aWeakBaseStats[$j][0], $aWeakBaseStats[$j][1])
Next
FileClose($hFile)
EndFunc
Func updateWeakBaseStats($aResult)
If IsArray($aResult) Then
For $i = 1 To UBound($aResult) - 1
For $j = 0 To UBound($aWeakBaseStats) - 1
If $aWeakBaseStats[$j][0] = $aResult[$i][0] Then
$aWeakBaseStats[$j][1] = Number($aWeakBaseStats[$j][1]) + 1
EndIf
Next
Next
EndIf
EndFunc
Func displayWeakBaseLog($aResult, $showLog = False)
If $showLog And IsArray($aResult) Then
SetLog("================ Weak Base Detection Start ================", $COLOR_INFO)
SetLog("Highest Eagle Artillery: " & $aResult[1][0] & " - Level: " & $aResult[1][2], $COLOR_INFO)
SetLog("Highest Inferno Tower: " & $aResult[2][0] & " - Level: " & $aResult[2][2], $COLOR_INFO)
SetLog("Highest X-Bow: " & $aResult[3][0] & " - Level: " & $aResult[3][2], $COLOR_INFO)
SetLog("Highest Wizard Tower: " & $aResult[4][0] & " - Level: " & $aResult[4][2], $COLOR_INFO)
SetLog("Highest Mortar: " & $aResult[5][0] & " - Level: " & $aResult[5][2], $COLOR_INFO)
SetLog("Highest Air Defense: " & $aResult[6][0] & " - Level: " & $aResult[6][2], $COLOR_INFO)
SetLog("Time taken: " & $aResult[0][2] & " " & $aResult[0][3], $COLOR_INFO)
SetLog("================ Weak Base Detection Stop =================", $COLOR_INFO)
EndIf
EndFunc
Func getTHDefenseMax($levelTownHall, $defenseType)
Local $maxTH = 11
Local $eagleLevels[$maxTH] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2]
Local $infernoLevels[$maxTH] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4]
Local $mortarLevels[$maxTH] = [0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
Local $wizardLevels[$maxTH] = [0, 0, 0, 0, 2, 3, 4, 6, 7, 8, 9]
Local $xbowLevels[$maxTH] = [0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 4]
Local $adefenseLevels[$maxTH] = [0, 0, 0, 2, 3, 4, 5, 6, 7, 8, 8]
If $levelTownHall = 0 Then $levelTownHall = $maxTH
Local $result = 100
If $levelTownHall <= $maxTH Then
Switch $defenseType
Case $eWeakEagle
$result = $eagleLevels[$levelTownHall - 1]
Case $eWeakInferno
$result = $infernoLevels[$levelTownHall - 1]
Case $eWeakXBow
$result = $xbowLevels[$levelTownHall - 1]
Case $eWeakWizard
$result = $wizardLevels[$levelTownHall - 1]
Case $eWeakMortar
$result = $mortarLevels[$levelTownHall - 1]
Case $eWeakAirDefense
$result = $adefenseLevels[$levelTownHall - 1]
Case Else
EndSwitch
EndIf
Return $result
EndFunc
Func getMaxUISetting($settingArray, $defenseType)
Local $result = 0, $maxDB = 0, $maxLB = 0
If IsArray($settingArray) Then
$maxDB =(IsWeakBaseActive($DB)) ? $settingArray[$DB] : 0
$maxLB =(IsWeakBaseActive($LB)) ? $settingArray[$LB] : 0
$result = _Max(Number($maxDB), Number($maxLB))
EndIf
If $g_iDebugSetlog = 1 Then SetLog("Max " & $weakDefenseNames[$defenseType] & " Level: " & $result, $COLOR_INFO)
Return $result
EndFunc
Func getMinUISetting($settingArray, $defenseType)
Local $result = 0, $minDB = 0, $minLB = 0
If IsArray($settingArray) Then
$minDB =(IsWeakBaseActive($DB)) ? $settingArray[$DB] : 0
$minLB =(IsWeakBaseActive($LB)) ? $settingArray[$LB] : 0
$result = _Min(Number($minDB), Number($minLB))
EndIf
If $g_iDebugSetlog = 1 Then SetLog("Min " & $weakDefenseNames[$defenseType] & " Level: " & $result, $COLOR_INFO)
Return $result
EndFunc
Func getIsWeak($aResults, $searchType)
Return $aResults[$eWeakEagle][2] <= Number($g_aiFilterMaxEagleLevel[$searchType]) And $aResults[$eWeakInferno][2] <= Number($g_aiFilterMaxInfernoLevel[$searchType]) And $aResults[$eWeakXBow][2] <= Number($g_aiFilterMaxXBowLevel[$searchType]) And $aResults[$eWeakWizard][2] <= Number($g_aiFilterMaxWizTowerLevel[$searchType]) And $aResults[$eWeakMortar][2] <= Number($g_aiFilterMaxMortarLevel[$searchType])
EndFunc
Func IsWeakBaseActive($type)
Return($g_abFilterMaxEagleEnable[$type] Or $g_abFilterMaxInfernoEnable[$type] Or $g_abFilterMaxXBowEnable[$type] Or $g_abFilterMaxWizTowerEnable[$type] Or $g_abFilterMaxMortarEnable[$type] Or $g_abFilterMaxAirDefenseEnable[$type]) And IsSearchModeActive($type, False, True)
EndFunc
Func defenseSearch(ByRef $aResult, $directory, $townHallLevel, $settingArray, $defenseType, ByRef $performSearch, $guiEnabledArray, $forceCaptureRegion = True)
Local $defaultCoords[1][2] = [[0, 0]]
Local $aDefenseResult[7] = ["Skipped", "Skipped", $weakDefenseMaxLevels[$defenseType], 0, 0, $defaultCoords, ""]
Local $aNotNecessary[7] = ["None", "None", 0, 0, 0, $defaultCoords, ""]
Local $minSearchLevel = getMinUISetting($settingArray, $defenseType) + 1
Local $maxSearchLevel = getTHDefenseMax($townHallLevel, $defenseType)
Local $guiCheckDefense = IsArray($guiEnabledArray) And((IsSearchModeActive($DB, False, True) And $guiEnabledArray[$DB]) Or(IsSearchModeActive($LB, False, True) And $guiEnabledArray[$LB]))
If $performSearch Then
Local $defenseTimer = TimerInit()
If $guiCheckDefense And $maxSearchLevel >= $minSearchLevel Then
Local $sDefenseName = StringSplit($directory ,"\",$STR_NOCOUNT)
If $g_iDebugSetlog Then SetLog("checkDefense :" & $sDefenseName[ubound($sDefenseName)-1] & " > " & $minSearchLevel & " < "& $maxSearchLevel & " For TH:" & $townHallLevel, $COLOR_ORANGE)
$aDefenseResult = returnHighestLevelSingleMatch($directory, $aResult[0][0], $g_sProfileWeakBasePath, $minSearchLevel, $maxSearchLevel, $forceCaptureRegion)
If $aResult[0][0] = "" Then $aResult[0][0] = $aDefenseResult[6]
If Number($aDefenseResult[2]) > getMaxUISetting($settingArray, $defenseType) Then $performSearch = False
If $g_iDebugSetlog = 1 Then SetLog("checkDefense: " & $weakDefenseNames[$defenseType] & " - " & Round(TimerDiff($defenseTimer) / 1000, 2) & " seconds")
Else
$aDefenseResult = $aNotNecessary
If $g_iDebugSetlog = 1 Then SetLog("checkDefense: " & $weakDefenseNames[$defenseType] & " not necessary!")
EndIf
EndIf
Return $aDefenseResult
EndFunc
Func weakBaseCheck($townHallLevel = 11, $redlines = "", $forceCaptureRegion = True)
Local $defaultCoords[1][2] = [[0, 0]]
Local $aResult[7][6] = [[$redlines, 0, 0, "Seconds", "", ""], ["Skipped", "Skipped", 2, 0, 0, $defaultCoords], ["Skipped", "Skipped", 4, 0, 0, $defaultCoords], ["Skipped", "Skipped", 4, 0, 0, $defaultCoords], ["Skipped", "Skipped", 9, 0, 0, $defaultCoords], ["Skipped", "Skipped", 9, 0, 0, $defaultCoords], ["Skipped", "Skipped", 8, 0, 0, $defaultCoords]]
Local $aEagleResults, $aInfernoResults, $aMortarResults, $aWizardTowerResults, $aXBowResults, $aAirDefenseResults
Local $performSearch = True
Local $hWeakTimer = TimerInit()
$aEagleResults = defenseSearch($aResult, @ScriptDir & "\imgxml\WeakBase\Eagle", $townHallLevel, $g_aiFilterMaxEagleLevel, $eWeakEagle, $performSearch, $g_abFilterMaxEagleEnable, $forceCaptureRegion)
$aInfernoResults = defenseSearch($aResult, @ScriptDir & "\imgxml\WeakBase\Infernos", $townHallLevel, $g_aiFilterMaxInfernoLevel, $eWeakInferno, $performSearch, $g_abFilterMaxInfernoEnable, $forceCaptureRegion)
$aXBowResults = defenseSearch($aResult, @ScriptDir & "\imgxml\WeakBase\Xbow", $townHallLevel, $g_aiFilterMaxXBowLevel, $eWeakXBow, $performSearch, $g_abFilterMaxXBowEnable, $forceCaptureRegion)
If $iDetectedImageType = 1 then
$aWizardTowerResults = defenseSearch($aResult, @ScriptDir & "\imgxml\WeakBase\WTower_Snow", $townHallLevel, $g_aiFilterMaxWizTowerLevel, $eWeakWizard, $performSearch, $g_abFilterMaxWizTowerEnable, $forceCaptureRegion)
Else
$aWizardTowerResults = defenseSearch($aResult, @ScriptDir & "\imgxml\WeakBase\WTower", $townHallLevel, $g_aiFilterMaxWizTowerLevel, $eWeakWizard, $performSearch, $g_abFilterMaxWizTowerEnable, $forceCaptureRegion)
EndIf
$aMortarResults = defenseSearch($aResult, @ScriptDir & "\imgxml\WeakBase\Mortars", $townHallLevel, $g_aiFilterMaxMortarLevel, $eWeakMortar, $performSearch, $g_abFilterMaxMortarEnable, $forceCaptureRegion)
$aAirDefenseResults = defenseSearch($aResult, @ScriptDir & "\imgxml\WeakBase\ADefense", $townHallLevel, $g_aiFilterMaxAirDefenseLevel, $eWeakAirDefense, $performSearch, $g_abFilterMaxAirDefenseEnable, $forceCaptureRegion)
For $i = 1 To UBound($aResult) - 1
For $j = 0 To UBound($aResult, 2) - 1
Switch $i
Case $eWeakEagle
If IsArray($aEagleResults) Then $aResult[$i][$j] = $aEagleResults[$j]
Case $eWeakInferno
If IsArray($aInfernoResults) Then $aResult[$i][$j] = $aInfernoResults[$j]
Case $eWeakXBow
If IsArray($aXBowResults) Then $aResult[$i][$j] = $aXBowResults[$j]
Case $eWeakWizard
If IsArray($aWizardTowerResults) Then $aResult[$i][$j] = $aWizardTowerResults[$j]
Case $eWeakMortar
If IsArray($aMortarResults) Then $aResult[$i][$j] = $aMortarResults[$j]
Case $eWeakAirDefense
If IsArray($aAirDefenseResults) Then $aResult[$i][$j] = $aAirDefenseResults[$j]
Case Else
EndSwitch
Next
Next
$aResult[0][2] = Round(TimerDiff($hWeakTimer) / 1000, 2)
$aResult[0][3] = "Seconds"
Return $aResult
EndFunc
Func IsWeakBase($townHallLevel = 11, $redlines = "", $forceCaptureRegion = True)
Local $aResult = weakBaseCheck($townHallLevel, $redlines, $forceCaptureRegion)
displayWeakBaseLog($aResult, $g_iDebugSetlog = 1)
If Number($aResult[0][2]) > 10 Then
captureDebugImage($aResult, "WeakBase_Detection_TooSlow")
ElseIf $g_iDebugImageSave = 1 And Number($aResult[1][4]) = 0 Then
captureDebugImage($aResult, "WeakBase_Detection_Eagle_NotDetected")
ElseIf $g_iDebugImageSave = 1 And Number($aResult[2][4]) = 0 Then
captureDebugImage($aResult, "WeakBase_Detection_Inferno_NotDetected")
ElseIf $g_iDebugImageSave = 1 And Number($aResult[3][4]) = 0 Then
captureDebugImage($aResult, "WeakBase_Detection_Xbow_NotDetected")
ElseIf $g_iDebugImageSave = 1 And Number($aResult[4][4]) = 0 Then
captureDebugImage($aResult, "WeakBase_Detection_WTower_NotDetected")
ElseIf $g_iDebugImageSave = 1 And Number($aResult[5][4]) = 0 Then
captureDebugImage($aResult, "WeakBase_Detection_Mortar_NotDetected")
ElseIf $g_iDebugImageSave = 1 And Number($aResult[6][4]) = 0 Then
captureDebugImage($aResult, "WeakBase_Detection_ADefense_NotDetected")
ElseIf $g_iDebugImageSave = 1 Then
captureDebugImage($aResult, "WeakBase_Detection")
EndIf
Return $aResult
EndFunc
Func CompareResources($pMode)
If $g_bSearchReductionEnable Then
If($iChkEnableAfter[$pMode] = 0 And $SearchCount <> 0 And Mod($SearchCount, $g_iSearchReductionCount) = 0) Or($iChkEnableAfter[$pMode] = 1 And $SearchCount - $g_aiSearchSearchesMin[$pMode] > 0 And Mod($SearchCount - $g_aiSearchSearchesMin[$pMode], $g_iSearchReductionCount) = 0) Then
If $iAimGold[$pMode] - $g_iSearchReductionGold >= 0 Then $iAimGold[$pMode] -= $g_iSearchReductionGold
If $iAimElixir[$pMode] - $g_iSearchReductionElixir >= 0 Then $iAimElixir[$pMode] -= $g_iSearchReductionElixir
If $iAimDark[$pMode] - $g_iSearchReductionDark >= 0 Then $iAimDark[$pMode] -= $g_iSearchReductionDark
If $iAimTrophy[$pMode] - $g_iSearchReductionTrophy >= 0 Then $iAimTrophy[$pMode] -= $g_iSearchReductionTrophy
If $iAimGoldPlusElixir[$pMode] - $g_iSearchReductionGoldPlusElixir >= 0 Then $iAimGoldPlusElixir[$pMode] -= $g_iSearchReductionGoldPlusElixir
Local $txtTrophies = "", $txtTownhall = ""
if $g_abFilterMeetTrophyEnable[$pMode] Then $txtTrophies = " [T]:" & StringFormat("%2s", $iAimTrophy[$pMode])
If $g_abFilterMeetTH[$pMode] Then $txtTownhall = " [TH]:" & StringFormat("%2s", $iMaxTH[$pMode])
If $g_abFilterMeetTHOutsideEnable[$pMode] Then $txtTownhall &= ", Out"
If $g_aiFilterMeetGE[$pMode] = 2 Then
SetLog("Aim:           [G+E]:" & StringFormat("%7s", $iAimGoldPlusElixir[$pMode]) & " [D]:" & StringFormat("%5s", $iAimDark[$pMode]) & $txtTrophies & $txtTownhall & " for: " & $g_asModeText[$pMode], $COLOR_SUCCESS, "Lucida Console", 7.5)
Else
SetLog("Aim: [G]:" & StringFormat("%7s", $iAimGold[$pMode]) & " [E]:" & StringFormat("%7s", $iAimElixir[$pMode]) & " [D]:" & StringFormat("%5s", $iAimDark[$pMode]) & $txtTrophies & $txtTownhall & " for: " & $g_asModeText[$pMode], $COLOR_SUCCESS, "Lucida Console", 7.5)
EndIf
EndIf
EndIf
Local $G =(Number($searchGold) >= Number($iAimGold[$pMode])), $E =(Number($searchElixir) >= Number($iAimElixir[$pMode])), $D =(Number($searchDark) >= Number($iAimDark[$pMode])), $T =(Number($searchTrophy) >= Number($iAimTrophy[$pMode])), $GPE =((Number($searchGold) + Number($searchElixir)) >= Number($iAimGoldPlusElixir[$pMode]))
If $g_abFilterMeetOneConditionEnable[$pMode] Then
If $g_aiFilterMeetGE[$pMode] = 0 Then
If $G = True And $E = True Then Return True
EndIf
If $g_abFilterMeetDEEnable[$pMode] Then
If $D = True Then Return True
EndIf
If $g_abFilterMeetTrophyEnable[$pMode] Then
If $T = True Then Return True
EndIf
If $g_aiFilterMeetGE[$pMode] = 1 Then
If $G = True Or $E = True Then Return True
EndIf
If $g_aiFilterMeetGE[$pMode] = 2 Then
If $GPE = True Then Return True
EndIf
Return False
Else
If $g_aiFilterMeetGE[$pMode] = 0 Then
If $G = False Or $E = False Then Return False
EndIf
If $g_abFilterMeetDEEnable[$pMode] Then
If $D = False Then Return False
EndIf
If $g_abFilterMeetTrophyEnable[$pMode] Then
If $T = False Then Return False
EndIf
If $g_aiFilterMeetGE[$pMode] = 1 Then
If $G = False And $E = False Then Return False
EndIf
If $g_aiFilterMeetGE[$pMode] = 2 Then
If $GPE = False Then Return False
EndIf
EndIf
Return True
EndFunc
Func CompareTH($pMode)
Local $THL = -1, $THLO = -1
For $i = 0 To 5
If $searchTH = $THText[$i] Then $THL = $i
Next
Switch $THLoc
Case "In"
$THLO = 0
Case "Out"
$THLO = 1
EndSwitch
$SearchTHLResult = 0
If $THL > -1 And $THL <= $g_iAtkTBMaxTHLevel And $searchTH <> "-" Then $SearchTHLResult = 1
If $g_abFilterMeetOneConditionEnable[$pMode] Then
If $g_abFilterMeetTH[$pMode] Then
If $THL <> -1 And $THL <= $g_aiFilterMeetTHMin[$pMode] Then Return True
EndIf
If $g_abFilterMeetTHOutsideEnable[$pMode] Then
If $THLO = 1 Then Return True
EndIf
Return False
Else
If $g_abFilterMeetTH[$pMode] Then
If $THL = -1 Or $THL > $g_aiFilterMeetTHMin[$pMode] Then Return False
EndIf
If $g_abFilterMeetTHOutsideEnable[$pMode] Then
If $THLO <> 1 Then Return False
EndIf
EndIf
Return True
EndFunc
Global $GetResourcesTXT
Func GetResources($bLog = True, $pMatchMode = -1)
Static $iStuck = 0
If _Sleep($iDelayRespond) Then Return
$searchGold = ""
$searchElixir = ""
$searchDark = ""
$searchTrophy = ""
SuspendAndroid()
Local $iCount = 0
While(getGoldVillageSearch(48, 69) = "") Or(getElixirVillageSearch(48, 69 + 29) = "")
$iCount += 1
If _Sleep($iDelayGetResources3) Then Return
If $iCount >= 50 Or isProblemAffect(True) Then ExitLoop
WEnd
If _Sleep($iDelayRespond) Then Return
$searchGold = getGoldVillageSearch(48, 69)
If _Sleep($iDelayRespond) Then Return
$searchElixir = getElixirVillageSearch(48, 69 + 29)
If _Sleep($iDelayRespond) Then Return
If $g_iDebugSetlog Then SetLog("Village dark elixir available chk color: " & _GetPixelColor(31, 144, True) & " : 0x0F0617 expected", $COLOR_DEBUG)
If _ColorCheck(_GetPixelColor(31, 144, True), Hex(0x282020, 6), 10) Or _ColorCheck(_GetPixelColor(31, 144, True), Hex(0x0F0617, 6), 5) Then
$searchDark = getDarkElixirVillageSearch(48, 126)
$searchTrophy = getTrophyVillageSearch(45, 168)
Else
$searchDark = "N/A"
$searchTrophy = getTrophyVillageSearch(48, 69 + 69)
EndIf
If $searchGold = $searchGold2 And $searchElixir = $searchElixir2 Then $iStuck += 1
If $searchGold <> $searchGold2 Or $searchElixir <> $searchElixir2 Then $iStuck = 0
$searchGold2 = $searchGold
$searchElixir2 = $searchElixir
If $iStuck >= 5 Or isProblemAffect(True) Then
$iStuck = 0
resetAttackSearch(True)
Return
EndIf
$SearchCount += 1
ResumeAndroid()
EndFunc
Func resetAttackSearch($bStuck = False)
$Is_ClientSyncError = True
checkMainScreen()
If $g_bRestart Then
$iNbrOfOoS += 1
UpdateStats()
If $bStuck Then
SetLog("Connection Lost While Searching", $COLOR_ERROR)
Else
SetLog("Disconnected At Search Clouds", $COLOR_ERROR)
EndIf
PushMsg("OoSResources")
Else
If $bStuck Then
SetLog("Attack Is Disabled Or Slow connection issues, Restarting CoC and Bot...", $COLOR_ERROR)
Else
SetLog("Stuck At Search Clouds, Restarting CoC and Bot...", $COLOR_ERROR)
EndIf
$Is_ClientSyncError = False
CloseCoC(True)
EndIf
Return
EndFunc
Func CheckZoomOut($sSource = "CheckZoomOut", $bCheckOnly = False, $bForecCapture = True)
If $bForecCapture = True Then
_CaptureRegion2()
EndIf
Local $aVillageResult = SearchZoomOut(False, True, $sSource, False)
If IsArray($aVillageResult) = 0 Or $aVillageResult[0] = "" Then
If $bCheckOnly = False Then
SetLog("Not Zoomed Out! Exiting to MainScreen...", $COLOR_ERROR)
checkMainScreen()
$g_bRestart = True
$Is_ClientSyncError = True
EndIf
Return False
EndIf
Return True
EndFunc
Func SearchTownHallLoc()
Local $addtiles = 0
Switch $g_iMatchMode
Case $TS
If $ArmyCapacity < 100 Then
$addtiles = $g_iAtkTSAddTilesWhileTrain
Else
$addtiles = $g_iAtkTSAddTilesFullTroops
EndIf
Case $LB
$addtiles = $g_iTHSnipeBeforeTiles[$LB]
Case $DB
If $duringMilkingAttack = 1 Then
$addtiles = $g_iMilkFarmTHMaxTilesFromBorder
Else
$addtiles = $g_iTHSnipeBeforeTiles[$DB]
EndIf
EndSwitch
If $searchTH <> "-" Then
If isInsideDiamondXY($THx, $THy) = False Then Return False
For $i = 0 To 22
If $Thx < 114 + $i * 16 + Ceiling(($addtiles - 2) / 2 * 16) And $THy < 359 - $i * 12 + Ceiling(($addtiles - 2) / 2 * 12) Then
$THi = $i
$THside = 0
Return True
EndIf
If $Thx < 117 + $i * 16 + Ceiling(($addtiles - 2) / 2 * 16) And $THy > 268 + $i * 12 - Floor(($addtiles - 2) / 2 * 12) Then
$THi = $i
$THside = 1
Return True
EndIf
If $Thx > 743 - $i * 16 - Floor(($addtiles - 2) / 2 * 16) And $THy < 358 - $i * 12 + Ceiling(($addtiles - 2) / 2 * 12) Then
$THi = $i
$THside = 2
Return True
EndIf
If $Thx > 742 - $i * 16 - Floor(($addtiles - 2) / 2 * 16) And $THy > 268 + $i * 12 - Floor(($addtiles - 2) / 2 * 12) Then
$THi = $i
$THside = 3
Return True
EndIf
Next
EndIf
Return False
EndFunc
Func FindTownHall($check = True, $forceCaptureRegion = True)
$searchTH = "-"
$THx=0
$THy=0
If $check = True Or IsSearchModeActive($TS) Or($isModeActive[$DB] And($g_abFilterMeetTH[$DB] Or $g_abFilterMeetTHOutsideEnable[$DB])) Or($isModeActive[$LB] And($g_abFilterMeetTH[$LB] Or $g_abFilterMeetTHOutsideEnable[$LB])) Then
$searchTH = imgloccheckTownHallADV2(0, 0, $forceCaptureRegion)
If $searchTH <> "-" And SearchTownHallLoc() = False Then
$THLoc = "In"
ElseIf $searchTH <> "-" Then
$THLoc = "Out"
Else
$THLoc = $searchTH
$THx = 0
$THy = 0
EndIf
Return " [TH]:" & StringFormat("%2s", $searchTH) & ", " & $THLoc
EndIf
$THLoc = $searchTH
$THx = 0
$THy = 0
Return ""
EndFunc
Func IsSearchModeActive($g_iMatchMode, $nocheckHeroes = False, $bNoLog = False)
Local $currentSearch = $SearchCount + 1
Local $currentTropies = $iTrophyCurrent
Local $currentArmyCamps = Int($CurCamp / $TotalCamp * 100)
Local $bMatchModeEnabled = False
Local $checkSearches = Int($currentSearch) >= Int($g_aiSearchSearchesMin[$g_iMatchMode]) And Int($currentSearch) <= Int($g_aiSearchSearchesMax[$g_iMatchMode]) And $g_abSearchSearchesEnable[$g_iMatchMode]
Local $checkTropies = Int($currentTropies) >= Int($g_aiSearchTrophiesMin[$g_iMatchMode]) And Int($currentTropies) <= Int($g_aiSearchTrophiesMax[$g_iMatchMode]) And $g_abSearchTropiesEnable[$g_iMatchMode]
Local $checkArmyCamps = Int($currentArmyCamps) >= Int($g_aiSearchCampsPct[$g_iMatchMode]) And $g_abSearchCampsEnable[$g_iMatchMode]
Local $checkHeroes = Not($g_aiSearchHeroWaitEnable[$g_iMatchMode] > $eHeroNone And(BitAND($g_aiAttackUseHeroes[$g_iMatchMode], $g_aiSearchHeroWaitEnable[$g_iMatchMode], $iHeroAvailable) = $g_aiSearchHeroWaitEnable[$g_iMatchMode]) = False) Or $nocheckHeroes
If $checkHeroes = False Then
If abs($g_aiSearchHeroWaitEnable[$g_iMatchMode] - $iHeroUpgradingBit) <= $eHeroNone Then $checkHeroes = True
EndIf
Local $checkSpells =($bFullArmySpells And $g_abSearchSpellsWaitEnable[$g_iMatchMode]) Or $g_abSearchSpellsWaitEnable[$g_iMatchMode] = False
Local $totalSpellsToBrew = 0
For $i = 0 To $eSpellCount - 1
$totalSpellsToBrew += $g_aiArmyCompSpells[$i]
Next
If GetCurTotalSpell() = $totalSpellsToBrew And $g_abSearchSpellsWaitEnable[$g_iMatchMode] Then
$checkSpells = True
ElseIf $bFullArmySpells = True And $g_abSearchSpellsWaitEnable[$g_iMatchMode] Then
$checkSpells = True
ElseIf $g_abSearchSpellsWaitEnable[$g_iMatchMode] = False Then
$checkSpells = True
Else
$checkSpells = False
EndIf
Switch $g_iMatchMode
Case $DB
$bMatchModeEnabled = $g_abAttackTypeEnable[$DB]
Case $LB
$bMatchModeEnabled = $g_abAttackTypeEnable[$LB]
Case $TS
$bMatchModeEnabled = $g_abAttackTypeEnable[$TS]
Case Else
$bMatchModeEnabled = False
EndSwitch
If $bMatchModeEnabled = False Then Return False
If $checkHeroes And $checkSpells Then
If($checkSearches Or $g_abSearchSearchesEnable[$g_iMatchMode] = False) And($checkTropies Or $g_abSearchTropiesEnable[$g_iMatchMode] = False) And($checkArmyCamps Or $g_abSearchCampsEnable[$g_iMatchMode] = False) Then
If $g_iDebugSetlog = 1 And $bNoLog = False Then Setlog($g_asModeText[$g_iMatchMode] & " active! ($checkSearches=" & $checkSearches & ",$checkTropies=" & $checkTropies & ",$checkArmyCamps=" & $checkArmyCamps & ",$checkHeroes=" & $checkHeroes & ",$checkSpells=" & $checkSpells & ")", $COLOR_INFO)
Return True
Else
If $g_iDebugSetlog = 1 And $bNoLog = False Then
Setlog($g_asModeText[$g_iMatchMode] & " not active!", $COLOR_INFO)
Local $txtsearches = "Fail"
If $checkSearches Then $txtsearches = "Success"
Local $txttropies = "Fail"
If $checkTropies Then $txttropies = "Success"
Local $txtArmyCamp = "Fail"
If $checkArmyCamps Then $txtArmyCamp = "Success"
Local $txtHeroes = "Fail"
If $checkHeroes Then $txtHeroes = "Success"
If $g_abSearchSearchesEnable[$g_iMatchMode] Then Setlog("searches range: " & $g_aiSearchSearchesMin[$g_iMatchMode] & "-" & $g_aiSearchSearchesMax[$g_iMatchMode] & "  actual value: " & $currentSearch & " - " & $txtsearches, $COLOR_INFO)
If $g_abSearchTropiesEnable[$g_iMatchMode] Then Setlog("tropies range: " & $g_aiSearchTrophiesMin[$g_iMatchMode] & "-" & $g_aiSearchTrophiesMax[$g_iMatchMode] & "  actual value: " & $currentTropies & " | " & $txttropies, $COLOR_INFO)
If $g_abSearchCampsEnable[$g_iMatchMode] Then Setlog("Army camps % range >=: " & $g_aiSearchCampsPct[$g_iMatchMode] & " actual value: " & $currentArmyCamps & " | " & $txtArmyCamp, $COLOR_INFO)
If $g_aiSearchHeroWaitEnable[$g_iMatchMode] > $eHeroNone Then SetLog("Hero status " & BitAND($g_aiAttackUseHeroes[$g_iMatchMode], $g_aiSearchHeroWaitEnable[$g_iMatchMode], $iHeroAvailable) & " " & $iHeroAvailable & " | " & $txtHeroes, $COLOR_INFO)
Local $txtSpells = "Fail"
If $checkSpells Then $txtSpells = "Success"
If $g_abSearchSpellsWaitEnable[$g_iMatchMode] Then SetLog("Full spell status: " & $bFullArmySpells & " | " & $txtSpells, $COLOR_INFO)
EndIf
Return False
EndIf
ElseIf $checkHeroes = 0 Then
If $g_iDebugSetlog = 1 And $bNoLog = False Then Setlog("Heroes not ready", $COLOR_DEBUG)
Return False
Else
If $g_iDebugSetlog = 1 And $bNoLog = False Then Setlog("Spells not ready", $COLOR_DEBUG)
Return False
EndIf
EndFunc
Func IsSearchModeActiveMini(Const $iMatchMode)
Return $g_abAttackTypeEnable[$DB] Or $g_abAttackTypeEnable[$LB] Or $g_abAttackTypeEnable[$TS]
EndFunc
Func IsWaitforSpellsActive()
For $i = $DB To $g_iModeCount - 1
If $g_abAttackTypeEnable[$i] And $g_abSearchSpellsWaitEnable[$i] Then
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then Setlog("IsWaitforSpellsActive = True", $COLOR_DEBUG)
Return True
EndIf
Next
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then Setlog("IsWaitforSpellsActive = False", $COLOR_DEBUG)
Return False
EndFunc
Func IsWaitforHeroesActive()
For $i = $DB To $g_iModeCount - 1
If $g_abAttackTypeEnable[$i] And($g_aiSearchHeroWaitEnable[$i] > $eHeroNone And(BitAND($g_aiAttackUseHeroes[$i], $g_aiSearchHeroWaitEnable[$i]) = $g_aiSearchHeroWaitEnable[$i]) And(abs($g_aiSearchHeroWaitEnable[$i] - $iHeroUpgradingBit) > $eHeroNone)) Then
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then Setlog("IsWaitforHeroesActive = True", $COLOR_DEBUG)
Return True
EndIf
Next
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then Setlog("IsWaitforHeroesActive = False", $COLOR_DEBUG)
Return False
EndFunc
Func IsSearchAttackEnabled()
If $g_iDebugSetlog = 1 Then Setlog("Begin IsSearchAttackScheduled:", $COLOR_DEBUG1)
If $ichkAttackPlannerEnable = 0 Then Return True
Local $sStartTime = "", $sEndTime = ""
Local $aNoAttackTimes[2] = [$sStartTime, $sEndTime]
Local $iWaitTime = 0
Local $bCloseGame = $ichkAttackPlannerCloseCoC = 1 Or $ichkAttackPlannerCloseAll = 1
If $g_iDebugSetlog = 1 Then Setlog("$bCloseGame:" & $bCloseGame, $COLOR_DEBUG)
If $ichkAttackPlannerDayLimit = 1 And _OverAttackLimit() Then
Setlog("Daily attack limit reached, skip attacks till new day starts!", $COLOR_INFO)
If _Sleep($iDelayRespond) Then Return True
If $bCloseGame Then
$iWaitTime = _getTimeRemainTimeToday()
UniversalCloseWaitOpenCoC($iWaitTime * 1000, "IsSearchAttackScheduled_", $ichkAttackPlannerCloseAll, True)
$g_bRestart = True
Return
Else
Return False
EndIf
EndIf
If $ichkAttackPlannerRandom = 1 Then
$aNoAttackTimes = _getDailyRandomStartEnd($icmbAttackPlannerRandom)
If @error Then
Setlog(@extended, $COLOR_ERROR)
Return True
EndIf
If _IsTimeInRange($aNoAttackTimes[0], $aNoAttackTimes[1]) Then
Setlog("Attack schedule random skip time found....", $COLOR_INFO)
If _Sleep($iDelayRespond) Then Return True
If $bCloseGame Then
$iWaitTime = _DateDiff("s", $aNoAttackTimes[1], _NowCalc())
If @error Then
_logErrorDateDiff(@error)
SetError(1, "Can not find NoAttack wait time", True)
Return True
EndIf
UniversalCloseWaitOpenCoC($iWaitTime * 1000, "IsSearchAttackScheduled_", $ichkAttackPlannerCloseAll, True)
$g_bRestart = True
Return
Else
Return False
EndIf
Else
Return True
EndIf
Else
If IsPlannedTimeNow() = False Then
Setlog("Attack schedule planned skip time found...", $COLOR_INFO)
If _Sleep($iDelayRespond) Then Return True
If $bCloseGame Then
If $iPlannedAttackWeekDays[@WDAY - 1] = 0 Then
$iWaitTime = _getTimeRemainTimeToday()
For $i = @WDAY To 6
If $iPlannedAttackWeekDays[$i] = 0 Then $iWaitTime += 86400
If $iPlannedAttackWeekDays[$i] = 1 Then ExitLoop
If $g_iDebugSetlog = 1 Then Setlog("Subtotal wait time= " & $iWaitTime & " Seconds", $COLOR_DEBUG)
Next
EndIf
If $iWaitTime = 0 Then
If $iPlannedAttackWeekDays[@WDAY - 1] = 1 And $iPlannedattackHours[@HOUR] = 0 Then
$iWaitTime +=(59 - @MIN) * 60
For $i = @HOUR + 1 To 23
If $iPlannedattackHours[$i] = 0 Then $iWaitTime += 3600
If $iPlannedattackHours[$i] = 1 Then ExitLoop
If $g_iDebugSetlog = 1 Then Setlog("Subtotal wait time= " & $iWaitTime & " Seconds", $COLOR_DEBUG)
Next
EndIf
EndIf
If $g_iDebugSetlog = 1 Then Setlog("Stop attack wait time= " & $iWaitTime & " Seconds", $COLOR_DEBUG)
UniversalCloseWaitOpenCoC($iWaitTime * 1000, "IsSearchAttackScheduled_", $ichkAttackPlannerCloseAll, True)
$g_bRestart = True
Return
Else
Return False
EndIf
EndIf
EndIf
Return True
EndFunc
Func _getTimeRemainTimeToday()
Local $iTimeRemain = _DateDiff("s", _NowCalc(), _NowCalcDate() & " 23:59:59")
If @error Then
_logErrorDateDiff(@error)
SetError(1, "Can not determine time remaining today", 0)
Return
EndIf
If $g_iDebugSetlog = 1 Then Setlog("getTimeRemainToday= " & $iTimeRemain & " Seconds", $COLOR_DEBUG)
Return $iTimeRemain
EndFunc
Func _IsTimeAfter($sCompareTime, $sCurrentTime = _NowCalc())
Local $bResult = _DateDiff("s", $sCurrentTime, $sCompareTime) < 0
If @error Then
_logErrorDateDiff(@error)
SetError(1, "Can not check if time is after", False)
Return
EndIf
If $g_iDebugSetlog = 1 Then Setlog("IsTimeAfter: " & $bResult, $COLOR_DEBUG)
Return $bResult
EndFunc
Func _IsTimeBefore($sCompareTime, $sCurrentTime = _NowCalc())
Local $bResult = _DateDiff("s", $sCurrentTime, $sCompareTime) > 0
If @error Then
_logErrorDateDiff(@error)
SetError(1, "Can not check if time is before", False)
Return
EndIf
If $g_iDebugSetlog = 1 Then Setlog("IsTimeBefore: " & $bResult, $COLOR_DEBUG)
Return $bResult
EndFunc
Func _IsTimeInRange($sStartTime, $sEndTime)
Local $sCurrentTime = _NowCalc()
Local $bResult = _IsTimeAfter($sStartTime, $sCurrentTime) And _IsTimeBefore($sEndTime, $sCurrentTime)
If $g_iDebugSetlog = 1 Then Setlog("IsTimeInRange: " & $bResult, $COLOR_DEBUG)
Return $bResult
EndFunc
Func _getDailyRandomStartEnd($iDuration = 4)
Local $iStartHour, $iEndHour
Local Static $iNowDay = @YDAY
If Not($iDuration >= 0 And $iDuration <= 24) Then
SetError(1, "Invalid duration for _getDailyRandomStartEnd")
Return
EndIf
Local $sStartTime = _DateAdd("h", Int(_getDailyRandom() *(23 - @HOUR)), _NowCalc())
If @error Then
_logErrorDateDiff(@error)
SetError(2, "Can not create initial random start time")
Return
EndIf
Local $sEndTime = _DateAdd("h", Int($iDuration), $sStartTime)
If @error Then
_logErrorDateDiff(@error)
SetError(3, "Can not create initial random end time")
Return
EndIf
Local Static $aNoAttackTimes[2] = [$sStartTime, $sEndTime]
If $iNowDay <> @YDAY Then
$iStartHour = _getDailyRandom() * 24
If $iStartHour <= @HOUR Then $iStartHour = @HOUR + 1.166
$iEndHour = $iStartHour + $iDuration
If $g_iDebugSetlog = 1 Then Setlog("StartHour: " & $iStartHour & "EndHour: " & $iEndHour, $COLOR_DEBUG)
$aNoAttackTimes[0] = _DateAdd("h", $iStartHour, _NowCalc())
If @error Then
_logErrorDateDiff(@error)
SetError(4, "Can not create random start time")
Return
EndIf
$aNoAttackTimes[1] = _DateAdd("h", $iEndHour, _NowCalc())
If @error Then
_logErrorDateDiff(@error)
SetError(5, "Can not create random end time")
Return
EndIf
EndIf
If $g_iDebugSetlog = 1 Then Setlog("NoAttackStart: " & $aNoAttackTimes[0] & "NoAttackEnd: " & $aNoAttackTimes[1], $COLOR_DEBUG)
Return $aNoAttackTimes
EndFunc
Func _getDailyRandom()
Local Static $iDailyRandomValue = Random(0.001, 1, 4)
Local Static $iNowDay = @YDAY
If $iNowDay <> @YDAY Then
$iDailyRandomValue = Round(Random(0.001, 1), 4)
$iNowDay = @YDAY
If $g_iDebugSetlog = 1 Then Setlog("New day = new random value!", $COLOR_DEBUG)
EndIf
If $g_iDebugSetlog = 1 Then Setlog("DailyRandomValue=" & StringFormat("%0.5f", $iDailyRandomValue), $COLOR_DEBUG)
Return $iDailyRandomValue
EndFunc
Func IsPlannedTimeNow()
Local $hour, $hourloot
If $iPlannedAttackWeekDays[@WDAY - 1] = 1 Then
$hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
$hourloot = $hour[0]
If $iPlannedattackHours[$hourloot] = 1 Then
If $g_iDebugSetlog = 1 Then SetLog("Attack plan enabled for now..", $COLOR_DEBUG)
Return True
Else
SetLog("Attack plan enabled today, but not this hour", $COLOR_INFO)
If _Sleep($iDelayRespond) Then Return False
Return False
EndIf
Else
SetLog("Attack plan not enabled today", $COLOR_INFO)
If _Sleep($iDelayRespond) Then Return False
Return False
EndIf
EndFunc
Func _OverAttackLimit()
Local Static $iAttackCountToday = 0
Local Static $iTotalAttackCount = $iAttackedCount
Local Static $iNowDay = @YDAY
If $iNowDay <> @YDAY Then
$iAttackCountToday = 0
$iNowDay = @YDAY
$iTotalAttackCount = $iAttackedCount
Else
$iAttackCountToday = $iAttackedCount - $iTotalAttackCount
EndIf
If $g_iDebugSetlog = 1 Then Setlog("AttackCountToday: " & $iAttackCountToday & ", AttackedCount: " & $iAttackedCount & "TotalAttackCount: " & $iTotalAttackCount, $COLOR_DEBUG)
Local $iRandomAttackCountToday = Ceiling(Int($icmbAttackPlannerDayMin) +(_getDailyRandom() *(Int($icmbAttackPlannerDayMax) - Int($icmbAttackPlannerDayMin))))
If $iRandomAttackCountToday > Int($icmbAttackPlannerDayMax) Then $iRandomAttackCountToday = Int($icmbAttackPlannerDayMax)
If $g_iDebugSetlog = 1 Then Setlog("RandomAttackCountToday: " & $iRandomAttackCountToday, $COLOR_DEBUG)
If $iAttackCountToday > $iRandomAttackCountToday Then Return True
Return False
EndFunc
Func WaitForClouds()
If $g_iDebugSetlog = 1 Then Setlog("Begin WaitForClouds:", $COLOR_DEBUG1)
Local $iCount = 0
Local $bigCount = 0, $iLastTime = 0
Local $hMinuteTimer, $iSearchTime
Local $bEnabledGUI = False
Local $maxSearchCount = 720
Local $maxLongSearchCount = 7
Switch Int($iTrophyCurrent)
Case 3700 To 4099
$maxSearchCount = Random(480, 840, 1)
$maxLongSearchCount = Random(10, 12, 1)
Case 4100 To 4399
$maxSearchCount = Random(480, 840, 1)
$maxLongSearchCount = Random(15, 25, 1)
Case 4400 To 4699
$maxSearchCount = Random(600, 840, 1)
$maxLongSearchCount = Random(24, 42, 1)
Case 4700 To 4999
$maxSearchCount = Random(600, 840, 1)
$maxLongSearchCount = Random(36, 50, 1)
Case 5000 To 6500
$maxSearchCount = Random(600, 840, 1)
$maxLongSearchCount = Random(80, 85, 1)
EndSwitch
If $g_iDebugSetlog Then
SetLog("RANDOM: $maxSearchCount= " & $maxSearchCount & "= " & Round($maxSearchCount / $iDelayGetResources1, 2) & " min between cloud chk", $COLOR_DEBUG)
SetLog("RANDOM: $maxLongSearchCount= " & $maxLongSearchCount & "= " & Round(($maxSearchCount / $iDelayGetResources1) * $maxLongSearchCount, 2) & " min max search time", $COLOR_DEBUG)
EndIf
ForceCaptureRegion()
Local $hMinuteTimer = TimerInit()
While _CheckPixel($aNoCloudsAttack, $g_bCapturePixel) = False
If _Sleep($iDelayGetResources1) Then Return
$iCount += 1
If isProblemAffect(True) Then
resetAttackSearch()
Return
EndIf
If $iCount >= $maxSearchCount Then
If EnableLongSearch() = False Then
resetAttackSearch()
Return
Else
$bigCount += 1
If $bigCount > $maxLongSearchCount Then
$iSearchTime = TimerDiff($hMinuteTimer) / 60000
SetLog("Spent " & $iSearchTime & " minutes in Clouds searching, Restarting CoC and Bot...", $COLOR_ERROR)
$Is_ClientSyncError = False
$g_bRestart = True
CloseCoC(True)
Return
EndIf
$iCount = 0
EndIf
EndIf
If $g_iDebugSetlog = 1 Then _GUICtrlStatusBar_SetText($g_hStatusBar, " Status: Loop to clean screen without Clouds, # " & $iCount)
$iSearchTime = TimerDiff($hMinuteTimer) / 60000
If $iSearchTime >= $iLastTime + 1 Then
Setlog("Cloud wait time " & StringFormat("%.1f", $iSearchTime) & " minute(s)", $COLOR_INFO)
$iLastTime += 1
If chkAttackSearchFail() = 2 Or chkAttackSearchPersonalBreak() = True Then
resetAttackSearch()
Return
EndIf
If $iSearchTime > 2 And $bEnabledGUI = False Then
AndroidShieldForceDown(True)
EnableGuiControls()
SetLog("Enabled bot controls due to long wait time", $COLOR_SUCCESS)
$bEnabledGUI = True
EndIf
EndIf
ForceCaptureRegion()
WEnd
If $bEnabledGUI = True Then
SetLog("Disable bot controls after long wait time", $COLOR_SUCCESS)
AndroidShieldForceDown(False)
DisableGuiControls()
SaveConfig()
readConfig()
applyConfig()
EndIf
If _Sleep($iDelayCloudsCleared) Then Return
EndFunc
Func EnableLongSearch()
Local $result = ""
Local $iCount, $jCount, $kCount, $wCount
If $g_iDebugSetlog = 1 Then Setlog("Begin EnableLongSearch:", $COLOR_DEBUG1)
If Int($iTrophyCurrent) < 3700 Then
If $g_iDebugSetlog = 1 Then Setlog("Long cloud search not enabled due trophy count: " & $iTrophyCurrent, $COLOR_DEBUG)
Return False
EndIf
If chkSearchText() = True Then
$iCount = 0
While 1
If _CheckPixel($aOpenChatTab, $g_bCapturePixel, Default, "OpenChatTab check", $COLOR_DEBUG) Then
ClickP($aOpenChatTab, 1, 0, "#0510")
If _Sleep($iDelayGetResources1) Then Return
$jCount = 0
While 1
If _CheckPixel($aCloseChat, $g_bCapturePixel, Default, "CloseChatTab check", $COLOR_DEBUG) Then
ClickP($aCloseChat, 1, 0, "#0511")
$kCount = 0
While 1
If _Sleep($iDelaySleep) Then Return
$result = getCloudTextShort(260, 349 + $g_iMidOffsetY, "Cloud Search Text: sea=", $COLOR_DEBUG, Default)
If _CheckPixel($aCloseChat, $g_bCapturePixel, Default, "CloseChatTab check", $COLOR_DEBUG) Then
$kCount += 1
ElseIf $result <> "" And StringInStr($result, "sea", $STR_NOCASESENSEBASIC) > 0 Then
Return True
Else
Return True
EndIf
$kCount += 1
If $kCount > 30 Then
If chkSurrenderBtn() = True Then Return True
SetLog("Warning - Found CloseChat Btn still open during search extension", $COLOR_WARNING)
Return False
EndIf
WEnd
EndIf
If _Sleep($iDelaySleep) Then Return
$jCount += 1
If $jCount > 50 Then
If chkSurrenderBtn() = True Then Return True
SetLog("Warning - Not find CloseChat tab during search extension", $COLOR_WARNING)
Return False
EndIf
WEnd
EndIf
$iCount += 1
If $iCount > 30 Then
If chkSurrenderBtn() = True Then Return True
SetLog("Cloud Search Text found, but chat button not found, restart search..", $COLOR_ERROR)
Return False
EndIf
WEnd
Else
If chkSurrenderBtn() = True Then Return True
If chkAttackSearchPersonalBreak() = True Then Return False
If chkAttackSearchFail() = 1 Then Return True
If $g_iDebugSetlog = 1 Then SetLog("Cloud Search Text not found...", $COLOR_DEBUG)
Return False
EndIf
EndFunc
Func chkSearchText()
Local $result
$result = getCloudTextShort(388, 348 + $g_iMidOffsetY, "Cloud Search Text: for=", $COLOR_DEBUG, Default)
If $result <> "" And StringInStr($result, "for", $STR_NOCASESENSEBASIC) <> 0 Then
Return True
EndIf
Return False
EndFunc
Func chkAttackSearchFail()
Local $result
$result = getCloudFailShort(271, 351 + $g_iMidOffsetY, "Cloud Search Fail Text: unable=", $COLOR_DEBUG, Default)
If $result <> "" And StringInStr($result, "unable", $STR_NOCASESENSEBASIC) > 0 Then
If btnSearchFailRetry() = True Then
Setlog("Search Fail? Retry search button pushed, continue...", $COLOR_SUCCESS)
Return 1
Else
SetLog("Warning, failed to find/press retry search button", $COLOR_WARNING)
Return 2
EndIf
EndIf
EndFunc
Func chkAttackSearchPersonalBreak()
Local $result
$result = getCloudFailShort(499, 350 + $g_iMidOffsetY, "Cloud Search PB Text: Break=", $COLOR_DEBUG, Default)
If $result <> "" And StringInStr($result, "break", $STR_NOCASESENSEBASIC) > 0 Then
Setlog("Prepare base before Personal Break in clouds..", $COLOR_INFO)
CheckBaseQuick(True, "cloud")
Return True
EndIf
If $ichkSinglePBTForced And _DateIsValid($sPBStartTime) Then
Local $iTimeTillPBTstartSec = Int(_DateDiff('s', $sPBStartTime, _NowCalc()))
If $g_iDebugSetlog = 1 Then Setlog("PB starts in: " & $iTimeTillPBTstartSec & " Seconds", $COLOR_DEBUG)
If $iTimeTillPBTstartSec >= 0 Then
Setlog("Prepare base before user forced Break..", $COLOR_INFO)
CheckBaseQuick(True, "cloud")
Return True
EndIf
EndIf
Return False
EndFunc
Func btnSearchFailRetry()
Local $offColors[3][3] = [[0x000000, 50, 8], [0x60B014, 55, 21], [0x020201, 90, 7]]
Global $ButtonPixel = _MultiPixelSearch(364, 405 + $g_iMidOffsetY, 466, 430 + $g_iMidOffsetY, 1, 1, Hex(0x000000, 6), $offColors, 20)
If $g_iDebugSetlog = 1 Then Setlog("Retry btn clr chk-#1: " & _GetPixelColor(368, 347 + $g_iMidOffsetY, True) & ", #2: " &  _GetPixelColor(368 + 50, 347 + 8 + $g_iMidOffsetY, True) & ", #3: " & _GetPixelColor(368 + 55, 347 + 21 + $g_iMidOffsetY, True) & ", #4: " &  _GetPixelColor(368 + 90, 347 + 7 + $g_iMidOffsetY, True), $COLOR_DEBUG)
If IsArray($ButtonPixel) Then
If $g_iDebugSetlog = 1 Then
Setlog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("Retry Btn Pixel color found #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 144, $ButtonPixel[1], True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 54, $ButtonPixel[1] + 17, True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 54, $ButtonPixel[1] + 27, True), $COLOR_DEBUG)
EndIf
Click($ButtonPixel[0] + 75, $ButtonPixel[1] + 25, 1, 0, "#0512")
Return True
EndIf
Return False
EndFunc
Func chkSurrenderBtn()
Local $wCount = 0
While 1
If _CheckPixel($aSurrenderButton, $g_bCapturePixel, Default, "Surrender btn wait #" & $wCount, $COLOR_DEBUG) = True Then
If $g_iDebugSetlog = 1 Then Setlog("Surrender button found, clouds gone, continue...", $COLOR_DEBUG)
Return True
EndIf
If _Sleep($iDelaySleep) Then Return
$wCount += 1
If $wCount >= 30 Or isProblemAffect(True) Then
Return False
EndIf
WEnd
EndFunc
Func BoostStructure($sName, $sOcrName, $aPos, ByRef $icmbBoostValue, $cmbBoostCtrl)
Local $boosted = False
Local $ok = False
If UBound($aPos) > 1 And $aPos[0] > 0 And $aPos[1] > 0 Then
BuildingClickP($aPos, "#0462")
If _Sleep($iDelayBoostHeroes2) Then Return
ForceCaptureRegion()
Local $aResult = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If $aResult[0] > 1 Then
Local $sN = $aResult[1]
Local $sL = $aResult[2]
If $sOcrName = "" Or StringInStr($sN, $sOcrName, $STR_NOCASESENSEBASIC) > 0 Then
SetLog("Boosting " & $sN & " (Level " & $sL & ") located at " & $aPos[0] & ", " & $aPos[1])
$ok = True
Else
SetLog("Cannot boost " & $sN & " (Level " & $sL & ") located at " & $aPos[0] & ", " & $aPos[1], $COLOR_ERROR)
EndIf
EndIf
EndIf
If $ok = True Then
Local $Boost = findButton("BoostOne")
If IsArray($Boost) Then
If $g_iDebugSetlog = 1 Then Setlog("Boost Button X|Y = " & $Boost[0] & "|" & $Boost[1], $COLOR_DEBUG)
Click($Boost[0], $Boost[1], 1, 0, "#0463")
If _Sleep($iDelayBoostHeroes1) Then Return
$Boost = findButton("GEM")
If IsArray($Boost) Then
Click($Boost[0], $Boost[1], 1, 0, "#0464")
If _Sleep($iDelayBoostHeroes4) Then Return
If IsArray(findButton("EnterShop")) Then
SetLog("Not enough gems to boost " & $sName, $COLOR_ERROR)
Else
$icmbBoostValue -= 1
SetLog($sName & ' Boost completed. Remaining iterations: ' & $icmbBoostValue, $COLOR_SUCCESS)
_GUICtrlComboBox_SetCurSel($cmbBoostCtrl, $icmbBoostValue)
$boosted = True
EndIf
Else
SetLog($sName & " is already Boosted", $COLOR_ERROR)
EndIf
If _Sleep($iDelayBoostHeroes3) Then Return
ClickP($aAway, 1, 0, "#0465")
Else
SetLog($sName & " Boost Button not found", $COLOR_ERROR)
If _Sleep($iDelayBoostHeroes4) Then Return
EndIf
Else
SetLog("Abort boosting " & $sName & ", bad location", $COLOR_ERROR)
EndIf
Return $boosted
EndFunc
Func AllowBoosting($sName, $icmbBoost)
If($bTrainEnabled = True And $icmbBoost > 0) = False Then Return False
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If $g_abBoostBarracksHours[$hour[0]] = False Then
SetLog("Boosting " & $sName & " is not planned and skipped...", $COLOR_SUCCESS)
Return False
EndIf
Return True
EndFunc
Global $DebugBarrackBoost = 0
Func BoostBarracks()
If $bTrainEnabled = False Then Return
If $g_iCmbBoostBarracks = 0 Then Return
If $g_iCmbBoostBarracks >= 1 Then
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If $g_abBoostBarracksHours[$hour[0]] = False Then
SetLog("Boost Barracks are not Planned, Skipped..", $COLOR_BLUE)
Return
EndIf
EndIf
If OpenArmyWindow() = True Then
Local $CheckArmyWindow = ISArmyWindow()
OpenTrainTabNumber(1, "BoostBarracks")
If _Sleep(400) Then Return
Local $ClickResult = ClickOnBoostArmyWindow()
If $ClickResult = True Then
Local $GemResult = IsGemWindowOpen(True)
If $GemResult = True Then
If $g_iCmbBoostBarracks >= 1 Then $g_iCmbBoostBarracks -= 1
Setlog(" Total remain cycles to boost Barracks:" & $g_iCmbBoostBarracks, $COLOR_GREEN)
GUICtrlSetData($g_hCmbBoostBarracks, $g_iCmbBoostBarracks)
EndIf
EndIf
ClickP($aAway, 1, 0, "#0161")
PureClickP($aAway, 1, 0, "#0140")
EndIf
_Sleep($iDelayBoostBarracks5 + 1000)
checkMainScreen(False)
Return True
EndFunc
Func BoostSpellFactory()
If $bTrainEnabled = False Then Return
If $g_iCmbBoostSpellFactory >= 1 Then
SetLog("Boosting Spell Factory...", $COLOR_BLUE)
If OpenArmyWindow() = True Then
Local $CheckArmyWindow = ISArmyWindow()
OpenTrainTabNumber(2, "BoostSpellFactory")
If _Sleep(400) Then Return
Local $ClickResult = ClickOnBoostArmyWindow()
If $ClickResult = True Then
Local $GemResult = IsGemWindowOpen(True)
If $GemResult = True Then
If $g_iCmbBoostSpellFactory >= 1 Then $g_iCmbBoostSpellFactory -= 1
Setlog(" Total remain cycles to boost Spells:" & $g_iCmbBoostSpellFactory, $COLOR_GREEN)
GUICtrlSetData($g_hCmbBoostSpellFactory, $g_iCmbBoostSpellFactory)
EndIf
EndIf
ClickP($aAway, 1, 0, "#0161")
PureClickP($aAway, 1, 0, "#0140")
EndIf
_Sleep($iDelayBoostBarracks5 + 1000)
checkMainScreen(False)
Return True
EndIf
EndFunc
Func ClickOnBoostArmyWindow()
If $DebugBarrackBoost = 1 Then SetLog("Func ClickOnBoostArmyWindow()", $COLOR_DEBUG)
_Sleep($iDelayBoostBarracks2)
Local $ClockColor = _GetPixelColor(780, 312 + $g_iMidOffsetY, True)
Local $ResColCheck = _ColorCheck($ClockColor, Hex(0x65AF20, 6), 40)
If $ResColCheck = True Then
SetLog("Boost Button is Available, Clicking On...", $COLOR_BLUE)
Click(770, 325)
_Sleep($iDelayBoostBarracks2)
Return True
Else
If _ColorCheck(_GetPixelColor(718, 285 + $g_iMidOffsetY, True), Hex(0xEEF470, 6), 40) Then
SetLog("Already Boosted! Skipping...", $COLOR_GREEN)
Else
SetLog("Cannot Verify Boost Button! Skipping...", $COLOR_ORANGE)
EndIf
Return False
EndIf
EndFunc
Func IsGemWindowOpen($AcceptGem = False)
If $DebugBarrackBoost = 1 Then SetLog("Func IsGemWindowOpen(" & $AcceptGem & ")", $COLOR_DEBUG)
_Sleep($iDelayisGemOpen1)
If _ColorCheck(_GetPixelColor(590, 235 + $g_iMidOffsetY, True), Hex(0xD80408, 6), 20) Then
If _ColorCheck(_GetPixelColor(375, 383 + $g_iMidOffsetY, True), Hex(0x222322, 6), 20) Then
If $g_iDebugSetlog = 1 Or $DebugBarrackBoost = 1 Then Setlog("DETECTED, GEM Window Is OPEN", $COLOR_DEBUG)
If $AcceptGem = True Then
Click(435, 445)
_Sleep($iDelayBoostBarracks2)
SetLog('Boost was Successful.', $COLOR_GREEN)
Else
PureClickP($aAway, 1, 0, "#0140")
EndIf
_Sleep($iDelayBoostSpellFactory3)
ClickP($aAway, 1, 0, "#0161")
If $DebugBarrackBoost = 1 Then SetLog("Func IsGemWindowOpen(" & $AcceptGem & ") = TRUE", $COLOR_GREEN)
Return True
EndIf
EndIf
If $DebugBarrackBoost = 1 Then SetLog("Func IsGemWindowOpen(" & $AcceptGem & ") = FALSE", $COLOR_GREEN)
Return False
EndFunc
Func BotDetectFirstTime()
Local $collx, $colly, $Result, $i = 0 , $t =0
If $Is_ClientSyncError = True Then Return
ClickP($aAway, 1, 0, "#0166")
If _Sleep($iDelayBotDetectFirstTime1) Then Return
SetLog("Detecting your Buildings..", $COLOR_INFO)
If(isInsideDiamond($TownHallPos) = False) Then
If _GetPixelColor($aTopLeftClient[0], $aTopLeftClient[1], True) <> Hex($aTopLeftClient[2], 6) And _GetPixelColor($aTopRightClient[0], $aTopRightClient[1], True) <> Hex($aTopRightClient[2], 6) Then
Zoomout()
Collect()
EndIf
_CaptureRegion2()
Local $PixelTHHere = GetLocationItem("getLocationTownHall")
If UBound($PixelTHHere) > 0 Then
Local $pixel = $PixelTHHere[0]
$TownHallPos[0] = $pixel[0]
$TownHallPos[1] = $pixel[1]
If $g_iDebugSetlog = 1 Then SetLog("DLLc# Townhall: (" & $TownHallPos[0] & "," & $TownHallPos[1] & ")", $COLOR_ERROR)
EndIf
If $TownHallPos[1] = "" Or $TownHallPos[1] = -1 Then
imglocTHSearch(true,true)
$TownHallPos[0] = $THx
$TownHallPos[1] = $THy
If $g_iDebugSetlog = 1 Then SetLog("OldDDL Townhall: (" & $TownHallPos[0] & "," & $TownHallPos[1] & ")", $COLOR_ERROR)
EndIf
SetLog("Townhall: (" & $TownHallPos[0] & "," & $TownHallPos[1] & ")", $COLOR_DEBUG)
EndIf
If Number($iTownHallLevel) < 2 Then
$Result = GetTownHallLevel(True)
If IsArray($Result) Then $iTownHallLevel = 0
EndIf
If Number($iTownHallLevel) > 1 And Number($iTownHallLevel) < 6 Then
Setlog("Warning: TownHall level below 6 NOT RECOMMENDED!", $COLOR_ERROR)
Setlog("Proceed with caution as errors may occur.", $COLOR_ERROR)
EndIf
If _Sleep($iDelayBotDetectFirstTime1) Then Return
CheckImageType()
If _Sleep($iDelayBotDetectFirstTime1) Then Return
If GUICtrlRead($g_hChkScreenshotHideName) = $GUI_CHECKED Or $ichkScreenshotHideName = 1 Then
If _Sleep($iDelayBotDetectFirstTime3) Then Return
If $aCCPos[0] = -1 Then
LocateClanCastle()
SaveConfig()
EndIf
EndIf
If $g_bAutoLabUpgradeEnable = True Then
If _Sleep($iDelayBotDetectFirstTime3) Then Return
If $aLabPos[0] = "" Or $aLabPos[0] = -1 Then
LocateLab()
SaveConfig()
EndIf
EndIf
If(GUICtrlRead($g_hCmbBoostBarbarianKing) > 0) Or $g_bUpgradeKingEnable = True Then
If _Sleep($iDelayBotDetectFirstTime3) Then Return
If $KingAltarPos[0] = -1 Then
LocateKingAltar()
SaveConfig()
EndIf
EndIf
If(GUICtrlRead($g_hCmbBoostArcherQueen) > 0) Or $g_bUpgradeQueenEnable = True Then
If _Sleep($iDelayBotDetectFirstTime3) Then Return
If $QueenAltarPos[0] = -1 Then
LocateQueenAltar()
SaveConfig()
EndIf
EndIf
If Number($iTownHallLevel) > 10 And((GUICtrlRead($g_hCmbBoostWarden) > 0) Or $g_bUpgradeWardenEnable = True) Then
If _Sleep($iDelayBotDetectFirstTime3) Then Return
If $WardenAltarPos[0] = -1 Then
LocateWardenAltar()
SaveConfig()
EndIf
EndIf
GUICtrlSetData($g_hLblTHLevels, "")
_GUI_Value_STATE("HIDE", $groupListTHLevels)
If $g_iDebugSetlog = 1 Then Setlog("Select TH Level:" & Number($iTownHallLevel), $COLOR_DEBUG)
GUICtrlSetState($g_ahPicTHLevels[$iTownHallLevel], $GUI_SHOW)
GUICtrlSetData($g_hLblTHLevels, $iTownHallLevel)
EndFunc
Func BotCommand()
Static $TimeToStop = -1
If $g_bChkBotStop = True Then
$g_bMeetCondStop = False
$bTrainEnabled = True
$bDonationEnabled = True
If $g_iCmbBotCond = 15 And $g_iCmbHoursStop <> 0 Then $TimeToStop = $g_iCmbHoursStop * 3600000
Local $iTrophyCurrent = getTrophyMainScreen($aTrophies[0], $aTrophies[1])
Local $TrophyMax = Number($iTrophyCurrent) > Number($itxtMaxTrophy)
Local $Trophy =($TrophyMax ? "Max. Trophy Reached!" : "")
Switch $g_iCmbBotCond
Case 0
If isGoldFull() And isElixirFull() And $TrophyMax Then $g_bMeetCondStop = True
Case 1
If(isGoldFull() And isElixirFull()) Or $TrophyMax Then $g_bMeetCondStop = True
Case 2
If(isGoldFull() Or isElixirFull()) And $TrophyMax Then $g_bMeetCondStop = True
Case 3
If isGoldFull() Or isElixirFull() Or $TrophyMax Then $g_bMeetCondStop = True
Case 4
If isGoldFull() And isElixirFull() Then $g_bMeetCondStop = True
Case 5
If isGoldFull() Or isElixirFull() Then $g_bMeetCondStop = True
Case 6
If isGoldFull() And $TrophyMax Then $g_bMeetCondStop = True
Case 7
If isElixirFull() And $TrophyMax Then $g_bMeetCondStop = True
Case 8
If isGoldFull() Or $TrophyMax Then $g_bMeetCondStop = True
Case 9
If isElixirFull() Or $TrophyMax Then $g_bMeetCondStop = True
Case 10
If isGoldFull() Then $g_bMeetCondStop = True
Case 11
If isElixirFull() Then $g_bMeetCondStop = True
Case 12
If $TrophyMax Then $g_bMeetCondStop = True
Case 13
If isDarkElixirFull() Then $g_bMeetCondStop = True
Case 14
If isGoldFull() And isElixirFull() And isDarkElixirFull() Then $g_bMeetCondStop = True
Case 15
If Round(TimerDiff($g_hTimerSinceStarted)) > $TimeToStop Then $g_bMeetCondStop = True
Case 16
$g_bMeetCondStop = True
Case 17
$g_bMeetCondStop = True
$bTrainEnabled = False
Case 18
$g_bMeetCondStop = True
$bTrainEnabled = False
$bDonationEnabled = False
Case 19
If $g_bWaitShield = True Then $g_bMeetCondStop = True
Case 20
If $g_bWaitShield = True Then
$g_bMeetCondStop = True
$bTrainEnabled = False
EndIf
Case 21
If $g_bWaitShield = True Then
$g_bMeetCondStop = True
$bTrainEnabled = False
$bDonationEnabled = False
EndIf
EndSwitch
If $g_bMeetCondStop Then
If $g_iCmbBotCond <> 4 And $g_iCmbBotCond <> 5 And $g_iCmbBotCond <> 10 And $g_iCmbBotCond <> 11 Then
If $Trophy <> "" Then SetLog($Trophy, $COLOR_SUCCESS)
If _Sleep($iDelayBotCommand1) Then Return
EndIf
Switch $g_iCmbBotCommand
Case 0
If $bDonationEnabled = False Then
SetLog("Halt Attack, Stay Online/Collect...", $COLOR_INFO)
ElseIf $bTrainEnabled = False Then
SetLog("Halt Attack, Stay Online/Collect/Donate...", $COLOR_INFO)
Else
SetLog("Halt Attack, Stay Online/Train/Collect/Donate...", $COLOR_INFO)
EndIf
$g_iCommandStop = 0
If _Sleep($iDelayBotCommand1) Then Return
Case 1
SetLog("MyBot.run Bot Stop as requested!!", $COLOR_INFO)
If _Sleep($iDelayBotCommand1) Then Return
Return True
Case 2
SetLog("MyBot.run Close Bot as requested!!", $COLOR_INFO)
If _Sleep($iDelayBotCommand1) Then Return
BotClose()
Return True
Case 3
SetLog("Close Android and Bot as requested!!", $COLOR_INFO)
If _Sleep($iDelayBotCommand1) Then Return
CloseAndroid("BotCommand")
BotClose()
Return True
Case 4
SetLog("Force Shutdown of PC...", $COLOR_INFO)
If _Sleep($iDelayBotCommand1) Then Return
Shutdown(BitOR($SD_SHUTDOWN, $SD_FORCE))
Return True
Case 5
SetLog("PC Sleep Mode Start now ...", $COLOR_INFO)
If _Sleep($iDelayBotCommand1) Then Return
Shutdown($SD_STANDBY)
Return True
Case 6
SetLog("Rebooting PC...", $COLOR_INFO)
If _Sleep($iDelayBotCommand1) Then Return
Shutdown(BitOR($SD_REBOOT, $SD_FORCE))
Return True
EndSwitch
EndIf
EndIf
Return False
EndFunc
Func BreakPersonalShield()
If _CheckPixel($aRemoveShldButton, $g_bCapturePixel) Then
Setlog("Oops, Need to have latest CoC installed!", $COLOR_ERROR)
Setlog("New Personal Guard info window not avialable!", $COLOR_ERROR)
SetError(1)
Return
EndIf
If $g_iDebugSetlog = 1 Then Setlog("Checking if Shield available", $COLOR_INFO)
If $g_iDebugSetlog = 1 Then Setlog("Have shield pixel color: " & _GetPixelColor($aHaveShield, $g_bCapturePixel) & " :" & _CheckPixel($aHaveShield, $g_bCapturePixel), $COLOR_DEBUG)
If _CheckPixel($aHaveShield, $g_bCapturePixel) Then
If IsMainPage() Then
PureClickP($aShieldInfoButton)
If _Sleep($iPersonalShield1) Then
SetError(2)
Return
EndIf
Local $result = ClickRemove("Shield")
If($result = False) Or @error Then
SetError(3, "shield remove button not found", "")
Return
EndIf
$result = ClickOkay("Shield")
If($result = False) Or @error Then
SetError(4, "shield Okay button not found", "")
Return
EndIf
Setlog("Shield removed", $COLOR_SUCCESS)
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog("No shield available", $COLOR_SUCCESS)
EndIf
If _Sleep($iPersonalShield1) Then
SetError(2)
Return
EndIf
If $g_iDebugSetlog = 1 Then Setlog("Checking if Personal Guard available", $COLOR_INFO)
If $g_iDebugSetlog = 1 Then Setlog("Have guard pixel color: " & _GetPixelColor($aHavePerGuard, $g_bCapturePixel) & " :" & _CheckPixel($aHavePerGuard, $g_bCapturePixel), $COLOR_DEBUG)
If _CheckPixel($aHavePerGuard, $g_bCapturePixel) Then
If IsMainPage() Then
PureClickP($aShieldInfoButton)
If _Sleep($iPersonalShield1) Then
SetError(2)
Return
EndIf
Local $result = ClickRemove("Guard")
If($result = False) Or @error Then
SetError(5, "guard remove button not found")
Return
EndIf
$result = ClickOkay("Guard")
If($result = False) Or @error Then
SetError(6, "guard Okay button not found")
Return
EndIf
Setlog("Guard removed", $COLOR_SUCCESS)
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog("No guard available", $COLOR_SUCCESS)
EndIf
EndFunc
Func CheckImageType()
Setlog("Detecting your Village Theme", $COLOR_INFO)
ClickP($aAway, 2, 20, "#0467")
If _Sleep($iDelayImageType1) Then Return
If Not IsMainPage() Then ClickP($aAway, 2, 20, "#0467")
Local $x = 200
Local $y = 130
Local $x1 = $x + 60
Local $y1 = $y + 80
Local $directory = @ScriptDir & "\imgxml\SnowTheme"
Local $temp = SearchImgloc($directory, $x, $y, $x1, $y1)
If IsArray($temp) then
If StringInStr($temp[0], "Snow") > 0 Then
$iDetectedImageType = 1
Setlog("Snow Theme detected")
Else
$iDetectedImageType = 0
Setlog("Normal Theme detected")
EndIf
Else
$iDetectedImageType = 0
Setlog("Normal Theme detected", $COLOR_RED)
EndIf
EndFunc
Func CheckBaseQuick($bStopRecursion = False, $sReturnHome = "")
If $bStopRecursion = True Then $bDisableBreakCheck = True
Switch $sReturnHome
Case "cloud"
If _CheckPixel($aRtnHomeCloud1, $g_bCapturePixel, Default, "Return Home Btn chk1", $COLOR_DEBUG) And  _CheckPixel($aRtnHomeCloud2, $g_bCapturePixel, Default, "Return Home Btn chk2", $COLOR_DEBUG) Then
ClickP($aRtnHomeCloud1, 1, 0, "#0513")
Local $wCount = 0
While IsMainPage() = False
If _Sleep($iDelayGetResources1) Then Return
$wCount += 1
If $wCount > 40 Then
Setlog("Warning, Main page not found", $COLOR_WARNING)
ExitLoop
EndIf
WEnd
EndIf
EndSwitch
If IsMainPage() Then
If $g_iDebugSetlog = 1 Then Setlog("CheckBaseQuick now...", $COLOR_DEBUG)
RequestCC()
If _Sleep($iDelayRunBot1) Then Return
checkMainScreen(False)
If $g_bRestart = True Then
If $bStopRecursion = True Then $bDisableBreakCheck = False
Return
EndIf
DonateCC()
If _Sleep($iDelayRunBot1) Then Return
checkMainScreen(False)
If $g_bRestart = True Then
If $bStopRecursion = True Then $bDisableBreakCheck = False
Return
EndIf
CheckOverviewFullArmy(True)
If Not($FullArmy) And $bTrainEnabled = True Then
If $actual_train_skip < $max_train_skip Then
TrainRevamp()
If $g_bRestart = True Then Return
Else
If $g_iDebugSetlogTrain = 1 Then Setlog("skip train. " & $actual_train_skip + 1 & "/" & $max_train_skip, $color_purple)
$actual_train_skip = $actual_train_skip + 1
CheckOverviewFullArmy(True, False)
If ISArmyWindow(False, $ArmyTAB) then CheckExistentArmy("Spells")
getArmyHeroCount(False, True)
If $actual_train_skip >= $max_train_skip Then
$actual_train_skip = 0
EndIf
If $bStopRecursion = True Then $bDisableBreakCheck = False
Return
EndIf
EndIf
Collect()
If _Sleep($iDelayRunBot1) Then Return
Else
If $g_iDebugSetlog = 1 Then Setlog("Not on main page, CheckBaseQuick skipped", $COLOR_WARNING)
EndIf
If $bStopRecursion = True Then $bDisableBreakCheck = False
EndFunc
Func chkShieldStatus($bChkShield = True, $bForceChkPBT = False)
If($ichkSinglePBTForced = 0 And($g_bChkBotStop = True And $g_iCmbBotCond >= 19) = False) And $g_bCloseWhileTrainingEnable = False Or Not(IsMainPage()) Then Return
Local $Result, $iTimeTillPBTstartSec, $ichkTime = 0, $ichkSTime = 0, $ichkPBTime = 0
If $bChkShield Or $aShieldStatus[0] = "" Or $aShieldStatus[1] = "" Or $aShieldStatus[2] = "" Or $sPBStartTime = "" Or $g_bGForcePBTUpdate = True Then
$Result = getShieldInfo()
If @error Then Setlog("chkShieldStatus Shield OCR error= " & @error & "Extended= " & @extended, $COLOR_ERROR)
If _Sleep($iDelayRespond) Then Return
If IsArray($Result) Then
Local $iShieldExp = _DateDiff('n', $Result[2], _NowCalc())
If Abs($iShieldExp) > 0 Then
Local $sFormattedDiff = _Date_Difference(_NowCalc(), $Result[2], 4)
Setlog("Shield expires in: " & $sFormattedDiff)
Else
Setlog("Shield has expired")
EndIf
If _DateIsValid($aShieldStatus[2]) Then
$ichkTime = Abs(Int(_DateDiff('s', $aShieldStatus[2], $Result[2])))
If $ichkTime > 60 Then
$bForceChkPBT = True
If $g_iDebugSetlog = 1 Then Setlog("Shield time changed: " & $ichkTime & " Sec, Force PBT OCR: " & $bForceChkPBT, $COLOR_WARNING)
EndIf
EndIf
$aShieldStatus = $Result
If $g_bChkBotStop = True And $g_iCmbBotCond >= 19 Then
If $aShieldStatus[0] = "shield" Then
Setlog("Shield found, Halt Attack Now!", $COLOR_INFO)
$g_bWaitShield = True
$Is_ClientSyncError = False
$Is_SearchLimit = False
Else
$g_bWaitShield = False
If $g_bMeetCondStop = True Then
Setlog("Shield expired, resume attacking", $COLOR_INFO)
$bTrainEnabled = True
$bDonationEnabled = True
$g_bMeetCondStop = False
Else
If $g_iDebugSetlog = 1 Then Setlog("Halt With Shield: Shield not found...", $COLOR_DEBUG)
EndIf
EndIf
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog("Bad getShieldInfo() return value: " & $Result, $COLOR_ERROR)
If _Sleep($iDelayRespond) Then Return
For $i = 0 To UBound($aShieldStatus) - 1
$aShieldStatus[$i] = ""
Next
EndIf
EndIf
If $ichkSinglePBTForced = 0 Then Return
If _DateIsValid($sPBStartTime) Then
$ichkPBTime = Int(_DateDiff('s', $sPBStartTime, _NowCalc()))
If $ichkPBTime >= 295 Then
$bForceChkPBT = True
If $g_iDebugSetlog = 1 Then Setlog("Found old PB time= " & $ichkPBTime & " Seconds, Force update:" & $bForceChkPBT, $COLOR_WARNING)
EndIf
EndIf
If $bForceChkPBT Or $g_bGForcePBTUpdate Or $sPBStartTime = "" Then
$g_bGForcePBTUpdate = False
$Result = getPBTime()
If @error Then Setlog("chkShieldStatus getPBTime OCR error= " & @error & ", Extended= " & @extended, $COLOR_ERROR)
If _Sleep($iDelayRespond) Then Return
If _DateIsValid($Result) Then
Local $iTimeTillPBTstartMin = Int(_DateDiff('n', $Result, _NowCalc()))
If Abs($iTimeTillPBTstartMin) > 0 Then
Local $sFormattedDiff = _Date_Difference(_DateAdd("n",-1,_NowCalc()), $Result, 4)
Setlog("Personal Break starts in: " & $sFormattedDiff)
EndIf
If $iTimeTillPBTstartMin < -(Int($iValuePBTimeForcedExit)) Then
$sPBStartTime = _DateAdd('n', -(Int($iValuePBTimeForcedExit)), $Result)
ElseIf $iTimeTillPBTstartMin < 0 Then
$sPBStartTime = $Result
Else
$sPBStartTime = ""
EndIf
If $g_iDebugSetlog = 1 Then Setlog("Early Log Off time=" & $sPBStartTime & ", In " & _DateDiff('n', $sPBStartTime, _NowCalc()) & " Minutes", $COLOR_DEBUG)
Else
Setlog("Bad getPBTtime() return value: " & $Result, $COLOR_ERROR)
$sPBStartTime = ""
EndIf
EndIf
If checkObstacles() Then checkMainScreen(False)
EndFunc
Func _Date_Difference($sStartDate, Const $sEndDate, Const $iGrain)
Local $aUnit[6] = ["Y", "M", "D", "h", "n", "s"]
Local $aType[6] = ["year", "month", "day", "hour", "minute", "second"]
Local $sReturn = "", $iUnit
For $i = 0 To $iGrain
$iUnit = _DateDiff($aUnit[$i], $sStartDate, $sEndDate)
If $iUnit <> 0 Then
$sReturn &= $iUnit & " " & $aType[$i] &($iUnit > 1 ? "s" : "") & " "
EndIf
$sStartDate = _DateAdd($aUnit[$i], $iUnit, $sStartDate)
Next
Return $sReturn
EndFunc
Func Collect()
If $g_bChkCollect = False Then Return
If $g_bRunState = False Then Return
ClickP($aAway, 1, 0, "#0332")
StartGainCost()
checkAttackDisable($iTaBChkIdle)
SetLog("Collecting Resources", $COLOR_INFO)
If _Sleep($iDelayCollect2) Then Return
Local $directory = @ScriptDir & "\imgxml\Resources\Collect"
Local $Filename = ""
Local $CollectXY
Local $aResult = returnMultipleMatchesOwnVillage($directory)
If UBound($aResult) > 1 Then
Local $aiUnSortedMatchXY[1][2], $iMatchCount = 0
For $i = 1 To UBound($aResult) - 1
$Filename = $aResult[$i][1]
$CollectXY = $aResult[$i][5]
If IsMainPage() Then
If IsArray($CollectXY) Then
For $t = 0 To UBound($CollectXY) - 1
If isInsideDiamondXY($CollectXY[$t][0], $CollectXY[$t][1]) Then
If $g_iDebugSetlog = 1 Then SetLog($Filename & " found (" & $CollectXY[$t][0] & "," & $CollectXY[$t][1] & ")", $COLOR_SUCCESS)
ReDim $aiUnSortedMatchXY[$iMatchCount+1][2]
$aiUnSortedMatchXY[$iMatchCount][0] = $CollectXY[$t][0]
$aiUnSortedMatchXY[$iMatchCount][1] = $CollectXY[$t][1]
$iMatchCount += 1
EndIf
Next
EndIf
EndIf
Next
If $iMatchCount > 0 Then
Local $aiSortedMatchXY = SortXYArrayByClosestNeighbor($aiUnSortedMatchXY)
For $i = 0 To UBound($aiSortedMatchXY) - 1
If $g_iDebugSetlog = 1 Then SetLog("Sorted Collectors: " & $aiSortedMatchXY[$i][0] & "," & $aiSortedMatchXY[$i][1], $COLOR_SUCCESS)
If $iUseRandomClick = 0 then
Click($aiSortedMatchXY[$i][0], $aiSortedMatchXY[$i][1], 1, 0, "#0430")
If _Sleep($iDelayCollect2) Then Return
Else
ClickZone($aiSortedMatchXY[$i][0], $aiSortedMatchXY[$i][1], 5, "#0430")
_Sleep(Random($iDelayCollect2, $iDelayCollect2 * 4, 1))
EndIf
Next
EndIf
EndIf
If _Sleep($iDelayCollect3) Then Return
checkMainScreen(False)
Setlog("Searching for a Loot Cart..", $COLOR_INFO)
Local $LootCart = @ScriptDir & "\imgxml\Resources\LootCart\loot_cart_0_85.xml"
Local $LootCartX, $LootCartY
$ToleranceImgLoc = 0.850
Local $fullCocAreas = "ECD"
Local $MaxReturnPoints = 1
_CaptureRegion2()
Local $res = DllCall($g_hLibImgLoc, "str", "FindTile", "handle", $hHBitmap2, "str", $LootCart, "str", $fullCocAreas, "Int", $MaxReturnPoints)
If @error Then _logErrorDLLCall($g_sLibImgLocPath, @error)
If IsArray($res) Then
If $g_iDebugSetlog = 1 Then SetLog("DLL Call succeeded " & $res[0], $COLOR_ERROR)
If $res[0] = "0" Or $res[0] = "" Then
SetLog("No Loot Cart found, Yard is clean!", $COLOR_SUCCESS)
ElseIf StringLeft($res[0], 2) = "-1" Then
SetLog("DLL Error: " & $res[0], $COLOR_ERROR)
Else
Local $expRet = StringSplit($res[0], "|", $STR_NOCOUNT)
Local $posPoint = StringSplit($expRet[1], ",", $STR_NOCOUNT)
If IsArray($posPoint) Then
$LootCartX = Int($posPoint[0])
$LootCartY = Int($posPoint[1])
If isInsideDiamondXY($LootCartX, $LootCartY) Then
If $g_iDebugSetlog Then SetLog("LootCart found (" & $LootCartX & "," & $LootCartY & ")", $COLOR_SUCCESS)
If IsMainPage() Then Click($LootCartX, $LootCartY, 1, 0, "#0330")
If _Sleep($iDelayCollect1) Then Return
Local $sInfo = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
Local $CountGetInfo = 0
While IsArray($sInfo) = False
$sInfo = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
If _Sleep($iDelayCollect1) Then Return
$CountGetInfo += 1
If $CountGetInfo >= 5 Then Return
WEnd
If $g_iDebugSetlog Then SetLog(_ArrayToString($sInfo, " "), $COLOR_DEBUG)
If @error Then Return SetError(0, 0, 0)
If $sInfo[0] > 1 Or $sInfo[0] = "" Then
If StringInStr($sInfo[1], "Loot") = 0 Then
If $g_iDebugSetlog Then SetLog("Bad Loot Cart location", $COLOR_ACTION)
Else
If IsMainPage() Then Click($aLootCartBtn[0], $aLootCartBtn[1], 1, 0, "#0331")
EndIf
EndIf
Else
Setlog("Loot Cart not removed, please do manually!", $COLOR_WARNING)
EndIf
EndIf
EndIf
EndIf
EndGainCost("Collect")
EndFunc
Func SortXYArrayByClosestNeighbor(Const ByRef $aUnsorted)
If IsArray($aUnsorted) = False Then Return
Local $iPoints = UBound($aUnsorted)
If $iPoints = 0 Then Return
Local $aSorted[$iPoints][2]
Local $aUnsortedTemp = $aUnsorted
Local $iFirst = Random(0, $iPoints-1, 1)
$aSorted[0][0] = $aUnsortedTemp[$iFirst][0]
$aSorted[0][1] = $aUnsortedTemp[$iFirst][1]
_ArrayDelete($aUnsortedTemp, $iFirst)
Local $iSortedCount = 1
While UBound($aUnsortedTemp) > 0
Local $iNextClosest = 999, $fBestDist = 999
For $i = 0 To UBound($aUnsortedTemp) - 1
Local $fDist = Sqrt(($aUnsortedTemp[$i][0]-$aSorted[$iSortedCount-1][0])^2 +($aUnsortedTemp[$i][1]-$aSorted[$iSortedCount-1][1])^2)
If $fDist < $fBestDist Then
$fBestDist = $fDist
$iNextClosest = $i
EndIf
Next
If $iNextClosest = 999 Then
SetDebugLog("SortXYArrayByClosestNeighbor error", $COLOR_ERROR)
Return 0
EndIf
$aSorted[$iSortedCount][0] = $aUnsortedTemp[$iNextClosest][0]
$aSorted[$iSortedCount][1] = $aUnsortedTemp[$iNextClosest][1]
$iSortedCount += 1
_ArrayDelete($aUnsortedTemp, $iNextClosest)
WEnd
Return $aSorted
EndFunc
Func donateCCWBLUserImageCollect($x, $y)
Local $imagematch = False
_CaptureRegion2()
If $g_iDebugSetlog = 1 Then Setlog("Search into whitelist...", $color_purple)
Local $xyz = _FileListToArrayRec($g_sProfileDonateCaptureWhitelistPath, "*.png", $FLTAR_FILES, $FLTAR_NORECUR, $FLTAR_SORT, $FLTAR_NOPATH)
If UBound($xyz) > 1 Then
For $i = 1 To UBound($xyz) - 1
Local $result = FindImageInPlace("DCCWBL", $g_sProfileDonateCaptureWhitelistPath & $xyz[$i], "0," & $y - 90 & "," & $x - 30 & "," & $y, False)
If StringInStr($result, ",") > 0 Then
If $g_iCmbDonateFilter = 2 Then Setlog("WHITE LIST: image match! " & $xyz[$i], $COLOR_SUCCESS)
$imagematch = True
If $g_iCmbDonateFilter = 2 Then Return True
ExitLoop
EndIf
Next
EndIf
If $g_iDebugSetlog = 1 Then Setlog("Search into blacklist...", $color_purple)
Local $xyz1 = _FileListToArrayRec($g_sProfileDonateCaptureBlacklistPath, "*.png", $FLTAR_FILES, $FLTAR_NORECUR, $FLTAR_SORT, $FLTAR_NOPATH)
If UBound($xyz1) > 1 Then
For $i = 1 To UBound($xyz1) - 1
Local $result1 = FindImageInPlace("DCCWBL", $g_sProfileDonateCaptureBlacklistPath & $xyz1[$i], "0," & $y - 90 & "," & $x - 30 & "," & $y, False)
If StringInStr($result1, ",") > 0 Then
If $g_iCmbDonateFilter = 3 Then Setlog("BLACK LIST: image match! " & $xyz1[$i], $COLOR_SUCCESS)
$imagematch = True
If $g_iCmbDonateFilter = 3 Then Return False
ExitLoop
Else
If $g_iDebugSetlog = 1 Then SetLog("Image not found", $COLOR_ERROR)
EndIf
Next
EndIf
If $imagematch = False And $g_iCmbDonateFilter > 0 Then
If $g_iDebugSetlog = 1 Then Setlog("Search into images to assign...", $color_purple)
Local $xyzw = _FileListToArrayRec($g_sProfileDonateCapturePath, "*.png", $FLTAR_FILES, $FLTAR_NORECUR, $FLTAR_SORT, $FLTAR_NOPATH)
If UBound($xyzw) > 1 Then
For $i = 1 To UBound($xyzw) - 1
Local $resultxyzw = FindImageInPlace("DCCWBL", $g_sProfileDonateCapturePath & $xyzw[$i], "0," & $y - 90 & "," & $x - 30 & "," & $y, False)
If StringInStr($resultxyzw, ",") > 0 Then
If $g_iCmbDonateFilter = 1 Or $g_iDebugSetlog = 1 Then Setlog("IMAGES TO ASSIGN: image match! " & $xyzw[$i], $COLOR_SUCCESS)
$imagematch = True
ExitLoop
EndIf
Next
EndIf
If $imagematch = False Then
If $g_iDebugSetlog = 1 Then Setlog("save image in images to assign...", $color_purple)
Local $chat_divider = @ScriptDir & "\imgxml\donateccwbl\chatdivider_0_98.xml"
Local $chat_divider_hidden = @ScriptDir & "\imgxml\donateccwbl\chatdividerhidden_0_98.xml"
Local $iAllFilesCount = 0
Local $res = FindImageInPlace("DCCWBL", $chat_divider, "0," & $y - 90 & "," & $x - 30 & "," & $y, False)
If $res = "" Then
Local $reshidden = FindImageInPlace("DCCWBL", $chat_divider_hidden, "0," & $y - 90 & "," & $x - 30 & "," & $y, False)
If $reshidden = "" Then
If $g_iDebugSetlog = 1 Then SetLog("No Chat divider hidden found", $COLOR_ERROR)
Else
Local $xfound = Int(StringSplit($reshidden, ",", 2)[0])
Local $yfound = Int(StringSplit($reshidden, ",", 2)[1])
If $g_iDebugSetlog = 1 Then
SetLog("ChatDivider hidden found (" & $xfound & "," & $yfound & ")", $COLOR_SUCCESS)
EndIf
Local $oBitmap = _GDIPlus_BitmapCreateFromHBITMAP($hHBitmap2)
Local $hClone = _GDIPlus_BitmapCloneArea($oBitmap, 31, $yfound + 14, 100, 11, $GDIP_PXF24RGB)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
$iAllFilesCount = _FileListToArrayRec($g_sProfileDonateCapturePath, "*", 1, 0, 0, 0)
If IsArray($iAllFilesCount) Then
$iAllFilesCount = $iAllFilesCount[0]
Else
$iAllFilesCount = 0
EndIf
Local $filename = String("ClanMate-" & $Date & "_" & Number($iAllFilesCount) + 1 & "_98.png")
_GDIPlus_ImageSaveToFile($hClone, $g_sProfileDonateCapturePath & $filename)
If $g_iCmbDonateFilter = 1 Then Setlog("Clan Mate image Stored: " & $filename, $COLOR_SUCCESS)
_GDIPlus_BitmapDispose($hClone)
_GDIPlus_BitmapDispose($oBitmap)
EndIf
Else
Local $xfound = Int(StringSplit($res, ",", 2)[0])
Local $yfound = Int(StringSplit($res, ",", 2)[1])
If $g_iDebugSetlog = 1 Then
SetLog("ChatDivider found (" & $xfound & "," & $yfound & ")", $COLOR_SUCCESS)
EndIf
Local $oBitmap = _GDIPlus_BitmapCreateFromHBITMAP($hHBitmap2)
Local $hClone = _GDIPlus_BitmapCloneArea($oBitmap, 31, $yfound + 14, 100, 11, $GDIP_PXF24RGB)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
$iAllFilesCount = _FileListToArrayRec($g_sProfileDonateCapturePath, "*", 1, 0, 0, 0)
If IsArray($iAllFilesCount) Then
$iAllFilesCount = $iAllFilesCount[0]
Else
$iAllFilesCount = 0
EndIf
Local $filename = String("ClanMate--" & $Date & "_" & Number($iAllFilesCount) + 1 & "_98.png")
_GDIPlus_ImageSaveToFile($hClone, $g_sProfileDonateCapturePath & $filename)
_GDIPlus_BitmapDispose($hClone)
_GDIPlus_BitmapDispose($oBitmap)
If $g_iCmbDonateFilter = 1 Then Setlog("IMAGES TO ASSIGN: stored!", $COLOR_SUCCESS)
Deletefiles($g_sProfileDonateCapturePath, "*.png", 2, 0)
EndIf
EndIf
EndIf
If $g_iCmbDonateFilter <= 1 Then
Return True
ElseIf $g_iCmbDonateFilter = 3 Then
Return True
Else
Return False
EndIf
EndFunc
Func GetTownHallLevel($bFirstTime = False)
Local $aTHInfo[3] = ["", "", ""]
If $g_iDebugSetlog = 1 Then SetLog("Town Hall Position: " & $TownHallPos[0] & ", " & $TownHallPos[1], $COLOR_DEBUG)
If isInsideDiamond($TownHallPos) = False Then
LocateTownHall(True)
If isInsideDiamond($TownHallPos) Then SaveConfig()
If _Sleep($iDelayGetTownHallLevel1) Then Return
EndIf
If $bFirstTime = True Then
BuildingClickP($TownHallPos, "#0349")
If _Sleep($iDelayGetTownHallLevel2) Then Return
EndIf
If $g_iDebugImageSave = 1 Then DebugImageSave("GetTHLevelView")
$iTownHallLevel = 0
$aTHInfo = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If $g_iDebugSetlog = 1 Then Setlog("$aTHInfo[0]=" & $aTHInfo[0] & ", $aTHInfo[1]=" & $aTHInfo[1] & ", $aTHInfo[2]=" & $aTHInfo[2], $COLOR_DEBUG)
If $aTHInfo[0] > 1 Then
If StringInStr($aTHInfo[1], "Town") = 0 Then
SetLog("Town Hall not found! I detected a " & $aTHInfo[1] & "! Please locate again!", $COLOR_WARNING)
Return $aTHInfo
EndIf
If $aTHInfo[2] <> "" Then
$iTownHallLevel = $aTHInfo[2]
SetLog("Your Town Hall Level read as: " & $iTownHallLevel, $COLOR_SUCCESS)
saveConfig()
Else
SetLog("Your Town Hall Level was not found! Please Manually Locate", $COLOR_INFO)
ClickP($aAway, 1, 0, "#0350")
Return False
EndIf
Else
SetLog("Your Town Hall Level was not found! Please Manually Locate", $COLOR_INFO)
ClickP($aAway, 1, 0, "#0351")
Return False
EndIf
ClickP($aAway, 2, $iDelayGetTownHallLevel3, "#0352")
Return True
EndFunc
Func isDarkElixirFull()
If isAttackPage() And _CheckPixel($aIsAtkDarkElixirFull, $g_bCapturePixel) Or _CheckPixel($aIsDarkElixirFull, $g_bCapturePixel) Then
SetLog("Dark Elixir Storages is full!", $COLOR_SUCCESS)
Return True
EndIf
Return False
EndFunc
Func isGoldFull()
If _CheckPixel($aIsGoldFull, $g_bCapturePixel) Then
SetLog("Gold Storages are full!", $COLOR_SUCCESS)
Return True
EndIf
Return False
EndFunc
Func isElixirFull()
If _CheckPixel($aIsElixirFull, $g_bCapturePixel) Then
SetLog("Elixir Storages are full!", $COLOR_SUCCESS)
Return True
EndIf
Return False
EndFunc
Func LocateUpgrades()
WinGetAndroidHandle()
If $HWnD <> 0 And $g_bAndroidBackgroundLaunched = True Then
Setlog("Reboot " & $g_sAndroidEmulator & " for Window access", $COLOR_ERROR)
RebootAndroid(True)
EndIf
If $HWnD = 0 Then
Setlog($g_sAndroidEmulator & " is not open", $COLOR_ERROR)
SetError(1)
Return
EndIf
AndroidToFront()
Local $wasDown = AndroidShieldForcedDown()
AndroidShield("LocateUpgrades")
Local $MsgBox, $stext
Local $icount = 0
Local $hGraphic = 0
Local $bInitGraphics = True
While 1
_CaptureRegion(0, 0, $g_iDEFAULT_WIDTH, 2)
If _GetPixelColor(1, 1) <> Hex(0x000000, 6) Or _GetPixelColor(850, 1) <> Hex(0x000000, 6) Then
SetLog("Locate Oops, prep screen 1st", $COLOR_INFO)
ZoomOut()
$bDisableBreakCheck = True
Collect()
$bDisableBreakCheck = False
EndIf
$bDisableBreakCheck = True
Collect()
$bDisableBreakCheck = False
If $bInitGraphics Then
$bInitGraphics = False
$hGraphic = AndroidGraphicsGdiBegin()
If $hGraphic <> 0 Then
Local $hPen = AndroidGraphicsGdiAddObject("Pen", _GDIPlus_PenCreate(0xFFFFFF00, 2))
SetDebugLog("LocateUpgrades: $hGraphic=" & $hGraphic & ", $hPen=" & $hPen)
For $icount = 0 To UBound($g_avBuildingUpgrades, 1) - 1
If $hGraphic <> 0 And $g_avBuildingUpgrades[$icount][0] > 0 And $g_avBuildingUpgrades[$icount][0] > 0 Then
Local $xUpgrade = $g_avBuildingUpgrades[$icount][0]
Local $yUpgrade = $g_avBuildingUpgrades[$icount][1]
ConvertToVillagePos($xUpgrade, $yUpgrade)
Local $bMarkerDrawn = _GDIPlus_GraphicsDrawEllipse($hGraphic, $xUpgrade - 10, $yUpgrade - 10, 20, 20, $hPen)
AndroidGraphicsGdiUpdate()
SetDebugLog("Existing Updgrade #" & $icount & " found at " & $g_avBuildingUpgrades[$icount][0] & "/" & $g_avBuildingUpgrades[$icount][1] & ", marker drawn: " & $bMarkerDrawn)
EndIf
Next
EndIf
EndIf
For $icount = 0 To UBound($g_avBuildingUpgrades, 1) - 1
If $g_abUpgradeRepeatEnable[$icount] = True And(GUICtrlRead($g_hTxtUpgradeName[$icount]) <> "") Then
GUICtrlSetImage($g_hPicUpgradeStatus[$icount], $g_sLibIconPath, $eIcnYellowLight)
GUICtrlSetState($g_hChkUpgrade[$icount], $GUI_CHECKED)
ContinueLoop
EndIf
AndroidShieldForceDown(True, True)
$stext = GetTranslated(640, 51, "Click 'Locate Building' button then click on your Building/Hero to upgrade.") & @CRLF & @CRLF & GetTranslated(640, 52, "Click 'Finished' button when done locating all upgrades.") & @CRLF & @CRLF & GetTranslated(640, 53, "Click on Cancel to exit finding buildings.") & @CRLF & @CRLF
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 10, "Comic Sans MS", 500)
$MsgBox = _ExtMsgBox(0, GetTranslated(640, 54, "Locate Building|Finished|Cancel"), GetTranslated(640, 55, "Locate Upgrades"), $stext, 0, $g_hFrmBot)
Switch $MsgBox
Case 1
Local $aPos = FindPos()
$g_avBuildingUpgrades[$icount][0] = $aPos[0]
$g_avBuildingUpgrades[$icount][1] = $aPos[1]
If isInsideDiamondXY($g_avBuildingUpgrades[$icount][0], $g_avBuildingUpgrades[$icount][1]) Then
Local $bMarkerDrawn = False
If $hGraphic <> 0 Then
Local $xUpgrade = $g_avBuildingUpgrades[$icount][0]
Local $yUpgrade = $g_avBuildingUpgrades[$icount][1]
ConvertToVillagePos($xUpgrade, $yUpgrade)
$bMarkerDrawn = _GDIPlus_GraphicsDrawEllipse($hGraphic, $xUpgrade - 10, $yUpgrade - 10, 20, 20, $hPen)
AndroidGraphicsGdiUpdate()
EndIf
SetDebugLog("Updgrade #" & $icount & " added at " & $g_avBuildingUpgrades[$icount][0] & "/" & $g_avBuildingUpgrades[$icount][1] & ", marker drawn: " & $bMarkerDrawn)
GUICtrlSetImage($g_hPicUpgradeStatus[$icount], $g_sLibIconPath, $eIcnYellowLight)
$g_aiPicUpgradeStatus[$icount] = $eIcnYellowLight
_Sleep(750)
Else
Setlog("Bad location recorded, location skipped?", $COLOR_ERROR)
$g_avBuildingUpgrades[$icount][0] = -1
$g_avBuildingUpgrades[$icount][1] = -1
ContinueLoop
EndIf
Case 2
If $icount = 0 Then
Setlog("Locate Upgrade Cancelled", $COLOR_WARNING)
btnResetUpgrade()
AndroidGraphicsGdiEnd()
AndroidShieldForceDown($wasDown)
Return False
EndIf
ExitLoop
Case 3
Setlog("Locate Upgrade Cancelled", $COLOR_WARNING)
btnResetUpgrade()
AndroidGraphicsGdiEnd()
AndroidShieldForceDown($wasDown)
Return False
Case Else
Setlog("Impossible value (" & $MsgBox & ") from Msgbox, you have been a bad programmer!", $COLOR_DEBUG)
EndSwitch
ClickP($aAway, 1, 0, "#0210")
Next
ExitLoop
WEnd
AndroidGraphicsGdiEnd()
AndroidShieldForceDown($wasDown)
CheckUpgrades()
EndFunc
Func CheckUpgrades()
If AndroidShielded() = False Then
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
Local $stext = GetTranslated(640, 38, "Keep Mouse OUT of Android Emulator Window While I Check Your Upgrades, Thanks!!")
Local $MsgBox = _ExtMsgBox(48, GetTranslated(640, 36, "OK"), GetTranslated(640, 37, "Notice"), $stext, 15, $g_hFrmBot)
If _Sleep($iDelayCheckUpgrades1) Then Return
If $MsgBox <> 1 Then
Setlog("Something weird happened in getting upgrade values, try again", $COLOR_ERROR)
Return False
EndIf
EndIf
For $iz = 0 To UBound($g_avBuildingUpgrades, 1) - 1
If isInsideDiamondXY($g_avBuildingUpgrades[$iz][0], $g_avBuildingUpgrades[$iz][1]) = False Then
GUICtrlSetImage($g_hPicUpgradeStatus[$iz], $g_sLibIconPath, $eIcnRedLight)
GUICtrlSetState($g_hChkUpgrade[$iz], $GUI_UNCHECKED)
If $g_abUpgradeRepeatEnable[$iz] = True Then GUICtrlSetState($g_hChkUpgradeRepeat[$iz], $GUI_UNCHECKED)
ContinueLoop
EndIf
If UpgradeValue($iz) = False Then
If $g_abUpgradeRepeatEnable[$iz] = True And $g_avBuildingUpgrades[$iz][4] <> "" Then ContinueLoop
Setlog("Locate Upgrade #" & $iz + 1 & " Value Error, try again", $COLOR_ERROR)
GUICtrlSetImage($g_hPicUpgradeStatus[$iz], $g_sLibIconPath, $eIcnRedLight)
GUICtrlSetData($g_hTxtUpgradeName[$iz], "")
GUICtrlSetData($g_hTxtUpgradeLevel[$iz], "")
GUICtrlSetData($g_hTxtUpgradeValue[$iz], "")
GUICtrlSetData($g_hTxtUpgradeTime[$iz], "")
GUICtrlSetData($g_hTxtUpgradeEndTime[$iz], "")
GUICtrlSetImage($g_hPicUpgradeType[$iz], $g_sLibIconPath, $eIcnBlank)
If $g_abUpgradeRepeatEnable[$iz] = True Then GUICtrlSetState($g_hChkUpgradeRepeat[$iz], $GUI_UNCHECKED)
ContinueLoop
EndIf
Next
EndFunc
Func UpgradeValue($inum, $bRepeat = False)
Local $inputbox, $iLoot, $aString, $aResult
Local $bOopsFlag = False
If $bRepeat = True Or $g_abUpgradeRepeatEnable[$inum] = True Then
ClickP($aAway, 1, 0, "#0999")
If _Sleep($iDelayUpgradeValue1) Then Return
BuildingClick($g_avBuildingUpgrades[$inum][0], $g_avBuildingUpgrades[$inum][1])
If _Sleep($iDelayUpgradeValue4) Then Return
If $bOopsFlag = True Then DebugImageSave("ButtonView")
If StringInStr($g_avBuildingUpgrades[$inum][4], "collect", $STR_NOCASESENSEBASIC) Or StringInStr($g_avBuildingUpgrades[$inum][4], "mine", $STR_NOCASESENSEBASIC) Or StringInStr($g_avBuildingUpgrades[$inum][4], "drill", $STR_NOCASESENSEBASIC) Then
ClickP($aAway, 1, 0, "#0999")
If _Sleep($iDelayUpgradeValue1) Then Return
BuildingClick($g_avBuildingUpgrades[$inum][0], $g_avBuildingUpgrades[$inum][1])
If _Sleep($iDelayUpgradeValue4) Then Return
EndIf
Local $offColors[3][3] = [[0x000000, 44, 17], [0xE07740, 69, 31], [0xF2F7F1, 81, 0]]
Global $ButtonPixel = _MultiPixelSearch(284, 572, 570, 615, 1, 1, Hex(0x000000, 6), $offColors, 25)
If $g_iDebugSetlog = 1 Then Setlog("Pixel Color #1: " & _GetPixelColor(389, 572, True) & ", #2: " & _GetPixelColor(433, 589, True) & ", #3: " & _GetPixelColor(458, 603, True) & ", #4: " & _GetPixelColor(470, 572, True), $COLOR_DEBUG)
If IsArray($ButtonPixel) Then
If $g_iDebugSetlog = 1 Or $bOopsFlag = True Then
Setlog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("Pixel Color #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 44, $ButtonPixel[1] + 17, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 69, $ButtonPixel[1] + 31, True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 81, $ButtonPixel[1], True), $COLOR_DEBUG)
EndIf
Setlog("Selection #" & $inum + 1 & " Upgrade in process - Skipped!", $COLOR_WARNING)
ClickP($aAway, 1, 0, "#0999")
Return False
EndIf
Else
If $g_avBuildingUpgrades[$inum][0] <= 0 Or $g_avBuildingUpgrades[$inum][1] <= 0 Then Return False
$g_avBuildingUpgrades[$inum][2] = 0
GUICtrlSetData($g_hTxtUpgradeValue[$inum], "")
$g_avBuildingUpgrades[$inum][3] = ""
GUICtrlSetImage($g_hPicUpgradeType[$inum], $g_sLibIconPath, $eIcnBlank)
$g_avBuildingUpgrades[$inum][4] = ""
GUICtrlSetData($g_hTxtUpgradeName[$inum], "")
$g_avBuildingUpgrades[$inum][5] = ""
GUICtrlSetData($g_hTxtUpgradeLevel[$inum], "")
$g_avBuildingUpgrades[$inum][6] = ""
GUICtrlSetData($g_hTxtUpgradeTime[$inum], "")
$g_avBuildingUpgrades[$inum][7] = ""
GUICtrlSetData($g_hTxtUpgradeEndTime[$inum], "")
ClickP($aAway, 1, 0, "#0211")
SetLog("-$Upgrade #" & $inum + 1 & " Location =  " & "(" & $g_avBuildingUpgrades[$inum][0] & "," & $g_avBuildingUpgrades[$inum][1] & ")", $COLOR_DEBUG1)
If _Sleep($iDelayUpgradeValue1) Then Return
BuildingClick($g_avBuildingUpgrades[$inum][0], $g_avBuildingUpgrades[$inum][1], "#0212")
If _Sleep($iDelayUpgradeValue2) Then Return
If $bOopsFlag = True Then DebugImageSave("ButtonView")
EndIf
If $bOopsFlag = True And $g_iDebugImageSave = 1 Then DebugImageSave("ButtonView")
$aResult = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If $aResult[0] > 0 Then
$g_avBuildingUpgrades[$inum][4] = $aResult[1]
GUICtrlSetData($g_hTxtUpgradeName[$inum], $g_avBuildingUpgrades[$inum][4])
If $aResult[0] > 1 Then
$g_avBuildingUpgrades[$inum][5] = $aResult[2]
GUICtrlSetData($g_hTxtUpgradeLevel[$inum], $g_avBuildingUpgrades[$inum][5])
Else
Setlog("Error: Level for Upgrade not found?", $COLOR_ERROR)
EndIf
Else
Setlog("Error: Name & Level for Upgrade not found?", $COLOR_ERROR)
EndIf
Setlog("Upgrade Name = " & $g_avBuildingUpgrades[$inum][4] & ", Level = " & $g_avBuildingUpgrades[$inum][5], $COLOR_INFO)
Local $offColors[3][3] = [[0xD6714B, 47, 37], [0xF0E850, 70, 0], [0xF4F8F2, 79, 0]]
Global $ButtonPixel = _MultiPixelSearch(240, 563 + $g_iBottomOffsetY, 670, 620 + $g_iBottomOffsetY, 1, 1, Hex(0xF3F3F1, 6), $offColors, 30)
If $g_iDebugSetlog = 1 And IsArray($ButtonPixel) Then
Setlog("GoldButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("Color #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 47, $ButtonPixel[1] + 37, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 70, $ButtonPixel[1], True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 79, $ButtonPixel[1], True), $COLOR_DEBUG)
EndIf
If IsArray($ButtonPixel) = 0 Then
Local $offColors[3][3] = [[0xBC5B31, 38, 32], [0xF84CF9, 72, 0], [0xF5F9F2, 79, 0]]
Global $ButtonPixel = _MultiPixelSearch(240, 563 + $g_iBottomOffsetY, 670, 620 + $g_iBottomOffsetY, 1, 1, Hex(0xF4F7F2, 6), $offColors, 30)
If $g_iDebugSetlog = 1 And IsArray($ButtonPixel) Then
Setlog("ElixirButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("Color #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 38, $ButtonPixel[1] + 32, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 70, $ButtonPixel[1], True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 79, $ButtonPixel[1], True), $COLOR_DEBUG)
EndIf
EndIf
If IsArray($ButtonPixel) = 0 Then
Local $offColors[3][3] = [[0xE07B50, 41, 23], [0x282020, 72, 0], [0xF4F5F2, 79, 0]]
Global $ButtonPixel = _MultiPixelSearch(240, 563 + $g_iBottomOffsetY, 670, 620 + $g_iBottomOffsetY, 1, 1, Hex(0xF5F6F2, 6), $offColors, 25)
If $g_iDebugSetlog = 1 And IsArray($ButtonPixel) Then
Setlog("HeroButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("Color #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 41, $ButtonPixel[1] + 23, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 72, $ButtonPixel[1], True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 79, $ButtonPixel[1], True), $COLOR_DEBUG)
EndIf
EndIf
If IsArray($ButtonPixel) Then
If $g_iDebugSetlog = 1 Or $bOopsFlag = True Then
Setlog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("#1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 41, $ButtonPixel[1] + 23, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 70, $ButtonPixel[1], True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 79, $ButtonPixel[1], True), $COLOR_DEBUG)
EndIf
Click($ButtonPixel[0] + 20, $ButtonPixel[1] + 20, 1, 0, "#0213")
If _Sleep($iDelayUpgradeValue3) Then Return
If $bOopsFlag = True And $g_iDebugImageSave = 1 Then DebugImageSave("UpgradeView")
_CaptureRegion()
Select
Case _ColorCheck(_GetPixelColor(677, 150 + $g_iMidOffsetY), Hex(0xE00408, 6), 20)
If _ColorCheck(_GetPixelColor(351, 485 + $g_iMidOffsetY), Hex(0xE0403D, 6), 20) Then
If $g_abUpgradeRepeatEnable[$inum] = True Then
Setlog("Selection #" & $inum + 1 & " can not repeat upgrade, need TH upgrade - Skipped!", $COLOR_ERROR)
$g_abUpgradeRepeatEnable[$inum] = False
GUICtrlSetState($g_hChkUpgradeRepeat[$inum], $GUI_UNCHECKED)
Else
Setlog("Selection #" & $inum + 1 & " upgrade not available, need TH upgrade - Skipped!", $COLOR_ERROR)
EndIf
ClearUpgradeInfo($inum)
GUICtrlSetImage($g_hPicUpgradeType[$inum], $g_sLibIconPath, $eIcnRedLight)
GUICtrlSetImage($g_hPicUpgradeStatus[$inum], $g_sLibIconPath, $eIcnTroops)
$g_abBuildingUpgradeEnable[$inum] = False
GUICtrlSetState($g_hChkUpgrade[$inum], $GUI_UNCHECKED)
$g_avBuildingUpgrades[$inum][7] = ""
GUICtrlSetData($g_hTxtUpgradeEndTime[$inum], "")
ClickP($aAway, 1, 0, "#0214")
Return False
EndIf
If _ColorCheck(_GetPixelColor(477, 490 + $g_iMidOffsetY), Hex(0xF0E850, 6), 20) Then $g_avBuildingUpgrades[$inum][3] = "Gold"
If _ColorCheck(_GetPixelColor(483, 486 + $g_iMidOffsetY), Hex(0xF030D8, 6), 20) Then $g_avBuildingUpgrades[$inum][3] = "Elixir"
$g_avBuildingUpgrades[$inum][2] = Number(getResourcesBonus(366, 487 + $g_iMidOffsetY))
If $g_avBuildingUpgrades[$inum][2] = "" Then $g_avBuildingUpgrades[$inum][2] = Number(getUpgradeResource(366, 487 + $g_iMidOffsetY))
If $g_avBuildingUpgrades[$inum][2] = "" And $g_abUpgradeRepeatEnable[$inum] = False Then $bOopsFlag = True
$g_avBuildingUpgrades[$inum][6] = getBldgUpgradeTime(196, 304 + $g_iMidOffsetY)
Setlog("Upgrade #" & $inum + 1 & " Time = " & $g_avBuildingUpgrades[$inum][6], $COLOR_INFO)
If $g_avBuildingUpgrades[$inum][6] <> "" Then $g_avBuildingUpgrades[$inum][7] = ""
Case _ColorCheck(_GetPixelColor(719, 118 + $g_iMidOffsetY), Hex(0xDF0408, 6), 20)
If _ColorCheck(_GetPixelColor(400, 485 + $g_iMidOffsetY), Hex(0xE0403D, 6), 20) Then
If $g_abUpgradeRepeatEnable[$inum] = True Then
Setlog("Selection #" & $inum + 1 & " can not repeat upgrade, need TH upgrade - Skipped!", $COLOR_ERROR)
$g_abUpgradeRepeatEnable[$inum] = False
GUICtrlSetState($g_hChkUpgradeRepeat[$inum], $GUI_UNCHECKED)
Else
Setlog("Selection #" & $inum + 1 & " upgrade not available, need TH upgrade - Skipped!", $COLOR_ERROR)
EndIf
ClearUpgradeInfo($inum)
GUICtrlSetImage($g_hPicUpgradeType[$inum], $g_sLibIconPath, $eIcnRedLight)
GUICtrlSetImage($g_hPicUpgradeStatus[$inum], $g_sLibIconPath, $eIcnTroops)
$g_abBuildingUpgradeEnable[$inum] = False
GUICtrlSetState($g_hChkUpgrade[$inum], $GUI_UNCHECKED)
$g_avBuildingUpgrades[$inum][7] = ""
GUICtrlSetData($g_hTxtUpgradeEndTime[$inum], "")
ClickP($aAway, 1, 0, "#0215")
Return False
EndIf
If _ColorCheck(_GetPixelColor(703, 535 + $g_iMidOffsetY), Hex(0x000000, 6), 20) Then $g_avBuildingUpgrades[$inum][3] = "Dark"
$g_avBuildingUpgrades[$inum][2] = Number(getResourcesBonus(598, 519 + $g_iMidOffsetY))
If $g_avBuildingUpgrades[$inum][2] = "" Then $g_avBuildingUpgrades[$inum][2] = Number(getUpgradeResource(598, 519 + $g_iMidOffsetY))
If $g_avBuildingUpgrades[$inum][2] = "" And $g_abUpgradeRepeatEnable[$inum] = False Then $bOopsFlag = True
$g_avBuildingUpgrades[$inum][6] = getHeroUpgradeTime(464, 527 + $g_iMidOffsetY)
Setlog("Upgrade #" & $inum + 1 & " Time = " & $g_avBuildingUpgrades[$inum][6], $COLOR_INFO)
If $g_avBuildingUpgrades[$inum][6] <> "" Then $g_avBuildingUpgrades[$inum][7] = ""
Case Else
If isGemOpen(True) Then ClickP($aAway, 1, 0, "#0216")
Setlog("Selected Upgrade Window Opening Error, try again", $COLOR_ERROR)
ClearUpgradeInfo($inum)
ClickP($aAway, 1, 0, "#0217")
Return False
EndSelect
If StringInStr($g_avBuildingUpgrades[$inum][4],"Warden") > 0 then $g_avBuildingUpgrades[$inum][3] = "Elixir"
If $g_avBuildingUpgrades[$inum][3] <> "" And $bOopsFlag = True And $bRepeat = False Then
$iLoot = $g_avBuildingUpgrades[$inum][2]
If $iLoot = "" Then $iLoot = 8000000
Local $aBotLoc = WinGetPos($g_hFrmBot)
$inputbox = InputBox(GetTranslated(640, 56, "Text Read Error"), GetTranslated(640, 57, "Enter the cost of the upgrade"), $iLoot, "", -1, -1, $aBotLoc[0] + 125, $aBotLoc[1] + 225, -1, $g_hFrmBot)
If @error Then
Setlog("InputBox error, data reset. Try again", $COLOR_ERROR)
ClearUpgradeInfo($inum)
Return False
EndIf
$g_avBuildingUpgrades[$inum][2] = Int($inputbox)
Setlog("User input value = " & $g_avBuildingUpgrades[$inum][2], $COLOR_DEBUG)
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
Local $stext = GetTranslated(640, 58, "Save copy of upgrade image for developer analysis ?")
Local $MsgBox = _ExtMsgBox(48, GetTranslated(640, 59, "YES|NO"), GetTranslated(640, 37, "Notice"), $stext, 60, $g_hFrmBot)
If $MsgBox = 1 And $g_iDebugImageSave = 1 Then DebugImageSave("UpgradeReadError_")
EndIf
If $g_avBuildingUpgrades[$inum][3] = "" And $bOopsFlag = True And $bRepeat = False Then
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 10, "Comic Sans MS", 500)
$inputbox = _ExtMsgBox(0, GetTranslated(640, 60, "   GOLD   |  ELIXIR  |DARK ELIXIR"), GetTranslated(640, 61, "Need User Help"), GetTranslated(640, 62, "Select Upgrade Type:"), 0, $g_hFrmBot)
If $g_iDebugSetlog = 1 Then Setlog(" _MsgBox returned = " & $inputbox, $COLOR_DEBUG)
Switch $inputbox
Case 1
$g_avBuildingUpgrades[$inum][3] = "Gold"
Case 2
$g_avBuildingUpgrades[$inum][3] = "Elixir"
Case 3
$g_avBuildingUpgrades[$inum][3] = "Dark"
Case Else
SetLog("Silly programmer made an error!", $COLOR_WARNING)
$g_avBuildingUpgrades[$inum][3] = "HaHa"
EndSwitch
Setlog("User selected type = " & $g_avBuildingUpgrades[$inum][3], $COLOR_DEBUG)
EndIf
If $g_avBuildingUpgrades[$inum][2] = "" Or $g_avBuildingUpgrades[$inum][3] = "" And $g_abUpgradeRepeatEnable[$inum] = False Then
Setlog("Error finding loot info " & $inum & ", Loot = " & $g_avBuildingUpgrades[$inum][2] & ", Type= " & $g_avBuildingUpgrades[$inum][3], $COLOR_ERROR)
$g_avBuildingUpgrades[$inum][0] = -1
$g_avBuildingUpgrades[$inum][1] = -1
ClickP($aAway, 2, 0, "#0218")
Return False
EndIf
Setlog("Upgrade #" & $inum + 1 & " Value = " & _NumberFormat($g_avBuildingUpgrades[$inum][2]) & " " & $g_avBuildingUpgrades[$inum][3], $COLOR_INFO)
Else
If $g_abUpgradeRepeatEnable[$inum] = False Then
Setlog("Upgrade selection problem - data cleared, please try again", $COLOR_ERROR)
ClearUpgradeInfo($inum)
ElseIf $g_abUpgradeRepeatEnable[$inum] = True Then
Setlog("Repeat upgrade problem - will retry value update later", $COLOR_ERROR)
EndIf
ClickP($aAway, 2, 0, "#0219")
Return False
EndIf
ClickP($aAway, 2, 200, "#0220")
Switch $g_avBuildingUpgrades[$inum][3]
Case "Gold"
GUICtrlSetImage($g_hPicUpgradeType[$inum], $g_sLibIconPath, $eIcnGold)
Case "Elixir"
GUICtrlSetImage($g_hPicUpgradeType[$inum], $g_sLibIconPath, $eIcnElixir)
Case "Dark"
GUICtrlSetImage($g_hPicUpgradeType[$inum], $g_sLibIconPath, $eIcnDark)
Case Else
GUICtrlSetImage($g_hPicUpgradeType[$inum], $g_sLibIconPath, $eIcnBlank)
EndSwitch
GUICtrlSetData($g_hTxtUpgradeValue[$inum], _NumberFormat($g_avBuildingUpgrades[$inum][2]))
GUICtrlSetData($g_hTxtUpgradeTime[$inum], StringStripWS($g_avBuildingUpgrades[$inum][6], $STR_STRIPALL))
GUICtrlSetData($g_hTxtUpgradeEndTime[$inum], $g_avBuildingUpgrades[$inum][7])
Return True
EndFunc
Func ClearUpgradeInfo($inum)
$g_aiPicUpgradeStatus[$inum] = $eIcnTroops
$g_avBuildingUpgrades[$inum][0] = -1
$g_avBuildingUpgrades[$inum][1] = -1
$g_avBuildingUpgrades[$inum][2] = 0
$g_avBuildingUpgrades[$inum][3] = ""
$g_avBuildingUpgrades[$inum][4] = ""
$g_avBuildingUpgrades[$inum][5] = ""
$g_avBuildingUpgrades[$inum][6] = ""
$g_avBuildingUpgrades[$inum][7] = ""
EndFunc
Func LocateClanCastle()
Local $stext, $MsgBox, $iSilly = 0, $iStupid = 0, $sErrorText = "", $sInfo
SetLog("Locating Clan Castle...", $COLOR_INFO)
If _GetPixelColor($aTopLeftClient[0], $aTopLeftClient[1], True) <> Hex($aTopLeftClient[2], 6) Or _GetPixelColor($aTopRightClient[0], $aTopRightClient[1], True) <> Hex($aTopRightClient[2], 6) Then
Zoomout()
Collect()
EndIf
While 1
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$stext = $sErrorText & @CRLF & GetTranslated(640,32,"Click OK then click on your Clan Castle") & @CRLF & @CRLF & GetTranslated(640,26,"Do not move mouse quickly after clicking location") & @CRLF & @CRLF & GetTranslated(640,27,"Make sure the building name is visible for me!") & @CRLF
$MsgBox = _ExtMsgBox(0, GetTranslated(640,1,"Ok|Cancel"), GetTranslated(640,33,"Locate Clan Castle"), $stext, 15)
If $MsgBox = 1 Then
WinGetAndroidHandle()
ClickP($aAway, 1, 0, "#0373")
Local $aPos = FindPos()
$aCCPos[0] = $aPos[0]
$aCCPos[1] = $aPos[1]
If isInsideDiamond($aCCPos) = False Then
$iStupid += 1
Select
Case $iStupid = 1
$sErrorText = "Clan Castle Location Not Valid!" & @CRLF
SetLog("Location not valid, try again", $COLOR_ERROR)
ContinueLoop
Case $iStupid = 2
$sErrorText = "Please try to click inside the grass field!" & @CRLF
ContinueLoop
Case $iStupid = 3
$sErrorText = "This is not funny, why did you click @ (" & $aCCPos[0] & "," & $aCCPos[1] & ")?" & @CRLF & "  Please stop!" & @CRLF & @CRLF
ContinueLoop
Case $iStupid = 4
$sErrorText = "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iStupid > 4
SetLog(" Operator Error - Bad Clan Castle Location: " & "(" & $aCCPos[0] & "," & $aCCPos[1] & ")", $COLOR_ERROR)
ClickP($aAway, 1, 0, "#0374")
Return False
Case Else
SetLog(" Operator Error - Bad Clan Castle Location: " & "(" & $aCCPos[0] & "," & $aCCPos[1] & ")", $COLOR_ERROR)
$aCCPos[0] = -1
$aCCPos[1] = -1
ClickP($aAway, 1, 0, "#0375")
Return False
EndSelect
EndIf
SetLog("Clan Castle: " & "(" & $aCCPos[0] & "," & $aCCPos[1] & ")", $COLOR_SUCCESS)
Else
SetLog("Locate Clan Castle Cancelled", $COLOR_INFO)
ClickP($aAway, 1, 0, "#0376")
Return
EndIf
$sInfo = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If IsArray($sInfo) and($sInfo[0] > 1 Or $sInfo[0] = "") Then
If StringInStr($sInfo[1], "clan") = 0 Then
Local $sLocMsg =($sInfo[0] = "" ? "Nothing" : $sInfo[1])
$iSilly += 1
Select
Case $iSilly = 1
$sErrorText = "Wait, That is not the Clan Castle?, It was a " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 2
$sErrorText = "Quit joking, That was " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 3
$sErrorText = "This is not funny, why did you click " & $sLocMsg & "? Please stop!" & @CRLF
ContinueLoop
Case $iSilly = 4
$sErrorText = $sLocMsg & " ?!?!?!" & @CRLF & @CRLF & "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iSilly > 4
SetLog("Quit joking, Click the Clan Castle, or restart bot and try again", $COLOR_ERROR)
$aCCPos[0] = -1
$aCCPos[1] = -1
ClickP($aAway, 1, 0, "#0377")
Return False
EndSelect
EndIf
If $sInfo[2] = "Broken" Then
SetLog("You did not rebuild your Clan Castle yet.", $COLOR_ACTION)
Else
SetLog("Your Clan Castle is at level: " & $sInfo[2], $COLOR_SUCCESS)
EndIf
Else
SetLog(" Operator Error - Bad Clan Castle Location: " & "(" & $aCCPos[0] & "," & $aCCPos[1] & ")", $COLOR_ERROR)
$aCCPos[0] = -1
$aCCPos[1] = -1
ClickP($aAway, 1, 0, "#0378")
Return False
EndIf
ExitLoop
WEnd
ClickP($aAway, 1, 200, "#0327")
EndFunc
Func LocateLab()
Local $stext, $MsgBox, $iStupid = 0, $iSilly = 0, $sErrorText = ""
SetLog("Locating Laboratory...", $COLOR_INFO)
If _GetPixelColor($aTopLeftClient[0], $aTopLeftClient[1], True) <> Hex($aTopLeftClient[2], 6) Or _GetPixelColor($aTopRightClient[0], $aTopRightClient[1], True) <> Hex($aTopRightClient[2], 6) Then
Zoomout()
Collect()
EndIf
While 1
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 600)
$stext = $sErrorText & @CRLF & GetTranslated(640,43,"Click OK then click on your Laboratory building") & @CRLF & @CRLF & GetTranslated(640,26,"Do not move mouse quickly after clicking location") & @CRLF & @CRLF & GetTranslated(640,27,"Make sure the building name is visible for me!") & @CRLF
$MsgBox = _ExtMsgBox(0, GetTranslated(640,1,"Ok|Cancel"), GetTranslated(640,44,"Locate Laboratory"), $stext, 15)
If $MsgBox = 1 Then
WinGetAndroidHandle()
ClickP($aAway, 1, 0, "#0379")
Local $aPos = FindPos()
$aLabPos[0] = Int($aPos[0])
$aLabPos[1] = Int($aPos[1])
If isInsideDiamond($aLabPos) = False Then
$iStupid += 1
Select
Case $iStupid = 1
$sErrorText = "Laboratory Location Not Valid!" & @CRLF
SetLog("Location not valid, try again", $COLOR_ERROR)
ContinueLoop
Case $iStupid = 2
$sErrorText = "Please try to click inside the grass field!" & @CRLF
ContinueLoop
Case $iStupid = 3
$sErrorText = "This is not funny, Please stop!" & @CRLF & @CRLF
ContinueLoop
Case $iStupid = 4
$sErrorText = "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iStupid > 4
SetLog(" Operator Error - Bad Laboratory Location.", $COLOR_ERROR)
ClickP($aAway, 1, 0, "#0380")
Return False
Case Else
SetLog(" Operator Error - Bad Laboratory Location.", $COLOR_ERROR)
$aLabPos[0] = -1
$aLabPos[1] = -1
ClickP($aAway, 1, 0, "#0381")
Return False
EndSelect
EndIf
Else
SetLog("Locate Laboratory Cancelled", $COLOR_INFO)
ClickP($aAway, 1, 0, "#0382")
Return
EndIf
Local $sLabInfo = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If $sLabInfo[0] > 1 Or $sLabInfo[0] = "" Then
If StringInStr($sLabInfo[1], "Lab") = 0 Then
Local $sLocMsg =($sLabInfo[0] = "" ? "Nothing" : $sLabInfo[1])
$iSilly += 1
Select
Case $iSilly = 1
$sErrorText = "Wait, That is not the laboratory?, It was a " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 2
$sErrorText = "Quit joking, That was " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 3
$sErrorText = "This is not funny, why did you click " & $sLocMsg & "? Please stop!" & @CRLF
ContinueLoop
Case $iSilly = 4
$sErrorText = $sLocMsg & " ?!?!?!" & @CRLF & @CRLF & "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iSilly > 4
SetLog("Quit joking, Click the Army Camp, or restart bot and try again", $COLOR_ERROR)
$aLabPos[0] = -1
$aLabPos[1] = -1
ClickP($aAway, 1, 0, "#0383")
Return False
EndSelect
EndIf
Else
SetLog(" Operator Error - Bad Laboratory Location: " & "(" & $aLabPos[0] & "," & $aLabPos[1] & ")", $COLOR_ERROR)
$aLabPos[0] = -1
$aLabPos[1] = -1
ClickP($aAway, 1, 0, "#0384")
Return False
EndIf
SetLog("Locate Laboratory Success: " & "(" & $aLabPos[0] & "," & $aLabPos[1] & ")", $COLOR_SUCCESS)
ExitLoop
WEnd
Clickp($aAway, 2, 0, "#0207")
EndFunc
Func LocateTownHall($bLocationOnly = False)
Local $stext, $MsgBox, $Success, $sLocMsg
Local $iStupid = 0, $iSilly = 0, $sErrorText = ""
SetLog("Locating Town Hall ...", $COLOR_INFO)
WinGetAndroidHandle()
If _GetPixelColor($aTopLeftClient[0], $aTopLeftClient[1], True) <> Hex($aTopLeftClient[2], 6) Or _GetPixelColor($aTopRightClient[0], $aTopRightClient[1], True) <> Hex($aTopRightClient[2], 6) Then
Zoomout()
Collect()
EndIf
While 1
_ExtMsgBoxSet(1 + 64, 1, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 600)
$stext = $sErrorText & @CRLF & GetTranslated(640,49,"Click OK then click on your Town Hall") & @CRLF & @CRLF & GetTranslated(640,26,"Do not move mouse quickly after clicking location") & @CRLF & @CRLF & GetTranslated(640,27,"Make sure the building name is visible for me!") & @CRLF
$MsgBox = _ExtMsgBox(0, GetTranslated(640,1,"Ok|Cancel"), GetTranslated(640,50,"Locate TownHall"), $stext, 30)
If $MsgBox = 1 Then
WinGetAndroidHandle()
ClickP($aAway, 1, 0, "#0391")
Local $aPos = FindPos()
$TownHallPos[0] = $aPos[0]
$TownHallPos[1] = $aPos[1]
If _Sleep($iDelayLocateTownHall1) Then Return
If isInsideDiamond($TownHallPos) = False Then
$iStupid += 1
Select
Case $iStupid = 1
$sErrorText = "TownHall Location not valid!" & @CRLF
SetLog("Location not valid, try again", $COLOR_ERROR)
ContinueLoop
Case $iStupid = 2
$sErrorText = "Please try to click inside the grass field!" & @CRLF
ContinueLoop
Case $iStupid = 3
$sErrorText = "This is not funny, why did you click @ (" & $TownHallPos[0] & "," & $TownHallPos[1] & ")?" & @CRLF & "Please stop!" & @CRLF
ContinueLoop
Case $iStupid = 4
$sErrorText = "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iStupid > 4
SetLog(" Operator Error - Bad Townhall Location: " & "(" & $TownHallPos[0] & "," & $TownHallPos[1] & ")", $COLOR_ERROR)
$TownHallPos[0] = -1
$TownHallPos[1] = -1
ClickP($aAway, 1, 0, "#0392")
Return False
EndSelect
EndIf
SetLog("Townhall: " & "(" & $TownHallPos[0] & "," & $TownHallPos[1] & ")", $COLOR_SUCCESS)
Else
SetLog("Locate TownHall Cancelled", $COLOR_INFO)
ClickP($aAway, 1, 0, "#0393")
Return
EndIf
If $bLocationOnly = False Then
$Success = GetTownHallLevel()
$iSilly += 1
If IsArray($Success) Or $Success = False Then
If $Success = False Then
$sLocMsg = "Nothing"
Else
$sLocMsg = $Success[1]
EndIf
Select
Case $iSilly = 1
$sErrorText = "Wait, That is not a TownHall?, It was a " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 2
$sErrorText = "Quit joking, That was " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 3
$sErrorText = "This is not funny, why did you click " & $sLocMsg & "? Please stop!" & @CRLF
ContinueLoop
Case $iSilly = 4
$sErrorText = $sLocMsg & " ?!?!?!" & @CRLF & @CRLF & "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iSilly > 4
SetLog("Quit joking, Click on the TH, or restart bot and try again", $COLOR_ERROR)
$TownHallPos[0] = -1
$TownHallPos[1] = -1
ClickP($aAway, 1, 0, "#0394")
Return False
EndSelect
Else
SetLog("Locate TH Success!", $COLOR_ERROR)
EndIf
EndIf
ExitLoop
WEnd
ClickP($aAway, 1, 50, "#0209")
EndFunc
Func LocateQueenAltar()
Local $wasRunState = $g_bRunState
$g_bRunState = True
AndroidShield("LocateQueenAltar 1")
Local $Result = _LocateQueenAltar()
$g_bRunState = $wasRunState
AndroidShield("LocateQueenAltar 2")
Return $Result
EndFunc
Func _LocateQueenAltar()
Local $stext, $MsgBox, $iSilly = 0, $iStupid = 0, $sErrorText = "", $sInfo
WinGetAndroidHandle()
checkMainScreen(False)
If _GetPixelColor($aTopLeftClient[0], $aTopLeftClient[1], True) <> Hex($aTopLeftClient[2], 6) Or _GetPixelColor($aTopRightClient[0], $aTopRightClient[1], True) <> Hex($aTopRightClient[2], 6) Then
Zoomout()
$bDisableBreakCheck = True
Collect()
$bDisableBreakCheck = False
EndIf
SetLog("Locating Queen Altar...", $COLOR_INFO)
While 1
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$stext = $sErrorText & @CRLF & GetTranslated(640,34,"Click OK then click on your Queen Altar") & @CRLF & @CRLF & GetTranslated(640,26,"Do not move mouse after clicking location") & @CRLF & @CRLF & GetTranslated(640,27,"Make sure the building name is visible for me!") & @CRLF
$MsgBox = _ExtMsgBox(0, GetTranslated(640,1,"Ok|Cancel"), GetTranslated(640,35,"Locate Queen Altar"), $stext, 15)
If $MsgBox = 1 Then
WinGetAndroidHandle()
ClickP($aTopLeftClient)
Local $aPos = FindPos()
$QueenAltarPos[0] = $aPos[0]
$QueenAltarPos[1] = $aPos[1]
If isInsideDiamond($QueenAltarPos) = False Then
$iStupid += 1
Select
Case $iStupid = 1
$sErrorText = "Queen Altar Location Not Valid!" & @CRLF
SetLog("Location not valid, try again", $COLOR_ERROR)
ContinueLoop
Case $iStupid = 2
$sErrorText = "Please try to click inside the grass field!" & @CRLF
ContinueLoop
Case $iStupid = 3
$sErrorText = "This is not funny, why did you click @ (" & $QueenAltarPos[0] & "," & $QueenAltarPos[1] & ")?" & @CRLF & "  Please stop!" & @CRLF & @CRLF
ContinueLoop
Case $iStupid = 4
$sErrorText = "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iStupid > 4
SetLog(" Operator Error - Bad Queen Altar Location: " & "(" & $QueenAltarPos[0] & "," & $QueenAltarPos[1] & ")", $COLOR_ERROR)
ClickP($aTopLeftClient)
Return False
Case Else
SetLog(" Operator Error - Bad Queen Altar Location: " & "(" & $QueenAltarPos[0] & "," & $QueenAltarPos[1] & ")", $COLOR_ERROR)
$QueenAltarPos[0] = -1
$QueenAltarPos[1] = -1
ClickP($aTopLeftClient)
Return False
EndSelect
EndIf
SetLog("Queen Altar: " & "(" & $QueenAltarPos[0] & "," & $QueenAltarPos[1] & ")", $COLOR_SUCCESS)
Else
SetLog("Locate Queen Altar Cancelled", $COLOR_INFO)
ClickP($aTopLeftClient)
Return
EndIf
$sInfo = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
Local $CountGetInfo = 0
While IsArray($sInfo) = False
$sInfo = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
Sleep(100)
$CountGetInfo += 1
If $CountGetInfo = 50 Then Return
WEnd
If $g_iDebugSetlog = 1 Then SetLog($sInfo[1] & $sInfo[2])
If @error Then Return SetError(0, 0, 0)
If $sInfo[0] > 1 Or $sInfo[0] = "" Then
If @error Then Return SetError(0, 0, 0)
If StringInStr($sInfo[1], "Quee") = 0 Then
Local $sLocMsg =($sInfo[0] = "" ? "Nothing" : $sInfo[1])
$iSilly += 1
Select
Case $iSilly = 1
$sErrorText = "Wait, That is not the Queen Altar?, It was a " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 2
$sErrorText = "Quit joking, That was " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 3
$sErrorText = "This is not funny, why did you click " & $sLocMsg & "? Please stop!" & @CRLF
ContinueLoop
Case $iSilly = 4
$sErrorText = $sLocMsg & " ?!?!?!" & @CRLF & @CRLF & "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iSilly > 4
SetLog("Quit joking, Click the Queen Altar, or restart bot and try again", $COLOR_ERROR)
$QueenAltarPos[0] = -1
$QueenAltarPos[1] = -1
ClickP($aTopLeftClient)
Return False
EndSelect
EndIf
Else
SetLog(" Operator Error - Bad Queen Altar Location: " & "(" & $QueenAltarPos[0] & "," & $QueenAltarPos[1] & ")", $COLOR_ERROR)
$QueenAltarPos[0] = -1
$QueenAltarPos[1] = -1
ClickP($aTopLeftClient)
Return False
EndIf
ExitLoop
WEnd
ClickP($aTopLeftClient, 1, 200, "#0327")
If _Sleep(1000) Then Return
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$stext = GetTranslated(640,38,"Now you can remove mouse out of Android Emulator, Thanks!!")
$MsgBox = _ExtMsgBox(48, GetTranslated(640,36,"OK"), GetTranslated(640,37,"Notice!"), $stext, 15)
IniWrite($g_sProfileBuildingPath, "other", "xQueenAltarPos", $QueenAltarPos[0])
IniWrite($g_sProfileBuildingPath, "other", "yQueenAltarPos", $QueenAltarPos[1])
EndFunc
Func LocateKingAltar()
Local $wasRunState = $g_bRunState
$g_bRunState = True
AndroidShield("LocateKingAltar 1")
Local $Result = _LocateKingAltar()
$g_bRunState = $wasRunState
AndroidShield("LocateKingAltar 2")
Return $Result
EndFunc
Func _LocateKingAltar()
Local $stext, $MsgBox, $iSilly = 0, $iStupid = 0, $sErrorText = "", $sInfo
WinGetAndroidHandle()
checkMainScreen(False)
If _GetPixelColor($aTopLeftClient[0], $aTopLeftClient[1], True) <> Hex($aTopLeftClient[2], 6) Or _GetPixelColor($aTopRightClient[0], $aTopRightClient[1], True) <> Hex($aTopRightClient[2], 6) Then
Zoomout()
$bDisableBreakCheck = True
Collect()
$bDisableBreakCheck = False
EndIf
SetLog("Locating King Altar...", $COLOR_INFO)
While 1
ClickP($aTopLeftClient)
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$stext = $sErrorText & @CRLF & GetTranslated(640,39,"Click OK then click on your King Altar") & @CRLF & @CRLF & GetTranslated(640,26,"Do not move mouse quickly after clicking location") & @CRLF & @CRLF & GetTranslated(640,27,"Make sure the building name is visible for me!") & @CRLF
$MsgBox = _ExtMsgBox(0, GetTranslated(640,1,"Ok|Cancel"), GetTranslated(640,40,"Locate King Altar"), $stext, 15)
If $MsgBox = 1 Then
WinGetAndroidHandle()
Local $aPos = FindPos()
$KingAltarPos[0] = $aPos[0]
$KingAltarPos[1] = $aPos[1]
If isInsideDiamond($KingAltarPos) = False Then
$iStupid += 1
Select
Case $iStupid = 1
$sErrorText = "King Altar Location Not Valid!" & @CRLF
SetLog("Location not valid, try again", $COLOR_ERROR)
ContinueLoop
Case $iStupid = 2
$sErrorText = "Please try to click inside the grass field!" & @CRLF
ContinueLoop
Case $iStupid = 3
$sErrorText = "This is not funny, why did you click @ (" & $KingAltarPos[0] & "," & $KingAltarPos[1] & ")?" & @CRLF & "  Please stop!" & @CRLF & @CRLF
ContinueLoop
Case $iStupid = 4
$sErrorText = "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iStupid > 4
SetLog(" Operator Error - Bad King Altar Location: " & "(" & $KingAltarPos[0] & "," & $KingAltarPos[1] & ")", $COLOR_ERROR)
ClickP($aTopLeftClient)
Return False
Case Else
SetLog(" Operator Error - Bad King Altar Location: " & "(" & $KingAltarPos[0] & "," & $KingAltarPos[1] & ")", $COLOR_ERROR)
$KingAltarPos[0] = -1
$KingAltarPos[1] = -1
ClickP($aTopLeftClient)
Return False
EndSelect
EndIf
SetLog("King Altar: " & "(" & $KingAltarPos[0] & "," & $KingAltarPos[1] & ")", $COLOR_SUCCESS)
Else
SetLog("Locate King Altar Cancelled", $COLOR_INFO)
ClickP($aTopLeftClient)
Return
EndIf
$sInfo = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
Local $CountGetInfo = 0
While IsArray($sInfo) = False
$sInfo = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
Sleep(100)
$CountGetInfo += 1
If $CountGetInfo = 50 Then Return
WEnd
If $g_iDebugSetlog = 1 Then SetLog($sInfo[1] & $sInfo[2])
If @error Then Return SetError(0, 0, 0)
If $sInfo[0] > 1 Or $sInfo[0] = "" Then
If(StringInStr($sInfo[1], "Barb") = 0) And(StringInStr($sInfo[1], "King") = 0) Then
Local $sLocMsg =($sInfo[0] = "" ? "Nothing" : $sInfo[1])
$iSilly += 1
Select
Case $iSilly = 1
$sErrorText = "Wait, That is not the King Altar?, It was a " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 2
$sErrorText = "Quit joking, That was " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 3
$sErrorText = "This is not funny, why did you click " & $sLocMsg & "? Please stop!" & @CRLF
ContinueLoop
Case $iSilly = 4
$sErrorText = $sLocMsg & " ?!?!?!" & @CRLF & @CRLF & "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iSilly > 4
SetLog("Quit joking, Click the King Altar, or restart bot and try again", $COLOR_ERROR)
$KingAltarPos[0] = -1
$KingAltarPos[1] = -1
ClickP($aTopLeftClient)
Return False
EndSelect
EndIf
Else
SetLog(" Operator Error - Bad King Altar Location: " & "(" & $KingAltarPos[0] & "," & $KingAltarPos[1] & ")", $COLOR_ERROR)
$KingAltarPos[0] = -1
$KingAltarPos[1] = -1
ClickP($aTopLeftClient)
Return False
EndIf
ExitLoop
WEnd
ClickP($aTopLeftClient, 1, 200, "#0327")
If _Sleep(1000) Then Return
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$stext = GetTranslated(640,38,"Now you can remove mouse out of Android Emulator, Thanks!!")
$MsgBox = _ExtMsgBox(48, GetTranslated(640,36,"OK"), GetTranslated(640,37,"Notice!"), $stext, 15)
IniWrite($g_sProfileBuildingPath, "other", "xKingAltarPos", $KingAltarPos[0])
IniWrite($g_sProfileBuildingPath, "other", "yKingAltarPos", $KingAltarPos[1])
EndFunc
Func LocateWardenAltar()
Local $wasRunState = $g_bRunState
$g_bRunState = True
AndroidShield("LocateWardenAltar 1")
Local $Result = _LocateWardenAltar()
$g_bRunState = $wasRunState
AndroidShield("LocateWardenAltar 2")
Return $Result
EndFunc
Func _LocateWardenAltar()
Local $stext, $MsgBox, $iSilly = 0, $iStupid = 0, $sErrorText = "", $sInfo
If Number($iTownHallLevel) < 11 Then
SetLog("Grand Warden requires TH11, Cancel locate Altar!", $COLOR_ERROR)
Return
EndIf
WinGetAndroidHandle()
checkMainScreen(False)
If _GetPixelColor($aTopLeftClient[0], $aTopLeftClient[1], True) <> Hex($aTopLeftClient[2], 6) And _GetPixelColor($aTopRightClient[0], $aTopRightClient[1], True) <> Hex($aTopRightClient[2], 6) Then
Zoomout()
$bDisableBreakCheck = True
Collect()
$bDisableBreakCheck = False
EndIf
SetLog("Locating Grand Warden Altar... work in progress!", $COLOR_INFO)
While 1
ClickP($aTopLeftClient)
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$stext = $sErrorText & @CRLF & GetTranslated(640,41,"Click OK then click on your Grand Warden Altar") & @CRLF & @CRLF & GetTranslated(640,26,"Do not move mouse quickly after clicking location") & @CRLF & @CRLF & GetTranslated(640,27,"Make sure the building name is visible for me!") & @CRLF
$MsgBox = _ExtMsgBox(0, GetTranslated(640,1,"Ok|Cancel"), GetTranslated(640,42,"Locate Grand Warden Altar"), $stext, 15)
If $MsgBox = 1 Then
WinGetAndroidHandle()
Local $aPos = FindPos()
$WardenAltarPos[0] = $aPos[0]
$WardenAltarPos[1] = $aPos[1]
If isInsideDiamond($WardenAltarPos) = False Then
$iStupid += 1
Select
Case $iStupid = 1
$sErrorText = "Grand Warden Altar Location Not Valid!" & @CRLF
SetLog("Location not valid, try again", $COLOR_ERROR)
ContinueLoop
Case $iStupid = 2
$sErrorText = "Please try to click inside the grass field!" & @CRLF
ContinueLoop
Case $iStupid = 3
$sErrorText = "This is not funny, why did you click @ (" & $WardenAltarPos[0] & "," & $WardenAltarPos[1] & ")?" & @CRLF & "  Please stop!" & @CRLF & @CRLF
ContinueLoop
Case $iStupid = 4
$sErrorText = "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iStupid > 4
SetLog(" Operator Error - Bad Grand Warden Altar Location: " & "(" & $WardenAltarPos[0] & "," & $WardenAltarPos[1] & ")", $COLOR_ERROR)
ClickP($aTopLeftClient)
Return False
Case Else
SetLog(" Operator Error - Bad Grand Warden Altar Location: " & "(" & $WardenAltarPos[0] & "," & $WardenAltarPos[1] & ")", $COLOR_ERROR)
$WardenAltarPos[0] = -1
$WardenAltarPos[1] = -1
ClickP($aTopLeftClient)
Return False
EndSelect
EndIf
SetLog("Grand Warden Altar: " & "(" & $WardenAltarPos[0] & "," & $WardenAltarPos[1] & ")", $COLOR_SUCCESS)
Else
SetLog("Locate Grand Warden Altar Cancelled", $COLOR_INFO)
ClickP($aTopLeftClient)
Return
EndIf
$sInfo = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
Local $CountGetInfo = 0
While IsArray($sInfo) = False
$sInfo = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
Sleep(100)
$CountGetInfo += 1
If $CountGetInfo = 50 Then Return
WEnd
If $g_iDebugSetlog = 1 Then SetLog($sInfo[1] & $sInfo[2])
If @error Then Return SetError(0, 0, 0)
If $sInfo[0] > 1 Or $sInfo[0] = "" Then
If @error Then Return SetError(0, 0, 0)
If StringInStr($sInfo[1], "Warden") = 0 Then
Local $sLocMsg =($sInfo[0] = "" ? "Nothing" : $sInfo[1])
$iSilly += 1
Select
Case $iSilly = 1
$sErrorText = "Wait, That is not the Grand Warden Altar?, It was a " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 2
$sErrorText = "Quit joking, That was " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 3
$sErrorText = "This is not funny, why did you click " & $sLocMsg & "? Please stop!" & @CRLF
ContinueLoop
Case $iSilly = 4
$sErrorText = $sLocMsg & " ?!?!?!" & @CRLF & @CRLF & "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iSilly > 4
SetLog("Quit joking, Click the Grand Warden Altar, or restart bot and try again", $COLOR_ERROR)
$WardenAltarPos[0] = -1
$WardenAltarPos[1] = -1
ClickP($aTopLeftClient)
Return False
EndSelect
EndIf
Else
SetLog(" Operator Error - Bad Grand Warden Altar Location: " & "(" & $WardenAltarPos[0] & "," & $WardenAltarPos[1] & ")", $COLOR_ERROR)
$WardenAltarPos[0] = -1
$WardenAltarPos[1] = -1
ClickP($aTopLeftClient)
Return False
EndIf
ExitLoop
WEnd
ClickP($aTopLeftClient, 1, 200, "#0327")
If _Sleep(1000) Then Return
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$stext = GetTranslated(640,38,"Now you can remove mouse out of Android Emulator, Thanks!!")
$MsgBox = _ExtMsgBox(48, GetTranslated(640,36,"OK"), GetTranslated(640,37,"Notice!"), $stext, 15)
IniWrite($g_sProfileBuildingPath, "other", "xWardenAltarPos", $WardenAltarPos[0])
IniWrite($g_sProfileBuildingPath, "other", "yWardenAltarPos", $WardenAltarPos[1])
EndFunc
Func ProfileReport()
Local $AttacksWon = 0, $DefensesWon = 0
Local $iCount
ClickP($aAway, 1, 0, "#0221")
If _Sleep($iDelayProfileReport1) Then Return
SetLog("Profile Report", $COLOR_INFO)
SetLog("Opening Profile page to read atk, def, donated and received...", $COLOR_INFO)
Click(30, 40, 1, 0, "#0222")
If _Sleep($iDelayProfileReport2) Then Return
While _ColorCheck(_GetPixelColor(400, 104 + $g_iMidOffsetY, True), Hex(0xA2A6BE, 6), 20) = False
If $g_iDebugSetlog = 1 Then Setlog("Profile wait time: " & $iCount & ", color= " & _GetPixelColor(400, 104 + $g_iMidOffsetY, True)& " pos (400," & 104 + $g_iMidOffsetY&")", $COLOR_DEBUG)
$iCount += 1
If _Sleep($iDelayProfileReport1) Then Return
If $iCount >= 25 Then ExitLoop
WEnd
If $g_iDebugSetlog = 1 And $iCount >= 25 Then Setlog("Excess wait time for profile to open: " & $iCount, $COLOR_DEBUG)
If _Sleep($iDelayProfileReport1) Then Return
$AttacksWon = ""
If _ColorCheck(_GetPixelColor($ProfileRep01[0], $ProfileRep01[1] , True), Hex($ProfileRep01[2], 6), $ProfileRep01[3]) = true Then
If $g_iDebugSetlog=1 Then Setlog("Village have no attack and no defenses " & $ProfileRep01[0] & "," & $ProfileRep01[1] + $g_iMidOffsetY,$COLOR_DEBUG)
$AttacksWon = 0
$DefensesWon = 0
Else
$AttacksWon = getProfile(578, 268 + $g_iMidOffsetY)
If $g_iDebugSetlog = 1 Then Setlog("$AttacksWon 1st read: " & $AttacksWon, $COLOR_DEBUG)
$iCount = 0
While $AttacksWon = ""
If _Sleep($iDelayProfileReport1) Then Return
$AttacksWon = getProfile(578, 268 + $g_iMidOffsetY)
If $g_iDebugSetlog = 1 Then Setlog("Read Loop $AttacksWon: " & $AttacksWon & ", Count: " & $iCount, $COLOR_DEBUG)
$iCount += 1
If $iCount >= 20 Then ExitLoop
WEnd
If $g_iDebugSetlog = 1 And $iCount >= 20 Then Setlog("Excess wait time for reading $AttacksWon: " & getProfile(578, 268 + $g_iMidOffsetY), $COLOR_DEBUG)
$DefensesWon = getProfile(790, 268 + $g_iMidOffsetY)
EndIf
$TroopsDonated = getProfile(158, 268 + $g_iMidOffsetY)
$TroopsReceived = getProfile(360, 268 + $g_iMidOffsetY)
SetLog(" [ATKW]: " & _NumberFormat($AttacksWon) & " [DEFW]: " & _NumberFormat($DefensesWon) & " [TDON]: " & _NumberFormat($TroopsDonated) & " [TREC]: " & _NumberFormat($TroopsReceived), $COLOR_SUCCESS)
Click(830, 80, 1, 0, "#0223")
If _Sleep($iDelayProfileReport3) Then Return
$iCount = 0
While _CheckPixel($aIsMain, $g_bCapturePixel) = False
If _Sleep($iDelayProfileReport3) Then Return
$iCount += 1
If $g_iDebugSetlog = 1 Then Setlog("End ProfileReport $iCount= " & $iCount, $COLOR_DEBUG)
If $iCount > 50 Then
If $g_iDebugSetlog = 1 Then Setlog("Excess wait time clearing ProfileReport window: " & $iCount, $COLOR_DEBUG)
ExitLoop
EndIf
WEnd
EndFunc
Func ReArm()
If $g_bChkTrap = False Then Return
If $NotNeedAllTime[0] = 0 Then Return
SetLog("Checking if Village needs Rearming..", $COLOR_INFO)
Local $ImagesToUse[3]
$ImagesToUse[0] = @ScriptDir & "\imgxml\rearm\Traps_0_90.xml"
$ImagesToUse[1] = @ScriptDir & "\imgxml\rearm\Xbow_0_90.xml"
$ImagesToUse[2] = @ScriptDir & "\imgxml\rearm\Inferno_0_90.xml"
$ToleranceImgLoc = 0.90
Local $locate = 0
Local $t = 0
If isInsideDiamond($TownHallPos) = False Then
LocateTownHall(True)
SaveConfig()
If _Sleep($iDelayReArm3) Then Return
EndIf
ClickP($aAway, 1, 0, "#0224")
If _Sleep($iDelayReArm4) Then Return
If IsMainPage() Then BuildingClickP($TownHallPos, "#0225")
If _Sleep($iDelayReArm2) Then Return
If Number($iTownHallLevel) > 8 Then $t = 1
If Number($iTownHallLevel) > 9 Then $t = 2
For $i = 0 To $t
If FileExists($ImagesToUse[$i]) Then
_CaptureRegion2(125, 610, 740, 715)
Local $res = DllCall($g_hLibImgLoc, "str", "FindTile", "handle", $hHBitmap2, "str", $ImagesToUse[$i], "str", "FV", "int", 1)
If @error Then _logErrorDLLCall($g_sLibImgLocPath, @error)
If IsArray($res) Then
If $g_iDebugSetlog = 1 Then SetLog("DLL Call succeeded " & $res[0], $COLOR_ERROR)
If $res[0] = "0" Or $res[0] = "" Then
If $g_iDebugSetlog = 1 Then SetLog("No Button found")
ElseIf StringLeft($res[0], 2) = "-1" Then
SetLog("DLL Error: " & $res[0], $COLOR_ERROR)
Else
Local $expRet = StringSplit($res[0], "|", $STR_NOCOUNT)
Local $posPoint = StringSplit($expRet[1], ",", $STR_NOCOUNT)
Local $ButtonX = 125 + Int($posPoint[0])
Local $ButtonY = 610 + Int($posPoint[1])
If IsMainPage() Then Click($ButtonX, $ButtonY, 1, 0, "#0330")
If _Sleep($iDelayReArm1) Then Return
Click(515, 400, 1, 0, "#0226")
If _Sleep($iDelayReArm4) Then Return
If isGemOpen(True) = True Then
Setlog("Not enough loot to rearm traps.....", $COLOR_ERROR)
Click(585, 252, 1, 0, "#0227")
If _Sleep($iDelayReArm1) Then Return
Else
Switch $i
Case 0
SetLog("Rearmed Trap(s)", $COLOR_SUCCESS)
$NotNeedAllTime[0] = 0
Case 1
SetLog("Reloaded XBow(s)", $COLOR_SUCCESS)
$NotNeedAllTime[0] = 0
Case 2
SetLog("Reloaded Inferno(s)", $COLOR_SUCCESS)
$NotNeedAllTime[0] = 0
EndSwitch
$locate = 1
If _Sleep($iDelayReArm1) Then Return
EndIf
EndIf
EndIf
EndIf
Next
If $locate = 0 Then
SetLog("Rearm not needed!", $COLOR_SUCCESS)
$NotNeedAllTime[0] = 0
EndIf
ClickP($aAway, 1, 0, "#0234")
If _Sleep($iDelayReArm2) Then Return
checkMainScreen(False)
EndFunc
Func RequestCC($ClickPAtEnd = True, $specifyText = "")
If $g_bRequestTroopsEnable = False Or $canRequestCC = False Or $bDonationEnabled = False Then
Return
EndIf
If $g_bRequestTroopsEnable = True Then
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If $g_abRequestCCHours[$hour[0]] = False Then
SetLog("Request Clan Castle troops not planned, Skipped..", $COLOR_ACTION)
Return
EndIf
EndIf
SetLog("Requesting Clan Castle Troops", $COLOR_INFO)
If IsMainPage() Then
If $iUseRandomClick = 0 then
Click($aArmyTrainButton[0], $aArmyTrainButton[1], 1, 0, "#0334")
Else
ClickR($aArmyTrainButtonRND, $aArmyTrainButton[0], $aArmyTrainButton[1], 1, 0)
EndIF
EndIf
If _Sleep($iDelayRequestCC1) Then Return
checkAttackDisable($iTaBChkIdle)
Local $icount = 0
While Not( _ColorCheck(_GetPixelColor($aArmyOverviewTest[0], $aArmyOverviewTest[1], True), Hex($aArmyOverviewTest[2], 6), $aArmyOverviewTest[3]))
If _Sleep($iDelayRequestCC1) Then ExitLoop
$icount += 1
If $g_iDebugSetlog = 1 Then Setlog("$icount1 = " & $icount & ", " & _GetPixelColor($aArmyOverviewTest[0], $aArmyOverviewTest[1], True), $COLOR_DEBUG)
If $icount > 5 Then ExitLoop
WEnd
If $icount > 5 And $g_iDebugSetlog = 1 Then Setlog("RequestCC warning 1", $COLOR_DEBUG)
Local $color = _GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1], True)
If _ColorCheck($color, Hex($aRequestTroopsAO[2], 6), $aRequestTroopsAO[5]) Then
Local $x = _makerequest()
ElseIf _ColorCheck($color, Hex($aRequestTroopsAO[3], 6), $aRequestTroopsAO[5]) Then
SetLog("Request has already been made")
ElseIf _ColorCheck($color, Hex($aRequestTroopsAO[4], 6), $aRequestTroopsAO[5]) Then
SetLog("Your Clan Castle is already full or you are not in a clan.")
$canRequestCC = False
Else
SetLog("Cannot detect button request troops.")
setlog("The Pixel on " & $aRequestTroopsAO[0]& "-" & $aRequestTroopsAO[1]& " was: " & $color, $COLOR_ERROR)
EndIf
If _Sleep($iDelayRequestCC1) Then Return
If $ClickPAtEnd = True Then ClickP($aAway, 2, 0, "#0335")
EndFunc
Func _makerequest()
Click($aRequestTroopsAO[0], $aRequestTroopsAO[1], 1, 0, "0336")
Local $icount = 0
While Not( _ColorCheck(_GetPixelColor($aCancRequestCCBtn[0], $aCancRequestCCBtn[1], True), Hex($aCancRequestCCBtn[2], 6), $aCancRequestCCBtn[3]))
If _Sleep($iDelaymakerequest1) Then ExitLoop
$icount += 1
If $g_iDebugSetlog = 1 Then Setlog("$icount2 = " & $icount & ", " & _GetPixelColor($aCancRequestCCBtn[0], $aCancRequestCCBtn[1], True), $COLOR_DEBUG)
If $icount > 20 Then ExitLoop
WEnd
If $icount > 20 Then
SetLog("Request has already been made, or request window not available", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0257")
If _Sleep($iDelaymakerequest2) Then Return
Else
If $g_sRequestTroopsText <> "" Then
If $g_bChkBackgroundMode = False And $g_bNoFocusTampering = False Then ControlFocus($HWnD, "", "")
AndroidSendText($g_sRequestTroopsText, True)
Click($atxtRequestCCBtn[0], $atxtRequestCCBtn[1], 1, 0, "#0254")
_Sleep($iDelaymakerequest2)
If SendText($g_sRequestTroopsText) = 0 Then
Setlog(" Request text entry failed, try again", $COLOR_ERROR)
Return
EndIf
EndIf
If _Sleep($iDelaymakerequest2) Then Return
$icount = 0
While Not _ColorCheck(_GetPixelColor($aSendRequestCCBtn[0], $aSendRequestCCBtn[1], True), Hex(0x5fac10, 6), 20)
If _Sleep($iDelaymakerequest1) Then ExitLoop
$icount += 1
If $g_iDebugSetlog = 1 Then Setlog("$icount3 = " & $icount & ", " & _GetPixelColor($aSendRequestCCBtn[0], $aSendRequestCCBtn[1], True), $COLOR_DEBUG)
If $icount > 25 Then ExitLoop
WEnd
If $icount > 25 Then
If $g_iDebugSetlog = 1 Then SetLog("Send request button not found", $COLOR_DEBUG)
CheckMainScreen(False)
EndIf
If $g_bChkBackgroundMode = False And $g_bNoFocusTampering = False Then ControlFocus($HWnD, "", "")
Click($aSendRequestCCBtn[0], $aSendRequestCCBtn[1], 1, 100, "#0256")
$canRequestCC = False
EndIf
EndFunc
Func Laboratory()
Static $aUpgradeValue[30] = [-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Local $iAvailElixir, $iAvailDark, $iElixirCount, $iDarkCount, $TimeDiff, $aArray, $Result
$g_iUpgradeMinElixir = Number($g_iUpgradeMinElixir)
$g_iUpgradeMinDark = Number($g_iUpgradeMinDark)
$iLaboratoryElixirCost = 0
If $g_bAutoLabUpgradeEnable = False Then Return
If $g_iCmbLaboratory = 0 Then
SetLog("Laboratory enabled, but no troop upgrade selected", $COLOR_WARNING)
Return False
EndIf
If $aLabPos[0] = 0 Or $aLabPos[1] = 0 Then
SetLog("Laboratory Location not found!", $COLOR_ERROR)
LocateLab()
If $aLabPos[0] = 0 Or $aLabPos[1] = 0 Then
SetLog("Problem locating Laboratory, train laboratory position before proceeding", $COLOR_ERROR)
Return False
EndIf
EndIf
If $sLabUpgradeTime <> "" Then $TimeDiff = _DateDiff("n", _NowCalc(), $sLabUpgradeTime)
If @error Then _logErrorDateDiff(@error)
If $g_iDebugSetlog = 1 Then SetLog($aLabTroops[$g_iCmbLaboratory][3] & " Lab end time: " & $sLabUpgradeTime & ", DIFF= " & $TimeDiff, $COLOR_DEBUG)
If $g_bRunState = False Then Return
If $TimeDiff <= 0 Then
SetLog("Checking Troop Upgrade in Laboratory ...", $COLOR_INFO)
Else
SetLog("Laboratory Upgrade in progress, waiting for completion", $COLOR_INFO)
Return False
EndIf
If _ColorCheck(_GetPixelColor(837, 134, True), Hex(0x302030, 6), 10) Then
$iElixirCount = getResourcesMainScreen(705, 74)
$iDarkCount = getResourcesMainScreen(728, 123)
SetLog("Updating village values [E]: " & $iElixirCount & " [D]: " & $iDarkCount, $COLOR_SUCCESS)
Else
$iElixirCount = getResourcesMainScreen(710, 74)
SetLog("Updating village values [E]: " & $iElixirCount, $COLOR_SUCCESS)
EndIf
$iAvailElixir = Number($iElixirCount)
$iAvailDark = Number($iDarkCount)
BuildingClickP($aLabPos, "#0197")
If _Sleep($iDelayLaboratory1) Then Return
Local $offColors[4][3] = [[0x708CB0, 37, 34], [0x603818, 50, 43], [0xD5FC58, 61, 8], [0x000000, 82, 0]]
Global $ButtonPixel = _MultiPixelSearch(433, 565 + $g_iBottomOffsetY, 562, 619 + $g_iBottomOffsetY, 1, 1, Hex(0x000000, 6), $offColors, 30)
If IsArray($ButtonPixel) Then
If $g_iDebugSetlog = 1 Then
Setlog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("#1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 37, $ButtonPixel[1] + 34, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 50, $ButtonPixel[1] + 43, True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 61, $ButtonPixel[1] + 8, True), $COLOR_DEBUG)
EndIf
If $g_iDebugImageSave = 1 Then DebugImageSave("LabUpgrade_")
Click($ButtonPixel[0] + 40, $ButtonPixel[1] + 25, 1, 0, "#0198")
If _Sleep($iDelayLaboratory1) Then Return
Else
Setlog("Trouble finding research button, try again...", $COLOR_WARNING)
ClickP($aAway, 2, $iDelayLaboratory4, "#0199")
Return False
EndIf
If $g_iDebugSetlog = 1 Then LabTroopImages1()
If $iFirstTimeLab = 0 Then
For $i = 1 To 12
$aUpgradeValue[$i] = getLabUpgrdResourceRed($aLabTroops[$i][0] + 13, $aLabTroops[$i][1] + 74)
If $g_iDebugSetlog = 1 Then Setlog($aLabTroops[$i][3] & " Red text upgrade value = " & $aUpgradeValue[$i], $COLOR_DEBUG)
If $aUpgradeValue[$i] = "" Or $aUpgradeValue[$i] < 49999 Then
$aUpgradeValue[$i] = getLabUpgrdResourceWht($aLabTroops[$i][0] + 13, $aLabTroops[$i][1] + 74)
If $g_iDebugSetlog = 1 Then Setlog($aLabTroops[$i][3] & " White text upgrade value = " & $aUpgradeValue[$i], $COLOR_DEBUG)
EndIf
If $aUpgradeValue[$i] = "" Or $aUpgradeValue[$i] < 49999 Then
If _ColorCheck(_GetPixelColor($aLabTroops[$i][0] + 78, $aLabTroops[$i][1] + 78, True), Hex(0xEFFFFF, 6), 20) And _ColorCheck(_GetPixelColor($aLabTroops[$i][0] + 78, $aLabTroops[$i][1] + 83, True), Hex(0xFFFFFF, 6), 20) Then
$aUpgradeValue[$i] = -1
If $g_iDebugSetlog = 1 Then Setlog($aLabTroops[$i][3] & " Is Maxed already, now = " & $aUpgradeValue[$i], $COLOR_DEBUG)
EndIf
EndIf
If $g_bRunState = False Then Return
Next
$iFirstTimeLab = 1
EndIf
If $aLabTroops[$g_iCmbLaboratory][2] >= 1 Then
ClickDrag(650, 423 + $g_iMidOffsetY, 323, 423 + $g_iMidOffsetY, 1000)
If _Sleep($iDelayLaboratory3) Then Return
If $g_iDebugSetlog = 1 Then LabTroopImages2()
If $iFirstTimeLab < 2 Then
For $i = 13 To 18
$aUpgradeValue[$i] = getLabUpgrdResourceRed($aLabTroops[$i][0] + 13, $aLabTroops[$i][1] + 74)
If $g_iDebugSetlog = 1 Then Setlog($aLabTroops[$i][3] & " Red text upgrade value = " & $aUpgradeValue[$i], $COLOR_DEBUG)
If $aUpgradeValue[$i] = "" Or $aUpgradeValue[$i] < 9999 Then
$aUpgradeValue[$i] = getLabUpgrdResourceWht($aLabTroops[$i][0] + 13, $aLabTroops[$i][1] + 74)
If $g_iDebugSetlog = 1 Then Setlog($aLabTroops[$i][3] & " White text upgrade value = " & $aUpgradeValue[$i], $COLOR_DEBUG)
EndIf
If $aUpgradeValue[$i] = "" Or $aUpgradeValue[$i] < 9999 Then
If _ColorCheck(_GetPixelColor($aLabTroops[$i][0] + 78, $aLabTroops[$i][1] + 78, True), Hex(0xEFFFFF, 6), 20) And _ColorCheck(_GetPixelColor($aLabTroops[$i][0] + 78, $aLabTroops[$i][1] + 83, True), Hex(0xFFFFFF, 6), 20) Then
$aUpgradeValue[$i] = -1
If $g_iDebugSetlog = 1 Then Setlog($aLabTroops[$i][3] & " Is Maxed already, $aUpgradeValue now = " & $aUpgradeValue[$i], $COLOR_DEBUG)
EndIf
EndIf
If $g_bRunState = False Then Return
Next
$iFirstTimeLab += 2
EndIf
EndIf
If $aLabTroops[$g_iCmbLaboratory][2] = 2 Then
ClickDrag(734, 423 + $g_iMidOffsetY, 3, 423 + $g_iMidOffsetY, 2000)
If _Sleep($iDelayLaboratory3) Then Return
If $g_iDebugSetlog = 1 Then LabTroopImages3()
If $iFirstTimeLab < 4 Then
For $i = 19 To 29
$aUpgradeValue[$i] = getLabUpgrdResourceRed($aLabTroops[$i][0] + 13, $aLabTroops[$i][1] + 74)
If $g_iDebugSetlog = 1 Then Setlog($aLabTroops[$i][3] & " Red text upgrade value = " & $aUpgradeValue[$i], $COLOR_DEBUG)
If $aUpgradeValue[$i] = "" Or $aUpgradeValue[$i] < 9999 Then
$aUpgradeValue[$i] = getLabUpgrdResourceWht($aLabTroops[$i][0] + 13, $aLabTroops[$i][1] + 74)
If $g_iDebugSetlog = 1 Then Setlog($aLabTroops[$i][3] & " White text upgrade value = " & $aUpgradeValue[$i], $COLOR_DEBUG)
EndIf
If $aUpgradeValue[$i] = "" Or $aUpgradeValue[$i] < 9999 Then
If _ColorCheck(_GetPixelColor($aLabTroops[$i][0] + 78, $aLabTroops[$i][1] + 78, True), Hex(0xEFFFFF, 6), 20) And _ColorCheck(_GetPixelColor($aLabTroops[$i][0] + 78, $aLabTroops[$i][1] + 83, True), Hex(0xFFFFFF, 6), 20) Then
$aUpgradeValue[$i] = -1
If $g_iDebugSetlog = 1 Then Setlog($aLabTroops[$i][3] & " Is Maxed already, $aUpgradeValue now = " & $aUpgradeValue[$i], $COLOR_DEBUG)
EndIf
EndIf
If $g_bRunState = False Then Return
Next
$iFirstTimeLab += 4
EndIf
EndIf
Switch $g_iCmbLaboratory
Case 1 To 18
If $aUpgradeValue[$g_iCmbLaboratory] > 0 Then $iLaboratoryElixirCost = $aUpgradeValue[$g_iCmbLaboratory]
EndSwitch
If _ColorCheck(_GetPixelColor(625, 250 + $g_iMidOffsetY, True), Hex(0x60AC10, 6), 20) Or _ColorCheck(_GetPixelColor(660, 250 + $g_iMidOffsetY, True), Hex(0x60AC10, 6), 20) Then
SetLog("Upgrade in progress, waiting for completion of other troops", $COLOR_INFO)
If _Sleep($iDelayLaboratory2) Then Return
If $sLabUpgradeTime = "" Or $TimeDiff <= 0 Then
$Result = getRemainTLaboratory(336, 260)
If $g_iDebugSetlog = 1 Then Setlog($aLabTroops[$g_iCmbLaboratory][3] & " OCR Remaining Lab Time = " & $Result, $COLOR_DEBUG)
$aArray = StringSplit($Result, ' ', BitOR($STR_CHRSPLIT, $STR_NOCOUNT))
If IsArray($aArray) Then
Local $iRemainingTimeMin = 0
For $i = 0 To UBound($aArray) - 1
Local $sTime = ""
Select
Case StringInStr($aArray[$i], "d", $STR_NOCASESENSEBASIC) > 0
$sTime = StringTrimRight($aArray[$i], 1)
$iRemainingTimeMin +=(Int($sTime) * 24 * 60)
Case StringInStr($aArray[$i], "h", $STR_NOCASESENSEBASIC) > 0
$sTime = StringTrimRight($aArray[$i], 1)
$iRemainingTimeMin +=(Int($sTime) * 60)
Case StringInStr($aArray[$i], "m", $STR_NOCASESENSEBASIC) > 0
$sTime = StringTrimRight($aArray[$i], 1)
$iRemainingTimeMin += Int($sTime)
Case StringInStr($aArray[$i], "s", $STR_NOCASESENSEBASIC) > 0
$sTime = StringTrimRight($aArray[$i], 1)
$iRemainingTimeMin += Int($sTime) / 60
Case Else
Setlog("Remaining lab time OCR invalid:" & $aArray[$i], $COLOR_WARNING)
ClickP($aAway, 2, $iDelayLaboratory4, "#0328")
Return False
EndSelect
If $g_iDebugSetlog = 1 Then Setlog("Remain Lab Time: " & $aArray[$i] & ", Minutes= " & $iRemainingTimeMin, $COLOR_DEBUG)
Next
$sLabUpgradeTime = _DateAdd('n', Ceiling($iRemainingTimeMin), _NowCalc())
If @error Then _logErrorDateAdd(@error)
SetLog($aLabTroops[$g_iCmbLaboratory][3] & "Updated Lab finishing time: " & $sLabUpgradeTime, $COLOR_SUCCESS)
LabStatusGUIUpdate()
Else
If $g_iDebugSetlog = 1 Then Setlog("Invalid getRemainTLaboratory OCR", $COLOR_DEBUG)
EndIf
EndIf
ClickP($aAway, 2, $iDelayLaboratory4, "#0328")
Return False
EndIf
If $aUpgradeValue[$g_iCmbLaboratory] = -1 Then
SetLog($aLabTroops[$g_iCmbLaboratory][3] & " already max level, select another troop", $COLOR_ERROR)
ClickP($aAway, 2, $iDelayLaboratory4, "#0353")
Return False
EndIf
If $aUpgradeValue[$g_iCmbLaboratory] = 0 Then
If _ColorCheck(_GetPixelColor($aLabTroops[$g_iCmbLaboratory][0] + 3, $aLabTroops[$g_iCmbLaboratory][1] + 19, True), Hex(0xC0C0C0, 6), 25) = True Then
SetLog("Lab upgrade not available for " & $aLabTroops[$g_iCmbLaboratory][3] & ", Pick different troop!", $COLOR_ERROR)
If _Sleep($iDelayLabUpgrade2) Then Return
Else
SetLog($aLabTroops[$g_iCmbLaboratory][3] & " value read error, close bot and try again!", $COLOR_ERROR)
EndIf
$iFirstTimeLab = 2
ClickP($aAway, 2, $iDelayLaboratory4, "#0354")
Return False
EndIf
Switch $g_iCmbLaboratory
Case 1 To 18
If $iAvailElixir <($aUpgradeValue[$g_iCmbLaboratory] + $g_iUpgradeMinElixir) Then
SetLog("Insufficent Elixir for " & $aLabTroops[$g_iCmbLaboratory][3] & ", Lab requires: " & $aUpgradeValue[$g_iCmbLaboratory] & " + " & $g_iUpgradeMinElixir & " user reserve", $COLOR_INFO)
ClickP($aAway, 2, $iDelayLaboratory4, "#0355")
Return False
EndIf
If LabUpgrade() = True Then
Setlog("Elixir used = " & $aUpgradeValue[$g_iCmbLaboratory], $COLOR_INFO)
ClickP($aAway, 2, $iDelayLaboratory4, "#0356")
Return True
EndIf
Case 19 To 29
If $iAvailDark < $aUpgradeValue[$g_iCmbLaboratory] + $g_iUpgradeMinDark Then
SetLog("Insufficent Dark Elixir for " & $aLabTroops[$g_iCmbLaboratory][3] & ", Lab requires: " & $aUpgradeValue[$g_iCmbLaboratory] & " + " & $g_iUpgradeMinDark & " user reserve", $COLOR_INFO)
ClickP($aAway, 2, $iDelayLaboratory4, "#0357")
Return False
EndIf
If LabUpgrade() = True Then
Setlog("Dark Elixir used = " & $aUpgradeValue[$g_iCmbLaboratory], $COLOR_INFO)
ClickP($aAway, 2, $iDelayLaboratory4, "#0358")
Return True
EndIf
Case Else
Setlog("Something went wrong with loot value on Lab upgrade on #" & $aLabTroops[$g_iCmbLaboratory][3], $COLOR_ERROR)
Return False
EndSwitch
ClickP($aAway, 2, $iDelayLaboratory4, "#0359")
Return False
EndFunc
Func LabUpgrade()
Local $StartTime, $EndTime, $EndPeriod, $Result, $TimeAdd = 0
Select
Case _ColorCheck(_GetPixelColor($aLabTroops[$g_iCmbLaboratory][0] + 47, $aLabTroops[$g_iCmbLaboratory][1] + 6, True), Hex(0xE8E8E0, 6), 20) = True
SetLog($aLabTroops[$g_iCmbLaboratory][3] & " not unlocked yet, select another troop", $COLOR_ERROR)
If _Sleep($iDelayLabUpgrade2) Then Return
Case _ColorCheck(_GetPixelColor($aLabTroops[$g_iCmbLaboratory][0] + 68, $aLabTroops[$g_iCmbLaboratory][1] + 79, True), Hex(0xE70A12, 6), 20) And _ColorCheck(_GetPixelColor($aLabTroops[$g_iCmbLaboratory][0] + 68, $aLabTroops[$g_iCmbLaboratory][1] + 84, True), Hex(0xE70A12, 6), 20)
SetLog("Value check error and Not enough Loot to upgrade " & $aLabTroops[$g_iCmbLaboratory][3] & "...", $COLOR_ERROR)
If _Sleep($iDelayLabUpgrade2) Then Return
Case _ColorCheck(_GetPixelColor($aLabTroops[$g_iCmbLaboratory][0] + 23, $aLabTroops[$g_iCmbLaboratory][1] + 60, True), Hex(0xFFC360, 6), 20) = True
SetLog($aLabTroops[$g_iCmbLaboratory][3] & " already max level, select another troop", $COLOR_ERROR)
If _Sleep($iDelayLabUpgrade2) Then Return
Case _ColorCheck(_GetPixelColor($aLabTroops[$g_iCmbLaboratory][0] + 3, $aLabTroops[$g_iCmbLaboratory][1] + 19, True), Hex(0xB7B7B7, 6), 20) = True
SetLog("Laboratory upgrade not available now for " & $aLabTroops[$g_iCmbLaboratory][3] & "...", $COLOR_ERROR)
If _Sleep($iDelayLabUpgrade2) Then Return
Case Else
Click($aLabTroops[$g_iCmbLaboratory][0] + 40, $aLabTroops[$g_iCmbLaboratory][1] + 40, 1, 0, "#0200")
If _Sleep($iDelayLabUpgrade1) Then Return
If $g_iDebugImageSave = 1 Then DebugImageSave("LabUpgrade_")
If _ColorCheck(_GetPixelColor(258, 192, True), Hex(0xFF1919, 6), 20) And _ColorCheck(_GetPixelColor(272, 194, True), Hex(0xFF1919, 6), 20) Then
SetLog($aLabTroops[$g_iCmbLaboratory][3] & " Previously maxxed, select another troop", $COLOR_ERROR)
If _Sleep($iDelayLabUpgrade2) Then Return
ClickP($aAway, 2, $iDelayLabUpgrade3, "#0201")
Return False
EndIf
If _ColorCheck(_GetPixelColor(557, 487, True), Hex(0xE70A12, 6), 20) And _ColorCheck(_GetPixelColor(557, 494), Hex(0xE70A12, 6), 20) Then
SetLog("Missing Loot to upgrade " & $aLabTroops[$g_iCmbLaboratory][3] & " (secondary check after Upgrade Value read failed)", $COLOR_ERROR)
If _Sleep($iDelayLabUpgrade2) Then Return
ClickP($aAway, 2, $iDelayLabUpgrade3, "#0333")
Return False
EndIf
If _ColorCheck(_GetPixelColor(625, 250 + $g_iMidOffsetY, True), Hex(0x848484, 6), 20) And _ColorCheck(_GetPixelColor(660, 250 + $g_iMidOffsetY, True), Hex(0x848484, 6), 20) Then
SetLog("Upgrade in progress, waiting for completion of other troops", $COLOR_WARNING)
If _Sleep($iDelayLaboratory2) Then Return
ClickP($aAway, 2, $iDelayLaboratory4, "#0000")
Return False
Else
$Result = getLabUpgradeTime(482, 557)
Setlog($aLabTroops[$g_iCmbLaboratory][3] & " Upgrade OCR Time = " & $Result, $COLOR_INFO)
$StartTime = _NowCalc()
If $g_iDebugSetlog = 1 Then SetLog($aLabTroops[$g_iCmbLaboratory][3] & "Upgrade Started @ " & $StartTime, $COLOR_SUCCESS)
$EndTime = ""
$EndPeriod = ""
$TimeAdd = 0
$sLabUpgradeTime = StringStripWS($Result, $STR_STRIPALL)
Local $aArray = StringRegExp($sLabUpgradeTime, '\d+', $STR_REGEXPARRAYMATCH)
If IsArray($aArray) Then
If $g_iDebugSetlog = 1 Then
For $i = 0 To UBound($aArray) - 1
Setlog("UpgradeTime $aArray[" & $i & "] = " & $aArray[$i])
Next
EndIf
$EndTime = $aArray[0]
$EndPeriod = StringReplace($sLabUpgradeTime, $EndTime, "")
Switch $EndPeriod
Case "d"
$TimeAdd =(Int($EndTime) * 24 * 60) - 10
$sLabUpgradeTime = _DateAdd('n', $TimeAdd, $StartTime)
Case "h"
$TimeAdd =(Int($EndTime) * 60) - 3
$sLabUpgradeTime = _DateAdd('n', $TimeAdd, $StartTime)
Case "m"
$TimeAdd = Int($EndTime)
$sLabUpgradeTime = _DateAdd('n', $TimeAdd, $StartTime)
Case Else
Setlog("Upgrade time period invalid, try again!", $COLOR_WARNING)
EndSwitch
If $g_iDebugSetlog = 1 Then Setlog("$EndTime = " & $EndTime & " , $EndPeriod = " & $EndPeriod & ", $timeadd = " & $TimeAdd, $COLOR_DEBUG)
SetLog($aLabTroops[$g_iCmbLaboratory][3] & "Upgrade Finishes @ " & $sLabUpgradeTime, $COLOR_SUCCESS)
Else
Setlog("Error reading the upgrade time required, try again!", $COLOR_WARNING)
EndIf
If _DateIsValid($sLabUpgradeTime) = 0 Then
Setlog("Error processing upgrade time required, try again!", $COLOR_WARNING)
Return False
Else
Local $txtTip = GetTranslated(614, 8, "Visible Red button means that laboratory upgrade in process") & @CRLF & GetTranslated(614, 9, "This will automatically disappear when near time for upgrade to be completed.") & @CRLF & GetTranslated(614, 10, "If upgrade has been manually finished with gems before normal end time,") & @CRLF & GetTranslated(614, 11, "Click red button to reset internal upgrade timer BEFORE STARTING NEW UPGRADE") & @CRLF & GetTranslated(614, 12, "Caution - Unnecessary timer reset will force constant checks for lab status") & @CRLF & @CRLF & GetTranslated(614, 19, "Troop Upgrade started") & ": " & $StartTime & ", " & GetTranslated(614, 20, "Will begin to check completion at:") & " " & $sLabUpgradeTime & @CRLF & " "
_GUICtrlSetTip($g_hBtnResetLabUpgradeTime, $txtTip)
EndIf
Click(660, 520 + $g_iMidOffsetY, 1, 0, "#0202")
If _Sleep($iDelayLabUpgrade1) Then Return
EndIf
If isGemOpen(True) = False Then
If Not(_ColorCheck(_GetPixelColor(625, 250 + $g_iMidOffsetY, True), Hex(0x60AC10, 6), 20)) Or Not(_ColorCheck(_GetPixelColor(660, 250 + $g_iMidOffsetY, True), Hex(0x60AC10, 6), 20)) Then
SetLog("Something went wrong with " & $aLabTroops[$g_iCmbLaboratory][3] & " Upgrade, try again.", $COLOR_ERROR)
ClickP($aAway, 2, $iDelayLabUpgrade3, "#0360")
Return False
EndIf
SetLog("Upgrade " & $aLabTroops[$g_iCmbLaboratory][3] & " in your laboratory is complete...", $COLOR_SUCCESS)
PushMsg("LabSuccess")
If _Sleep($iDelayLabUpgrade2) Then Return
$g_bAutoLabUpgradeEnable = False
GUICtrlSetState($g_hChkAutoLabUpgrades, $GUI_UNCHECKED)
ClickP($aAway, 2, 0, "#0204")
Return True
Else
SetLog("Oops, Gems required for " & $aLabTroops[$g_iCmbLaboratory][3] & " Upgrade, try again.", $COLOR_ERROR)
EndIf
EndSelect
ClickP($aAway, 2, $iDelayLabUpgrade3, "#0205")
Return False
EndFunc
Func DebugRegionSave($sTxtName = "Unknown", $iLeft = 0, $iTop = 0, $iRight = $g_iDEFAULT_WIDTH, $iBottom = $g_iDEFAULT_HEIGHT)
SetLog("Taking debug snapshot for later review", $COLOR_SUCCESS)
Local $Date = @MDAY & "." & @MON & "." & @YEAR
Local $Time = @HOUR & "." & @MIN & "." & @SEC
If $iLeft <> 0 And $iTop <> 0 And $iRight <> $g_iDEFAULT_WIDTH And $iBottom <> $g_iDEFAULT_HEIGHT Then
Local $sName = $sTxtName & "_Left_" & $iLeft & "_Top_" & $iTop & "_Right_" & $iRight & "_Bottom_" & $iBottom & "_"
Else
$sName = $sTxtName
EndIf
_CaptureRegion($iLeft, $iTop, $iRight, $iBottom)
_GDIPlus_ImageSaveToFile($hBitmap, $g_sProfileTempDebugPath & $sName & $Date & " at " & $Time & ".png")
If _Sleep($iDelayLaboratory2) Then Return
EndFunc
Func LabTroopImages1()
If $g_iDebugImageSave = 1 Then DebugImageSave("LabUpgrade_")
For $i = 1 To 12
DebugRegionSave($aLabTroops[$i][3], $aLabTroops[$i][0], $aLabTroops[$i][1], $aLabTroops[$i][0] + 98, $aLabTroops[$i][1] + 98)
SetLog($aLabTroops[$i][3], $COLOR_WARNING)
SetLog("_GetPixelColor(+47, +6): " & _GetPixelColor($aLabTroops[$i][0] + 47, $aLabTroops[$i][1] + 6, True) & ":E0E4D0 =Not unlocked", $COLOR_DEBUG)
SetLog("_GetPixelColor(+68, +79): " & _GetPixelColor($aLabTroops[$i][0] + 68, $aLabTroops[$i][1] + 79, True) & ":E70A12 =No Loot1", $COLOR_DEBUG)
SetLog("_GetPixelColor(+68, +82): " & _GetPixelColor($aLabTroops[$i][0] + 68, $aLabTroops[$i][1] + 84, True) & ":E70A12 =No Loot2", $COLOR_DEBUG)
SetLog("_GetPixelColor(+81, +82): " & _GetPixelColor($aLabTroops[$i][0] + 81, $aLabTroops[$i][1] + 82, True) & ":XXXXXX =Loot type", $COLOR_DEBUG)
SetLog("_GetPixelColor(+78, +83): " & _GetPixelColor($aLabTroops[$i][0] + 78, $aLabTroops[$i][1] + 83, True) & ":FFFFFF =Max L", $COLOR_DEBUG)
SetLog("_GetPixelColor(+78, +78): " & _GetPixelColor($aLabTroops[$i][0] + 78, $aLabTroops[$i][1] + 78, True) & ":EFFFFF =Max L", $COLOR_DEBUG)
SetLog("_GetPixelColor(+3, +19): " & _GetPixelColor($aLabTroops[$i][0] + 3, $aLabTroops[$i][1] + 19, True) & ":C0C0C0 =Not possible", $COLOR_DEBUG)
SetLog("_GetPixelColor(+8, +59): " & _GetPixelColor($aLabTroops[$i][0] + 23, $aLabTroops[$i][1] + 60, True) & ":FFC360 =Max troop", $COLOR_DEBUG)
Next
EndFunc
Func LabTroopImages2()
If $g_iDebugImageSave = 1 Then DebugImageSave("LabUpgrade_")
For $i = 13 To 18
DebugRegionSave($aLabTroops[$i][3], $aLabTroops[$i][0], $aLabTroops[$i][1], $aLabTroops[$i][0] + 98, $aLabTroops[$i][1] + 98)
SetLog($aLabTroops[$i][3], $COLOR_WARNING)
SetLog("_GetPixelColor(+47, +6): " & _GetPixelColor($aLabTroops[$i][0] + 47, $aLabTroops[$i][1] + 6, True) & ":E0E4D0 =Not unlocked", $COLOR_DEBUG)
SetLog("_GetPixelColor(+68, +79): " & _GetPixelColor($aLabTroops[$i][0] + 68, $aLabTroops[$i][1] + 79, True) & ":E70A12 =No Loot1", $COLOR_DEBUG)
SetLog("_GetPixelColor(+68, +82): " & _GetPixelColor($aLabTroops[$i][0] + 68, $aLabTroops[$i][1] + 84, True) & ":E70A12 =No Loot2", $COLOR_DEBUG)
SetLog("_GetPixelColor(+81, +82): " & _GetPixelColor($aLabTroops[$i][0] + 81, $aLabTroops[$i][1] + 82, True) & ":XXXXXX =Loot type", $COLOR_DEBUG)
SetLog("_GetPixelColor(+78, +83): " & _GetPixelColor($aLabTroops[$i][0] + 78, $aLabTroops[$i][1] + 83, True) & ":FFFFFF =Max L", $COLOR_DEBUG)
SetLog("_GetPixelColor(+78, +78): " & _GetPixelColor($aLabTroops[$i][0] + 78, $aLabTroops[$i][1] + 78, True) & ":EFFFFF =Max L", $COLOR_DEBUG)
SetLog("_GetPixelColor(+3, +19): " & _GetPixelColor($aLabTroops[$i][0] + 3, $aLabTroops[$i][1] + 19, True) & ":C0C0C0 =Not possible", $COLOR_DEBUG)
SetLog("_GetPixelColor(+8, +59): " & _GetPixelColor($aLabTroops[$i][0] + 23, $aLabTroops[$i][1] + 60, True) & ":FFC360 =Max troop", $COLOR_DEBUG)
Next
EndFunc
Func LabTroopImages3()
If $g_iDebugImageSave = 1 Then DebugImageSave("LabUpgrade_")
For $i = 19 To 29
DebugRegionSave($aLabTroops[$i][3], $aLabTroops[$i][0], $aLabTroops[$i][1], $aLabTroops[$i][0] + 98, $aLabTroops[$i][1] + 98)
SetLog($aLabTroops[$i][3], $COLOR_WARNING)
SetLog("_GetPixelColor(+47, +6): " & _GetPixelColor($aLabTroops[$i][0] + 47, $aLabTroops[$i][1] + 6, True) & ":E0E4D0 =Not unlocked", $COLOR_DEBUG)
SetLog("_GetPixelColor(+68, +79): " & _GetPixelColor($aLabTroops[$i][0] + 68, $aLabTroops[$i][1] + 79, True) & ":E70A12 =No Loot1", $COLOR_DEBUG)
SetLog("_GetPixelColor(+68, +82): " & _GetPixelColor($aLabTroops[$i][0] + 68, $aLabTroops[$i][1] + 84, True) & ":E70A12 =No Loot2", $COLOR_DEBUG)
SetLog("_GetPixelColor(+81, +82): " & _GetPixelColor($aLabTroops[$i][0] + 81, $aLabTroops[$i][1] + 82, True) & ":XXXXXX =Loot type", $COLOR_DEBUG)
SetLog("_GetPixelColor(+78, +83): " & _GetPixelColor($aLabTroops[$i][0] + 78, $aLabTroops[$i][1] + 83, True) & ":FFFFFF =Max L", $COLOR_DEBUG)
SetLog("_GetPixelColor(+78, +78): " & _GetPixelColor($aLabTroops[$i][0] + 78, $aLabTroops[$i][1] + 78, True) & ":EFFFFF =Max L", $COLOR_DEBUG)
SetLog("_GetPixelColor(+3, +19): " & _GetPixelColor($aLabTroops[$i][0] + 3, $aLabTroops[$i][1] + 19, True) & ":C0C0C0 =Not possible", $COLOR_DEBUG)
SetLog("_GetPixelColor(+8, +59): " & _GetPixelColor($aLabTroops[$i][0] + 23, $aLabTroops[$i][1] + 60, True) & ":FFC360 =Max troop", $COLOR_DEBUG)
Next
EndFunc
Func ReplayShare($last = 1)
Local $dtLocal = _Date_Time_GetLocalTime()
Local $dLastShareDate = _DateAdd("n", -60, _Date_Time_SystemTimeToDateTimeStr($dtLocal, 1))
Local $txtMessage, $tNew
If $iShareAttack = 0 Then Return
If $last = 1 Then
ClickP($aAway, 1, 0, "#0235")
If _Sleep($iDelayReplayShare2) Then Return
SetLog("Share Replay: Opening Messages Page...", $COLOR_INFO)
If $g_iDebugSetlog = 1 Then Setlog("$last= " & $last, $COLOR_DEBUG)
ClickP($aMessageButton, 1, 0, "#0236")
If _Sleep($iDelayReplayShare3) Then Return
Click(380, 94 + $g_iMidOffsetY, 1, 0, "#0237")
If _Sleep($iDelayReplayShare3) Then Return
_CaptureRegion()
Local $FileListQueueName = _FileListToArray($g_sProfileTempPath, "Village*.png", 1)
If $g_iDebugSetlog = 1 Then Setlog("Top share button pixel color 70D4E8 or BBBBBB: " & _GetPixelColor(500, 156 + $g_iMidOffsetY), $COLOR_DEBUG)
If _ColorCheck(_GetPixelColor(500, 156 + $g_iMidOffsetY), Hex(0x70D4E8, 6), 10) = True And Not(IsArray($FileListQueueName)) Then
Setlog("Ok, sharing!")
Click(500, 156 + $g_iMidOffsetY, 1, 0, "#0238")
If _Sleep($iDelayReplayShare1) Then Return
Click(300, 120, 1, 0, "#0239")
If _Sleep($iDelayReplayShare1) Then Return
Local $smessage = $sShareMessage
$smessage = StringReplace($smessage, @LF, "")
$smessage = StringReplace($smessage, @CR, "|")
While StringInStr($smessage, "||")
$smessage = StringReplace($smessage, "||", "|")
WEnd
Local $smessagearray = StringSplit($smessage, "|")
If @error Then
$txtMessage = $smessagearray[1]
Else
$txtMessage = $smessagearray[Random(1, $smessagearray[0], 1)]
EndIf
$txtMessage = StringReplace($txtMessage, "<n>", StringFormat("%s", $SearchCount))
ControlSend($HWnD, "", "", $txtMessage, 0)
If _Sleep($iDelayReplayShare1) Then Return
Click(530, 210 + $g_iMidOffsetY, 1, 0, "#0240")
$tNew = _Date_Time_GetLocalTime()
$dLastShareDate = _Date_Time_SystemTimeToDateTimeStr($tNew, 1)
Else
If _ColorCheck(_GetPixelColor(500, 156 + $g_iMidOffsetY), Hex(0xbbbbbb, 6), 6) = True Or IsArray($FileListQueueName) Then
If IsArray($FileListQueueName) Then
SetLog("Others replay in queue, Share Later Last Replay")
Else
Setlog("Cannot Share Now... retry later.")
EndIf
_CaptureRegion(87, 149 + $g_iMidOffsetY, 87 + 100, 149 + 20 + $g_iMidOffsetY)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN
Local $iSaveFile = _GDIPlus_ImageSaveToFile($hBitmap, $g_sProfileTempPath & "Village_" & $Date & "_" & $Time & "^" & StringFormat("%s", $SearchCount) & ".png")
If Not($iSaveFile) Then SetLog("An error occurred putting screenshot in queue", $COLOR_ERROR)
Click(763, 86 + $g_iMidOffsetY, 1, 0, "#0241")
If _Sleep($iDelayReplayShare2) Then Return
Else
Setlog("Cannot Share Now... retry later.", $COLOR_ERROR)
EndIf
EndIf
$iShareAttackNow = 0
Else
$tNew = _Date_Time_GetLocalTime()
If _DateDiff("n", $dLastShareDate, _Date_Time_SystemTimeToDateTimeStr($tNew, 1)) > 30 Then
Local $FileListName = _FileListToArray($g_sProfileTempPath, "Village*.png", 1)
Local $x, $t, $tmin = 0
If Not((Not IsArray($FileListName)) Or(@error = 1)) Then
Local $FileListDate
For $x = 1 To $FileListName[0]
$t = FileGetTime($g_sProfileTempPath & $FileListName[$x], 1, 1)
If $tmin = 0 Then
$tmin = $t
$FileListDate = $x
Else
If $t < $tmin Then
$t = $tmin
$FileListDate = $x
EndIf
EndIf
Next
ClickP($aAway, 1, 0, "#0242")
If _Sleep($iDelayReplayShare2) Then Return
SetLog("Share Replay: Opening Messages Page...", $COLOR_INFO)
If $g_iDebugSetlog = 1 Then Setlog("$last= " & $last, $COLOR_DEBUG)
ClickP($aMessageButton, 1, 0, "#0243")
If _Sleep($iDelayReplayShare3) Then Return
Click(380, 94 + $g_iMidOffsetY, 1, 0, "#0244")
If _Sleep($iDelayReplayShare3) Then Return
_CaptureRegion()
If $g_iDebugSetlog = 1 Then Setlog("Top share button pixel color 70D4E8 or BBBBBB: " & _GetPixelColor(500, 156 + $g_iMidOffsetY), $COLOR_DEBUG)
If _ColorCheck(_GetPixelColor(500, 156 + $g_iMidOffsetY), Hex(0x70D4E8, 6), 10) = True Then
Setlog("Ok, sharing!")
Local $VilLoc, $VilX, $VilY, $VilTol
For $VilTol = 0 To 20
If $VilLoc = 0 Then
$VilLoc = _ImageSearch($g_sProfileTempPath & $FileListName[$FileListDate], 1, $VilX, $VilY, $VilTol)
If $VilLoc = 1 And $VilX > 35 And $VilY < 610 Then
Click(500, $VilY, 1, 0, "#0245")
If _Sleep($iDelayReplayShare1) Then Return
Click(300, 120, 1, 0, "#0246")
If _Sleep($iDelayReplayShare1) Then Return
Local $a = StringInStr($FileListName[$FileListDate], "^")
Local $b = StringInStr($FileListName[$FileListDate], ".png")
Local $stry = "0"
If $a > 0 And $b > 0 Then $stry = StringMid($FileListName[$FileListDate], $a + 1, $b - $a - 1)
$SearchCount = $stry
Local $smessage = $sShareMessage
$smessage = StringReplace($smessage, @LF, "")
$smessage = StringReplace($smessage, @CR, "|")
While StringInStr($smessage, "||")
$smessage = StringReplace($smessage, "||", "|")
WEnd
Local $smessagearray = StringSplit($smessage, "|")
If @error Then
$txtMessage = $smessagearray[1]
Else
$txtMessage = $smessagearray[Random(1, $smessagearray[0], 1)]
EndIf
$txtMessage = StringReplace($txtMessage, "<n>", StringFormat("%s", $SearchCount))
ControlSend($HWnD, "", "", $txtMessage, 0)
If _Sleep($iDelayReplayShare1) Then Return
Click(500, 210 + $g_iMidOffsetY, 1, 0, "#0247")
$tNew = _Date_Time_GetLocalTime()
$dLastShareDate = _Date_Time_SystemTimeToDateTimeStr($tNew, 1)
Local $iCopy = FileCopy($g_sProfileTempPath & $FileListName[$FileListDate], $g_sProfileTempPath & "shared_" & $FileListName[$FileListDate])
If Not($iCopy) Then Setlog("An error occurred copying a temporary file", $COLOR_ERROR)
Local $iDelete = FileDelete($g_sProfileTempPath & $FileListName[$FileListDate])
If Not($iDelete) Then Setlog("An error occurred deleting a temporary file", $COLOR_ERROR)
If _Sleep($iDelayReplayShare4) Then Return
Return True
EndIf
EndIf
Next
If $VilLoc = 0 Then
Local $iCopy = FileCopy($g_sProfileTempPath & $FileListName[$FileListDate], $g_sProfileTempPath & "discard_" & $FileListName[$FileListDate])
If Not($iCopy) Then Setlog("An error occurred copying a temporary file", $COLOR_ERROR)
Local $iDelete = FileDelete($g_sProfileTempPath & $FileListName[$FileListDate])
If Not($iDelete) Then Setlog("An error occurred deleting a temporary file", $COLOR_ERROR)
EndIf
Else
If _ColorCheck(_GetPixelColor(500, 156 + $g_iMidOffsetY), Hex(0xbbbbbb, 6), 6) = True Then
Setlog("Cannot Share Now... retry later.")
Click(763, 86 + $g_iMidOffsetY, 1, 0, "#0248")
$tNew = _Date_Time_GetLocalTime()
$dLastShareDate = _DateAdd("n", -20, _Date_Time_SystemTimeToDateTimeStr($tNew, 1))
If _Sleep($iDelayReplayShare2) Then Return
Else
Setlog("Button Share not found, abort.", $COLOR_ERROR)
Click(763, 86 + $g_iMidOffsetY, 1, 0, "#0249")
If _Sleep($iDelayReplayShare2) Then Return
EndIf
EndIf
Return True
EndIf
EndIf
EndIf
If _Sleep($iDelayReplayShare2) Then Return
checkMainScreen(False)
EndFunc
Func BoostKing()
If AllowBoosting("Barbarian King", $g_iCmbBoostBarbarianKing) = False Then Return
SetLog("Boost Barbarian King...", $COLOR_INFO)
If $KingAltarPos[0] = "" Or $KingAltarPos[0] = -1 Then
LocateKingAltar()
SaveConfig()
If _Sleep($iDelayBoostHeroes4) Then Return
EndIf
BoostStructure("Barbarian King", "King", $KingAltarPos, $g_iCmbBoostBarbarianKing, $g_hCmbBoostBarbarianKing)
If _Sleep($iDelayBoostBarracks5) Then Return
checkMainScreen(False)
EndFunc
Func BoostQueen()
If AllowBoosting("Archer Queen", $g_iCmbBoostArcherQueen) = False Then Return
SetLog("Boost Archer Queen...", $COLOR_INFO)
If $QueenAltarPos[0] = "" Or $QueenAltarPos[0] = -1 Then
LocateQueenAltar()
SaveConfig()
If _Sleep($iDelayBoostHeroes4) Then Return
EndIf
BoostStructure("Archer Queen", "Quee", $QueenAltarPos, $g_iCmbBoostArcherQueen, $g_hCmbBoostArcherQueen)
If _Sleep($iDelayBoostBarracks5) Then Return
checkMainScreen(False)
EndFunc
Func BoostWarden()
If AllowBoosting("Grand Warden", $g_iCmbBoostWarden) = False Then Return
SetLog("Boost Grand Warden...", $COLOR_INFO)
If $WardenAltarPos[0] = "" Or $WardenAltarPos[0] = -1 Then
LocateWardenAltar()
SaveConfig()
If _Sleep($iDelayBoostHeroes4) Then Return
EndIf
BoostStructure("Grand Warden", "Warden", $WardenAltarPos, $g_iCmbBoostWarden, $g_hCmbBoostWarden)
If _Sleep($iDelayBoostBarracks5) Then Return
checkMainScreen(False)
EndFunc
Func StarBonus()
If $g_iDebugSetlog = 1 Then Setlog("Begin Star Bonus window check", $COLOR_DEBUG1)
If _CheckPixel($aIsMainGrayed, $g_bCapturePixel) = False Then Return
If $g_iDebugSetlog = 1 Then Setlog("StarBonusWindowChk #1: " & _GetPixelColor(640, 185 + $g_iMidOffsetY, $g_bCapturePixel) & ", #2: " & _GetPixelColor(650, 462 + $g_iBottomOffsetY, $g_bCapturePixel), $COLOR_DEBUG)
If _Sleep($iDelayStarBonus100) Then Return
If _ColorCheck(_GetPixelColor(640, 185 + $g_iMidOffsetY, $g_bCapturePixel), Hex(0xC00F15, 6), 10) And  _ColorCheck(_GetPixelColor(650, 462 + $g_iBottomOffsetY, $g_bCapturePixel), Hex(0xE8E8E0, 6), 10) Then
Local $offColors[3][3] = [[0x000000, 143, 0], [0xFFFFFF, 53, 17], [0xFFFFFF, 53, 29]]
Global $ButtonPixel = _MultiPixelSearch(353, 440 + $g_iMidOffsetY, 502, 474 + $g_iMidOffsetY, 1, 1, Hex(0x000000, 6), $offColors, 20)
If $g_iDebugSetlog = 1 Then Setlog("Bonus Okay btn chk-#1: " & _GetPixelColor(355, 441 + $g_iMidOffsetY, $g_bCapturePixel) & ", #2: " & _GetPixelColor(355 + 143, 441 + $g_iMidOffsetY, $g_bCapturePixel) & ", #3: " & _GetPixelColor(355 + 53, 441 + 17 + $g_iMidOffsetY, $g_bCapturePixel) & ", #4: " & _GetPixelColor(355 + 53, 441 + 29 + $g_iMidOffsetY, $g_bCapturePixel), $COLOR_DEBUG)
If IsArray($ButtonPixel) Then
If $g_iDebugSetlog = 1 Then
Setlog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("Bonus Okay Pixel color found #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], $g_bCapturePixel) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 143, $ButtonPixel[1], $g_bCapturePixel) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 53, $ButtonPixel[1] + 17, $g_bCapturePixel) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 53, $ButtonPixel[1] + 29, $g_bCapturePixel), $COLOR_DEBUG)
EndIf
Click($ButtonPixel[0] + 75, $ButtonPixel[1] + 25, 1, 0, "#0000")
If _Sleep($iDelayStarBonus500) Then Return
Return True
EndIf
EndIf
If $g_iDebugSetlog = 1 Then Setlog("Star Bonus window not found?", $COLOR_DEBUG)
Return False
EndFunc
Func AddIdleTime()
If $g_bTrainAddRandomDelayEnable = False Then Return
Local $iTimeToWait
If $g_iTrainAddRandomDelayMin < $g_iTrainAddRandomDelayMax Then
$iTimeToWait = random($g_iTrainAddRandomDelayMin, $g_iTrainAddRandomDelayMax, 1)
Else
$iTimeToWait = random($g_iTrainAddRandomDelayMax, $g_iTrainAddRandomDelayMin, 1)
EndIf
Setlog("Waiting, Add random delay of " & $iTimeToWait & " seconds.",$COLOR_INFO)
If _SleepStatus($iTimeToWait * 1000) Then Return
_GUICtrlStatusBar_SetText($g_hStatusBar, "")
EndFunc
Func GetVillageSize($DebugLog = True)
Local $aResult = 0
Local $directory = @ScriptDir & "\imgxml\village\"
Local $stone[6] = [0, 0, 0, 0, 0, ""], $tree[6] = [0, 0, 0, 0, 0, ""]
Local $x0, $y0, $d0, $x, $y, $x1, $y1, $right, $bottom, $a
Local $iAdditional = 75
Local $aStoneFiles = _FileListToArray($directory, "stone*.*", $FLTA_FILES)
If @error Then
SetLog("Error: Missing stone files", $COLOR_ERROR)
Return $aResult
EndIf
Local $aTreeFiles = _FileListToArray($directory, "tree*.*", $FLTA_FILES)
If @error Then
SetLog("Error: Missing tree files", $COLOR_ERROR)
Return $aResult
EndIf
local $i, $findImage, $sArea, $a
For $i = 1 To $aStoneFiles[0]
$findImage = $aStoneFiles[$i]
$a = StringRegExp($findImage, ".*-(\d+)-(\d+)-(\d*,*\d+)_.*[.](xml|png|bmp)$", $STR_REGEXPARRAYMATCH)
If UBound($a) = 4 Then
$x0 = $a[0]
$y0 = $a[1]
$d0 = StringReplace($a[2], ",", ".")
$x1 = $x0 - $iAdditional
$y1 = $y0 - $iAdditional
$right = $x0 + $iAdditional
$bottom = $y0 + $iAdditional
$sArea = Int($x1) & "," & Int($y1) & "|" & Int($right) & "," & Int($y1) & "|" & Int($right) & "," & Int($bottom) & "|" & Int($x1) & "," & Int($bottom)
$a = decodeSingleCoord(findImage($findImage, $directory & "\" & $findImage, $sArea, 1, False))
If UBound($a) = 2 Then
$x = Int($a[0])
$y = Int($a[1])
$stone[0] = $x
$stone[1] = $y
$stone[2] = $x0
$stone[3] = $y0
$stone[4] = $d0
$stone[5] = $findImage
ExitLoop
EndIf
Else
EndIf
Next
If $stone[0] = 0 Then
SetDebugLog("GetVillageSize cannot find stone", $COLOR_WARNING)
Return $aResult
EndIf
For $i = 1 To $aTreeFiles[0]
$findImage = $aTreeFiles[$i]
$a = StringRegExp($findImage, ".*-(\d+)-(\d+)-(\d*,*\d+)_.*[.](xml|png|bmp)$", $STR_REGEXPARRAYMATCH)
If UBound($a) = 4 Then
$x0 = $a[0]
$y0 = $a[1]
$d0 = StringReplace($a[2], ",", ".")
$x1 = $x0 - $iAdditional
$y1 = $y0 - $iAdditional
$right = $x0 + $iAdditional
$bottom = $y0 + $iAdditional
$sArea = Int($x1) & "," & Int($y1) & "|" & Int($right) & "," & Int($y1) & "|" & Int($right) & "," & Int($bottom) & "|" & Int($x1) & "," & Int($bottom)
$a = decodeSingleCoord(findImage($findImage, $directory & "\" & $findImage, $sArea, 1, False))
If UBound($a) = 2 Then
$x = Int($a[0])
$y = Int($a[1])
$tree[0] = $x
$tree[1] = $y
$tree[2] = $x0
$tree[3] = $y0
$tree[4] = $d0
$tree[5] = $findImage
ExitLoop
EndIf
Else
EndIf
Next
If $tree[0] = 0 Then
SetDebugLog("GetVillageSize cannot find tree", $COLOR_WARNING)
Return $aResult
EndIf
Local $a = $tree[0] - $stone[0]
Local $b = $stone[1] - $tree[1]
Local $c = Sqrt($a * $a + $b * $b) - $stone[4] - $tree[4]
Local $z = $c / 473.60282919315
Local $stone_x_exp = $stone[2]
Local $stone_y_exp = $stone[3]
ConvertVillagePos($stone_x_exp, $stone_y_exp, $z)
$x = $stone[0] - $stone_x_exp
$y = $stone[1] - $stone_y_exp
If $DebugLog Then SetDebugLog("GetVillageSize measured: " & $c & ", Zoom factor: " & $z & ", Offset: " & $x & ", " & $y, $COLOR_INFO)
Dim $aResult[10]
$aResult[0] = $c
$aResult[1] = $z
$aResult[2] = $x
$aResult[3] = $y
$aResult[4] = $stone[0]
$aResult[5] = $stone[1]
$aResult[6] = $stone[5]
$aResult[7] = $tree[0]
$aResult[8] = $tree[1]
$aResult[9] = $tree[5]
Return $aResult
EndFunc
Func updateGlobalVillageOffset($x, $y)
Local $updated = False
If $IMGLOCREDLINE <> "" Then
Local $newReadLine = ""
Local $aPoints = StringSplit($IMGLOCREDLINE, "|", $STR_NOCOUNT)
For $sPoint In $aPoints
Local $aPoint = GetPixel($sPoint, ",")
$aPoint[0] += $x
$aPoint[1] += $y
If StringLen($newReadLine) > 0 Then $newReadLine &= "|"
$newReadLine &=($aPoint[0] & "," & $aPoint[1])
Next
$IMGLOCREDLINE = $newReadLine
$updated = True
EndIf
If $aTownHall[0] <> 0 And $aTownHall[1] <> 0 Then
$aTownHall[0] += $x
$aTownHall[1] += $y
$updated = True
EndIf
If $THx <> 0 And $THy <> 0 Then
$THx += $x
$THy += $y
$updated = True
EndIf
ConvertInternalExternArea()
Return $updated
EndFunc
Func ConvertOCRTime($WhereRead, $ToConvert)
Local $iRemainTimer = 0, $sResultMinutes = "", $aResult
If $ToConvert <> "" Then
If StringInStr($ToConvert, "h") > 1 Then
$aResult = StringSplit($ToConvert, "h", $STR_NOCOUNT)
$sResultMinutes = StringTrimRight($aResult[1], 1)
$iRemainTimer =(Number($aResult[0]) * 60) + Number($sResultMinutes)
ElseIf StringInStr($ToConvert, "m") > 1 Then
$iRemainTimer = Number(StringTrimRight($ToConvert, 1))
ElseIf StringInStr($ToConvert, "s") > 1 Then
$iRemainTimer = Number(StringTrimRight($ToConvert, 1)) / 60
Else
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then SetLog($WhereRead & ": Bad OCR string", $COLOR_ERROR)
EndIf
SetLog($WhereRead & " time: " & StringFormat("%.2f", $iRemainTimer) & " min", $COLOR_INFO)
Else
If Not $bFullArmySpells Then
If $g_iDebugSetlogTrain = 1 Or $g_iDebugSetlog = 1 Then SetLog("Can not read remaining time for " & $WhereRead, $COLOR_ERROR)
EndIf
EndIf
Return $iRemainTimer
EndFunc
Global $TempBot[4] = [1, 10, 20, 0]
Func ClickZone($x, $y, $Offset = 7, $debugtxt = "", $times = 1, $speed = 0, $OutScreen =(680 + $g_iBottomOffsetY), $scale = 3, $density = 1, $centerX = 0, $centerY = 0)
Local $BasY
If $y-$Offset > $OutScreen Then
$BasY = $y
Else
$BasY = $y-$Offset
EndIf
Dim $TempBot[4] = [$x-$Offset, $BasY, $x+$Offset, $y+$Offset]
If $g_iDebugClick = 1 Then
Local $txt = _DecodeDebug($debugtxt)
SetLog("ClickZone " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_ACTION, "Verdana", "7.5", 0)
EndIf
ClickR($TempBot,$x, $y, $times, $speed, $OutScreen, $scale, $density, $centerX, $centerY)
EndFunc
Func ClickR($boundingBox, $x, $y, $times = 1, $speed = 0, $OutScreen =(680 + $g_iBottomOffsetY), $scale = 3, $density = 1, $centerX = 0, $centerY = 0)
Local $AncVal = " ValIn: X=" & $x & " Y=" & $y
Local Const $PI = 3.141592653589793
Local $boxWidth = $boundingBox[2] - $boundingBox[0]
Local $boxHeight = $boundingBox[3] - $boundingBox[1]
Local $boxCenterX = $boundingBox[0] + $boxWidth/2 + $centerX
Local $boxCenterY = $boundingBox[1] + $boxHeight/2 + $centerY
Local $loopStartTime = TimerInit()
Do
Local $angle = Random() * 2 *$PI
Local $xR = Random()
If $xR = 0 Then $xR = 0.000001
Local $distance = $scale *(($xR ^(-1.0/$density)) - 1)
Local $offsetX = $distance * Sin($angle)
Local $offsetY = $distance * Cos($angle)
$x = $boxCenterX + $boxWidth * $offsetX/4
$y = $boxCenterY + $boxHeight * $offsetY/4
If TimerDiff($loopStartTime)>5000 Then
$x = $boxCenterX
$y = $boxCenterY
ExitLoop
EndIf
Until $x >= $boundingBox[0] And $x <= $boundingBox[2] And $y >= $boundingBox[1] And $y <= $boundingBox[3]
If $y > $OutScreen Then
$y = $OutScreen
Else
$y = $y
EndIf
$x = Round($x, 3)
$y = Round($y, 3)
If $times <> 1 Then
For $i = 0 To($times - 1)
If $g_iDebugClick = 1 Then SetLog("_ControlClick " & "X=" & $x & " Y=" & $y & " ,t" & $times & ",s" & $speed & $AncVal, $COLOR_ACTION, "Verdana", "7.5", 0)
Click($x, $y)
If _Sleep($speed, False) Then ExitLoop
Next
Else
If $g_iDebugClick = 1 Then SetLog("_ControlClick " & "X=" & $x & " Y=" & $y & $AncVal, $COLOR_ACTION, "Verdana", "7.5", 0)
Click($x, $y)
EndIf
EndFunc
Func PureClickR($boundingBox, $x, $y, $times = 1, $speed = 0, $OutScreen =(680 + $g_iBottomOffsetY), $scale = 3, $density = 1, $centerX = 0, $centerY = 0)
Local $AncVal = " ValIn: X=" & $x & " Y=" & $y
Local Const $PI = 3.141592653589793
Local $boxWidth = $boundingBox[2] - $boundingBox[0]
Local $boxHeight = $boundingBox[3] - $boundingBox[1]
Local $boxCenterX = $boundingBox[0] + $boxWidth/2 + $centerX
Local $boxCenterY = $boundingBox[1] + $boxHeight/2 + $centerY
Local $loopStartTime = TimerInit()
Do
Local $angle = Random() * 2 *$PI
Local $xR = Random()
If $xR = 0 Then $xR = 0.000001
Local $distance = $scale *(($xR ^(-1.0/$density)) - 1)
Local $offsetX = $distance * Sin($angle)
Local $offsetY = $distance * Cos($angle)
$x = $boxCenterX + $boxWidth * $offsetX/4
$y = $boxCenterY + $boxHeight * $offsetY/4
If TimerDiff($loopStartTime)>5000 Then
$x = $boxCenterX
$y = $boxCenterY
ExitLoop
EndIf
Until $x >= $boundingBox[0] And $x <= $boundingBox[2] And $y >= $boundingBox[1] And $y <= $boundingBox[3]
If $y > $OutScreen Then
$y = $OutScreen
Else
$y = $y
EndIf
$x = Round($x, 3)
$y = Round($y, 3)
If $times <> 1 Then
For $i = 0 To($times - 1)
If $g_iDebugClick = 1 Then SetLog("PureClick " & "X=" & $x & " Y=" & $y & " ,t" & $times & ",s" & $speed & $AncVal, $COLOR_ACTION, "Verdana", "7.5", 0)
PureClick($x, $y)
If _Sleep($speed, False) Then ExitLoop
Next
Else
If $g_iDebugClick = 1 Then SetLog("PureClick " & "X=" & $x & " Y=" & $y & $AncVal, $COLOR_ACTION, "Verdana", "7.5", 0)
PureClick($x, $y)
EndIf
EndFunc
Func GemClickR($boundingBox,$x, $y, $times = 1, $speed = 0, $debugtxt = "", $OutScreen =(680 + $g_iBottomOffsetY), $scale = 3, $density = 1, $centerX = 0, $centerY = 0)
Local Const $PI = 3.141592653589793
Local $boxWidth = $boundingBox[2] - $boundingBox[0]
Local $boxHeight = $boundingBox[3] - $boundingBox[1]
Local $boxCenterX = $boundingBox[0] + $boxWidth/2 + $centerX
Local $boxCenterY = $boundingBox[1] + $boxHeight/2 + $centerY
Local $loopStartTime = TimerInit()
Do
Local $angle = Random() * 2 *$PI
Local $xR = Random()
If $xR = 0 Then $xR = 0.000001
Local $distance = $scale *(($xR ^(-1.0/$density)) - 1)
Local $offsetX = $distance * Sin($angle)
Local $offsetY = $distance * Cos($angle)
$x = $boxCenterX + $boxWidth * $offsetX/4
$y = $boxCenterY + $boxHeight * $offsetY/4
If TimerDiff($loopStartTime)>5000 Then
$x = $boxCenterX
$y = $boxCenterY
ExitLoop
EndIf
Until $x >= $boundingBox[0] And $x <= $boundingBox[2] And $y >= $boundingBox[1] And $y <= $boundingBox[3]
If $y > $OutScreen Then
$y = $OutScreen
Else
$y = $y
EndIf
$x = Round($x, 3)
$y = Round($y, 3)
If $g_iDebugClick = 1 Then
Local $txt = _DecodeDebug($debugtxt)
SetLog("GemClickR " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_ACTION, "Verdana", "7.5", 0)
EndIf
If $g_bAndroidAdbClick = True Then
If isGemOpen(True) Then
Return False
EndIf
AndroidClick($x, $y, $times, $speed)
EndIf
If $g_bAndroidAdbClick = True Then
Return
EndIf
Local $SuspendMode = ResumeAndroid()
Local $i
If $times <> 1 Then
For $i = 0 To($times - 1)
If isGemOpen(True) Then
SuspendAndroid($SuspendMode)
Return False
EndIf
If isProblemAffectBeforeClick($i) Then
If $g_iDebugClick = 1 Then Setlog("VOIDED GemClickR " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_ERROR, "Verdana", "7.5", 0)
checkMainScreen(False)
SuspendAndroid($SuspendMode)
Return
EndIf
MoveMouseOutBS()
_ControlClick($x, $y)
If isGemOpen(True) Then
SuspendAndroid($SuspendMode)
Return False
EndIf
If _Sleep($speed, False) Then ExitLoop
Next
Else
If isGemOpen(True) Then
SuspendAndroid($SuspendMode)
Return False
EndIf
If isProblemAffectBeforeClick() Then
If $g_iDebugClick = 1 Then Setlog("VOIDED GemClickR " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_ERROR, "Verdana", "7.5", 0)
checkMainScreen(False)
SuspendAndroid($SuspendMode)
Return
EndIf
MoveMouseOutBS()
_ControlClick($x, $y)
If isGemOpen(True) Then
SuspendAndroid($SuspendMode)
Return False
EndIf
EndIf
SuspendAndroid($SuspendMode)
EndFunc
Func CheckNeedOpenTrain($TimeBeforeTrain)
Local $bToReturn = False
Local $QuickArmyCamps = 100
If $g_abSearchCampsEnable[$DB] Then
If $g_aiSearchCampsPct[$DB] < $QuickArmyCamps Then $QuickArmyCamps = $g_aiSearchCampsPct[$DB]
If $g_aiSearchCampsPct[$DB] - Int($CurCamp / $TotalCamp * 100) < $QuickArmyCamps Then $QuickArmyCamps = $g_aiSearchCampsPct[$DB] - Int($CurCamp / $TotalCamp * 100)
EndIf
If $g_abSearchCampsEnable[$LB] Then
If $g_aiSearchCampsPct[$LB] < $QuickArmyCamps Then $QuickArmyCamps = $g_aiSearchCampsPct[$LB]
If $g_aiSearchCampsPct[$LB] - Int($CurCamp / $TotalCamp * 100) < $QuickArmyCamps Then $QuickArmyCamps = $g_aiSearchCampsPct[$LB] - Int($CurCamp / $TotalCamp * 100)
EndIf
If $g_abSearchCampsEnable[$TS] Then
If $g_aiSearchCampsPct[$TS] < $QuickArmyCamps Then $QuickArmyCamps = $g_aiSearchCampsPct[$TS]
If $g_aiSearchCampsPct[$TS] - Int($CurCamp / $TotalCamp * 100) < $QuickArmyCamps Then $QuickArmyCamps = $g_aiSearchCampsPct[$TS] - Int($CurCamp / $TotalCamp * 100)
EndIf
If $aTimeTrain[0] = 0 Or $TimeBeforeTrain >=($aTimeTrain[0] * 60) *($QuickArmyCamps / 100) Then $bToReturn = True
If $g_iDebugSetlogTrain = 1 Then SetLog("Time to train: " &($aTimeTrain[0] * 60) *($QuickArmyCamps / 100) & " Waiting time: " & $TimeBeforeTrain, $COLOR_DEBUG)
Local $iTimeDiffOpen =(($aTimeTrain[0] * 60) *($QuickArmyCamps / 100)) - $TimeBeforeTrain
If($bActiveDonate Or $bDonationEnabled) And $g_bChkDonate Then $bToReturn = True
If $iTimeDiffOpen > 0 And $bToReturn = False Then
SetLog("Next open Army Window: " & StringFormat("%02i", Floor(Floor($iTimeDiffOpen / 60) / 60)) & ":" & StringFormat("%02i", Floor(Mod(Floor($iTimeDiffOpen / 60), 60))) & ":" & StringFormat("%02i", Floor(Mod($iTimeDiffOpen, 60))))
EndIf
If $bToReturn = False Then ClickP($aAway, 1, 0, "#0332")
Return $bToReturn
EndFunc
Global $sWatchdogMutex = "MyBot.run/ManageFarm"
Global $tagSTRUCT_BOT_STATE = "struct;hwnd frmBot;hwnd HWnD;boolean RunState;boolean TPaused;endstruct"
Global $tBotState = DllStructCreate($tagSTRUCT_BOT_STATE)
Global $WM_MYBOTRUN_API_1_0 = _WinAPI_RegisterWindowMessage("MyBot.run/API/1.0")
Global $WM_MYBOTRUN_STATE_1_0 = _WinAPI_RegisterWindowMessage("MyBot.run/STATE/1.0")
Global $aManagedMyBotHosts[0]
GUIRegisterMsg($WM_MYBOTRUN_API_1_0, "WM_MYBOTRUN_API_1_0_CLIENT")
Func WM_MYBOTRUN_API_1_0_CLIENT($hWind, $iMsg, $wParam, $lParam)
If $hWind <> $g_hFrmBot Then Return 0
$hWind = 0
Switch BitAND($wParam, 0xFFFF)
Case 0x0000
$hWind = HWnd($lParam)
$lParam = $g_hFrmBot
$wParam += 1
Local $wParamHi = 0
If $g_bRunState = True Then $wParamHi += 1
If $g_bBotPaused = True Then $wParamHi += 2
$wParam += BitShift($wParamHi, -16)
Case 0x0010
$iMsg = $WM_MYBOTRUN_STATE_1_0
$hWind = HWnd($lParam)
$lParam = $g_hFrmBot
$wParam = DllStructGetPtr($tBotState)
DllStructSetData($tBotState, "frmBot", $g_hFrmBot)
DllStructSetData($tBotState, "HWnD", $HWnD)
DllStructSetData($tBotState, "RunState", $g_bRunState)
DllStructSetData($tBotState, "TPaused", $g_bBotPaused)
Case 0x1000
$hWind = HWnd($lParam)
$lParam = $g_hFrmBot
$wParam += 1
Local $wParamHi = 0
If $g_bRunState = False Then
$wParamHi = 1
$wParam += BitShift($wParamHi, -16)
_WinAPI_PostMessage($hWind, $iMsg, $wParam, $lParam)
btnStart()
Return
EndIf
$wParam += BitShift($wParamHi, -16)
Case 0x1010
$hWind = HWnd($lParam)
$lParam = $g_hFrmBot
$wParam += 1
Local $wParamHi = 0
If $g_bRunState = True Then
$wParamHi = 1
btnStop()
EndIf
$wParam += BitShift($wParamHi, -16)
Case 0x1020
$hWind = HWnd($lParam)
$lParam = $g_hFrmBot
$wParam += 1
Local $wParamHi = 0
If $g_bBotPaused = True And $g_bRunState = True Then
TogglePauseImpl("ManageFarm")
$wParamHi = 1
EndIf
$wParam += BitShift($wParamHi, -16)
Case 0x1030
$hWind = HWnd($lParam)
$lParam = $g_hFrmBot
$wParam += 1
Local $wParamHi = 0
If $g_bBotPaused = False And $g_bRunState = True Then
TogglePauseImpl("ManageFarm")
$wParamHi = 1
EndIf
$wParam += BitShift($wParamHi, -16)
Case 0x1040
$hWind = HWnd($lParam)
$lParam = $g_hFrmBot
$wParam += 1
Local $wParamHi = 0
BotCloseRequest()
$wParam += BitShift($wParamHi, -16)
EndSwitch
If $hWind <> 0 Then
Local $a = GetManagedMyBotHost($hWind)
$a[1] = TimerInit()
_WinAPI_PostMessage($hWind, $iMsg, $wParam, $lParam)
EndIf
Return 1
EndFunc
Func GetManagedMyBotHost($hFrmHost = Default)
If $hFrmHost = Default Then
Return $aManagedMyBotHosts
EndIf
If IsHWnd($hFrmHost) = 0 Then Return -1
For $i = 0 To UBound($aManagedMyBotHosts) - 1
Local $a = $aManagedMyBotHosts[$i]
If $a[0] = $hFrmHost Then Return $a
Next
ReDim $aManagedMyBotHosts[UBound($aManagedMyBotHosts) + 1]
Local $a[2]
$a[0] = $hFrmHost
$aManagedMyBotHosts[$i] = $a
SetDebugLog("New Bot Host Window Handle registered: " & $hFrmHost)
Return $a
EndFunc
Func LaunchWatchdog()
Local $hMutex = _Singleton($sWatchdogMutex, 1)
If $hMutex = 0 Then
SetDebugLog("Watchdog already running")
Return 0
EndIf
_WinAPI_CloseHandle($hMutex)
Local $cmd = """" & @ScriptDir & "\MyBot.run.Watchdog.exe"""
If @Compiled = 0 Then $cmd = """" & @AutoItExe & """ /AutoIt3ExecuteScript """ & @ScriptDir & "\MyBot.run.Watchdog.au3" & """"
Local $pid = Run($cmd, @ScriptDir, @SW_HIDE)
If $pid = 0 Then
SetLog("Cannot launch watchdog", $COLOR_RED)
Return 0
EndIf
If $g_iDebugSetlog Then
SetDebugLog("Watchdog launched, PID = " & $pid)
Else
SetLog("Watchdog launched")
EndIf
Return $pid
EndFunc
Func UnregisterManagedMyBotHost()
For $i = 0 To UBound($aManagedMyBotHosts) - 1
Local $a = $aManagedMyBotHosts[$i]
Local $hFrmHost = $a[0]
$a[0] = 0
$aManagedMyBotHosts[$i] = $a
If IsHWnd($hFrmHost) Then
Local $hWind = $hFrmHost
Local $iMsg = $WM_MYBOTRUN_API_1_0
Local $wParam = 0x1040 + 2
Local $lParam = $g_hFrmBot
_WinAPI_PostMessage($hWind, $iMsg, $wParam, $lParam)
SetDebugLog("Bot Host Window Handle un-registered: " & $hFrmHost)
EndIf
Next
EndFunc
Func CheckVersion()
If $ichkVersion = 1 Then
CheckVersionHTML()
If $g_sLastModversion = "" Then
SetLog("WE CANNOT OBTAIN MOD VERSION AT THIS TIME", $COLOR_ORANGE)
CheckModVersion()
ElseIf VersionNumFromVersionTXT($g_sModversion) < VersionNumFromVersionTXT($g_sLastModversion) Then
SetLog("WARNING, YOUR MOD VERSION (" & $g_sModversion & ") IS OUT OF DATE.", $COLOR_RED)
SetLog("CHIEF, PLEASE DOWNLOAD THE LATEST (" & $g_sLastModversion & ")", $COLOR_RED)
SetLog("FROM https://MyBot.run               ", $COLOR_RED)
SetLog(" ")
_PrintLogVersion($g_sOldModversmessage)
CheckModVersion()
ElseIf VersionNumFromVersionTXT($g_sModversion) > VersionNumFromVersionTXT($g_sLastModversion) Then
SetLog("YOU ARE USING A FUTURE MOD BY DOC.OC VERSION CHIEF!", $COLOR_GREEN)
SetLog("YOUR MOD VERSION: " & $g_sModversion, $COLOR_GREEN)
SetLog("OFFICIAL MOD VERSION: " & $g_sLastModversion, $COLOR_GREEN)
SetLog(" ")
Else
SetLog("WELCOME CHIEF, YOU HAVE THE LATEST MOD VERSION", $COLOR_GREEN)
SetLog(" ")
SetLog("BY DOC.OC TEAM", $COLOR_BLUE)
SetLog("CHEEERS..")
SetLog(" ")
_PrintLogVersion($lastmessage)
EndIf
EndIf
EndFunc
Func CheckVersionHTML()
Local $versionfile = @ScriptDir & "\LastVersion.txt"
If FileExists(@ScriptDir & "\TestVersion.txt") Then
FileCopy(@ScriptDir & "\TestVersion.txt", $versionfile, 1)
Else
Local $hDownload = InetGet("https://raw.githubusercontent.com/TheRevenor/MyBotRun_DocOC_Server/master/Version/LastVersions.txt", $versionfile, 0, 1)
Local $i = 0
Do
Sleep($iDelayCheckVersionHTML1)
$i += 1
Until InetGetInfo($hDownload, $INET_DOWNLOADCOMPLETE) Or $i > 25
InetClose($hDownload)
EndIf
Local $f, $f2, $line, $line2, $Casesense = 0, $chkvers = False, $chkmsg = False, $chkmsg2 = False, $i = 0
$g_sLastModversion = ""
If FileExists($versionfile) Then
$f = FileOpen($versionfile, 0)
$g_sLastModversion = IniRead($versionfile, "mod", "version", "")
Local $versionfilelocalized = @ScriptDir & "\LastVersion_" & $sLanguage & ".txt"
If FileExists(@ScriptDir & "\TestVersion_" & $sLanguage & ".txt") Then
FileCopy(@ScriptDir & "\TestVersion_" & $sLanguage & ".txt", $versionfilelocalized, 1)
Else
$hDownload = InetGet("https://raw.githubusercontent.com/TheRevenor/MyBotRun_DocOC_Server/master/Version/LastVersions_" & $sLanguage & ".txt", $versionfilelocalized, 0, 1)
Local $i = 0
Do
Sleep($iDelayCheckVersionHTML1)
$i += 1
Until InetGetInfo($hDownload, $INET_DOWNLOADCOMPLETE) Or $i > 25
InetClose($hDownload)
EndIf
If FileExists($versionfilelocalized) Then
$f2 = FileOpen($versionfilelocalized, 0)
$g_sLastModmessage = IniRead($versionfilelocalized, "mod", "messagenew", "")
$g_sOldModversmessage = IniRead($versionfilelocalized, "mod", "messageold", "")
FileClose($f2)
FileDelete($versionfilelocalized)
Else
$g_sLastModmessage = IniRead($versionfilelocalized, "mod", "messagenew", "")
$g_sOldModversmessage = IniRead($versionfilelocalized, "mod", "messageold", "")
EndIf
FileClose($f)
FileDelete($versionfile)
EndIf
EndFunc
Func VersionNumFromVersionTXT($versionTXT)
Local $versionTXT_clean
If StringInStr($versionTXT, " ") Then
$versionTXT_clean = StringLeft($versionTXT, StringInStr($versionTXT, " ") - 1)
Else
$versionTXT_clean = $versionTXT
EndIf
Local $resultnumber = 0
If StringLeft($versionTXT_clean, 1) = "v" Then
Local $versionTXT_Vector = StringSplit(StringMid($versionTXT_clean, 2, -1), ".")
Local $multiplier = 1000000
If UBound($versionTXT_Vector) > 0 Then
For $i = 1 To UBound($versionTXT_Vector) - 1
$resultnumber = $resultnumber + Number($versionTXT_Vector[$i]) * $multiplier
$multiplier = $multiplier / 1000
Next
Else
$resultnumber = Number($versionTXT_Vector) * $multiplier
EndIf
EndIf
Return $resultnumber
EndFunc
Func _PrintLogVersion($message)
Local $messagevet = StringSplit($message, "\n", 1)
If Not(IsArray($messagevet)) Then
Setlog($message)
Else
For $i = 1 To $messagevet[0]
If StringLen($messagevet[$i]) <= 53 Then
SetLog($messagevet[$i], $COLOR_BLACK, "Lucida Console", 8.5)
Else
While StringLen($messagevet[$i]) > 53
Local $sp = StringInStr(StringLeft($messagevet[$i], 53), " ", 0, -1)
If $sp = 0 Then
Local $sp = StringInStr($messagevet[$i], " ", 0)
If $sp = 0 Then
SetLog($messagevet[$i], $COLOR_BLACK, "Lucida Console", 8.5)
Else
SetLog(StringLeft($messagevet[$i], $sp), $COLOR_BLACK, "Lucida Console", 8.5)
$messagevet[$i] = StringMid($messagevet[$i], $sp + 1, -1)
EndIf
Else
SetLog(StringLeft($messagevet[$i], $sp), $COLOR_BLACK, "Lucida Console", 8.5)
$messagevet[$i] = StringMid($messagevet[$i], $sp + 1, -1)
EndIf
WEnd
If StringLen($messagevet[$i]) > 0 Then SetLog($messagevet[$i], $COLOR_BLACK, "Lucida Console", 8.5)
EndIf
Next
EndIf
EndFunc
Func GetVersionNormalized($VersionString, $Chars = 5)
If StringLeft($VersionString, 1) = "v" Then $VersionString = StringMid($VersionString, 2)
Local $a = StringSplit($VersionString, ".", 2)
Local $i
For $i = 0 To UBound($a) - 1
If StringLen($a[$i]) < $Chars Then $a[$i] = _StringRepeat("0", $Chars - StringLen($a[$i])) & $a[$i]
Next
Return _ArrayToString($a, ".")
EndFunc
Func CheckModVersion()
If $g_sLastModversion = "" Then
MsgBox($MB_ICONWARNING, "", "WE CANNOT OBTAIN MOD VERSION AT THIS TIME" & @CRLF & "BAD CONNECTION", 10)
ElseIf VersionNumFromVersionTXT($g_sModversion) < VersionNumFromVersionTXT($g_sLastModversion) Then
PushMsg("Update")
If MsgBox(BitOR($MB_ICONWARNING, $MB_YESNO), "BOT Update Detected", "Chief, there is a new version of the bot available (" & $g_sLastModversion & ")" & @CRLF & @CRLF & "Do you want to download the latest version ?", 30) = $IDYES Then
ShellExecute($g_sModSupportUrl)
Return False
EndIf
Else
MsgBox($MB_ICONINFORMATION, "Notify", "You Are Using The Latest Version Of Mod By DocOc Team" & @CRLF & "Thanks..", 15)
EndIf
EndFunc
Func ArrayRemoveDuplicates(ByRef $Arr)
Local $iStart = 0
Local $IndexesToDelete = ""
For $i = $iStart To(UBound($Arr) - 1)
For $j = $i + 1 To(UBound($Arr) - 1)
If $Arr[$j] = $Arr[$i] Then
$IndexesToDelete &= $j & ","
ExitLoop
EndIf
Next
Next
If StringRight($IndexesToDelete, 1) = "," Then $IndexesToDelete = StringLeft($IndexesToDelete,(StringLen($IndexesToDelete) - 1))
Local $splitedToDelete = StringSplit($IndexesToDelete, ",", 2)
Local $tmpArr[UBound($Arr)]
Local $searchResult = -1
For $i = 0 To(UBound($Arr) - 1)
$searchResult = _ArraySearch($splitedToDelete, $i)
If $searchResult > -1 And StringLen($splitedToDelete[$searchResult]) > 0 Then ContinueLoop
$tmpArr[$i] = $Arr[$i]
Next
_ArryRemoveBlanks($tmpArr)
$Arr = $tmpArr
EndFunc
Func _ArryRemoveBlanks(ByRef $Array)
Switch(UBound($Array, 2) > 0)
Case True
Local $canKeep = True
Local $2DBound = UBound($Array, 2)
Local $Counter = 0
For $i = 0 To(UBound($Array) - 1)
For $j = 0 To(UBound($Array, 2) - 1)
If $Array[$i][$j] = "" Then
$canKeep = False
Else
$canKeep = True
ExitLoop
EndIf
Next
If $canKeep = True Then
For $j = 0 To(UBound($Array, 2) - 1)
$Array[$Counter][$j] = $Array[$i][$j]
Next
$Counter += 1
EndIf
Next
ReDim $Array[$Counter][$2DBound]
Case Else
Local $Counter = 0
For $i = 0 To(UBound($Array) - 1)
If $Array[$i] <> "" Then
$Array[$Counter] = $Array[$i]
$Counter += 1
EndIf
Next
ReDim $Array[$Counter]
EndSwitch
EndFunc
Func _StringEqualSplit($sString, $iNumChars = Default)
If $iNumChars = Default Then $iNumChars = StringLen($sString)
If Not IsString($sString) Or $sString = "" Then Return SetError(1, 0, 0)
If Not IsInt($iNumChars) Or $iNumChars < 1 Then Return SetError(2, 0, 0)
Return StringRegExp($sString, "(?s).{1," & $iNumChars & "}", 3)
EndFunc
Func _ArrayMerge(ByRef $a_base, ByRef $a_add, $i_start = 0)
Local $X
For $X = $i_start To UBound($a_add) - 1
_ArrayAdd($a_base, $a_add[$X])
Next
EndFunc
Func _ArrayClear(ByRef $aArray)
Local $iCols = UBound($aArray, 2)
Local $iDim = UBound($aArray, 0)
Local $iRows = UBound($aArray, 1)
If $iDim = 1 Then
Local $aArray1D[$iRows]
$aArray = $aArray1D
Else
Local $aArray2D[$iRows][$iCols]
$aArray = $aArray2D
EndIf
EndFunc
Func getCurrentXP($x_start, $y_start)
Local $bUseOcrImgLoc = True
Return getOcrAndCapture("CurXpOCR-bundle", $x_start, $y_start, 95, 15, True, $bUseOcrImgLoc)
EndFunc
Func multiMatchesPixelOnly($directory, $maxReturnPoints = 0, $fullCocAreas = $ECD, $redLines = "", $statFile = "", $minLevel = 0, $maxLevel = 1000, $x1 = 0, $y1 = 0, $x2 = $g_iGAME_WIDTH, $y2 = $g_iGAME_HEIGHT, $bCaptureNew = True, $xDiff = Default, $yDiff = Default, $forceReturnString = False, $saveSourceImg = False)
Local $Result = ""
Local $res
If $bCaptureNew Then
_CaptureRegion2($x1, $y1, $x2, $y2)
$res = DllCall($g_sLibImgLocPath, "str", "SearchMultipleTilesBetweenLevels", "handle", $hHBitmap2, "str", $directory, "str", $fullCocAreas, "Int", $maxReturnPoints, "str", $redLines, "Int", $minLevel, "Int", $maxLevel)
If @error Then _logErrorDLLCall($g_sLibImgLocPath, @error)
If $saveSourceImg = True Then _GDIPlus_ImageSaveToFile(_GDIPlus_BitmapCreateFromHBITMAP($hHBitmap2), @ScriptDir & "\multiMatchesPixelOnly.png")
Local $aValue = DllCall($g_sLibImgLocPath, "str", "GetProperty", "str", "redline", "str", "")
$redLines = $aValue[0]
Else
Local $hClone = CloneAreaToSearch($x1, $y1, $x2, $y2)
$res = DllCall($g_sLibImgLocPath, "str", "SearchMultipleTilesBetweenLevels", "handle", $hClone, "str", $directory, "str", $fullCocAreas, "Int", $maxReturnPoints, "str", $redLines, "Int", $minLevel, "Int", $maxLevel)
If @error Then _logErrorDLLCall($g_sLibImgLocPath, @error)
If $saveSourceImg = True Then _GDIPlus_ImageSaveToFile(_GDIPlus_BitmapCreateFromHBITMAP($hClone), @ScriptDir & "\multiMatchesPixelOnly.png")
Local $aValue = DllCall($g_sLibImgLocPath, "str", "GetProperty", "str", "redline", "str", "")
$redLines = $aValue[0]
_WinAPI_DeleteObject($hClone)
EndIf
If $res[0] <> "" Then
Local $aKeys = StringSplit($res[0], "|", $STR_NOCOUNT)
For $i = 0 To UBound($aKeys) - 1
$Result &= returnPropertyValue($aKeys[$i], "objectpoints") & "|"
Next
EndIf
If StringLen($Result) > 0 Then
If StringRight($Result, 1) = "|" Then $Result = StringLeft($Result,(StringLen($Result) - 1))
If($xDiff <> Default) Or($yDiff <> Default) Then
If $xDiff = Default Then $xDiff = 0
If $yDiff = Default Then $yDiff = 0
DelPosWithDiff($Result, $xDiff, $yDiff, True)
Return $Result
EndIf
EndIf
Return $Result
EndFunc
Func CloneAreaToSearch($x, $y, $x1, $y1)
Local $hClone, $hImage, $iX, $iY, $hBMP
$iX = $x1 - $x
$iY = $y1 - $y
If StringInStr($iX, "-") > 0 Or StringInStr($iY, "-") > 0 Or $iX = 0 Or $iY = 0 Then Return $hHBitmap2
$hImage = _GDIPlus_BitmapCreateFromHBITMAP($hHBitmap2)
$hClone = _GDIPlus_BitmapCloneArea($hImage, $x, $y, $iX, $iY)
$hBMP = _GDIPlus_BitmapCreateHBITMAPFromBitmap($hClone)
_GDIPlus_BitmapDispose($hImage)
_GDIPlus_BitmapDispose($hClone)
_WinAPI_DeleteObject($hHBitmap2)
Return $hBMP
EndFunc
Func DelPosWithDiff(ByRef $Input, $xDiff, $yDiff, $ReturnAsString = True, $And = True)
If IsArray($Input) Then
_DelPosWithDiff1($Input, $xDiff, $yDiff, $ReturnAsString, $And)
Else
_DelPosWithDiff2($Input, $xDiff, $yDiff, $ReturnAsString, $And)
EndIf
EndFunc
Func _DelPosWithDiff1(ByRef $Arr, $xDiff, $yDiff, $ReturnAsString = True, $And = True)
Local $iStart = 0
Local $iXDiff = 0, $iYDiff = 0
Local $IndexesToDelete = ""
For $i = $iStart To(UBound($Arr) - 1)
For $j = $i + 1 To(UBound($Arr) - 1)
$iXDiff = Number(Abs(Number(Number($Arr[$i][0]) - Number($Arr[$j][0]))))
$iYDiff = Number(Abs(Number(Number($Arr[$i][1]) - Number($Arr[$j][1]))))
If $And = True Then
If($iXDiff <= $xDiff) And($iYDiff <= $yDiff) Then
$IndexesToDelete &= $j & ","
$i += 1
ExitLoop
EndIf
Else
If($iXDiff <= $xDiff) Or($iYDiff <= $yDiff) Then
$IndexesToDelete &= $j & ","
$i += 1
ExitLoop
EndIf
EndIf
$iXDiff = 0
$iYDiff = 0
Next
Next
If StringRight($IndexesToDelete, 1) = "," Then $IndexesToDelete = StringLeft($IndexesToDelete,(StringLen($IndexesToDelete) - 1))
If StringLen($IndexesToDelete) > 0 Then
Local $tmpArr[UBound($Arr)][2]
Local $splitedToDelete
If StringInStr($IndexesToDelete, ",") > 0 Then
$splitedToDelete = StringSplit($IndexesToDelete, ",", 2)
Else
$splitedToDelete = _StringEqualSplit($IndexesToDelete, StringLen($IndexesToDelete))
EndIf
Local $searchResult = -1
For $i = 0 To(UBound($Arr) - 1)
$searchResult = _ArraySearch($splitedToDelete, $i)
If $searchResult > -1 And StringLen($splitedToDelete[$searchResult]) > 0 Then ContinueLoop
$tmpArr[$i][0] = $Arr[$i][0]
$tmpArr[$i][1] = $Arr[$i][1]
Next
_ArryRemoveBlanks($tmpArr)
$Arr = $tmpArr
EndIf
If $ReturnAsString = True Then
Local $ToReturn = ""
For $k = 0 To(UBound($Arr) - 1)
$ToReturn &= $Arr[$k][0] & "," & $Arr[$k][1] & "|"
Next
If StringRight($ToReturn, 1) = "|" Then $ToReturn = StringLeft($ToReturn,(StringLen($ToReturn) - 1))
$Arr = $ToReturn
Return $ToReturn
EndIf
EndFunc
Func _DelPosWithDiff2(ByRef $sResult, $xDiff, $yDiff, $ReturnAsString = True, $And = True)
Local $tmpSplitedPositions
If StringInStr($sResult, "|") > 0 Then
$tmpSplitedPositions = StringSplit($sResult, "|", 2)
Else
$tmpSplitedPositions = _StringEqualSplit($sResult, StringLen($sResult))
EndIf
Local $splitedPositions[UBound($tmpSplitedPositions)][2]
For $j = 0 To(UBound($tmpSplitedPositions) - 1)
If StringInStr($tmpSplitedPositions[$j], ",") Then
$splitedPositions[$j][0] = StringSplit($tmpSplitedPositions[$j], ",", 2)[0]
$splitedPositions[$j][1] = StringSplit($tmpSplitedPositions[$j], ",", 2)[1]
EndIf
Next
Local $Arr = $splitedPositions
Local $iStart = 0
Local $iXDiff = 0, $iYDiff = 0
Local $IndexesToDelete = ""
For $i = $iStart To(UBound($Arr) - 1)
For $j = $i + 1 To(UBound($Arr) - 1)
$iXDiff = Number(Abs(Number(Number($Arr[$i][0]) - Number($Arr[$j][0]))))
$iYDiff = Number(Abs(Number(Number($Arr[$i][1]) - Number($Arr[$j][1]))))
If $And = True Then
If($iXDiff <= $xDiff) And($iYDiff <= $yDiff) Then
$IndexesToDelete &= $j & ","
$i += 1
ExitLoop
EndIf
Else
If($iXDiff <= $xDiff) Or($iYDiff <= $yDiff) Then
$IndexesToDelete &= $j & ","
$i += 1
ExitLoop
EndIf
EndIf
$iXDiff = 0
$iYDiff = 0
Next
Next
If StringRight($IndexesToDelete, 1) = "," Then $IndexesToDelete = StringLeft($IndexesToDelete,(StringLen($IndexesToDelete) - 1))
If StringLen($IndexesToDelete) > 0 Then
Local $tmpArr[UBound($Arr)][2]
Local $splitedToDelete
If StringInStr($IndexesToDelete, ",") > 0 Then
$splitedToDelete = StringSplit($IndexesToDelete, ",", 2)
Else
$splitedToDelete = _StringEqualSplit($IndexesToDelete, StringLen($IndexesToDelete))
EndIf
Local $searchResult = -1
For $i = 0 To(UBound($Arr) - 1)
$searchResult = _ArraySearch($splitedToDelete, $i)
If $searchResult > -1 And StringLen($splitedToDelete[$searchResult]) > 0 Then ContinueLoop
$tmpArr[$i][0] = $Arr[$i][0]
$tmpArr[$i][1] = $Arr[$i][1]
Next
_ArryRemoveBlanks($tmpArr)
$Arr = $tmpArr
EndIf
If $ReturnAsString = True Then
Local $ToReturn = ""
For $k = 0 To(UBound($Arr) - 1)
$ToReturn &= $Arr[$k][0] & "," & $Arr[$k][1] & "|"
Next
If StringRight($ToReturn, 1) = "|" Then $ToReturn = StringLeft($ToReturn,(StringLen($ToReturn) - 1))
$sResult = $ToReturn
Return $ToReturn
EndIf
Return $Arr
EndFunc
Func CollectTreasury()
If $g_ichkEnableTrCollect = 1 Then
Setlog("Collecting treasury...", $COLOR_INFO)
If OpenTreasuryMenu() Then
If _ColorCheck(_GetPixelColor(430, 510, True), "60AC10", 20) Then
If $g_ichkForceTrCollect = 1 Then
CollectTreasuryStand()
Else
Local $iNeedToCollect = 0
If $g_ichkGoldTrCollect = 1 And(GUICtrlRead($txtMinGoldTrCollect) > $iGoldCurrent) Then
Setlog("Gold amount is below minimum, need to collect treasury", $COLOR_SUCCESS1)
$iNeedToCollect += 1
ElseIf $g_ichkGoldTrCollect = 1 Then
Setlog("Gold amount is above minimum...", $COLOR_ORANGE)
EndIf
If $g_ichkElxTrCollect = 1 And(GUICtrlRead($txtMinElxTrCollect) > $iElixirCurrent) Then
Setlog("Elixir amount is below minimum, need to collect treasury", $COLOR_SUCCESS1)
$iNeedToCollect += 1
ElseIf $g_ichkElxTrCollect = 1 Then
Setlog("Elixir amount is above minimum...", $COLOR_ORANGE)
EndIf
If $g_ichkDarkTrCollect = 1 And(GUICtrlRead($txtMinDarkTrCollect) > $iDarkCurrent) Then
Setlog("Dark amount is below minimum, need to collect treasury", $COLOR_SUCCESS1)
$iNeedToCollect += 1
ElseIf $g_ichkDarkTrCollect = 1 Then
Setlog("Dark amount is above minimum...", $COLOR_ORANGE)
EndIf
If $g_ichkFullGoldTrCollect = 1 And _ColorCheck(_GetPixelColor(688, 284, True), "40AC00", 20) Then
Setlog("Gold is full, need to collect treasury", $COLOR_SUCCESS1)
$iNeedToCollect += 1
ElseIf $g_ichkFullGoldTrCollect = 1 Then
Setlog("Gold is not full...", $COLOR_ORANGE)
EndIf
If $g_ichkFullElxTrCollect = 1 And _ColorCheck(_GetPixelColor(688, 318, True), "40AC00", 20) Then
Setlog("Elixir is full, need to collect treasury", $COLOR_SUCCESS1)
$iNeedToCollect += 1
ElseIf $g_ichkFullElxTrCollect = 1 Then
Setlog("Elixir is not full...", $COLOR_ORANGE)
EndIf
If $g_ichkFullDarkTrCollect = 1 And _ColorCheck(_GetPixelColor(688, 351, True), "40AC00", 20) Then
Setlog("Dark is full, need to collect treasury", $COLOR_SUCCESS1)
$iNeedToCollect += 1
ElseIf $g_ichkFullElxTrCollect = 1 Then
Setlog("Dark is not full...", $COLOR_ORANGE)
EndIf
If $iNeedToCollect > 1 Then
SetLog($iNeedToCollect & " conditions met to collect treasury, collecting...", $COLOR_ACTION1)
CollectTreasuryStand()
ElseIf $iNeedToCollect = 1 Then
SetLog($iNeedToCollect & " condition met to collect treasury, collecting...", $COLOR_ACTION1)
CollectTreasuryStand()
Else
SetLog("No condition met to collect treasury, skipping...", $COLOR_WARNING)
EndIf
EndIf
Else
SetLog("Collect button unavailable, treasury empty... skipping...", $COLOR_WARNING)
EndIf
EndIf
EndIf
ClickP($aAway, 2, 0, "#0346")
If _sleep(500) then return
EndFunc
Func CollectTreasuryStand()
If _ColorCheck(_GetPixelColor(690, 210, True), "FFFFFF", 20) Then
Click(435, 490)
randomSleep(1500)
If _ColorCheck(_GetPixelColor(520, 450, True), "60AD10", 20) And _ColorCheck(_GetPixelColor(590, 280, True), "E8E8E0", 20) Then
Click(520, 430)
SetLog("Treasury collected successfully", $COLOR_SUCCESS)
Else
SetLog("Error when trying to find Okay button... skipping...", $COLOR_WARNING)
EndIf
Else
SetLog("Error when trying to find Treasury menu... skipping...", $COLOR_WARNING)
EndIf
EndFunc
Func OpenTreasuryMenu()
If $aCCPos[0] = -1 Or $aCCPos[1] = -1 Then
Setlog("Clan Castle unlocated, please, locate it manually. skipping...", $COLOR_ERROR)
Return False
Else
Click($aCCPos[0], $aCCPos[1])
randomSleep(1500)
If QuickMIS("BC1", @ScriptDir & "\imgxml\Resources\Treasury", 480, 610, 650, 710) Then
Click($g_iQuickMISX + 480, $g_iQuickMISY + 610)
randomSleep(1500)
Else
SetLog("Error when trying to open Treasury menu... skipping...", $COLOR_WARNING)
Return False
EndIf
Return True
EndIf
EndFunc
Func chkEnableTrCollect()
If GUICtrlRead($chkEnableTrCollect) = $GUI_CHECKED Then
$g_ichkEnableTrCollect = 1
For $i = $chkForceTrCollect To $chkFullDarkTrCollect
GUICtrlSetState($i, $GUI_ENABLE)
Next
chkResTrCollect()
chkFullResTrCollect()
chkForceTrCollect()
Else
$g_ichkEnableTrCollect = 0
For $i = $chkForceTrCollect To $chkFullDarkTrCollect
GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
EndFunc
Func chkForceTrCollect()
If GUICtrlRead($chkForceTrCollect) = $GUI_CHECKED Then
$g_ichkForceTrCollect = 1
For $i = $chkGoldTrCollect To $chkFullDarkTrCollect
GUICtrlSetState($i, $GUI_DISABLE)
Next
Else
$g_ichkForceTrCollect = 0
For $i = $chkGoldTrCollect To $chkFullDarkTrCollect
GUICtrlSetState($i, $GUI_ENABLE)
Next
chkResTrCollect()
chkFullResTrCollect()
EndIf
EndFunc
Func chkResTrCollect()
If GUICtrlRead($chkGoldTrCollect) = $GUI_CHECKED Then
$g_ichkGoldTrCollect = 1
GUICtrlSetState($txtMinGoldTrCollect, $GUI_ENABLE)
Else
$g_ichkGoldTrCollect = 0
GUICtrlSetState($txtMinGoldTrCollect, $GUI_DISABLE)
EndIf
If GUICtrlRead($chkElxTrCollect) = $GUI_CHECKED Then
$g_ichkElxTrCollect = 1
GUICtrlSetState($txtMinElxTrCollect, $GUI_ENABLE)
Else
$g_ichkElxTrCollect = 0
GUICtrlSetState($txtMinElxTrCollect, $GUI_DISABLE)
EndIf
If GUICtrlRead($chkDarkTrCollect) = $GUI_CHECKED Then
$g_ichkDarkTrCollect = 1
GUICtrlSetState($txtMinDarkTrCollect, $GUI_ENABLE)
Else
$g_ichkDarkTrCollect = 0
GUICtrlSetState($txtMinDarkTrCollect, $GUI_DISABLE)
EndIf
chkFullResTrCollect()
EndFunc
Func chkFullResTrCollect()
If GUICtrlRead($chkFullGoldTrCollect) = $GUI_CHECKED Then
$g_ichkFullGoldTrCollect = 1
Else
$g_ichkFullGoldTrCollect = 0
EndIf
If GUICtrlRead($chkFullElxTrCollect) = $GUI_CHECKED Then
$g_ichkFullElxTrCollect = 1
Else
$g_ichkFullElxTrCollect = 0
EndIf
If GUICtrlRead($chkFullDarkTrCollect) = $GUI_CHECKED Then
$g_ichkFullDarkTrCollect = 1
Else
$g_ichkFullDarkTrCollect = 0
EndIf
EndFunc
Func MainSuperXPHandler()
If $ichkEnableSuperXP = 0 Then Return
If $g_idebugSetlog Or $DebugSX Then SetLog("Begin MainSuperXPHandler, $irbSXTraining=" & $irbSXTraining & ", $IsFullArmywithHeroesAndSpells=" & $IsFullArmywithHeroesAndSpells, $COLOR_DEBUG)
If $irbSXTraining = 1 And $IsFullArmywithHeroesAndSpells = True Then Return
If $iGainedXP >= $itxtMaxXPtoGain Then
SetLog("You have Max XP to Gain GoblinXP", $COLOR_DEBUG)
If $DebugSX = 1 Then SetLog("$iGainedXP = " & $iGainedXP & "|$itxtMaxXPtoGain = " & $itxtMaxXPtoGain, $COLOR_DEBUG)
$ichkEnableSuperXP = 0
GUICtrlSetState($chkEnableSuperXP, $GUI_UNCHECKED)
Return
EndIf
If WaitForMain() = False Then
SetLog("Cannot get in Main Screen!! Exiting SuperXP", $COLOR_RED)
Return False
EndIf
$iTrophyCurrent = getTrophyMainScreen($aTrophies[0], $aTrophies[1])
If $g_iDebugSetlog = 1 Then SetLog("Current Trophy Count: " & $iTrophyCurrent, $COLOR_DEBUG)
If Number($iTrophyCurrent) > Number($iTxtMaxTrophy) Then Return
Local $heroRes = getArmyHeroCount(True, True)
If $heroRes = @error And @error > 0 Then SetLog("Error while getting hero count, #" & @error, $COLOR_DEBUG)
If WaitForMain() = False Then
SetLog("Cannot get in Main Screen!! Exiting SuperXP", $COLOR_RED)
Return False
EndIf
$canGainXP =($iHeroAvailable <> $eHeroNone And(IIf($ichkSXBK = $eHeroNone, False, BitAND($iHeroAvailable, $eHeroKing) = $eHeroKing) Or IIf($ichkSXAQ = $eHeroNone, False, BitAND($iHeroAvailable, $eHeroQueen) = $eHeroQueen) Or IIf($ichkSXGW = $eHeroNone, False, BitAND($iHeroAvailable, $eHeroWarden) = $eHeroWarden) And IIf($irbSXTraining = 1, $IsFullArmywithHeroesAndSpells = False, True) And Number($iGainedXP) < Number($itxtMaxXPtoGain)))
If $DebugSX = 1 Then SetLog("$iHeroAvailable = " & $iHeroAvailable)
If $DebugSX = 1 Then SetLog("BK: " & $ichkSXBK & ", AQ: " & $ichkSXAQ & ", GW: " & $ichkSXGW)
If $DebugSX = 1 Then SetLog("$canGainXP = " & $canGainXP & @CRLF & "1: " & String(IIf($ichkSXBK = $eHeroNone, False, BitAND($iHeroAvailable, $eHeroKing) = $eHeroKing)) & ", 2: " & String(IIf($ichkSXAQ = $eHeroNone, False, BitAND($iHeroAvailable, $eHeroQueen) = $eHeroQueen) & "|" & BitAND($iHeroAvailable, $eHeroQueen)) & ", 3: " & String(IIf($ichkSXGW = $eHeroNone, False, BitAND($iHeroAvailable, $eHeroWarden) = $eHeroWarden) & "|" & BitAND($iHeroAvailable, $eHeroWarden)) & ", 4: " &($iHeroAvailable <> $eHeroNone) & ", 5: " & String(IIf($irbSXTraining = 1, $IsFullArmywithHeroesAndSpells = False, True)) & ", 6: " & String(Number($iGainedXP) < Number($itxtMaxXPtoGain)))
If $canGainXP = False Then Return
If $iStartXP = 0 Then
$iStartXP = GetCurXP()
SXSetXP("S")
EndIf
While $canGainXP = True
If WaitForMain() = False Then
SetLog("Cannot get in Main Screen!! Exiting SuperXP", $COLOR_RED)
Return False
EndIf
If $iGainedXP >= $itxtMaxXPtoGain Then
$canGainXP = False
SetLog("You have Max XP to Gain GoblinXP", $COLOR_DEBUG)
If $DebugSX = 1 Then SetLog("$iGainedXP = " & $iGainedXP & "|$itxtMaxXPtoGain = " & $itxtMaxXPtoGain, $COLOR_DEBUG)
$ichkEnableSuperXP = 0
GUICtrlSetState($chkEnableSuperXP, $GUI_UNCHECKED)
ExitLoop
EndIf
SetLog("Attacking to Goblin Picnic - GoblinXP", $COLOR_BLUE)
If $g_bRunState = False Then Return
If OpenGoblinPicnic() = False Then
SafeReturnSX()
Return False
EndIf
If $g_bRunState = False Then Return
Local $rAttackSuperXP = AttackSuperXP()
If $rAttackSuperXP = True Then
If $g_bRunState = False Then Return
WaitToFinishSuperXP()
EndIf
If $g_bRunState = False Then Return
SetLog("Attacking Finished - GoblinXP", $COLOR_GREEN)
If $rAttackSuperXP = True Then AttackFinishedSX()
If $canGainXP = False Then ExitLoop
DonateCC(True)
If $irbSXTraining = 1 Then CheckForFullArmy()
$canGainXP =($iHeroAvailable <> $eHeroNone And(IIf($ichkSXBK = $eHeroNone, False, BitAND($iHeroAvailable, $eHeroKing) = $eHeroKing) Or IIf($ichkSXAQ = $eHeroNone, False, BitAND($iHeroAvailable, $eHeroQueen) = $eHeroQueen) Or IIf($ichkSXGW = $eHeroNone, False, BitAND($iHeroAvailable, $eHeroWarden) = $eHeroWarden) And IIf($irbSXTraining = 1, $IsFullArmywithHeroesAndSpells = False, True) And $ichkEnableSuperXP = 1 And Number($iGainedXP) < Number($itxtMaxXPtoGain)))
If $DebugSX = 1 Then SetLog("$iHeroAvailable = " & $iHeroAvailable)
If $DebugSX = 1 Then SetLog("BK: " & $ichkSXBK & ", AQ: " & $ichkSXAQ & ", GW: " & $ichkSXGW)
If $DebugSX = 1 Then SetLog("While|$canGainXP = " & $canGainXP & @CRLF & "1: " & String(IIf($ichkSXBK = $eHeroNone, False, BitAND($iHeroAvailable, $eHeroKing) = $eHeroKing)) & ", 2: " & String(IIf($ichkSXAQ = $eHeroNone, False, BitAND($iHeroAvailable, $eHeroQueen) = $eHeroQueen)) & ", 3: " & String(IIf($ichkSXGW = $eHeroNone, False, BitAND($iHeroAvailable, $eHeroWarden) = $eHeroWarden)) & ", 4: " &($iHeroAvailable <> $eHeroNone) & ", 5: " & String(IIf($irbSXTraining = 1, $IsFullArmywithHeroesAndSpells = False, True)) & ", 6: " & String($ichkEnableSuperXP = 1) & ", 7: " & String(Number($iGainedXP) < Number($itxtMaxXPtoGain)))
WEnd
EndFunc
Func CheckForFullArmy()
If $DebugSX = 1 Then SetLog("SX|CheckForFullArmy", $COLOR_PURPLE)
If WaitForMain() = False Then
SetLog("Cannot get in Main Screen!! Exiting CheckForFullArmy", $COLOR_RED)
Return False
EndIf
OpenArmyWindow()
$fullarmy = False
$bFullArmySpells = False
$canRequestCC = _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1], True), Hex($aRequestTroopsAO[2], 6), $aRequestTroopsAO[5])
IsFullArmy(True)
If $g_bRunState = False Then Return
IsFullSpells(True)
Local $fullcastlespells = IsFullCastleSpells()
If $g_bRunState = False Then Return
Local $fullcastletroops = IsFullCastleTroops()
Local $checkSpells = checkspells()
If($g_iCommandStop = 3 Or $g_iCommandStop = 0) And $fullarmy Then
SetLog("You are in halt attack mode and your Army is prepared!", $COLOR_DEBUG)
If $g_bFirstStart Then $g_bFirstStart = False
Return
EndIf
If IsWaitforHeroesActive() Or $iChkTrophyRange = 1 Or $ichkEnableSuperXP = 1 Then
getArmyHeroCount()
Else
$bFullArmyHero = True
EndIf
If $g_bRunState = False Then Return
If $fullarmy And $checkSpells And $bFullArmyHero And $fullcastlespells And $fullcastletroops Then
$IsFullArmywithHeroesAndSpells = True
$g_bFirstStart = False
Else
$IsFullArmywithHeroesAndSpells = False
EndIf
If $IsFullArmywithHeroesAndSpells = False And(_ColorCheck(_GetPixelColor(391, 126, True), Hex(0x605C4C, 6), 15) = True And _ColorCheck(_GetPixelColor(587, 126, True), Hex(0x605C4D, 6), 15) = True) Then
If $DebugSX = 1 Then SetLog("SX|CFFA TrainRevamp Condi. #1")
TrainRevamp()
ElseIf $IsFullArmywithHeroesAndSpells = True And $ichkEnableSuperXP = 1 And $irbSXTraining = 1 Then
If $DebugSX = 1 Then SetLog("SX|CFFA TrainRevamp Condi. #2")
TrainRevamp()
EndIf
ClickP($aAway, 2, 0, "#0346")
If $DebugSX = 1 Then SetLog("SX|CheckForFullArmy Finished", $COLOR_PURPLE)
EndFunc
Func SafeReturnSX()
If $DebugSX = 1 Then SetLog("SX|SafeReturn", $COLOR_PURPLE)
$canGainXP = False
If IsMainPage() Then Return True
Local $rExit = False
If IsInAttackSuperXP() Then
$rExit = ReturnHomeSuperXP()
ElseIf IsInSPPage() Then
$rExit = ExitSPPage()
EndIf
If $DebugSX = 1 Then SetLog("SX|SafeReturn=" & $rExit)
Return $rExit
EndFunc
Func ExitSPPage()
If $DebugSX = 1 Then SetLog("SX|ExitSPPage", $COLOR_PURPLE)
Click(822, 32, 1, 0, "#0152")
Local $Counter = 0
While Not(IsMainPage())
If _Sleep(50) Then Return False
$Counter += 1
If $Counter >= 200 Then ExitLoop
WEnd
If $Counter >= 200 Then
SetLog("Cannot Exit Single Player Page", $COLOR_RED)
Return False
EndIf
If $DebugSX = 1 Then SetLog("SX|ExitSPPage Finished", $COLOR_PURPLE)
Return True
EndFunc
Func AttackFinishedSX()
If $DebugSX = 1 Then SetLog("SX|AttackFinished", $COLOR_PURPLE)
$iCurrentXP = GetCurXP("Current")
$iGainedXP += 5
SXSetXP()
$ActivatedHeroes[0] = False
$ActivatedHeroes[1] = False
$ActivatedHeroes[2] = False
If $DebugSX = 1 Then SetLog("SX|AttackFinished Finished", $COLOR_PURPLE)
EndFunc
Func GetCurXP($returnVal = "Current")
If $DebugSX = 1 Then SetLog("SX|GetCurXP", $COLOR_PURPLE)
Local $ToReturn = "0#0"
Click(135, 30)
Local $iCounter = 0
While _ColorCheck(_GetPixelColor(143, 14 + $g_imidOffsetY, True), Hex(0xE8E8E8, 6), 40) = False
If $g_bRunState = False Then Return $iCurrentXP
_Sleep(10)
If $iCounter >= 1000 Then ExitLoop
$iCounter += 1
WEnd
If $iCounter >= 999 Then
SetLog("SX|Failed to Get Current XP|Loop #" & $iCounter, $COLOR_DEBUG)
If $g_bRunState = False Then Return $iCurrentXP
Return $ToReturn
EndIf
Local $XPOCRResult = getCurrentXP(90, 60)
ClickP($aAway, 2, 0, "#0346")
If $returnVal = "" Then
$ToReturn = $XPOCRResult
ElseIf StringInStr($returnVal, "Cur") And StringInStr($XPOCRResult, "#") Then
$ToReturn = StringSplit($XPOCRResult, "#", 2)[0]
ElseIf StringInStr($returnVal, "Tot") And StringInStr($XPOCRResult, "#") Then
$ToReturn = StringSplit($XPOCRResult, "#", 2)[1]
Else
$ToReturn = $XPOCRResult
EndIf
Return $ToReturn
If $DebugSX = 1 Then SetLog("SX|GetCurXP Finished", $COLOR_PURPLE)
EndFunc
Func WaitToFinishSuperXP()
If $DebugSX = 1 Then SetLog("SX|WaitToFinishSuperXP", $COLOR_PURPLE)
Local $BdTimer = TimerInit()
While 1
If CheckEarnedStars($minStarsToEnd) = True Then ExitLoop
If _Sleep(70) Then ExitLoop
If $g_bRunState = False Then ExitLoop
If IsInAttackSuperXP() = False Then ExitLoop
ActivateHeroesByDelay($BdTimer)
If TimerDiff($BdTimer) >= 120000 Then
If $DebugSX = 1 Then SetLog("SX|WaitToFinishSuperXP TimeOut", $COLOR_RED)
SafeReturnSX()
ExitLoop
EndIf
WEnd
If $DebugSX = 1 Then SetLog("SX|WaitToFinishSuperXP Finished", $COLOR_PURPLE)
Return True
EndFunc
Func ActivateHeroesByDelay($hBdTimer)
Local $QueenDelay = $BdGoblinPicnic[0]
If StringInStr($QueenDelay, "-") > 0 Then $QueenDelay = Random(Number(StringSplit($QueenDelay, "-", 2)[0]), Number(StringSplit($QueenDelay, "-", 2)[1]), 1)
Local $WardenDelay = $BdGoblinPicnic[1]
If StringInStr($WardenDelay, "-") > 0 Then $WardenDelay = Random(Number(StringSplit($WardenDelay, "-", 2)[0]), Number(StringSplit($WardenDelay, "-", 2)[1]), 1)
Local $KingDelay = $BdGoblinPicnic[2]
If StringInStr($KingDelay, "-") > 0 Then $KingDelay = Random(Number(StringSplit($KingDelay, "-", 2)[0]), Number(StringSplit($KingDelay, "-", 2)[1]), 1)
Local $tDiff = TimerDiff($hBdTimer)
If $tDiff >= $QueenDelay And $QueenDelay <> 0 And $ActivatedHeroes[0] = False And $Queen <> -1 And $ichkSXAQ <> $eHeroNone Then
If $DebugSX = 1 Then SetLog("SX|Activating Queen Ability After " & Round($tDiff, 3) & "/" & $QueenDelay & " ms(s)")
SelectDropTroop($Queen)
$ActivatedHeroes[0] = True
EndIf
If $tDiff >= $WardenDelay And $WardenDelay <> 0 And $ActivatedHeroes[1] = False And $Warden <> -1 And $ichkSXGW <> $eHeroNone Then
If $DebugSX = 1 Then SetLog("SX|Activating Warden Ability After " & Round($tDiff, 3) & "/" & $WardenDelay & " ms(s)")
SelectDropTroop($Warden)
$ActivatedHeroes[1] = True
EndIf
If $tDiff >= $KingDelay And $KingDelay <> 0 And $ActivatedHeroes[2] = False And $King <> -1 And $ichkSXBK <> $eHeroNone Then
If $DebugSX = 1 Then SetLog("SX|Activating King Ability After " & Round($tDiff, 3) & "/" & $KingDelay & " ms(s)")
SelectDropTroop($King)
$ActivatedHeroes[2] = True
EndIf
EndFunc
Func IsInAttackSuperXP()
If $DebugSX = 1 Then SetLog("SX|IsInAttackSuperXP", $COLOR_PURPLE)
If _ColorCheck(_GetPixelColor(60, 576, True), Hex(0x000000, 6), 20) Then Return True
If $DebugSX = 1 Then SetLog("SX|IsInAttackSuperXP=FALSE")
Return False
EndFunc
Func IsInSPPage()
If $DebugSX = 1 Then SetLog("SX|IsInSPPage", $COLOR_PURPLE)
Local $rColCheck = _ColorCheck(_GetPixelColor(316, 34, True), Hex(0xFFFFFF, 6), 20)
If $DebugSX = 1 Then SetLog("SX|IsInSPPage=" & $rColCheck)
Return $rColCheck
EndFunc
Func AttackSuperXP()
If $DebugSX = 1 Then SetLog("SX|AttackSuperXP", $COLOR_PURPLE)
If WaitForNoClouds() = False Then
If $DebugSX = 1 Then SetLog("SX|ASX|Wait For Clouds = False")
$Is_ClientSyncError = False
Return False
EndIf
PrepareSuperXPAttack()
If CheckAvailableHeroes() = False Then
SetLog("No heroes available to attack with", $COLOR_ORANGE)
ReturnHomeSuperXP()
Return False
EndIf
DropAQSuperXP($BdGoblinPicnic[0] = 0)
If CheckEarnedStars($minStarsToEnd) = True Then Return True
DropGWSuperXP($BdGoblinPicnic[1] = 0)
If CheckEarnedStars($minStarsToEnd) = True Then Return True
DropBKSuperXP($BdGoblinPicnic[2] = 0)
If $DebugSX = 1 Then SetLog("SX|AttackSuperXP Finished", $COLOR_PURPLE)
Return True
EndFunc
Func CheckAvailableHeroes()
$canGainXP =((IIf($ichkSXBK = $eHeroNone, False, $King <> -1) Or IIf($ichkSXAQ = $eHeroNone, False, $Queen <> -1) Or IIf($ichkSXGW = $eHeroNone, False, $Warden <> -1)) And IIf($irbSXTraining = 1, $IsFullArmywithHeroesAndSpells = False, True))
If $DebugSX = 1 Then SetLog("SX|CheckAvailableHeroes=" & $canGainXP)
Return $canGainXP
EndFunc
Func DropAQSuperXP($bActivateASAP = True)
If $Queen <> -1 And $ichkSXAQ <> $eHeroNone Then
SetLog("Deploying Queen", $COLOR_BLUE)
Click(GetXPosOfArmySlot($Queen, 68), 595 + $g_ibottomOffsetY, 1, 0, "#0000")
If _Sleep($iDelayDropSuperXP1) Then Return False
If CheckEarnedStars($minStarsToEnd) = True Then Return True
ClickP(GetDropPointSuperXP(1), 1, 0, "#0000")
If _Sleep($iDelayDropSuperXP3) Then Return False
If $bActivateASAP = True Then
If IsAttackPage() Then
SelectDropTroop($Queen)
$ActivatedHeroes[0] = True
EndIf
EndIf
If _Sleep($iDelayDropSuperXP3) Then Return False
EndIf
EndFunc
Func DropGWSuperXP($bActivateASAP = True)
If $Warden <> -1 And $ichkSXGW <> $eHeroNone Then
SetLog("Deploying Warden", $COLOR_BLUE)
Click(GetXPosOfArmySlot($Warden, 68), 595 + $g_ibottomOffsetY, 1, 0, "#0179")
If _Sleep($iDelayDropSuperXP1) Then Return False
If CheckEarnedStars($minStarsToEnd) = True Then Return True
ClickP(GetDropPointSuperXP(2), 1, 0, "#0180")
If _Sleep($iDelayDropSuperXP3) Then Return False
If $bActivateASAP = True Then
If IsAttackPage() Then
SelectDropTroop($Warden)
$ActivatedHeroes[1] = True
EndIf
EndIf
If _Sleep($iDelayDropSuperXP3) Then Return False
EndIf
EndFunc
Func DropBKSuperXP($bActivateASAP = True)
If $King <> -1 And $ichkSXBK <> $eHeroNone Then
SetLog("Deploying King", $COLOR_BLUE)
Click(GetXPosOfArmySlot($King, 68), 595 + $g_ibottomOffsetY, 1, 0, "#0177")
If _Sleep($iDelayDropSuperXP1) Then Return False
If CheckEarnedStars($minStarsToEnd) = True Then Return True
ClickP(GetDropPointSuperXP(3), 1, 0, "#0178")
If _Sleep($iDelayDropSuperXP3) Then Return False
If $bActivateASAP = True Then
If IsAttackPage() Then
SelectDropTroop($King)
$ActivatedHeroes[2] = True
EndIf
EndIf
If _Sleep($iDelayDropSuperXP3) Then Return False
EndIf
EndFunc
Func GetDropPointSuperXP($iHero)
Local $ToReturn[2] = [-1, -1]
Local $rDpGoblinPicnic[4] = [$DpGoblinPicnic[$iHero - 1][0], $DpGoblinPicnic[$iHero - 1][1], $DpGoblinPicnic[$iHero - 1][2], $DpGoblinPicnic[$iHero - 1][3]]
$ToReturn[0] = Random($rDpGoblinPicnic[0] - $rDpGoblinPicnic[2], $rDpGoblinPicnic[0] + $rDpGoblinPicnic[2], 1)
$ToReturn[1] = Random($rDpGoblinPicnic[1] - $rDpGoblinPicnic[3], $rDpGoblinPicnic[1] + $rDpGoblinPicnic[3], 1)
Return $ToReturn
EndFunc
Func PrepareSuperXPAttack()
If $DebugSX = 1 Then SetLog("SX|PrepareSuperXPAttack", $COLOR_PURPLE)
Local $troopsnumber = 0
If _Sleep($iDelayPrepareAttack1) Then Return
_CaptureRegion2(0, 571 + $g_ibottomOffsetY, 859, 671 + $g_ibottomOffsetY)
Local $Plural = 0
Local $result = AttackBarCheck()
If $g_idebugSetlog = 1 Then Setlog("DLL Troopsbar list: " & $result, $COLOR_DEBUG)
Local $aTroopDataList = StringSplit($result, "|")
Local $aTemp[12][3]
If $result <> "" Then
For $i = 1 To $aTroopDataList[0]
Local $troopData = StringSplit($aTroopDataList[$i], "#", $STR_NOCOUNT)
$aTemp[Number($troopData[1])][0] = $troopData[0]
$aTemp[Number($troopData[1])][1] = Number($troopData[2])
$aTemp[Number($troopData[1])][2] = Number($troopData[1])
Next
EndIf
For $i = 0 To UBound($aTemp) - 1
If $aTemp[$i][0] = "" And $aTemp[$i][1] = "" Then
$atkTroops[$i][0] = -1
$atkTroops[$i][1] = 0
Else
Local $troopKind = $aTemp[$i][0]
If $troopKind < $eKing Then
$atkTroops[$i][0] = $aTemp[$i][0]
$atkTroops[$i][1] = $aTemp[$i][1]
$troopKind = $aTemp[$i][1]
$troopsnumber += $aTemp[$i][1]
Else
$atkTroops[$i][0] = $troopKind
$troopsnumber += 1
$atkTroops[$i][0] = $aTemp[$i][0]
$troopKind = $aTemp[$i][1]
$troopsnumber += 1
EndIf
$Plural = 0
If $aTemp[$i][1] > 1 Then $Plural = 1
If $troopKind <> -1 Then SetLog($aTemp[$i][2] & " » " & $aTemp[$i][1] & " " & NameOfTroop($atkTroops[$i][0], $Plural), $COLOR_GREEN)
EndIf
Next
If $g_idebugSetlog = 1 Then Setlog("troopsnumber  = " & $troopsnumber)
$King = -1
$Queen = -1
$Warden = -1
For $i = 0 To UBound($atkTroops) - 1
If $atkTroops[$i][0] = $eKing Then
$King = $i
ElseIf $atkTroops[$i][0] = $eQueen Then
$Queen = $i
ElseIf $atkTroops[$i][0] = $eWarden Then
$Warden = $i
EndIf
Next
If $DebugSX = 1 Then SetLog("SX|PrepareSuperXPAttack Finished", $COLOR_PURPLE)
Return $troopsnumber
EndFunc
Func CheckEarnedStars($ExitWhileHave = 0)
If $DebugSX = 1 Then SetLog("SX|CheckEarnedStars", $COLOR_PURPLE)
Local $starsearned = 0
If $ExitWhileHave = 1 Then
If _ColorCheck(_GetPixelColor(455, 405, True), Hex(0xD0D8D0, 6), 20) Then
SetLog("1 Star earned", $COLOR_GREEN)
If ReturnHomeSuperXP() = False Then CloseCoC(True)
Return True
EndIf
EndIf
If _ColorCheck(_GetPixelColor(714, 594, True), Hex(0xCCCFC8, 6), 20) Then $starsearned += 1
If $ExitWhileHave <> 0 And $starsearned >= $ExitWhileHave Then
SetLog($starsearned & " Star earned", $COLOR_GREEN)
If ReturnHomeSuperXP() = False Then CloseCoC(True)
Return True
EndIf
If $ExitWhileHave >= 2 Then
If _ColorCheck(_GetPixelColor(740, 583, True), Hex(0xC6CBC5, 6), 20) Then $starsearned += 1
If $ExitWhileHave <> 0 And $starsearned >= $ExitWhileHave Then
SetLog($starsearned & " Stars earned", $COLOR_GREEN)
If ReturnHomeSuperXP() = False Then CloseCoC(True)
Return True
EndIf
If $ExitWhileHave >= 3 Then
If _ColorCheck(_GetPixelColor(764, 583, True), Hex(0xBEC5BE, 6), 20) Then $starsearned += 1
If $ExitWhileHave <> 0 And $starsearned >= $ExitWhileHave Then
SetLog($starsearned & " Stars earned", $COLOR_GREEN)
If ReturnHomeSuperXP() = False Then CloseCoC(True)
Return True
EndIf
EndIf
EndIf
Return False
EndFunc
Func ReturnHomeSuperXP()
Local Const $EndBattleText[4] = [29, 565 + $g_imidOffsetY, 0xFFFFFF, 10], $EndBattle2Text[4] = [377, 244 + $g_imidOffsetY, 0xFFFFFF, 20], $ReturnHomeText[4] = [428, 545 + $g_imidOffsetY, 0xFFFFFF, 10]
Local Const $iDelayEachCheck = 70, $iRetryLimits = 429
Local $Counter = 0
$King = -1
$Queen = -1
$Warden = -1
SetLog("Returning Home - SuperXP", $COLOR_BLUE)
While _ColorCheck(_GetPixelColor($EndBattleText[0], $EndBattleText[1], True), Hex($EndBattleText[2], 6), $EndBattleText[3]) = False
If $DebugSX = 1 Then SetLog("SX|RHSX|1-Loop #" & $Counter, $COLOR_DEBUG)
If _Sleep($iDelayEachCheck) Then Return False
$Counter += 1
If $Counter >= $iRetryLimits Then
If $DebugSX = 1 Then SetLog("SX|RHSX|First EndBattle Button not found")
Return False
EndIf
WEnd
Click(Random($EndBattleText[0] - 5, $EndBattleText[0] + 5, 1), Random($EndBattleText[1] - 5, $EndBattleText[1] + 5, 1))
If _Sleep($iDelayEachCheck) Then Return False
$Counter = 0
While _ColorCheck(_GetPixelColor($EndBattle2Text[0], $EndBattle2Text[1], True), Hex($EndBattle2Text[2], 6), $EndBattle2Text[3]) = False
If $DebugSX = 1 Then SetLog("SX|RHSX|2-Loop #" & $Counter, $COLOR_DEBUG)
If _Sleep($iDelayEachCheck) Then Return False
$Counter += 1
If $Counter >= $iRetryLimits Then
If $DebugSX = 1 Then SetLog("SX|RHSX|Second EndBattle Button not found")
Return False
EndIf
WEnd
Click(Random(455, 565, 1), Random(412, 447, 1))
If _Sleep($iDelayEachCheck) Then Return False
$Counter = 0
While _ColorCheck(_GetPixelColor($ReturnHomeText[0], $ReturnHomeText[1], True), Hex($ReturnHomeText[2], 6), $ReturnHomeText[3]) = False
If $DebugSX = 1 Then SetLog("SX|RHSX|3-Loop #" & $Counter, $COLOR_DEBUG)
If _Sleep($iDelayEachCheck) Then Return False
$Counter += 1
If $Counter >= $iRetryLimits Then
If $DebugSX = 1 Then SetLog("SX|RHSX|Last Return Home Button not found")
Return False
EndIf
WEnd
Click(Random($ReturnHomeText[0] - 5, $ReturnHomeText[0] + 5, 1), Random($ReturnHomeText[1] - 5, $ReturnHomeText[1] + 5, 1))
If _Sleep($iDelayReturnHome2) Then Return
$Counter = 0
While 1
If $DebugSX = 1 Then SetLog("SX|RHSX|4-Loop #" & $Counter, $COLOR_DEBUG)
If _Sleep($iDelayReturnHome4) Then Return
If IsMainPage(1) Then
_GUICtrlEdit_SetText($g_hTxtLog, _PadStringCenter(" BOT LOG ", 71, "="))
_GUICtrlRichEdit_SetFont($g_hTxtLog, 6, "Lucida Console")
_GUICtrlRichEdit_AppendTextColor($g_hTxtLog, "" & @CRLF, _ColorConvert($Color_Black))
Return True
EndIf
$Counter += 1
If $Counter >= 50 Or isProblemAffect(True) Then
SetLog("Cannot return home.", $COLOR_RED)
checkMainScreen(True)
Return True
EndIf
WEnd
EndFunc
Func WaitForNoClouds()
If $DebugSX = 1 Then SetLog("SX|WaitForNoClouds", $COLOR_PURPLE)
Local $i = 0
ForceCaptureRegion()
While _ColorCheck(_GetPixelColor(60, 576, True), Hex(0x000000, 6), 20) = False
If _Sleep($iDelayGetResources1) Then Return False
$i += 1
If $i >= 120 Or isProblemAffect(True) Then
$Is_ClientSyncError = True
checkMainScreen()
If $g_bRestart Then
$iNbrOfOoS += 1
UpdateStats()
SetLog("Disconnected At Search Clouds - SuperXP", $COLOR_RED)
PushMsg("OoSResources")
Else
SetLog("Stuck At Search Clouds, Restarting CoC and Bot... - SuperXP", $COLOR_RED)
$Is_ClientSyncError = False
CloseCoC(True)
EndIf
Return False
EndIf
If $DebugSX = 1 Then SetLog("SX|WFNC|Loop #" & $i)
ForceCaptureRegion()
WEnd
If $DebugSX = 1 Then SetLog("SX|WaitFornoClouds Finished", $COLOR_PURPLE)
Return True
EndFunc
Func OpenGoblinPicnic()
If $DebugSX = 1 Then SetLog("SX|OpenGoblinPicnic", $COLOR_PURPLE)
Local $rOpenSinglePlayerPage = OpenSinglePlayerPage()
If $rOpenSinglePlayerPage = False Then
SetLog("Failed to open Attack page, Single Player", $COLOR_RED)
SafeReturnSX()
Return False
EndIf
Local $rDragToGoblinPicnic = DragToGoblinPicnic()
If $rDragToGoblinPicnic = False Then
SetLog("Failed to find Goblin Picnic", $COLOR_RED)
SafeReturnSX()
Return False
EndIf
If $DebugSX = 1 Then SetLog("SX|OGP|Clicking On GP Text: " & $rDragToGoblinPicnic[0] & ", " & $rDragToGoblinPicnic[1])
Click($rDragToGoblinPicnic[0], $rDragToGoblinPicnic[1])
Local $Counter = 0
While _ColorCheck(_GetPixelColor(621, 665, True), Hex(0xFFFFFF, 6), 10) = False Or _ColorCheck(_GetPixelColor(663, 662, True), Hex(0xFFFFFF, 6), 10) = False
If _Sleep(50) Then ExitLoop
$Counter += 1
If $Counter > 200 Then ExitLoop
WEnd
If $Counter > 200 Then
SetLog("Available loot info didn't Displayed!", $COLOR_RED)
SafeReturnSX()
Return False
EndIf
$Counter = 0
While _ColorCheck(_GetPixelColor($rDragToGoblinPicnic[0], $rDragToGoblinPicnic[1] + 78, True), Hex(0xE04A00, 6), 30) = False
If _Sleep(50) Then ExitLoop
Click($rDragToGoblinPicnic[0], $rDragToGoblinPicnic[1])
$Counter += 1
If $Counter > 200 Then ExitLoop
WEnd
If $Counter > 200 Then
If IsGoblinPicnicLocked($rDragToGoblinPicnic) = True Then
SetLog("Are you kidding me? Goblin Picnic is Locked", $COLOR_RED)
DisableSX()
SafeReturnSX()
Return False
EndIf
SetLog("Attack Button Cannot be Verified", $COLOR_RED)
SafeReturnSX()
Return False
EndIf
If $DebugSX = 1 Then
SetLog("SX|OGP|Clicking On Attack Btn: " & $rDragToGoblinPicnic[0] & ", " & $rDragToGoblinPicnic[1] + 78)
EndIf
Click($rDragToGoblinPicnic[0], $rDragToGoblinPicnic[1] + 78)
$Counter = 0
While IsInSPPage()
If _Sleep(50) Then ExitLoop
$Counter += 1
If $Counter > 150 Then ExitLoop
WEnd
If $Counter >= 150 Then
SetLog("Still in SinglePlayer Page!! Something Strange Happened", $COLOR_RED)
$canGainXP = False
Return False
EndIf
Local $rIsGoblinPicnic = IsInGoblinPicnic()
If $rIsGoblinPicnic = False Then
SetLog("Looks like we're not in Goblin Picnic", $COLOR_RED)
If _CheckPixel($aCancelFight, $g_bNoCapturePixel) Or _CheckPixel($aCancelFight2, $g_bNoCapturePixel) Then
If $g_idebugSetlog Then SetLog("#cOb# Clicks X 2, $aCancelFight", $COLOR_BLUE)
PureClickP($aCancelFight, 1, 0, "#0135")
If _Sleep($iDelaycheckObstacles1) Then Return False
SafeReturnSX()
Return False
EndIf
SafeReturnSX()
Return False
EndIf
SetLog("Now we're in Goblin Picnic Base", $COLOR_GREEN)
Return True
EndFunc
Func IsInGoblinPicnic($Retry = True, $maxRetry = 30, $timeBetweenEachRet = 300)
If $DebugSX = 1 Then SetLog("SX|IsInGoblinPicnic", $COLOR_PURPLE)
Local $Found = False
Local $Counter = 0
Local $directory = @ScriptDir & "\imgxml\Resources\SuperXP\Verify"
Local $result = ""
While $Found = False
If _Sleep($timeBetweenEachRet) Then Return False
If IsInAttackSuperXP() = False Then ContinueLoop
$result = multiMatchesPixelOnly($directory, 0, "FV", "FV", "", 0, 1000, 0, 0, 111, 31)
If $DebugSX = 1 Then SetLog("SX|IGP|$result=" & $result)
$Found =(StringLen($result) > 2 And StringInStr($result, ","))
$Counter += 1
If $Counter = $maxRetry Then
$Found = False
ExitLoop
EndIf
WEnd
If $DebugSX = 1 Then SetLog("SX|IsGoblinPicnic=" & $Found, $COLOR_PURPLE)
Return $Found
EndFunc
Func IsGoblinPicnicLocked($FoundCoord)
If $DebugSX = 1 Then SetLog("SX|IsGoblinPicnicLocked", $COLOR_PURPLE)
Local $x = $FoundCoord[0], $y = $FoundCoord[1] + 9, $x1 = $x + 29, $y1 = $y + 34
Local $directory = @ScriptDir & "\imgxml\Resources\SuperXP\Locked"
Local $result = multiMatchesPixelOnly($directory, 0, "FV", "FV", "", 0, 1000, $x, $y, $x1, $y1)
If $DebugSX = 1 Then SetLog("SX|IGPL|$result=" & $result)
Local $Found =(StringLen($result) > 2 And StringInStr($result, ","))
If $DebugSX = 1 Then SetLog("SX|IGPL Return " & $Found)
Return $Found
EndFunc
Func DragToGoblinPicnic()
If $DebugSX = 1 Then SetLog("SX|DragToGoblinPicnic", $COLOR_PURPLE)
Local $rIsGoblinPicnicFound = False
Local $Counter = 0
Local $posInSinglePlayer2 = "MIDDLE"
Local $posInSinglePlayer = GetPositionInSinglePlayer()
If $DebugSX = 1 Then SetLog("SX|DTGP|$posInSinglePlayer=" & $posInSinglePlayer)
If $posInSinglePlayer = "MIDDLE" Then
If $DebugSX = 1 Then SetLog("SX|DTGP|Pos Middle, checking for GP")
$rIsGoblinPicnicFound = IsGoblinPicnicFound()
If IsArray($rIsGoblinPicnicFound) Then Return $rIsGoblinPicnicFound
If $DebugSX = 1 Then SetLog("SX|DTGP|Pos middle, Dragging To End")
If DragToEndSinglePlayer() = True Then $posInSinglePlayer = "END"
EndIf
If $posInSinglePlayer = "MIDDLE" Then
If $DebugSX = 1 Then SetLog("SX|DTGP|Failed to Drag To End, Still middle")
Return False
EndIf
Switch $posInSinglePlayer
Case "END"
While Not(IsArray($rIsGoblinPicnicFound))
If $DebugSX = 1 Then SetLog("SX|DTGP|Drag from End Loop #" & $Counter)
ClickDrag(Random(505, 515, 1), Random(95, 105, 1), Random(505, 515, 1), Random(656, 666, 1), 100)
If _Sleep(100) Then Return False
$rIsGoblinPicnicFound = IsGoblinPicnicFound()
If IsArray($rIsGoblinPicnicFound) Then ExitLoop
$Counter += 1
$posInSinglePlayer2 = GetPositionInSinglePlayer()
If $Counter = 15 Or $posInSinglePlayer2 = "FIRST" Then ExitLoop
WEnd
If $Counter = 15 Or $posInSinglePlayer2 And IsArray($rIsGoblinPicnicFound) = False Then Return False
Return $rIsGoblinPicnicFound
Case "FIRST"
While Not(IsArray($rIsGoblinPicnicFound))
If $DebugSX = 1 Then SetLog("SX|DTGP|Drag from First Loop #" & $Counter)
ClickDrag(Random(505, 515, 1), Random(656, 666, 1), Random(505, 515, 1), Random(95, 105, 1), 100)
If _Sleep(100) Then Return False
$rIsGoblinPicnicFound = IsGoblinPicnicFound()
If IsArray($rIsGoblinPicnicFound) Then ExitLoop
$Counter += 1
$posInSinglePlayer2 = GetPositionInSinglePlayer()
If $Counter = 15 Or $posInSinglePlayer2 = "FIRST" Then ExitLoop
WEnd
If $Counter = 15 Or $posInSinglePlayer2 And IsArray($rIsGoblinPicnicFound) = False Then Return False
Return $rIsGoblinPicnicFound
EndSwitch
EndFunc
Func IsGoblinPicnicFound()
If $DebugSX = 1 Then SetLog("SX|IsGoblinPicnicFound", $COLOR_PURPLE)
Click(840, 230 + $g_imidOffsetY)
If _Sleep(50) Then Return False
Local $directory = @ScriptDir & "\imgxml\Resources\SuperXP\Find"
Local $result = multiMatchesPixelOnly($directory, 0, "FV", "FV", "", 0, 1000, 554, 120, 639, $g_iGAME_HEIGHT)
If $DebugSX = 1 Then SetLog("SX|IGPF|$result=" & $result)
If StringLen($result) < 3 And StringInStr($result, "|") = 0 Then
If $DebugSX = 1 Then SetLog("SX|IGPF|Return False")
Return False
EndIf
Local $ToReturn = ""
If StringInStr($result, "|") > 0 Then
$ToReturn = StringSplit(StringSplit($result, "|", 2)[0], ",", 2)
Else
$ToReturn = StringSplit($result, ",", 2)
EndIf
$ToReturn[0] += 554
$ToReturn[1] += 120
If $DebugSX = 1 Then SetLog("SX|IGPF Return $ToReturn[2] = [0]=" & $ToReturn[0] & ",[1]=" & $ToReturn[1])
Return $ToReturn
EndFunc
Func DragToEndSinglePlayer()
If $DebugSX = 1 Then SetLog("SX|DragToEndSinglePlayer", $COLOR_PURPLE)
Local $rColCheckEnd = _ColorCheck(_GetPixelColor(670, 695, True), Hex(0x393224, 6), 20)
Local $Counter = 0
While $rColCheckEnd = False
If $DebugSX = 1 Then SetLog("SX|DTESP|Loop #" & $Counter)
ClickDrag(500, 635 + $g_imidOffsetY, 500, 60 + $g_imidOffsetY, 100)
$rColCheckEnd = _ColorCheck(_GetPixelColor(670, 695, True), Hex(0x393224, 6), 20)
$Counter += 1
If $Counter = 15 Then ExitLoop
WEnd
If $Counter = 15 Then
If $DebugSX = 1 Then SetLog("SX|DTESP|Return False")
Return False
EndIf
If $DebugSX = 1 Then SetLog("SX|DTESP|Return True")
Return True
EndFunc
Func GetPositionInSinglePlayer()
If $DebugSX = 1 Then SetLog("SX|GetPositionInSinglePlayer", $COLOR_PURPLE)
ClickP($aAway, 2, 0, "#0346")
Local $Counter = 0
While _ColorCheck(_GetPixelColor(621, 665, True), Hex(0xFFFFFF, 6), 10) And _ColorCheck(_GetPixelColor(663, 662, True), Hex(0xFFFFFF, 6), 10)
If _Sleep(50) Then ExitLoop
ClickP($aAway, 2, 0, "#0346")
$Counter += 1
If $Counter > 100 Then
If $DebugSX = 1 Then SetLog("SX|GPISP|Available Loot Not Hidden, Returning")
ExitLoop
EndIf
WEnd
Local $rColCheckEnd = _ColorCheck(_GetPixelColor(670, 695, True), Hex(0x393224, 6), 20)
If $rColCheckEnd Then
If $DebugSX = 1 Then SetLog("SX|GPISP|Return END")
Return "END"
Else
Local $rColCheckFirst = _ColorCheck(_GetPixelColor(585, 4, True), Hex(0x2E281D, 6), 20)
If $rColCheckFirst Then
If $DebugSX = 1 Then SetLog("SX|GPISP|Return FIRST")
Return "FIRST"
Else
If $DebugSX = 1 Then SetLog("SX|GPISP|Return MIDDLE")
Return "MIDDLE"
EndIf
EndIf
EndFunc
Func OpenSinglePlayerPage()
If $DebugSX = 1 Then SetLog("SX|OpenSinglePlayerPage", $COLOR_PURPLE)
If WaitForMain(True, 50, 300) = False Then
If $DebugSX = 1 Then SetLog("SX|MainPage Not Displayed to Open SingleP")
Return False
EndIf
SetLog("Going to Gain XP...", $COLOR_BLUE)
If IsMainPage() Then
If $iUseRandomClick = 0 Then
ClickP($aAttackButton, 1, 0, "#0149")
Else
ClickR($aAttackButtonRND, $aAttackButton[0], $aAttackButton[1], 1, 0)
EndIf
EndIf
If _Sleep(70) Then Return
Local $j = 0
While _ColorCheck(_GetPixelColor(606, 33, True), Hex(0xFFFFFF, 6), 10) = False And _ColorCheck(_GetPixelColor(804, 32, True), Hex(0xFFFFFF, 6), 10) = False
If _Sleep(70) Then Return
$j += 1
If $j > 214 Then ExitLoop
WEnd
If $j > 214 Then
SetLog("Launch attack Page Fail", $COLOR_RED)
checkMainScreen()
Return False
Else
Return True
EndIf
EndFunc
Func WaitForMain($clickAway = True, $delayEachCheck = 50, $maxRetry = 100)
If $clickAway Then ClickP($aAway, 2, 0, "#0346")
Local $Counter = 0
While Not(IsMainPage())
If _Sleep($delayEachCheck) Then Return True
If $clickAway Then ClickP($aAway, 2, 0, "#0346")
$Counter += 1
If $Counter > $maxRetry Then
Return False
EndIf
WEnd
Return True
EndFunc
Func ReturnHome($TakeSS = 1, $GoldChangeCheck = True)
If $g_iDebugSetlog = 1 Then Setlog("ReturnHome function... (from matchmode=" & $g_iMatchMode & " - " & $g_asModeText[$g_iMatchMode] & ")", $COLOR_DEBUG)
Local $counter = 0
Local $hBitmap_Scaled
Local $i, $j
If $g_bDESideDisableOther And $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] = 4 And $g_bDESideEndEnable And($dropQueen Or $dropKing) Then
SaveandDisableEBO()
SetLog("Disabling Normal End Battle Options", $COLOR_SUCCESS)
EndIf
If $GoldChangeCheck = True Then
If Not(IsReturnHomeBattlePage(True, False)) Then
SetLog("Checking if the battle has finished", $COLOR_INFO)
While GoldElixirChangeEBO()
If _Sleep($iDelayReturnHome1) Then Return
WEnd
If IsAttackPage() Then smartZap()
If($checkKPower = True Or $checkQPower = True Or $checkWPower = True) And $iActivateKQCondition = "Auto" Then
If _ColorCheck(_GetPixelColor($aRtnHomeCheck1[0], $aRtnHomeCheck1[1], True), Hex($aRtnHomeCheck1[2], 6), $aRtnHomeCheck1[3]) = False And _ColorCheck(_GetPixelColor($aRtnHomeCheck2[0], $aRtnHomeCheck2[1], True), Hex($aRtnHomeCheck2[2], 6), $aRtnHomeCheck2[3]) = False Then
If $checkKPower = True Then
SetLog("Activating King's power to restore some health before EndBattle", $COLOR_INFO)
If IsAttackPage() Then SelectDropTroop($King)
EndIf
If $checkQPower = True Then
SetLog("Activating Queen's power to restore some health before EndBattle", $COLOR_INFO)
If IsAttackPage() Then SelectDropTroop($Queen)
EndIf
If $checkWPower = True Then
SetLog("Activating Warden's power to restore some health before EndBattle", $COLOR_INFO)
If IsAttackPage() Then SelectDropTroop($Warden)
EndIf
EndIf
EndIf
Else
If $g_iDebugSetlog = 1 Then Setlog("Battle already over", $COLOR_DEBUG)
EndIf
EndIf
If $g_bDESideDisableOther And $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] = 4 And $g_bDESideEndEnable And($dropQueen Or $dropKing) Then
RevertEBO()
EndIf
$checkKPower = False
$checkQPower = False
$checkWPower = False
$HeroesTimerActivation[$eHeroBarbarianKing] = 0
$HeroesTimerActivation[$eHeroArcherQueen] = 0
$HeroesTimerActivation[$eHeroGrandWarden] = 0
If $g_abAttackTypeEnable[$TS] = 1 And $g_iMatchMode = $TS Then $g_bFirstStart = True
SetLog("Returning Home", $COLOR_INFO)
If $g_bRunState = False Then Return
If Not(IsReturnHomeBattlePage(True, False)) Then
$i = 0
While 1
If $g_iDebugSetlog = 1 Then SetDebugLog("Wait for surrender button to appear #" & $i)
If _CheckPixel($aSurrenderButton, $g_bCapturePixel) Then
If IsAttackPage() Then
ClickP($aSurrenderButton, 1, 0, "#0099")
$j = 0
While 1
If $g_iDebugSetlog = 1 Then SetDebugLog("Wait for OK button to appear #" & $j)
If IsEndBattlePage(False) Then
ClickOkay("SurrenderOkay")
ExitLoop 2
Else
$j += 1
EndIf
If ReturnHomeMainPage() Then Return
If $j > 10 Then ExitLoop
If _Sleep($iDelayReturnHome5) Then Return
WEnd
Else
$i += 1
EndIf
Else
$i += 1
EndIf
If ReturnHomeMainPage() Then Return
If $i > 5 Then ExitLoop
If _Sleep($iDelayReturnHome5) Then Return
WEnd
Else
If $g_iDebugSetlog = 1 Then Setlog("Battle already over.", $COLOR_DEBUG)
EndIf
If _Sleep($iDelayReturnHome2) Then Return
TrayTip($g_sBotTitle, "", BitOR($TIP_ICONASTERISK, $TIP_NOSOUND))
checkAndroidReboot(False)
If $GoldChangeCheck = True Then
If IsAttackPage() Then
$counter = 0
While _ColorCheck(_GetPixelColor($aRtnHomeCheck1[0], $aRtnHomeCheck1[1], True), Hex($aRtnHomeCheck1[2], 6), $aRtnHomeCheck1[3]) = False And _ColorCheck(_GetPixelColor($aRtnHomeCheck2[0], $aRtnHomeCheck2[1], True), Hex($aRtnHomeCheck2[2], 6), $aRtnHomeCheck2[3]) = False
If $g_iDebugSetlog = 1 Then SetDebugLog("Wait for Return Home Button to appear #" & $counter)
If _Sleep($iDelayReturnHome2) Then ExitLoop
$counter += 1
If $counter > 40 Then ExitLoop
WEnd
EndIf
If _Sleep($iDelayReturnHome3) Then Return
_CaptureRegion()
AttackReport()
EndIf
If $TakeSS = 1 And $GoldChangeCheck = True Then
SetLog("Taking snapshot of your loot", $COLOR_SUCCESS)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN
_CaptureRegion()
$hBitmap_Scaled = _GDIPlus_ImageResize($hBitmap, _GDIPlus_ImageGetWidth($hBitmap) / 2, _GDIPlus_ImageGetHeight($hBitmap) / 2)
If $ScreenshotLootInfo = 1 Then
$LootFileName = $Date & "_" & $Time & " G" & $g_iStatsLastAttack[$eLootGold] & " E" & $g_iStatsLastAttack[$eLootElixir] & " DE" & $g_iStatsLastAttack[$eLootDarkElixir] & " T" & $g_iStatsLastAttack[$eLootTrophy] & " S" & StringFormat("%3s", $SearchCount) & ".jpg"
Else
$LootFileName = $Date & "_" & $Time & ".jpg"
EndIf
_GDIPlus_ImageSaveToFile($hBitmap_Scaled, $g_sProfileLootsPath & $LootFileName)
_GDIPlus_ImageDispose($hBitmap_Scaled)
EndIf
If $GoldChangeCheck = True Then
PushMsg("LastRaid")
EndIf
$i = 0
While 1
If $g_iDebugSetlog = 1 Then SetDebugLog("Wait for End Fight Scene to appear #" & $i)
If _CheckPixel($aEndFightSceneAvl, $g_bCapturePixel) Then
If IsReturnHomeBattlePage() Then ClickP($aReturnHomeButton, 1, 0, "#0101")
ExitLoop
Else
$i += 1
EndIf
If $i > 10 Then ExitLoop
If _Sleep($iDelayReturnHome5) Then Return
WEnd
If _Sleep($iDelayReturnHome2) Then Return
$counter = 0
While 1
If $g_iDebugSetlog = 1 Then SetDebugLog("Wait for End Fight Scene to appear #" & $counter)
If _Sleep($iDelayReturnHome4) Then Return
If StarBonus() = True Then Setlog("Star Bonus window closed chief!", $COLOR_INFO)
If ReturnHomeMainPage() Then Return
$counter += 1
If $counter >= 50 Or isProblemAffect(True) Then
SetLog("Cannot return home.", $COLOR_ERROR)
checkMainScreen()
Return
EndIf
WEnd
EndFunc
Func ReturnHomeMainPage()
If IsMainPage(1) Then
_GUICtrlEdit_SetText($g_hTxtLog, _PadStringCenter(" BOT LOG ", 71, "="))
_GUICtrlRichEdit_SetFont($g_hTxtLog, 6, "Lucida Console")
_GUICtrlRichEdit_AppendTextColor($g_hTxtLog, "" & @CRLF, _ColorConvert($Color_Black))
Return True
EndIf
Return False
EndFunc
Func algorithm_AllTroops()
If $g_iDebugSetlog = 1 Then Setlog("algorithm_AllTroops", $COLOR_DEBUG)
SetSlotSpecialTroops()
If _Sleep($iDelayalgorithm_AllTroops1) Then Return
If $g_aiAttackStdDropSides[$g_iMatchMode] <> 4 Then
SmartAttackStrategy($g_iMatchMode)
EndIf
If($searchTH = "-" And($g_iMatchMode = $DB And $g_bTHSnipeBeforeEnable[$DB])) Or($searchTH = "-" And($g_iMatchMode = $LB And $g_bTHSnipeBeforeEnable[$LB])) Then
FindTownHall(True)
EndIf
Local $bTHSearchTemp = SearchTownHallLoc()
If $g_iMatchMode = $TS Or($g_iMatchMode = $DB And $g_bTHSnipeBeforeEnable[$DB] And $bTHSearchTemp = True) Or($g_iMatchMode = $LB And $g_bTHSnipeBeforeEnable[$LB] And $bTHSearchTemp = True) Then
SwitchAttackTHType()
EndIf
If $g_iMatchMode = $TS Then
If($THusedKing = 1 Or $THusedQueen = 1) And($ichkSmartZap = 1 And $ichkSmartZapSaveHeroes = 1) Then
SetLog("King and/or Queen dropped, close attack")
If $ichkSmartZap = 1 Then SetLog("Skipping SmartZap to protect your royals!", $COLOR_FUCHSIA)
ElseIf IsAttackPage() And Not SmartZap() And $THusedKing = 0 And $THusedQueen = 0 Then
Setlog("Wait few sec before close attack")
If _Sleep(Random(0, 2, 1) * 1000) Then Return
EndIf
If CompareResources($DB) And $g_aiAttackAlgorithm[$DB] = 0 And $g_bEndTSCampsEnable And Int($CurCamp / $TotalCamp * 100) >= Int($g_iEndTSCampsPct) Then
$g_iMatchMode = $DB
Else
CloseBattle()
Return
EndIf
EndIf
Local $nbSides = 0
Switch $g_aiAttackStdDropSides[$g_iMatchMode]
Case 0
SetLog("Attacking on a single side", $COLOR_INFO)
$nbSides = 1
Case 1
SetLog("Attacking on two sides", $COLOR_INFO)
$nbSides = 2
Case 2
SetLog("Attacking on three sides", $COLOR_INFO)
$nbSides = 3
Case 3
SetLog("Attacking on all sides", $COLOR_INFO)
$nbSides = 4
Case 4
SetLog("Attacking four finger fight style", $COLOR_BLUE)
$nbSides = 5
Case 5
SetLog("Attacking on Dark Elixir Side.", $COLOR_INFO)
$nbSides = 1
If Not($g_abAttackStdSmartAttack[$g_iMatchMode]) Then GetBuildingEdge($eSideBuildingDES)
Case 6
SetLog("Attacking on Town Hall Side.", $COLOR_INFO)
$nbSides = 1
If Not($g_abAttackStdSmartAttack[$g_iMatchMode]) Then GetBuildingEdge($eSideBuildingTH)
EndSwitch
If($nbSides = 0) Then Return
If _Sleep($iDelayalgorithm_AllTroops2) Then Return
Local $SlotsGiants = 1
LocaL $GiantComp = $g_ahTxtTrainArmyTroopCount[$eTroopGiant]
If Number($GiantComp) > 16 Or(Number($GiantComp) >= 8 And $nbSides = 5) Then $SlotsGiants = 2
If Number($GiantComp) > 20 Or(Number($GiantComp) >= 12 And $nbSides = 5) Then $SlotsGiants = 0
If $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] = 5 Then
Switch $g_aiAttackStdDropOrder[$g_iMatchMode]
Case 0
Local $listInfoDeploy[21][5] = [[$eGole, $nbSides, 1, 1, 2] , [$eLava, $nbSides, 1, 1, 2] , [$eGiant, $nbSides, 1, 1, $SlotsGiants] , [$eDrag, $nbSides, 1, 1, 0] , [$eBall, $nbSides, 1, 1, 0] , [$eBabyD, $nbSides, 1, 1, 1] , [$eHogs, $nbSides, 1, 1, 1] , [$eValk, $nbSides, 1, 1, 0] , [$eBowl, $nbSides, 1, 1, 0] , [$eMine, $nbSides, 1, 1, 0] , [$eBarb, $nbSides, 1, 1, 0] , [$eWall, $nbSides, 1, 1, 1] , [$eArch, $nbSides, 1, 1, 0] , [$eWiza, $nbSides, 1, 1, 0] , [$eMini, $nbSides, 1, 1, 0] , [$eWitc, $nbSides, 1, 1, 1] , [$eGobl, $nbSides, 1, 1, 0] , ["CC", 1, 1, 1, 1] , [$eHeal, $nbSides, 1, 1, 1] , [$ePekk, $nbSides, 1, 1, 1] , ["HEROES", 1, 2, 1, 1] ]
Case 1
Local $listInfoDeploy[6][5] = [[$eBarb, $nbSides, 1, 1, 0] , [$eArch, $nbSides, 1, 1, 0] , [$eGobl, $nbSides, 1, 1, 0] , [$eMini, $nbSides, 1, 1, 0] , ["CC", 1, 1, 1, 1] , ["HEROES", 1, 2, 1, 1] ]
Case 2
Local $listInfoDeploy[13][5] = [[$eGiant, $nbSides, 1, 1, $SlotsGiants] , [$eWall, $nbSides, 1, 1, 2] , [$eBarb, $nbSides, 1, 2, 2] , [$eArch, $nbSides, 1, 3, 3] , [$eBarb, $nbSides, 2, 2, 2] , [$eArch, $nbSides, 2, 3, 3] , ["CC", 1, 1, 1, 1] , ["HEROES", 1, 2, 1, 0] , [$eHogs, $nbSides, 1, 1, 1] , [$eWiza, $nbSides, 1, 1, 0] , [$eMini, $nbSides, 1, 1, 0] , [$eArch, $nbSides, 3, 3, 2] , [$eGobl, $nbSides, 1, 1, 1] ]
EndSwitch
ElseIf $nbSides = 5 Then
Local $listInfoDeploy[21][5] = [[$eGiant, $nbSides, 1, 1, $SlotsGiants], [$eGole, $nbSides, 1, 1, 2], [$eLava, $nbSides, 1, 1, 2], [$eBarb, $nbSides, 1, 1, 0], [$eWall, $nbSides, 1, 1, 2], [$eHogs, $nbSides, 1, 1, 2], [$eValk, $nbSides, 1, 1, 2], [$eBowl, $nbSides, 1, 1, 0], [$eArch, $nbSides, 1, 1, 0], [$eGobl, $nbSides, 1, 1, 0], [$eMine, $nbSides, 1, 1, 0], [$ePekk, $nbSides, 1, 1, 2], [$eDrag, $nbSides, 1, 1, 2], [$eBall, $nbSides, 1, 1, 2], [$eBabyD, $nbSides, 1, 1, 1], [$eWiza, $nbSides, 1, 1, 2], [$eWitc, $nbSides, 1, 1, 2], [$eMini, $nbSides, 1, 1, 0], ["CC", 1, 1, 1, 1], ["HEROES", 1, 2, 1, 1]]
Else
If $g_iDebugSetlog = 1 Then SetLog("listdeploy standard for attack", $COLOR_DEBUG)
Switch $g_aiAttackStdDropOrder[$g_iMatchMode]
Case 0
Local $listInfoDeploy[21][5] = [[$eGole, $nbSides, 1, 1, 2] , [$eLava, $nbSides, 1, 1, 2] , [$eGiant, $nbSides, 1, 1, $SlotsGiants] , [$eDrag, $nbSides, 1, 1, 0] , [$eBall, $nbSides, 1, 1, 0] , [$eBabyD, $nbSides, 1, 1, 0] , [$eHogs, $nbSides, 1, 1, 1] , [$eValk, $nbSides, 1, 1, 0] , [$eBowl, $nbSides, 1, 1, 0] , [$eMine, $nbSides, 1, 1, 0] , [$eBarb, $nbSides, 1, 1, 0] , [$eWall, $nbSides, 1, 1, 1] , [$eArch, $nbSides, 1, 1, 0] , [$eWiza, $nbSides, 1, 1, 0] , [$eMini, $nbSides, 1, 1, 0] , [$eWitc, $nbSides, 1, 1, 1] , [$eGobl, $nbSides, 1, 1, 0] , ["CC", 1, 1, 1, 1] , [$eHeal, $nbSides, 1, 1, 1] , [$ePekk, $nbSides, 1, 1, 1] , ["HEROES", 1, 2, 1, 1] ]
Case 1
Local $listInfoDeploy[6][5] = [[$eBarb, $nbSides, 1, 1, 0] , [$eArch, $nbSides, 1, 1, 0] , [$eGobl, $nbSides, 1, 1, 0] , [$eMini, $nbSides, 1, 1, 0] , ["CC", 1, 1, 1, 1] , ["HEROES", 1, 2, 1, 1] ]
Case 2
Local $listInfoDeploy[13][5] = [[$eGiant, $nbSides, 1, 1, $SlotsGiants] , [$eBarb, $nbSides, 1, 2, 0] , [$eWall, $nbSides, 1, 1, 1] , [$eArch, $nbSides, 1, 2, 0] , [$eBarb, $nbSides, 2, 2, 0] , [$eGobl, $nbSides, 1, 2, 0] , ["CC", 1, 1, 1, 1] , [$eHogs, $nbSides, 1, 1, 1] , [$eWiza, $nbSides, 1, 1, 0] , [$eMini, $nbSides, 1, 1, 0] , [$eArch, $nbSides, 2, 2, 0] , [$eGobl, $nbSides, 2, 2, 0] , ["HEROES", 1, 2, 1, 1] ]
Case Else
SetLog("Algorithm type unavailable, defaulting to regular", $COLOR_ERROR)
Local $listInfoDeploy[13][5] = [[$eGiant, $nbSides, 1, 1, $SlotsGiants] , [$eBarb, $nbSides, 1, 2, 0] , [$eWall, $nbSides, 1, 1, 1] , [$eArch, $nbSides, 1, 2, 0] , [$eBarb, $nbSides, 2, 2, 0] , [$eGobl, $nbSides, 1, 2, 0] , ["CC", 1, 1, 1, 1] , [$eHogs, $nbSides, 1, 1, 1] , [$eWiza, $nbSides, 1, 1, 0] , [$eMini, $nbSides, 1, 1, 0] , [$eArch, $nbSides, 2, 2, 0] , [$eGobl, $nbSides, 2, 2, 0] , ["HEROES", 1, 2, 1, 1] ]
EndSwitch
EndIf
$isCCDropped = False
$DeployCCPosition[0] = -1
$DeployCCPosition[1] = -1
$isHeroesDropped = False
$DeployHeroesPosition[0] = -1
$DeployHeroesPosition[1] = -1
LaunchTroop2($listInfoDeploy, $CC, $King, $Queen, $Warden)
Setlog("- Activate Heroes Condition: " & $iActivateKQCondition, $COLOR_INFO)
If $iActivateWardenCondition = 1 Then Setlog(" » Timed Warden in: " & $delayActivateW & "´s", $COLOR_INFO)
If $iActivateKQCondition = "Manual" Or $iActivateWardenCondition = 1 Then
$HeroesTimerActivation[$eHeroBarbarianKing] = 0
$HeroesTimerActivation[$eHeroArcherQueen] = 0
$HeroesTimerActivation[$eHeroGrandWarden] = 0
Setlog(" - Initial Timer from Heroes")
If $checkKPower Then $HeroesTimerActivation[$eHeroBarbarianKing] = TimerInit()
If $checkQPower Then $HeroesTimerActivation[$eHeroArcherQueen] = TimerInit()
If $checkWPower Then $HeroesTimerActivation[$eHeroGrandWarden] = TimerInit()
EndIf
If _Sleep($iDelayalgorithm_AllTroops4) Then Return
SetLog("Dropping left over troops", $COLOR_INFO)
For $x = 0 To 1
If PrepareAttack($g_iMatchMode, True) = 0 Then
If $g_iDebugSetlog = 1 Then Setlog("No Wast time... exit, no troops usable left", $COLOR_DEBUG)
ExitLoop
EndIf
For $i = $eBarb To $eBowl
LauchTroop($i, $nbSides, 0, 1)
CheckHeroesHealth()
If _Sleep($iDelayalgorithm_AllTroops5) Then Return
Next
Next
CheckHeroesHealth()
SetLog("Finished Attacking, waiting for the battle to end")
EndFunc
Func SetSlotSpecialTroops()
$King = -1
$Queen = -1
$CC = -1
$Warden = -1
For $i = 0 To UBound($atkTroops) - 1
If $atkTroops[$i][0] = $eCastle Then
$CC = $i
ElseIf $atkTroops[$i][0] = $eKing Then
$King = $i
ElseIf $atkTroops[$i][0] = $eQueen Then
$Queen = $i
ElseIf $atkTroops[$i][0] = $eWarden Then
$Warden = $i
EndIf
Next
If $g_iDebugSetlog = 1 Then SetLog("Use king SLOT # " & $King, $COLOR_DEBUG)
If $g_iDebugSetlog = 1 Then SetLog("Use queen SLOT # " & $Queen, $COLOR_DEBUG)
If $g_iDebugSetlog = 1 Then SetLog("Use CC SLOT # " & $CC, $COLOR_DEBUG)
If $g_iDebugSetlog = 1 Then SetLog("Use Warden SLOT # " & $Warden, $COLOR_DEBUG)
EndFunc
Func CloseBattle()
If IsAttackPage() Then
For $i = 1 To 30
If _ColorCheck(_GetPixelColor($aWonOneStar[0], $aWonOneStar[1], True), Hex($aWonOneStar[2], 6), $aWonOneStar[3]) = True Then ExitLoop
If _Sleep($iDelayalgorithm_AllTroops2) Then Return
Next
EndIf
If IsAttackPage() Then ClickP($aSurrenderButton, 1, 0, "#0030")
If _Sleep($iDelayalgorithm_AllTroops3) Then Return
If IsEndBattlePage() Then
ClickP($aConfirmSurrender, 1, 0, "#0031")
If _Sleep($iDelayalgorithm_AllTroops1) Then Return
EndIf
EndFunc
Func SmartAttackStrategy($imode)
If $g_iMatchMode <> $MA Then
If($g_abAttackStdSmartAttack[$imode]) Then
SetLog("Calculating Smart Attack Strategy", $COLOR_INFO)
Local $hTimer = TimerInit()
_CaptureRegion2()
_GetRedArea()
SetLog("Calculated  (in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds) :")
If($g_abAttackStdSmartNearCollectors[$imode][0] Or $g_abAttackStdSmartNearCollectors[$imode][1] Or $g_abAttackStdSmartNearCollectors[$imode][2]) Then
SetLog("Locating Mines, Collectors & Drills", $COLOR_INFO)
$hTimer = TimerInit()
Global $PixelMine[0]
Global $PixelElixir[0]
Global $PixelDarkElixir[0]
Global $PixelNearCollector[0]
If $g_abAttackStdSmartNearCollectors[$imode][0] Then
$PixelMine = GetLocationMine()
If(IsArray($PixelMine)) Then
_ArrayAdd($PixelNearCollector, $PixelMine)
EndIf
EndIf
If $g_abAttackStdSmartNearCollectors[$imode][1] Then
$PixelElixir = GetLocationElixir()
If(IsArray($PixelElixir)) Then
_ArrayAdd($PixelNearCollector, $PixelElixir)
EndIf
EndIf
If $g_abAttackStdSmartNearCollectors[$imode][2] Then
$PixelDarkElixir = GetLocationDarkElixir()
If(IsArray($PixelDarkElixir)) Then
_ArrayAdd($PixelNearCollector, $PixelDarkElixir)
EndIf
EndIf
SetLog("Located  (in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds) :")
SetLog("[" & UBound($PixelMine) & "] Gold Mines")
SetLog("[" & UBound($PixelElixir) & "] Elixir Collectors")
SetLog("[" & UBound($PixelDarkElixir) & "] Dark Elixir Drill/s")
$g_iNbrOfDetectedMines[$CurrentAccount][$imode] += UBound($PixelMine)
$g_iNbrOfDetectedCollectors[$CurrentAccount][$imode] += UBound($PixelElixir)
$g_iNbrOfDetectedDrills[$CurrentAccount][$imode] += UBound($PixelDarkElixir)
UpdateStats()
EndIf
EndIf
EndIf
EndFunc
Func DropTroop($troop, $nbSides, $number, $slotsPerEdge = 0, $indexToAttack = -1)
If isProblemAffect(True) Then Return
Local $nameFunc = "[DropTroop]"
debugRedArea($nameFunc & " IN ")
debugRedArea("troop : [" & $troop & "] / nbSides : [" & $nbSides & "] / number : [" & $number & "] / slotsPerEdge [" & $slotsPerEdge & "]")
If($g_abAttackStdSmartAttack[$g_iMatchMode]) and $g_aiAttackStdDropSides[$g_iMatchMode] <> 4 Then
If $slotsPerEdge = 0 Or $number < $slotsPerEdge Then $slotsPerEdge = $number
If _Sleep($iDelayDropTroop1) Then Return
SelectDropTroop($troop)
If _Sleep($iDelayDropTroop2) Then Return
If $nbSides < 1 Then Return
Local $nbTroopsLeft = $number
If($g_abAttackStdSmartNearCollectors[$g_iMatchMode][0] = False And $g_abAttackStdSmartNearCollectors[$g_iMatchMode][1] = False And $g_abAttackStdSmartNearCollectors[$g_iMatchMode][2] = False) Then
If $nbSides = 4 Then
Local $edgesPixelToDrop = GetPixelDropTroop($troop, $number, $slotsPerEdge)
For $i = 0 To $nbSides - 3
Local $nbTroopsPerEdge = Round($nbTroopsLeft /($nbSides - $i * 2))
If($number > 0 And $nbTroopsPerEdge = 0) Then $nbTroopsPerEdge = 1
Local $listEdgesPixelToDrop[2] = [$edgesPixelToDrop[$i], $edgesPixelToDrop[$i + 2]]
DropOnPixel($troop, $listEdgesPixelToDrop, $nbTroopsPerEdge, $slotsPerEdge)
$nbTroopsLeft -= $nbTroopsPerEdge * 2
Next
Return
EndIf
For $i = 0 To $nbSides - 1
If $nbSides = 1 Or($nbSides = 3 And $i = 2) Then
Local $nbTroopsPerEdge = Round($nbTroopsLeft /($nbSides - $i))
If($number > 0 And $nbTroopsPerEdge = 0) Then $nbTroopsPerEdge = 1
Local $edgesPixelToDrop = GetPixelDropTroop($troop, $nbTroopsPerEdge, $slotsPerEdge)
Local $listEdgesPixelToDrop[1] = [$edgesPixelToDrop[$i]]
DropOnPixel($troop, $listEdgesPixelToDrop, $nbTroopsPerEdge, $slotsPerEdge)
$nbTroopsLeft -= $nbTroopsPerEdge
ElseIf($nbSides = 2 And $i = 0) Or($nbSides = 3 And $i <> 1) Then
Local $nbTroopsPerEdge = Round($nbTroopsLeft /($nbSides - $i * 2))
If($number > 0 And $nbTroopsPerEdge = 0) Then $nbTroopsPerEdge = 1
Local $edgesPixelToDrop = GetPixelDropTroop($troop, $nbTroopsPerEdge, $slotsPerEdge)
Local $listEdgesPixelToDrop[2] = [$edgesPixelToDrop[$i + 3], $edgesPixelToDrop[$i + 1]]
DropOnPixel($troop, $listEdgesPixelToDrop, $nbTroopsPerEdge, $slotsPerEdge)
$nbTroopsLeft -= $nbTroopsPerEdge * 2
EndIf
Next
Else
Local $listEdgesPixelToDrop[0]
If($indexToAttack <> -1) Then
Local $nbTroopsPerEdge = $number
Local $maxElementNearCollector = $indexToAttack
Local $startIndex = $indexToAttack
Else
Local $nbTroopsPerEdge = Round($number / UBound($PixelNearCollector))
Local $maxElementNearCollector = UBound($PixelNearCollector) - 1
Local $startIndex = 0
EndIf
If($number > 0 And $nbTroopsPerEdge = 0) Then $nbTroopsPerEdge = 1
For $i = $startIndex To $maxElementNearCollector
Local $pixel = $PixelNearCollector[$i]
ReDim $listEdgesPixelToDrop[UBound($listEdgesPixelToDrop) + 1]
If($troop = $eArch Or $troop = $eWiza Or $troop = $eMini Or $troop = $eBarb) Then
$listEdgesPixelToDrop[UBound($listEdgesPixelToDrop) - 1] = _FindPixelCloser($PixelRedAreaFurther, $pixel, 5)
Else
$listEdgesPixelToDrop[UBound($listEdgesPixelToDrop) - 1] = _FindPixelCloser($PixelRedArea, $pixel, 5)
EndIf
Next
DropOnPixel($troop, $listEdgesPixelToDrop, $nbTroopsPerEdge, $slotsPerEdge)
EndIf
Else
DropOnEdges($troop, $nbSides, $number, $slotsPerEdge)
EndIf
debugRedArea($nameFunc & " OUT ")
EndFunc
Func DropTroop2($troop, $nbSides, $number, $slotsPerEdge = 0, $name = "")
Local $nameFunc = "[DropTroop2]"
debugRedArea($nameFunc & " IN ")
debugRedArea("troop : [" & $troop & "] / nbSides : [" & $nbSides & "] / number : [" & $number & "] / slotsPerEdge [" & $slotsPerEdge & "]")
Local $listInfoPixelDropTroop[0]
If($g_abAttackStdSmartAttack[$g_iMatchMode]) Then
If $slotsPerEdge = 0 Or $number < $slotsPerEdge Then $slotsPerEdge = $number
If $nbSides < 1 Then Return
Local $nbTroopsLeft = $number
Local $nbTroopsPerEdge = Round($nbTroopsLeft / $nbSides)
If(($g_abAttackStdSmartNearCollectors[$g_iMatchMode][0] = False And $g_abAttackStdSmartNearCollectors[$g_iMatchMode][1] = False And $g_abAttackStdSmartNearCollectors[$g_iMatchMode][2] = False) Or UBound($PixelNearCollector) = 0) Then
If($number > 0 And $nbTroopsPerEdge = 0) Then $nbTroopsPerEdge = 1
If $nbSides = 4 Then
ReDim $listInfoPixelDropTroop[UBound($listInfoPixelDropTroop) + 4]
Local $listInfoPixelDropTroop = GetPixelDropTroop($troop, $number, $slotsPerEdge)
Else
For $i = 0 To $nbSides - 1
If $nbSides = 1 Or($nbSides = 3 And $i = 2) Then
Local $edgesPixelToDrop = GetPixelDropTroop($troop, $nbTroopsPerEdge, $slotsPerEdge)
ReDim $listInfoPixelDropTroop[UBound($listInfoPixelDropTroop) + 1]
$listInfoPixelDropTroop[UBound($listInfoPixelDropTroop) - 1] = $edgesPixelToDrop[$i]
ElseIf($nbSides = 2 And $i = 0) Or($nbSides = 3 And $i <> 1) Then
Local $edgesPixelToDrop = GetPixelDropTroop($troop, $nbTroopsPerEdge, $slotsPerEdge)
ReDim $listInfoPixelDropTroop[UBound($listInfoPixelDropTroop) + 2]
$listInfoPixelDropTroop[UBound($listInfoPixelDropTroop) - 2] = $edgesPixelToDrop[$i + 3]
$listInfoPixelDropTroop[UBound($listInfoPixelDropTroop) - 1] = $edgesPixelToDrop[$i + 1]
EndIf
Next
EndIf
Else
Local $nbTroopsPerEdge = Round($number / UBound($PixelNearCollector))
If($number > 0 And $nbTroopsPerEdge = 0) Then $nbTroopsPerEdge = 1
Local $maxElementNearCollector = UBound($PixelNearCollector) - 1
Local $startIndex = 0
Local $troopFurther = False
If($troop = $eArch Or $troop = $eWiza Or $troop = $eMini Or $troop = $eBarb) Then
$troopFurther = True
EndIf
Local $centerPixel[2] = [430, 338]
For $i = $startIndex To $maxElementNearCollector
Local $pixel = $PixelNearCollector[$i]
ReDim $listInfoPixelDropTroop[UBound($listInfoPixelDropTroop) + 1]
Local $arrPixelToSearch
If($pixel[0] < $centerPixel[0] And $pixel[1] < $centerPixel[1]) Then
If($troopFurther) Then
$arrPixelToSearch = $PixelTopLeftFurther
Else
$arrPixelToSearch = $PixelTopLeft
EndIf
ElseIf($pixel[0] < $centerPixel[0] And $pixel[1] > $centerPixel[1]) Then
If($troopFurther) Then
$arrPixelToSearch = $PixelBottomLeftFurther
Else
$arrPixelToSearch = $PixelBottomLeft
EndIf
ElseIf($pixel[0] > $centerPixel[0] And $pixel[1] > $centerPixel[1]) Then
If($troopFurther) Then
$arrPixelToSearch = $PixelBottomRightFurther
Else
$arrPixelToSearch = $PixelBottomRight
EndIf
Else
If($troopFurther) Then
$arrPixelToSearch = $PixelTopRightFurther
Else
$arrPixelToSearch = $PixelTopRight
EndIf
EndIf
$listInfoPixelDropTroop[UBound($listInfoPixelDropTroop) - 1] = _FindPixelCloser($arrPixelToSearch, $pixel, 1)
Next
EndIf
Else
DropOnEdges($troop, $nbSides, $number, $slotsPerEdge)
EndIf
Local $infoDropTroop[6] = [$troop, $listInfoPixelDropTroop, $nbTroopsPerEdge, $slotsPerEdge, $number, $name]
debugRedArea($nameFunc & " OUT ")
Return $infoDropTroop
EndFunc
Func GetLocationMine()
Local $directory = @ScriptDir & "\imgxml\Storages\SideP\GoldMines"
Local $txt = "Mines"
Local $Maxpositions = 7
If $iDetectedImageType = 1 Then
$directory = @ScriptDir & "\imgxml\Storages\Mines_Snow"
$txt = "SnowMines"
EndIf
Local $aResult = returnMultipleMatches($directory, $Maxpositions)
Local $result = ConvertImgloc2MBR($aResult, $Maxpositions)
If $g_iDebugBuildingPos = 1 Then Setlog("#*# GetLocation"& $txt &": " & $result, $COLOR_DEBUG1)
If $g_iDebugGetLocation = 1 Then DebugImageGetLocation($result, $txt)
Return GetListPixel($result)
EndFunc
Func GetLocationElixir()
Local $directory = @ScriptDir & "\imgxml\Storages\SideP\Collectors"
Local $txt = "Collectors"
Local $Maxpositions = 7
If $iDetectedImageType = 1 Then
$directory = @ScriptDir & "\imgxml\Storages\Collectors_Snow"
$txt = "SnowCollectors"
EndIf
Local $aResult = returnMultipleMatches($directory, $Maxpositions)
Local $result = ConvertImgloc2MBR($aResult, $Maxpositions)
If $g_iDebugBuildingPos = 1 Then Setlog("#*# GetLocation"& $txt &": " & $result, $COLOR_DEBUG1)
If $g_iDebugGetLocation = 1 Then DebugImageGetLocation($result, $txt)
Return GetListPixel($result)
EndFunc
Func GetLocationDarkElixir()
Local $directory = @ScriptDir & "\imgxml\Storages\Drills"
Local $Maxpositions = 3
Local $aResult = returnMultipleMatches($directory, $Maxpositions)
Local $result = ConvertImgloc2MBR($aResult, $Maxpositions)
If $g_iDebugBuildingPos = 1 Then Setlog("#*# GetLocationDarkElixir: " & $result, $COLOR_DEBUG1)
If $g_iDebugGetLocation = 1 Then DebugImageGetLocation($result, "DarkElixir")
Return GetListPixel($result)
EndFunc
Func GetLocationTownHall()
Local $result = DllCall($g_hLibFunctions, "str", "getLocationTownHall", "ptr", $hHBitmap2)
If $g_iDebugBuildingPos = 1 Then Setlog("#*# GetLocationTownHall: " & $result[0], $COLOR_DEBUG1)
If $g_iDebugGetLocation = 1 Then DebugImageGetLocation($result[0], "TownHall")
Return GetListPixel($result[0])
EndFunc
Func GetLocationDarkElixirStorageWithLevel()
Local $result = DllCall($g_hLibFunctions, "str", "getLocationDarkElixirStorageWithLevel", "ptr", $hHBitmap2)
If $g_iDebugBuildingPos = 1 Then Setlog("#*# GetLocationDarkElixirStorageWithLevel: " & $result[0], $COLOR_DEBUG1)
If $g_iDebugGetLocation = 1 Then DebugImageGetLocation($result[0], "DarkElixirStorageWithLevel")
Return $result[0]
EndFunc
Func GetLocationDarkElixirStorage()
Local $result = DllCall($g_hLibFunctions, "str", "getLocationDarkElixirStorage", "ptr", $hHBitmap2)
If $g_iDebugBuildingPos = 1 Then Setlog("#*# GetLocationDarkElixirStorage: " & $result[0], $COLOR_DEBUG1)
If $g_iDebugGetLocation = 1 Then DebugImageGetLocation($result[0], "DarkElixirStorage")
Return GetListPixel($result[0])
EndFunc
Func GetLocationElixirWithLevel()
If $iDetectedImageType = 0 Then
Local $result = DllCall($g_hLibFunctions, "str", "getLocationElixirExtractorWithLevel", "ptr", $hHBitmap2)
If $g_iDebugBuildingPos = 1 Then Setlog("#*# getLocationElixirExtractorWithLevel: " & $result[0], $COLOR_DEBUG1)
If $g_iDebugGetLocation = 1 Then DebugImageGetLocation($result[0], "ElixirExtractorWithLevel")
Else
Local $result = DllCall($g_hLibFunctions, "str", "getLocationSnowElixirExtractorWithLevel", "ptr", $hHBitmap2)
If $g_iDebugBuildingPos = 1 Then Setlog("#*# getLocationSnowElixirExtractorWithLevel: " & $result[0], $COLOR_DEBUG1)
If $g_iDebugGetLocation = 1 Then DebugImageGetLocation($result[0], "SnowElixirExtractorWithLevel")
EndIf
Return $result[0]
EndFunc
Func GetLocationMineWithLevel()
If $iDetectedImageType = 0 Then
Local $result = DllCall($g_hLibFunctions, "str", "getLocationMineExtractorWithLevel", "ptr", $hHBitmap2)
If $g_iDebugBuildingPos = 1 Then Setlog("#*# getLocationMineExtractorWithLevel: " & $result[0], $COLOR_DEBUG1)
If $g_iDebugGetLocation = 1 Then DebugImageGetLocation($result[0], "MineExtractorWithLevel")
Else
Local $result = DllCall($g_hLibFunctions, "str", "getLocationSnowMineExtractorWithLevel", "ptr", $hHBitmap2)
If $g_iDebugBuildingPos = 1 Then Setlog("#*# getLocationSnowMineExtractorWithLevel: " & $result[0], $COLOR_DEBUG1)
If $g_iDebugGetLocation = 1 Then DebugImageGetLocation($result[0], "SnowMineExtractorWithLevel")
EndIf
Return $result[0]
EndFunc
Func GetLocationDarkElixirWithLevel()
Local $directory = @ScriptDir & "\imgxml\Storages\Drills"
Local $Maxpositions = 3
Local $aResult = returnMultipleMatches($directory, $Maxpositions)
Local $result = ConvertImgloc2MBR($aResult, $Maxpositions, True)
If $g_iDebugBuildingPos = 1 Then Setlog("#*# getLocationDarkElixirExtractorWithLevel: " & $result, $COLOR_DEBUG1)
If $g_iDebugGetLocation = 1 Then DebugImageGetLocation($result, "DarkElixirExtractorWithLevel")
Return $result
EndFunc
Func GetLocationGoldStorage()
Local $hTimer = TimerInit()
Local $directory = @ScriptDir & "\imgxml\Storages\Gold"
Local $TempVectStr
Local $TotalStorages = 0
Local $TotalObjects = 0
Local $GoldStorageXY
Local $maxReturnPoints = 4
Local $redLines = ""
Local $minLevel = 0
Local $maxLevel = 12
Local $statFile = ""
If $g_iDebugSetlog = 1 Then SetLog("Started the function | GetLocationGoldStorage")
Local $aResult = returnMultipleMatches($directory, $maxReturnPoints, $redLines, $statFile, $minLevel, $maxLevel)
If UBound($aResult) > 1 Then
For $i = 1 To UBound($aResult) - 1
Local $Filename = $aResult[$i][1]
$TotalObjects = $aResult[$i][4]
$GoldStorageXY = $aResult[$i][5]
If IsArray($GoldStorageXY) And $TotalObjects > 0 Then
For $t = 0 To UBound($GoldStorageXY) - 1
If $g_iDebugSetlog = 1 Then SetLog($Filename & " found (" & $GoldStorageXY[$t][0] & "," & $GoldStorageXY[$t][1] & ")", $COLOR_SUCCESS)
$TempVectStr &= $GoldStorageXY[$t][0] & "-" & $GoldStorageXY[$t][1] & "|"
$TotalStorages += 1
If $TotalStorages >= 4 Then ExitLoop(2)
Next
EndIf
Next
EndIf
If $g_iDebugSetlog = 1 Then SetLog("  - Calculated  in: " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds ", $COLOR_DEBUG1)
If StringLen($TempVectStr) > 0 Then
$TempVectStr = StringLeft($TempVectStr, StringLen($TempVectStr) - 1)
If $g_iDebugGetLocation = 1 Then DebugImageGetLocation($TempVectStr, "GoldStorage")
Local $InputVect = GetListPixel($TempVectStr)
SetLog("Total Gold Storages :" & $TotalStorages)
Return $InputVect
Else
Return 0
EndIf
EndFunc
Func GetLocationElixirStorage()
Local $hTimer = TimerInit()
Local $directory = @ScriptDir & "\imgxml\Storages\Elixir"
Local $TempVectStr
Local $TotalStorages = 0
Local $TotalObjects = 0
Local $ElixirStorageXY
Local $maxReturnPoints = 4
Local $redLines = ""
Local $minLevel = 0
Local $maxLevel = 12
Local $statFile = ""
If $g_iDebugSetlog = 1 Then SetLog("Started the function | GetLocationElixirStorage")
Local $aResult = returnMultipleMatches($directory, $maxReturnPoints, $redLines, $statFile, $minLevel, $maxLevel)
If UBound($aResult) > 1 Then
For $i = 1 To UBound($aResult) - 1
Local $Filename = $aResult[$i][1]
$TotalObjects = $aResult[$i][4]
$ElixirStorageXY = $aResult[$i][5]
If IsArray($ElixirStorageXY) And $TotalObjects > 0 Then
For $t = 0 To UBound($ElixirStorageXY) - 1
If $g_iDebugSetlog = 1 Then SetLog($Filename & " found (" & $ElixirStorageXY[$t][0] & "," & $ElixirStorageXY[$t][1] & ")", $COLOR_SUCCESS)
$TempVectStr &= $ElixirStorageXY[$t][0] & "-" & $ElixirStorageXY[$t][1] & "|"
$TotalStorages += 1
If $TotalStorages >= 4 Then ExitLoop(2)
Next
EndIf
Next
EndIf
If $g_iDebugSetlog = 1 Then SetLog("  - Calculated  in: " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds ", $COLOR_DEBUG1)
If StringLen($TempVectStr) > 0 Then
$TempVectStr = StringLeft($TempVectStr, StringLen($TempVectStr) - 1)
Local $InputVect = GetListPixel($TempVectStr)
SetLog("Total Elixirr Storages :" & $TotalStorages)
If $g_iDebugGetLocation = 1 Then DebugImageGetLocation($TempVectStr, "ElixirStorage")
Return $InputVect
Else
Return 0
EndIf
EndFunc
Func DebugImageGetLocation($vectorstr, $type)
setlog("DebugImage .............................")
setlog("input: " & $vectorstr)
setlog("type: " & $type)
Switch $type
Case "DarkElixirStorageWithLevel", "ElixirExtractorWithLevel", "SnowElixirExtractorWithLevel", "MineExtractorWithLevel", "SnowMineExtractorWithLevel", "DarkElixirExtractorWithLevel"
Local $vector = StringSplit($vectorstr, "~", 2)
Setlog("-- " & $type)
For $i = 0 To UBound($vector) - 1
Setlog($type & " " & $i & " --> " & $vector[$i])
Local $temp = StringSplit($vector[$i], "#", 2)
If UBound($temp) = 2 Then
Local $pixel = StringSplit($temp[1], "-", 2)
If UBound($pixel) = 2 Then
If isInsideDiamondRedArea($pixel) Then
If $g_iDebugSetlog = 1 Then Setlog("coordinate inside village (" & $pixel[0] & "," & $pixel[1] & ")")
_CaptureRegion($pixel[0] - 30, $pixel[1] - 30, $pixel[0] + 30, $pixel[1] + 30)
DebugImageSave("DebugImageGetLocation_" & $type & "_", False)
Else
If $g_iDebugSetlog = 1 Then Setlog("coordinate out of village (" & $pixel[0] & "," & $pixel[1] & ")")
EndIf
EndIf
EndIf
Next
Case "Mine", "SnowMine", "Elixir", "SnowElixir", "DarkElixir", "TownHall", "DarkElixirStorage", "GoldStorage", "ElixirStorage"
Local $vector = StringSplit($vectorstr, "|", 2)
Setlog("-- " & $type)
For $i = 0 To UBound($vector) - 1
Local $pixel = StringSplit($vector[$i], "-", 2)
If UBound($pixel) = 2 Then
If isInsideDiamondRedArea($pixel) Then
If $g_iDebugSetlog = 1 Then Setlog("coordinate inside village (" & $pixel[0] & "," & $pixel[1] & ")")
_CaptureRegion($pixel[0] - 30, $pixel[1] - 30, $pixel[0] + 30, $pixel[1] + 30)
DebugImageSave("DebugImageGetLocation_" & $type & "_", False)
Else
If $g_iDebugSetlog = 1 Then Setlog("coordinate out of village (" & $pixel[0] & "," & $pixel[1] & ")")
EndIf
EndIf
Next
Case Else
setlog("!!!!!!")
EndSwitch
setlog("-------------------------------------------")
EndFunc
Func ConvertImgloc2MBR($Array, $Maxpositions, $level = False)
Local $StringConverted = Null
Local $Max = 0
If IsArray($Array) Then
For $i = 1 To UBound($Array) - 1
Local $Coord = $Array[$i][5]
If IsArray($Coord) Then
For $t = 0 To UBound($Coord) - 1
If isInsideDiamondXY($Coord[$t][0], $Coord[$t][1]) Then
If $level = true then $StringConverted &= $Array[$i][2] & "#" & $Coord[$t][0] & "-" & $Coord[$t][1] & "~"
If $level = false then $StringConverted &= $Coord[$t][0] & "-" & $Coord[$t][1] & "|"
$Max += 1
If $Max = $Maxpositions Then ExitLoop(2)
EndIf
Next
EndIf
Next
Else
Setlog("Error on Imgloc detection Mines|Collectors|Drills", $COLOR_RED)
EndIf
$StringConverted = StringTrimRight($StringConverted, 1)
If $g_iDebugSetlog then Setlog("$StringConverted: " & $StringConverted)
Return $StringConverted
EndFunc
Func _GetRedArea($iMode = $REDLINE_IMGLOC, $iMaxAllowedPixelDistance = 25)
Local $nameFunc = "[_GetRedArea] "
debugRedArea($nameFunc & " IN")
Local $colorVariation = 40
Local $xSkip = 1
Local $ySkip = 5
Local $result = 0
If $g_iMatchMode = $LB And $g_aiAttackAlgorithm[$LB] = 0 And $g_aiAttackStdDropSides[$LB] = 4 Then
$result = DllCall($g_hLibFunctions, "str", "getRedAreaSideBuilding", "ptr", $hHBitmap2, "int", $xSkip, "int", $ySkip, "int", $colorVariation, "int", $eSideBuildingDES)
If $g_iDebugSetlog Then Setlog("Debug: Redline with DES Side chosen")
ElseIf $g_iMatchMode = $LB And $g_aiAttackAlgorithm[$LB] = 0 And $g_aiAttackStdDropSides[$LB] = 5 Then
$result = DllCall($g_hLibFunctions, "str", "getRedAreaSideBuilding", "ptr", $hHBitmap2, "int", $xSkip, "int", $ySkip, "int", $colorVariation, "int", $eSideBuildingTH)
If $g_iDebugSetlog Then Setlog("Debug: Redline with TH Side chosen")
Else
Switch $iMode
Case $REDLINE_NONE
Local $listPixelBySide = ["NoRedLine", "", "", "", ""]
Case $REDLINE_IMGLOC_RAW
SearchRedLinesMultipleTimes()
Local $listPixelBySide = getRedAreaSideBuilding()
Case $REDLINE_IMGLOC
SearchRedLinesMultipleTimes()
Local $dropPoints = GetOffSetRedline("TL") & "|" & GetOffSetRedline("BL") & "|" & GetOffSetRedline("BR") & "|" & GetOffSetRedline("TR")
Local $listPixelBySide = getRedAreaSideBuilding($dropPoints)
Case $REDLINE_ORIGINAL
Local $result = DllCall($g_hLibFunctions, "str", "getRedArea", "ptr", $hHBitmap2, "int", $xSkip, "int", $ySkip, "int", $colorVariation)
EndSwitch
If $g_iDebugSetlog Then Setlog("Debug: Redline chosen")
EndIf
If IsArray($result) Then
Local $listPixelBySide = StringSplit($result[0], "#")
EndIf
$PixelTopLeft = GetPixelSide($listPixelBySide, 1)
$PixelBottomLeft = GetPixelSide($listPixelBySide, 2)
$PixelBottomRight = GetPixelSide($listPixelBySide, 3)
$PixelTopRight = GetPixelSide($listPixelBySide, 4)
CleanRedArea($PixelTopLeft)
CleanRedArea($PixelTopRight)
CleanRedArea($PixelBottomLeft)
CleanRedArea($PixelBottomRight)
debugAttackCSV("RedArea cleaned")
debugAttackCSV("	[" & UBound($PixelTopLeft) & "] pixels TopLeft")
debugAttackCSV("	[" & UBound($PixelTopRight) & "] pixels TopRight")
debugAttackCSV("	[" & UBound($PixelBottomLeft) & "] pixels BottomLeft")
debugAttackCSV("	[" & UBound($PixelBottomRight) & "] pixels BottomRight")
If _Sleep($iDelayRespond) Then Return
Local $coordLeft = [$ExternalArea[0][0], $ExternalArea[0][1]]
Local $coordTop = [$ExternalArea[2][0], $ExternalArea[2][1]]
Local $coordRight = [$ExternalArea[1][0], $ExternalArea[1][1]]
Local $coordBottom = [$ExternalArea[3][0], $ExternalArea[3][1]]
Switch $g_aiAttackScrDroplineEdge[$g_iMatchMode]
Case $DROPLINE_EDGE_FIXED, $DROPLINE_FULL_EDGE_FIXED
Case $DROPLINE_EDGE_FIRST, $DROPLINE_FULL_EDGE_FIRST
Local $newAxis
Local $aPoint1 = GetMaxPoint($PixelTopLeft, 1)
Local $aPoint2 = GetMinPoint($PixelBottomLeft, 1)
$newAxis =(($aPoint1[0] < $aPoint2[0]) ?($aPoint1[0]) :($aPoint2[0]))
If Abs($newAxis) < 9999 Then $coordLeft[0] = $newAxis
Local $aPoint1 = GetMaxPoint($PixelTopLeft, 0)
Local $aPoint2 = GetMinPoint($PixelTopRight, 0)
$newAxis =(($aPoint1[1] < $aPoint2[1]) ?($aPoint1[1]) :($aPoint2[1]))
If Abs($newAxis) < 9999 Then $coordTop[1] = $newAxis
Local $aPoint1 = GetMaxPoint($PixelTopRight, 1)
Local $aPoint2 = GetMinPoint($PixelBottomRight, 1)
$newAxis =(($aPoint1[0] > $aPoint2[0]) ?($aPoint1[0]) :($aPoint2[0]))
If Abs($newAxis) < 9999 Then $coordRight[0] = $newAxis
Local $aPoint1 = GetMaxPoint($PixelBottomLeft, 0)
Local $aPoint2 = GetMinPoint($PixelBottomRight, 0)
$newAxis =(($aPoint1[1] > $aPoint2[1]) ?($aPoint1[1]) :($aPoint2[1]))
If Abs($newAxis) < 9999 Then $coordBottom[1] = $newAxis
EndSwitch
Local $StartEndTopLeft = [$coordLeft, $coordTop]
Local $StartEndTopRight = [$coordTop, $coordRight]
Local $StartEndBottomLeft = [$coordLeft, $coordBottom]
Local $StartEndBottomRight = [$coordBottom, $coordRight]
SetDebugLog("_GetRedArea, StartEndTopLeft     = " & PixelArrayToString($StartEndTopLeft, ","))
SetDebugLog("_GetRedArea, StartEndTopRight    = " & PixelArrayToString($StartEndTopRight, ","))
SetDebugLog("_GetRedArea, StartEndBottomLeft  = " & PixelArrayToString($StartEndBottomLeft, ","))
SetDebugLog("_GetRedArea, StartEndBottomRight = " & PixelArrayToString($StartEndBottomRight, ","))
Local $startPoint, $endPoint, $invalid1, $invalid2
Local $totalInvalid = 0
$startPoint = $StartEndTopLeft[0]
$endPoint = $StartEndTopLeft[1]
Local $PixelTopLeft1 = SortByDistance($PixelTopLeft, $startPoint, $endPoint, $invalid1)
$startPoint = $StartEndTopLeft[1]
$endPoint = $StartEndTopLeft[0]
Local $PixelTopLeft2 = SortByDistance($PixelTopLeft, $startPoint, $endPoint, $invalid2)
$totalInvalid +=(($invalid1 <= $invalid2) ?($invalid1) :($invalid2))
$PixelTopLeft = SortByDistance((($invalid1 <= $invalid2) ?($PixelTopLeft1) :($PixelTopLeft2)), $StartEndTopLeft[0], $StartEndTopLeft[1], $invalid1)
$startPoint = $StartEndTopRight[0]
$endPoint = $StartEndTopRight[1]
Local $PixelTopRight1 = SortByDistance($PixelTopRight, $startPoint, $endPoint, $invalid1)
$startPoint = $StartEndTopRight[1]
$endPoint = $StartEndTopRight[0]
Local $PixelTopRight2 = SortByDistance($PixelTopRight, $startPoint, $endPoint, $invalid2)
$totalInvalid +=(($invalid1 <= $invalid2) ?($invalid1) :($invalid2))
$PixelTopRight = SortByDistance((($invalid1 <= $invalid2) ?($PixelTopRight1) :($PixelTopRight2)), $StartEndTopRight[0], $StartEndTopRight[1], $invalid1)
$startPoint = $StartEndBottomLeft[0]
$endPoint = $StartEndBottomLeft[1]
Local $PixelBottomLeft1 = SortByDistance($PixelBottomLeft, $startPoint, $endPoint, $invalid1)
$startPoint = $StartEndBottomLeft[1]
$endPoint = $StartEndBottomLeft[0]
Local $PixelBottomLeft2 = SortByDistance($PixelBottomLeft, $startPoint, $endPoint, $invalid2)
$totalInvalid +=(($invalid1 <= $invalid2) ?($invalid1) :($invalid2))
$PixelBottomLeft = SortByDistance((($invalid1 <= $invalid2) ?($PixelBottomLeft1) :($PixelBottomLeft2)), $StartEndBottomLeft[0], $StartEndBottomLeft[1], $invalid1)
$startPoint = $StartEndBottomRight[0]
$endPoint = $StartEndBottomRight[1]
Local $PixelBottomRight1 = SortByDistance($PixelBottomRight, $startPoint, $endPoint, $invalid1)
$startPoint = $StartEndBottomRight[1]
$endPoint = $StartEndBottomRight[0]
Local $PixelBottomRight2 = SortByDistance($PixelBottomRight, $startPoint, $endPoint, $invalid2)
$totalInvalid +=(($invalid1 <= $invalid2) ?($invalid1) :($invalid2))
$PixelBottomRight = SortByDistance((($invalid1 <= $invalid2) ?($PixelBottomRight1) :($PixelBottomRight2)), $StartEndBottomRight[0], $StartEndBottomRight[1], $invalid1)
Local $offsetArcher = 15
ReDim $PixelRedArea[UBound($PixelTopLeft) + UBound($PixelBottomLeft) + UBound($PixelTopRight) + UBound($PixelBottomRight)]
ReDim $PixelRedAreaFurther[UBound($PixelRedArea)]
Local $a
If($g_iMatchMode = $DB And $g_aiAttackAlgorithm[$DB] = 2) Or($g_iMatchMode = $DB And $ichkUseAttackDBCSV = 1) Or($g_iMatchMode = $LB And $ichkUseAttackABCSV = 1) Then
If $g_iDebugSetlog = 1 Then setlog("redarea no calc pixel further (quick)", $COLOR_DEBUG)
Local $count = 0
ReDim $PixelTopLeftFurther[UBound($PixelTopLeft)]
For $i = 0 To UBound($PixelTopLeft) - 1
$a = $PixelTopLeft[$i]
$PixelTopLeftFurther[$i] = $a
$PixelRedArea[$count] = $a
$PixelRedAreaFurther[$count] = $PixelTopLeftFurther[$i]
$count += 1
Next
ReDim $PixelBottomLeftFurther[UBound($PixelBottomLeft)]
For $i = 0 To UBound($PixelBottomLeft) - 1
$PixelBottomLeftFurther[$i] = $PixelBottomLeft[$i]
$PixelRedArea[$count] = $PixelBottomLeft[$i]
$PixelRedAreaFurther[$count] = $PixelBottomLeftFurther[$i]
$count += 1
Next
ReDim $PixelTopRightFurther[UBound($PixelTopRight)]
For $i = 0 To UBound($PixelTopRight) - 1
$PixelTopRightFurther[$i] = $PixelTopRight[$i]
$PixelRedArea[$count] = $PixelTopRight[$i]
$PixelRedAreaFurther[$count] = $PixelTopRightFurther[$i]
$count += 1
Next
ReDim $PixelBottomRightFurther[UBound($PixelBottomRight)]
For $i = 0 To UBound($PixelBottomRight) - 1
$PixelBottomRightFurther[$i] = $PixelBottomRight[$i]
$PixelRedArea[$count] = $PixelBottomRight[$i]
$PixelRedAreaFurther[$count] = $PixelBottomRightFurther[$i]
$count += 1
Next
Else
If $g_iDebugSetlog = 1 Then setlog("redarea calc pixel further", $COLOR_DEBUG)
Local $count = 0
ReDim $PixelTopLeftFurther[UBound($PixelTopLeft)]
For $i = 0 To UBound($PixelTopLeft) - 1
$PixelTopLeftFurther[$i] = _GetOffsetTroopFurther($PixelTopLeft[$i], $eVectorLeftTop, $offsetArcher)
$PixelRedArea[$count] = $PixelTopLeft[$i]
$PixelRedAreaFurther[$count] = $PixelTopLeftFurther[$i]
$count += 1
Next
ReDim $PixelBottomLeftFurther[UBound($PixelBottomLeft)]
For $i = 0 To UBound($PixelBottomLeft) - 1
$PixelBottomLeftFurther[$i] = _GetOffsetTroopFurther($PixelBottomLeft[$i], $eVectorLeftBottom, $offsetArcher)
$PixelRedArea[$count] = $PixelBottomLeft[$i]
$PixelRedAreaFurther[$count] = $PixelBottomLeftFurther[$i]
$count += 1
Next
ReDim $PixelTopRightFurther[UBound($PixelTopRight)]
For $i = 0 To UBound($PixelTopRight) - 1
$PixelTopRightFurther[$i] = _GetOffsetTroopFurther($PixelTopRight[$i], $eVectorRightTop, $offsetArcher)
$PixelRedArea[$count] = $PixelTopRight[$i]
$PixelRedAreaFurther[$count] = $PixelTopRightFurther[$i]
$count += 1
Next
ReDim $PixelBottomRightFurther[UBound($PixelBottomRight)]
For $i = 0 To UBound($PixelBottomRight) - 1
$PixelBottomRightFurther[$i] = _GetOffsetTroopFurther($PixelBottomRight[$i], $eVectorRightBottom, $offsetArcher)
$PixelRedArea[$count] = $PixelBottomRight[$i]
$PixelRedAreaFurther[$count] = $PixelBottomRightFurther[$i]
$count += 1
Next
EndIf
If UBound($PixelTopLeft) < 10 Or GetPixelListDistance($PixelTopLeft, $iMaxAllowedPixelDistance) * 2 < GetPixelDistance($coordTop, $coordLeft) Then
$PixelTopLeft = _GetVectorOutZone($eVectorLeftTop)
$PixelTopLeftFurther = $PixelTopLeft
EndIf
If UBound($PixelBottomLeft) < 10 Or GetPixelListDistance($PixelBottomLeft, $iMaxAllowedPixelDistance) * 2 < GetPixelDistance($coordBottom, $coordLeft) Then
$PixelBottomLeft = _GetVectorOutZone($eVectorLeftBottom)
$PixelBottomLeftFurther = $PixelBottomLeft
EndIf
If UBound($PixelTopRight) < 10 Or GetPixelListDistance($PixelTopRight, $iMaxAllowedPixelDistance) * 2 < GetPixelDistance($coordTop, $coordRight) Then
$PixelTopRight = _GetVectorOutZone($eVectorRightTop)
$PixelTopRightFurther = $PixelTopRight
EndIf
If UBound($PixelBottomRight) < 10 Or GetPixelListDistance($PixelBottomRight, $iMaxAllowedPixelDistance) * 2 < GetPixelDistance($coordBottom, $coordRight) Then
$PixelBottomRight = _GetVectorOutZone($eVectorRightBottom)
$PixelBottomRightFurther = $PixelBottomRight
EndIf
debugRedArea($nameFunc & "  Size of arr pixel for TopLeft [" & UBound($PixelTopLeft) & "] /  BottomLeft [" & UBound($PixelBottomLeft) & "] /  TopRight [" & UBound($PixelTopRight) & "] /  BottomRight [" & UBound($PixelBottomRight) & "] ")
debugRedArea($nameFunc & " OUT ")
EndFunc
Func SortRedline($redline, $StartPixel, $EndPixel, $sDelim = ",")
Local $aPoints = StringSplit($redline, "|", $STR_NOCOUNT)
Local $size = UBound($aPoints)
If $size < 2 Then Return StringReplace($redline, $sDelim, "-")
For $i = 0 To $size - 1
Local $sPoint = $aPoints[$i]
Local $aPoint = GetPixel($sPoint, $sDelim)
If UBound($aPoint) > 1 Then $aPoints[$i] = $aPoint
Next
Local $iInvalid = 0
Local $s = PixelArrayToString(SortByDistance($aPoints, $StartPixel, $EndPixel, $iInvalid))
Return $s
EndFunc
Func SortByDistance($PixelList, ByRef $StartPixel, ByRef $EndPixel, ByRef $iInvalid)
If $g_iDebugSetlog = 1 Then SetDebugLog("SortByDistance Start = " & PixelToString($StartPixel, ',') & " : " & PixelArrayToString($PixelList, ","))
Local $iMax = UBound($PixelList) - 1
Local $iMin2 = 0
Local $iMax2 = $iMax
Local $Sorted[0]
Local $PrevPixel = $StartPixel
Local $PrevDistance = -1
Local $totalDistances = 0
Local $totalPoints = 0
Local $firstPixel = [-1, -1], $lastPixel = [-1, -1]
Local $avgDistance = 0
$iInvalid = 0
For $i = 0 To $iMax
Local $ClosestIndex = 0
Local $ClosestDistance = 9999
Local $ClosestPixel = [0, 0]
Local $adjustMin = True
Local $adjustMax = 0
For $j = $iMin2 To $iMax2
Local $Pixel = $PixelList[$j]
If IsArray($Pixel) = 0 Then
If $adjustMin Then $iMin2 = $j + 1
If $adjustMax = $iMax Then $adjustMax = $j
ContinueLoop
EndIf
$adjustMin = False
$adjustMax = $iMax
Local $d = GetPixelDistance($PrevPixel, $Pixel)
If $d < $ClosestDistance Then
$ClosestIndex = $j
$ClosestDistance = $d
$ClosestPixel = $Pixel
EndIf
Next
$iMax2 = $adjustMax
$avgDistance = $totalDistances / $totalPoints
Local $invalidPoint = $ClosestPixel[0] < 0 Or $ClosestPixel[1] < 0
If $invalidPoint Or($PrevDistance > -1 And($iMax - $i) / $iMax < 0.20 And($ClosestDistance > $avgDistance * 10 Or($ClosestDistance > $avgDistance * 3 And(GetPixelDistance($PrevPixel, $EndPixel) < 25 Or $ClosestDistance > $totalDistances / 2)))) Then
$iInvalid += 1
Else
If $firstPixel[0] = -1 Then $firstPixel = $ClosestPixel
$lastPixel = $ClosestPixel
$PrevPixel = $ClosestPixel
$PrevDistance = $ClosestDistance
$totalPoints += 1
$totalDistances += $ClosestDistance
ReDim $Sorted[UBound($Sorted) + 1]
$Sorted[UBound($Sorted) - 1] = $ClosestPixel
EndIf
$PixelList[$ClosestIndex] = 0
Next
If $firstPixel[0] > 0 And GetPixelDistance($StartPixel, $firstPixel) > $avgDistance * 3 Then
$StartPixel[0] = $firstPixel[0]
$StartPixel[1] = $firstPixel[1]
EndIf
If $lastPixel[0] > 0 And GetPixelDistance($EndPixel, $lastPixel) > $avgDistance * 3 Then
$EndPixel[0] = $lastPixel[0]
$EndPixel[1] = $lastPixel[1]
EndIf
Return $Sorted
EndFunc
Func PixelArrayToString(Const ByRef $PixelList, $sDelim = "-")
If UBound($PixelList) < 1 Then Return ""
Local $s = ""
For $i = 0 To UBound($PixelList) - 1
Local $Pixel = $PixelList[$i]
$s &= "|" & PixelToString($Pixel, $sDelim)
Next
$s = StringMid($s, 2)
Return $s
EndFunc
Func PixelToString(Const ByRef $Pixel, $sDelim = "-")
Return $Pixel[0] & $sDelim & $Pixel[1]
EndFunc
Func _SortRedline($redline, $sDelim = ",")
Local $aPoints = StringSplit($redline, "|", $STR_NOCOUNT)
Local $size = UBound($aPoints)
If $size < 2 Then Return StringReplace($redline, $sDelim, "-")
Local $a1[$size + 1][2] = [[0, 0]]
For $sPoint In $aPoints
Local $aPoint = GetPixel($sPoint, $sDelim)
If UBound($aPoint) > 1 Then getRedAreaSideBuildingSetPoint($a1, $aPoint)
Next
Local $s = getRedAreaSideBuildingString($a1)
Return $s
EndFunc
Func getRedAreaSideBuildingSetPoint(ByRef $aSide, ByRef $aPoint)
$aSide[0][0] += 1
$aSide[$aSide[0][0]][0] = Int($aPoint[0])
$aSide[$aSide[0][0]][1] = Int($aPoint[1])
EndFunc
Func getRedAreaSideBuildingString(ByRef $aSide)
If UBound($aSide) < 2 Or $aSide[0][0] < 1 Then Return ""
_ArraySort($aSide, 0, 1, $aSide[0][0], 0)
Local $s = ""
For $j = 1 To $aSide[0][0]
$s &=("|" & $aSide[$j][0] & "-" & $aSide[$j][1])
Next
$s = StringMid($s, 2)
Return $s
EndFunc
Func getRedAreaSideBuilding($redline = $IMGLOCREDLINE)
Local $c = 0
Local $a[5]
Local $aPoints = StringSplit($redline, "|", $STR_NOCOUNT)
Local $size = UBound($aPoints)
Local $a1[$size + 1][2] = [[0, 0]]
Local $a2[$size + 1][2] = [[0, 0]]
Local $a3[$size + 1][2] = [[0, 0]]
Local $a4[$size + 1][2] = [[0, 0]]
For $sPoint In $aPoints
Local $aPoint = GetPixel($sPoint, ",")
If UBound($aPoint) > 1 Then
$c += 1
Local $i = GetPixelSection($aPoint[0], $aPoint[1])
Switch $i
Case 1
getRedAreaSideBuildingSetPoint($a1, $aPoint)
Case 2
getRedAreaSideBuildingSetPoint($a2, $aPoint)
Case 3
getRedAreaSideBuildingSetPoint($a3, $aPoint)
Case 4
getRedAreaSideBuildingSetPoint($a4, $aPoint)
EndSwitch
EndIf
Next
$a[0] = $c
$a[1] = getRedAreaSideBuildingString($a1)
$a[2] = getRedAreaSideBuildingString($a2)
$a[3] = getRedAreaSideBuildingString($a3)
$a[4] = getRedAreaSideBuildingString($a4)
Return $a
EndFunc
Func GetPixelSection($x, $y)
Local $isLeft =($x <= $ExternalArea[2][0])
Local $isTop =($y <= $ExternalArea[0][1])
If $isLeft Then
If $isTop Then Return 1
Return 2
EndIf
If $isTop Then Return 4
Return 3
EndFunc
Func FindClosestToAxis(Const ByRef $PixelList)
Local $Axis = [$ExternalArea[2][0], $ExternalArea[0][1]]
Local $Search[2] = [9999, 9999]
Local $Points[2]
For $Pixel In $PixelList
For $i = 0 To 1
If Abs($Pixel[$i] - $Axis[$i]) < Abs($Search[$i] - $Axis[$i]) Then
$Search[$i] = $Pixel[$i]
$Points[$i] = $Pixel
EndIf
Next
Next
For $i = 0 To 1
If $Search[$i] = 9999 Then $Search[$i] = $Axis[$i]
Next
Return $Search
EndFunc
Func ResetRedLines()
_ArrayClear($CurBaseRedLine)
Return True
EndFunc
Func DropOnEdge($troop, $edge, $number, $slotsPerEdge = 0, $edge2 = -1, $x = -1, $FourFingers = 0)
If isProblemAffect(True) Then Return
If $number = 0 Then Return
If _SleepAttack($iDelayDropOnEdge1) Then Return
SelectDropTroop($troop)
If _SleepAttack($iDelayDropOnEdge2) Then Return
If $slotsPerEdge = 0 Or $number < $slotsPerEdge Then $slotsPerEdge = $number
If $number = 1 Or $slotsPerEdge = 1 Then
If $edge2 = -1 Then
AttackClick($edge[2][0], $edge[2][1], $number, $iDelayDropOnEdge1, $iDelayDropOnEdge3, "#0102")
Else
AttackClick($edge[2][0], $edge[2][1], $number, $iDelayDropOnEdge1, 0, "#0102")
AttackClick($edge2[2][0], $edge2[2][1], $number, $iDelayDropOnEdge1, $iDelayDropOnEdge3, "#0103")
EndIf
ElseIf $slotsPerEdge = 2 And $FourFingers = 0 Then
Local $half = Ceiling($number / 2)
AttackClick($edge[1][0], $edge[1][1], $half, SetSleep(0), 0, "#0104")
If $edge2 <> -1 Then
AttackClick($edge2[1][0], $edge2[1][1], $half, SetSleep(0), 0, "#0105")
EndIf
AttackClick($edge[3][0], $edge[3][1], $number - $half, SetSleep(0), 0, "#0106")
If $edge2 <> -1 Then
AttackClick($edge2[3][0], $edge2[3][1], $number - $half, SetSleep(0), 0, "#0107")
EndIf
Else
Local $minX = $edge[0][0]
Local $maxX = $edge[4][0]
Local $minY = $edge[0][1]
Local $maxY = $edge[4][1]
If $FourFingers = 5 Then
Local $minXTL = $TopLeft[0][0]
Local $maxXTL = $TopLeft[4][0]
Local $minYTL = $TopLeft[0][1]
Local $maxYTL = $TopLeft[4][1]
EndIf
If $edge2 <> -1 Then
Local $minX2 = $edge2[0][0]
Local $maxX2 = $edge2[4][0]
Local $minY2 = $edge2[0][1]
Local $maxY2 = $edge2[4][1]
If $FourFingers = 5 Then
Local $minX2TR = $TopRight[0][0]
Local $maxX2TR = $TopRight[4][0]
Local $minY2TR = $TopRight[0][1]
Local $maxY2TR = $TopRight[4][1]
EndIf
EndIf
Local $nbTroopsLeft = $number
For $i = 0 To $slotsPerEdge - 1
Local $nbtroopPerSlot = Round($nbTroopsLeft /($slotsPerEdge - $i))
If $FourFingers = 5 Then
Local $posX = $minX +(($maxX - $minX) *($slotsPerEdge - $i)) /($slotsPerEdge - 1)
Local $posY = $minY +(($maxY - $minY) *($slotsPerEdge - $i)) /($slotsPerEdge - 1)
AttackClick($posX, $posY, $nbtroopPerSlot, SetSleep(0), 0, "#0108")
Local $posX = $minXTL +(($maxXTL - $minXTL) * $i) /($slotsPerEdge - 1)
Local $posY = $minYTL +(($maxYTL - $minYTL) * $i) /($slotsPerEdge - 1)
Else
Local $posX = Round($minX +(($maxX - $minX) * $i) /($slotsPerEdge - 1))
Local $posY = Round($minY +(($maxY - $minY) * $i) /($slotsPerEdge - 1))
EndIf
AttackClick($posX, $posY, $nbtroopPerSlot, SetSleep(0), 0, "#0108")
If $edge2 <> -1 Then
If $FourFingers = 5 Then
Local $posX2 = $maxX2 -(($maxX2 - $minX2) *($slotsPerEdge - $i)) /($slotsPerEdge - 1)
Local $posY2 = $maxY2 -(($maxY2 - $minY2) *($slotsPerEdge - $i)) /($slotsPerEdge - 1)
AttackClick($posX2, $posY2, $nbtroopPerSlot, SetSleep(0), 0, "#0109")
Local $posX2 = $maxX2TR -(($maxX2TR - $minX2TR) * $i) /($slotsPerEdge - 1)
Local $posY2 = $maxY2TR -(($maxY2TR - $minY2TR) * $i) /($slotsPerEdge - 1)
Else
Local $posX2 = Round($maxX2 -(($maxX2 - $minX2) * $i) /($slotsPerEdge - 1))
Local $posY2 = Round($maxY2 -(($maxY2 - $minY2) * $i) /($slotsPerEdge - 1))
EndIf
AttackClick($posX2, $posY2, $nbtroopPerSlot, SetSleep(0), 0, "#0109")
EndIf
$nbTroopsLeft -= $nbtroopPerSlot
Next
EndIf
EndFunc
Func DropOnEdges($troop, $nbSides, $number, $slotsPerEdge = 0)
If $nbSides = 0 Or $number = 1 Then
OldDropTroop($troop, $Edges[0], $number)
Return
EndIf
If $nbSides < 1 Then Return
Local $nbTroopsLeft = $number
If $nbSides = 4 Then
For $i = 0 To $nbSides - 3
KeepClicks()
Local $nbTroopsPerEdge = Round($nbTroopsLeft /($nbSides - $i * 2))
DropOnEdge($troop, $Edges[$i], $nbTroopsPerEdge, $slotsPerEdge, $Edges[$i + 2], $i)
$nbTroopsLeft -= $nbTroopsPerEdge * 2
ReleaseClicks()
Next
Return
EndIf
If $nbSides = 5 Then
If $slotsPerEdge = 2 Then
For $i = 0 To $nbSides - 4
KeepClicks()
Local $nbTroopsPerEdge = Round($nbTroopsLeft /(($nbSides-1) - $i * 2))
DropOnEdge($troop, $Edges[$i], $nbTroopsPerEdge, $slotsPerEdge, $Edges[$i + 2], $i)
$nbTroopsLeft -= $nbTroopsPerEdge * 2
ReleaseClicks()
Next
Else
For $i = 0 To $nbSides - 5
KeepClicks()
Local $nbTroopsPerEdge = Round($nbTroopsLeft /(($nbSides-1) - $i * 2))
DropOnEdge($troop, $Edges[$i], $nbTroopsPerEdge, $slotsPerEdge, $Edges[$i + 2], $i, $nbSides)
$nbTroopsLeft -= $nbTroopsPerEdge * 2
ReleaseClicks()
Next
EndIf
Return
EndIf
For $i = 0 To $nbSides - 1
KeepClicks()
If $nbSides = 1 Or($nbSides = 3 And $i = 2) Then
Local $nbTroopsPerEdge = Round($nbTroopsLeft /($nbSides - $i))
If $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] >= 4 Then
DropOnEdge($troop, $Edges[$BuildingEdge], $nbTroopsPerEdge, $slotsPerEdge)
Else
DropOnEdge($troop, $Edges[$i], $nbTroopsPerEdge, $slotsPerEdge)
EndIf
$nbTroopsLeft -= $nbTroopsPerEdge
ElseIf($nbSides = 2 And $i = 0) Or($nbSides = 3 And $i <> 1) Then
Local $nbTroopsPerEdge = Round($nbTroopsLeft /($nbSides - $i * 2))
DropOnEdge($troop, $Edges[$i + 3], $nbTroopsPerEdge, $slotsPerEdge, $Edges[$i + 1])
$nbTroopsLeft -= $nbTroopsPerEdge * 2
EndIf
ReleaseClicks()
Next
EndFunc
Func LauchTroop($troopKind, $nbSides, $waveNb, $maxWaveNb, $slotsPerEdge = 0)
Local $troop = -1
Local $troopNb = 0
Local $name = ""
For $i = 0 To UBound($atkTroops) - 1
If $atkTroops[$i][0] = $troopKind Then
$troop = $i
$troopNb = Ceiling($atkTroops[$i][1] / $maxWaveNb)
Local $plural = 0
If $troopNb > 1 Then $plural = 1
$name = NameOfTroop($troopKind, $plural)
EndIf
Next
If($troop = -1) Or($troopNb = 0) Then
Return False
EndIf
Local $waveName = "first"
If $waveNb = 2 Then $waveName = "second"
If $waveNb = 3 Then $waveName = "third"
If $maxWaveNb = 1 Then $waveName = "only"
If $waveNb = 0 Then $waveName = "last"
SetLog("Dropping " & $waveName & " wave of " & $troopNb & " " & $name, $COLOR_SUCCESS)
DropTroop($troop, $nbSides, $troopNb, $slotsPerEdge)
Return True
EndFunc
Func LaunchTroop2($listInfoDeploy, $CC, $King, $Queen, $Warden)
If $g_iDebugSetlog = 1 Then SetLog("LaunchTroop2 with CC " & $CC & ", K " & $King & ", Q " & $Queen & ", W " & $Warden, $COLOR_DEBUG)
Local $listListInfoDeployTroopPixel[0]
Local $pixelRandomDrop[2]
Local $pixelRandomDropcc[2]
If($g_abAttackStdSmartAttack[$g_iMatchMode]) and $g_aiAttackStdDropSides[$g_iMatchMode] <> 4 Then
For $i = 0 To UBound($listInfoDeploy) - 1
Local $troop = -1
Local $troopNb = 0
Local $name = ""
Local $troopKind = $listInfoDeploy[$i][0]
Local $nbSides = $listInfoDeploy[$i][1]
Local $waveNb = $listInfoDeploy[$i][2]
Local $maxWaveNb = $listInfoDeploy[$i][3]
Local $slotsPerEdge = $listInfoDeploy[$i][4]
If $g_iDebugSetlog = 1 Then SetLog("**ListInfoDeploy row " & $i & ": USE " & $troopKind & " SIDES " & $nbSides & " WAVE " & $waveNb & " XWAVE " & $maxWaveNb & " SLOTXEDGE " & $slotsPerEdge, $COLOR_DEBUG)
If(IsNumber($troopKind)) Then
For $j = 0 To UBound($atkTroops) - 1
If $atkTroops[$j][0] = $troopKind Then
$troop = $j
$troopNb = Ceiling($atkTroops[$j][1] / $maxWaveNb)
Local $plural = 0
If $troopNb > 1 Then $plural = 1
$name = NameOfTroop($troopKind, $plural)
EndIf
Next
EndIf
If($troop <> -1 And $troopNb > 0) Or IsString($troopKind) Then
Local $listInfoDeployTroopPixel
If(UBound($listListInfoDeployTroopPixel) < $waveNb) Then
ReDim $listListInfoDeployTroopPixel[$waveNb]
Local $newListInfoDeployTroopPixel[0]
$listListInfoDeployTroopPixel[$waveNb - 1] = $newListInfoDeployTroopPixel
EndIf
$listInfoDeployTroopPixel = $listListInfoDeployTroopPixel[$waveNb - 1]
ReDim $listInfoDeployTroopPixel[UBound($listInfoDeployTroopPixel) + 1]
If(IsString($troopKind)) Then
Local $arrCCorHeroes[1] = [$troopKind]
$listInfoDeployTroopPixel[UBound($listInfoDeployTroopPixel) - 1] = $arrCCorHeroes
Else
Local $infoDropTroop = DropTroop2($troop, $nbSides, $troopNb, $slotsPerEdge, $name)
$listInfoDeployTroopPixel[UBound($listInfoDeployTroopPixel) - 1] = $infoDropTroop
EndIf
$listListInfoDeployTroopPixel[$waveNb - 1] = $listInfoDeployTroopPixel
EndIf
Next
If(($g_abAttackStdSmartNearCollectors[$g_iMatchMode][0] Or $g_abAttackStdSmartNearCollectors[$g_iMatchMode][1] Or $g_abAttackStdSmartNearCollectors[$g_iMatchMode][2]) And UBound($PixelNearCollector) = 0) Then
SetLog("Error, no pixel found near collector => Normal attack near red line")
EndIf
If($g_aiAttackStdSmartDeploy[$g_iMatchMode] = 0) Then
For $numWave = 0 To UBound($listListInfoDeployTroopPixel) - 1
Local $listInfoDeployTroopPixel = $listListInfoDeployTroopPixel[$numWave]
For $i = 0 To UBound($listInfoDeployTroopPixel) - 1
Local $infoPixelDropTroop = $listInfoDeployTroopPixel[$i]
If(IsString($infoPixelDropTroop[0]) And($infoPixelDropTroop[0] = "CC" Or $infoPixelDropTroop[0] = "HEROES")) Then
If $DeployHeroesPosition[0] <> -1 Then
$pixelRandomDrop[0] = $DeployHeroesPosition[0]
$pixelRandomDrop[1] = $DeployHeroesPosition[1]
If $g_iDebugSetlog = 1 Then SetLog("Deploy Heroes $DeployHeroesPosition")
Else
$pixelRandomDrop[0] = $BottomRight[2][0]
$pixelRandomDrop[1] = $BottomRight[2][1]
If $g_iDebugSetlog = 1 Then SetLog("Deploy Heroes $BottomRight")
EndIf
If $DeployCCPosition[0] <> -1 Then
$pixelRandomDropcc[0] = $DeployCCPosition[0]
$pixelRandomDropcc[1] = $DeployCCPosition[1]
If $g_iDebugSetlog = 1 Then SetLog("Deploy CC $DeployHeroesPosition")
Else
$pixelRandomDropcc[0] = $BottomRight[2][0]
$pixelRandomDropcc[1] = $BottomRight[2][1]
If $g_iDebugSetlog = 1 Then SetLog("Deploy CC $BottomRight")
EndIf
If($infoPixelDropTroop[0] = "CC") Then
dropCC($pixelRandomDropcc[0], $pixelRandomDropcc[1], $CC)
$isCCDropped = True
ElseIf($infoPixelDropTroop[0] = "HEROES") Then
dropHeroes($pixelRandomDrop[0], $pixelRandomDrop[1], $King, $Queen, $Warden)
$isHeroesDropped = True
EndIf
Else
If _Sleep($iDelayLaunchTroop21) Then Return
SelectDropTroop($infoPixelDropTroop[0])
If _Sleep($iDelayLaunchTroop21) Then Return
Local $waveName = "first"
If $numWave + 1 = 2 Then $waveName = "second"
If $numWave + 1 = 3 Then $waveName = "third"
If $numWave + 1 = 0 Then $waveName = "last"
SetLog("Dropping " & $waveName & " wave of " & $infoPixelDropTroop[5] & " " & $infoPixelDropTroop[4], $COLOR_SUCCESS)
DropOnPixel($infoPixelDropTroop[0], $infoPixelDropTroop[1], $infoPixelDropTroop[2], $infoPixelDropTroop[3])
EndIf
If($isHeroesDropped) Then
If _Sleep($iDelayLaunchTroop22) Then Return
CheckHeroesHealth()
EndIf
If _Sleep(SetSleep(1)) Then Return
Next
Next
Else
For $numWave = 0 To UBound($listListInfoDeployTroopPixel) - 1
Local $listInfoDeployTroopPixel = $listListInfoDeployTroopPixel[$numWave]
If(UBound($listInfoDeployTroopPixel) > 0) Then
Local $infoTroopListArrPixel = $listInfoDeployTroopPixel[0]
Local $numberSidesDropTroop = 1
For $i = 0 To UBound($listInfoDeployTroopPixel) - 1
$infoTroopListArrPixel = $listInfoDeployTroopPixel[$i]
If(UBound($infoTroopListArrPixel) > 1) Then
Local $infoListArrPixel = $infoTroopListArrPixel[1]
$numberSidesDropTroop = UBound($infoListArrPixel)
ExitLoop
EndIf
Next
If($numberSidesDropTroop > 0) Then
For $i = 0 To $numberSidesDropTroop - 1
For $j = 0 To UBound($listInfoDeployTroopPixel) - 1
$infoTroopListArrPixel = $listInfoDeployTroopPixel[$j]
If(IsString($infoTroopListArrPixel[0]) And($infoTroopListArrPixel[0] = "CC" Or $infoTroopListArrPixel[0] = "HEROES")) Then
If $DeployHeroesPosition[0] <> -1 Then
$pixelRandomDrop[0] = $DeployHeroesPosition[0]
$pixelRandomDrop[1] = $DeployHeroesPosition[1]
If $g_iDebugSetlog = 1 Then SetLog("Deploy Heroes $DeployHeroesPosition")
Else
$pixelRandomDrop[0] = $BottomRight[2][0]
$pixelRandomDrop[1] = $BottomRight[2][1]
If $g_iDebugSetlog = 1 Then SetLog("Deploy Heroes $BottomRight")
EndIf
If $DeployCCPosition[0] <> -1 Then
$pixelRandomDropcc[0] = $DeployCCPosition[0]
$pixelRandomDropcc[1] = $DeployCCPosition[1]
If $g_iDebugSetlog = 1 Then SetLog("Deploy CC $DeployHeroesPosition")
Else
$pixelRandomDropcc[0] = $BottomRight[2][0]
$pixelRandomDropcc[1] = $BottomRight[2][1]
If $g_iDebugSetlog = 1 Then SetLog("Deploy CC $BottomRight")
EndIf
If($isCCDropped = False And $infoTroopListArrPixel[0] = "CC") Then
dropCC($pixelRandomDropcc[0], $pixelRandomDropcc[1], $CC)
$isCCDropped = True
ElseIf($isHeroesDropped = False And $infoTroopListArrPixel[0] = "HEROES" And $i = $numberSidesDropTroop - 1) Then
dropHeroes($pixelRandomDrop[0], $pixelRandomDrop[1], $King, $Queen, $Warden)
$isHeroesDropped = True
EndIf
Else
$infoListArrPixel = $infoTroopListArrPixel[1]
Local $listPixel = $infoListArrPixel[$i]
If _Sleep($iDelayLaunchTroop21) Then Return
SelectDropTroop($infoTroopListArrPixel[0])
If _Sleep($iDelayLaunchTroop23) Then Return
SetLog("Dropping " & $infoTroopListArrPixel[2] & "  of " & $infoTroopListArrPixel[5] & " => on each side (side : " & $i + 1 & ")", $COLOR_SUCCESS)
Local $pixelDropTroop[1] = [$listPixel]
DropOnPixel($infoTroopListArrPixel[0], $pixelDropTroop, $infoTroopListArrPixel[2], $infoTroopListArrPixel[3])
EndIf
If($isHeroesDropped) Then
If _sleep(1000) Then Return
CheckHeroesHealth()
EndIf
Next
Next
EndIf
EndIf
If _Sleep(SetSleep(1)) Then Return
Next
EndIf
For $numWave = 0 To UBound($listListInfoDeployTroopPixel) - 1
Local $listInfoDeployTroopPixel = $listListInfoDeployTroopPixel[$numWave]
For $i = 0 To UBound($listInfoDeployTroopPixel) - 1
Local $infoPixelDropTroop = $listInfoDeployTroopPixel[$i]
If Not(IsString($infoPixelDropTroop[0]) And($infoPixelDropTroop[0] = "CC" Or $infoPixelDropTroop[0] = "HEROES")) Then
Local $numberLeft = ReadTroopQuantity($infoPixelDropTroop[0])
If($numberLeft > 0) Then
If _Sleep($iDelayLaunchTroop21) Then Return
SelectDropTroop($infoPixelDropTroop[0])
If _Sleep($iDelayLaunchTroop23) Then Return
SetLog("Dropping last " & $numberLeft & "  of " & $infoPixelDropTroop[5], $COLOR_SUCCESS)
DropOnPixel($infoPixelDropTroop[0], $infoPixelDropTroop[1], Ceiling($numberLeft / UBound($infoPixelDropTroop[1])), $infoPixelDropTroop[3])
EndIf
EndIf
Next
Next
Else
For $i = 0 To UBound($listInfoDeploy) - 1
If(IsString($listInfoDeploy[$i][0]) And($listInfoDeploy[$i][0] = "CC" Or $listInfoDeploy[$i][0] = "HEROES")) Then
If $g_iMatchMode = $LB And $g_aiAttackStdDropSides[$LB] >= 4 Then
Local $RandomEdge = $Edges[$BuildingEdge]
Local $RandomXY = 2
Else
Local $RandomEdge = $Edges[Round(Random(0, 3))]
Local $RandomXY = Round(Random(1, 3))
EndIf
If($listInfoDeploy[$i][0] = "CC") Then
dropCC($RandomEdge[$RandomXY][0], $RandomEdge[$RandomXY][1], $CC)
ElseIf($listInfoDeploy[$i][0] = "HEROES") Then
dropHeroes($RandomEdge[$RandomXY][0], $RandomEdge[$RandomXY][1], $King, $Queen, $Warden)
EndIf
Else
If $duringMilkingAttack = 0 Then
If LauchTroop($listInfoDeploy[$i][0], $listInfoDeploy[$i][1], $listInfoDeploy[$i][2], $listInfoDeploy[$i][3], $listInfoDeploy[$i][4]) Then
If _Sleep(SetSleep(1)) Then Return
EndIf
Else
If $listInfoDeploy[$i][0] <> $eGobl Then
If LauchTroop($listInfoDeploy[$i][0], $listInfoDeploy[$i][1], $listInfoDeploy[$i][2], $listInfoDeploy[$i][3], $listInfoDeploy[$i][4]) Then
If _Sleep(SetSleep(1)) Then Return
EndIf
EndIf
EndIf
EndIf
Next
EndIf
Return True
EndFunc
Func CheckHeroesHealth()
If $checkKPower Or $checkQPower or $checkWPower Then
ForceCaptureRegion()
Local $aKingHealthCopy = $aKingHealth
$aKingHealthCopy[0] = GetXPosOfArmySlot($King, 68) + 2
Local $aQueenHealthCopy = $aQueenHealth
$aQueenHealthCopy[0] = GetXPosOfArmySlot($Queen, 68) + 3
Local $aWardenHealthCopy = $aWardenHealth
$aWardenHealthCopy[0] = GetXPosOfArmySlot($Warden, 68)
If _Sleep($iDelayRespond) Then Return
If $g_iDebugSetlog = 1 Then
Setlog(" CheckHeroesHealth started ")
Local $KingPixelColor = _GetPixelColor($aKingHealthCopy[0], $aKingHealthCopy[1], $g_bCapturePixel)
Local $QueenPixelColor = _GetPixelColor($aQueenHealthCopy[0], $aQueenHealthCopy[1], $g_bCapturePixel)
Local $WardenPixelColor = _GetPixelColor($aWardenHealthCopy[0], $aWardenHealthCopy[1], $g_bCapturePixel)
EndIf
If $checkKPower And $iActivateKQCondition = "Auto" Then
If $g_iDebugSetlog = 1 Then Setlog(" King _GetPixelColor(" & $aKingHealthCopy[0] & "," & $aKingHealthCopy[1] & "): " & $KingPixelColor, $COLOR_DEBUG)
If _CheckPixel($aKingHealthCopy, $g_bCapturePixel, "Red") Then
SetLog("King is getting weak, Activating King's power", $COLOR_INFO)
SelectDropTroop($King)
$checkKPower = False
EndIf
EndIf
If $checkQPower And $iActivateKQCondition = "Auto" Then
If $g_iDebugSetlog = 1 Then Setlog(" Queen _GetPixelColor(" & $aQueenHealthCopy[0] & "," & $aQueenHealthCopy[1] & "): " & $QueenPixelColor, $COLOR_DEBUG)
If _CheckPixel($aQueenHealthCopy, $g_bCapturePixel, "Red") Then
SetLog("Queen is getting weak, Activating Queen's power", $COLOR_INFO)
SelectDropTroop($Queen)
$checkQPower = False
EndIf
EndIf
If $checkWPower And $iActivateKQCondition = "Auto" Then
If $g_iDebugSetlog = 1 Then Setlog(" Grand Warden _GetPixelColor(" & $aWardenHealthCopy[0] & "," & $aWardenHealthCopy[1] & "): " & $WardenPixelColor, $COLOR_DEBUG)
If _CheckPixel($aWardenHealthCopy, $g_bCapturePixel, "Red") Then
SetLog("Grand Warden is getting weak, Activating Warden's power", $COLOR_INFO)
SelectDropTroop($Warden)
$checkWPower = False
EndIf
EndIf
If $iActivateKQCondition = "Manual" Or $iActivateWardenCondition = 1 Then
Local $CorrectTimer[$eHeroCount] = [0, 0, 0]
If $HeroesTimerActivation[$eHeroBarbarianKing] <> 0 Then $CorrectTimer[$eHeroBarbarianKing] = Ceiling(TimerDiff($HeroesTimerActivation[$eHeroBarbarianKing]) / 1000)
If $HeroesTimerActivation[$eHeroArcherQueen] <> 0 Then $CorrectTimer[$eHeroArcherQueen] = Ceiling(TimerDiff($HeroesTimerActivation[$eHeroArcherQueen]) / 1000)
If $HeroesTimerActivation[$eHeroGrandWarden] <> 0 Then $CorrectTimer[$eHeroGrandWarden] = Ceiling(TimerDiff($HeroesTimerActivation[$eHeroGrandWarden]) / 1000)
If $checkKPower And $iActivateKQCondition = "Manual" Then
If $delayActivateKQ / 1000 <= $CorrectTimer[$eHeroBarbarianKing] Then
SetLog("Activating King's power", $COLOR_INFO)
SetLog("Activating after " & $CorrectTimer[$eHeroBarbarianKing] & "'s", $COLOR_INFO)
SelectDropTroop($King)
$checkKPower = False
$HeroesTimerActivation[$eHeroBarbarianKing] = 0
EndIf
EndIf
If $checkQPower And $iActivateKQCondition = "Manual" Then
If $delayActivateKQ / 1000 <= $CorrectTimer[$eHeroArcherQueen] Then
SetLog("Activating Queen's power", $COLOR_INFO)
SetLog("Activating after " & $CorrectTimer[$eHeroArcherQueen] & "'s", $COLOR_INFO)
SelectDropTroop($Queen)
$checkQPower = False
$HeroesTimerActivation[$eHeroArcherQueen] = 0
EndIf
EndIf
If $checkWPower And($iActivateKQCondition = "Manual" Or $iActivateWardenCondition = 1) Then
If($iActivateWardenCondition = 1 And $delayActivateW / 1000 <= $CorrectTimer[$eHeroGrandWarden]) Or($iActivateKQCondition = "Manual" And $delayActivateKQ / 1000 <= $CorrectTimer[$eHeroGrandWarden]) Then
SetLog("Activating Warden's power", $COLOR_INFO)
SetLog("Activating after " & $CorrectTimer[$eHeroGrandWarden] & "'s", $COLOR_INFO)
SelectDropTroop($Warden)
$checkWPower = False
$HeroesTimerActivation[$eHeroGrandWarden] = 0
EndIf
EndIf
EndIf
If _Sleep($iDelayRespond) Then Return
EndIf
EndFunc
Func GetXPosOfArmySlot($slotNumber, $xOffsetFor11Slot, $bNeedNewCapture = Default)
If $bNeedNewCapture = Default Then $bNeedNewCapture = True
Local $CheckSlot12, $SlotPixelColorTemp, $SlotPixelColor1 , $SlotComp
$xOffsetFor11Slot -= 8
Switch $slotNumber
Case 7
$SlotComp = 1
Case Else
$SlotComp = 0
EndSwitch
If $slotNumber = $King Or $slotNumber = $Queen Or $slotNumber = $Warden Then $xOffsetFor11Slot += 8
Local $oldBitmap = _GDIPlus_BitmapCreateFromHBITMAP($hHBitmap2)
If $bNeedNewCapture = True Then
$CheckSlot12 = _ColorCheck(_GetPixelColor(17, 643, True), Hex(0x478AC6, 6), 15) Or  _ColorCheck(_GetPixelColor(17, 643, True), Hex(0x434343, 6), 10)
Else
$CheckSlot12 = _ColorCheck(Hex(_GDIPlus_BitmapGetPixel($oldBitmap, 17, 643), 6), Hex(0x478AC6, 6), 15) Or  _ColorCheck(Hex(_GDIPlus_BitmapGetPixel($oldBitmap, 17, 643), 6), Hex(0x434343, 6), 10)
EndIf
If $g_iDebugSetlog = 1 Then
Setlog(" Slot 0  _ColorCheck 0x478AC6 at (17," & 643 & "): " & $CheckSlot12, $COLOR_DEBUG)
If $bNeedNewCapture = True Then
$SlotPixelColorTemp = _GetPixelColor(17, 643, $g_bCapturePixel)
Else
$SlotPixelColorTemp = Hex(_GDIPlus_BitmapGetPixel($oldBitmap, 17, 643), 6)
EndIf
Setlog(" Slot 0  _GetPixelColo(17," & 643 & "): " & $SlotPixelColorTemp, $COLOR_DEBUG)
EndIf
_GDIPlus_BitmapDispose($oldBitmap)
If $CheckSlot12 = False Then
Return $xOffsetFor11Slot + $SlotComp +($slotNumber * 72)
Else
Return $xOffsetFor11Slot + $SlotComp +($slotNumber * 72) - 13
EndIf
EndFunc
Func ReadTroopQuantity($Troop, $CheckSelectedSlot = False, $bNeedNewCapture = True)
Local $iAmount
Switch $CheckSelectedSlot
Case False
$iAmount = getTroopCountSmall(GetXPosOfArmySlot($Troop, 40), 641)
If $iAmount = "" Then
$iAmount = getTroopCountBig(GetXPosOfArmySlot($Troop, 40), 636)
EndIf
Case Else
Local $rGetXPosOfArmySlot = GetXPosOfArmySlot($Troop, 40, $bNeedNewCapture)
Local $isTheSlotSelected = IsSlotSelected($Troop, $bNeedNewCapture)
If $isTheSlotSelected = False Then
$iAmount = Number(getTroopCountSmall($rGetXPosOfArmySlot, 641, $bNeedNewCapture))
Else
$iAmount = Number(getTroopCountBig($rGetXPosOfArmySlot, 636, $bNeedNewCapture))
EndIf
EndSwitch
Return Number($iAmount)
EndFunc
Func displayZapLog(Const ByRef $aDarkDrills, Const ByRef $Spells)
Local $drillStealableString = "Drills Lvl/Estimated Amount left: "
Local $spellsLeftString = "Spells left: "
For $i = 0 To UBound($aDarkDrills) - 1
If $i = 0 Then
If $aDarkDrills[$i][3] <> -1 Then $drillStealableString &= "Lvl" & $aDarkDrills[$i][2] & "/" & $aDarkDrills[$i][3]
Else
If $aDarkDrills[$i][3] <> -1 Then $drillStealableString &= ", Lvl" & $aDarkDrills[$i][2] & "/" & $aDarkDrills[$i][3]
EndIf
Next
If $Spells[0][4] + $Spells[1][4] + $Spells[2][4] = 0 Then
$spellsLeftString &= "None"
Else
If $Spells[2][4] > 0 Then $spellsLeftString &= $Spells[2][4] & " " & NameOfTroop($Spells[2][1], 1)
If $Spells[2][4] > 0 And $Spells[0][4] + $Spells[1][4] > 0 Then $spellsLeftString &= ", "
If $Spells[0][4] + $Spells[1][4] > 0 Then $spellsLeftString &= $Spells[0][4] + $Spells[1][4] & " " & NameOfTroop($Spells[1][1], 1)
EndIf
If $drillStealableString <> "Drills Lvl/Estimated Amount left: " Then
If $ichkNoobZap = 0 Then
SetLog($drillStealableString, $COLOR_INFO)
Else
If $DebugSmartZap = 1 Then SetLog($drillStealableString, $COLOR_DEBUG)
EndIf
EndIf
If $spellsLeftString <> "Spells left: " Then
SetLog($spellsLeftString, $COLOR_INFO)
EndIf
EndFunc
Func getDarkElixir()
Local $searchDark = "", $iCount = 0
If _ColorCheck(_GetPixelColor(31, 144, True), Hex(0x282020, 6), 10) Or _ColorCheck(_GetPixelColor(31, 144, True), Hex(0x0F0617, 6), 5) Then
While $searchDark = ""
$searchDark = getDarkElixirVillageSearch(48, 126)
$iCount += 1
If $iCount > 15 Then ExitLoop
If _Sleep($DelaySmartZap1) Then Return
WEnd
Else
$searchDark = False
If $DebugSmartZap = 1 Then SetLog(" - No DE detected.", $COLOR_DEBUG)
EndIf
Return $searchDark
EndFunc
Func getDrillOffset()
Local $result = -1
Switch $iTownHallLevel
Case 0 To 7
$result = 2
Case 8
$result = 1
Case Else
$result = 0
EndSwitch
Return $result
EndFunc
Func getSpellOffset()
Local $result = -1
Switch $iTownHallLevel
Case 0 To 4
$result = -1
Case 5, 6
$result = -1
Case 7, 8
$result = 2
Case 9
$result = 1
Case Else
$result = 0
EndSwitch
Return $result
EndFunc
Func smartZap($minDE = -1)
Local $strikeOffsets = [0, 14]
Local $drillLvlOffset, $spellAdjust, $numDrills, $testX, $testY, $tempTestX, $tempTestY, $strikeGain, $expectedDE
Local $searchDark, $oldSearchDark = 0, $performedZap = False, $dropPoint
Local $aSpells [3][5] = [["Own", $eLSpell, -1, -1, 0 ] , ["Donated", $eLSpell, -1, -1, 0] , ["Donated", $eESpell, -1, -1, 0]]
If $DebugSmartZap = 1 Then SetLog("$ichkSmartZap = " & $ichkSmartZap & " | $ichkNoobZap = " & $ichkNoobZap, $COLOR_DEBUG)
If $ichkSmartZap <> 1 Then Return $performedZap
If $ichkSmartZap = 1 And $ichkNoobZap = 0 Then
SetLog("====== You have activated SmartZap Mode ======", $COLOR_ERROR)
ElseIf $ichkNoobZap = 1 Then
SetLog("====== You have activated NoobZap Mode ======", $COLOR_ERROR)
EndIf
If $minDE = -1 Then $minDE = Number($itxtMinDE)
$searchDark = getDarkElixirVillageSearch(48, 126)
If Number($searchDark) = 0 Then
SetLog("No Dark Elixir so lets just exit!", $COLOR_INFO)
If $DebugSmartZap = 1 Then SetLog("$searchDark|Current DE value: " & Number($searchDark), $COLOR_DEBUG)
Return $performedZap
Else
If $DebugSmartZap = 1 Then SetLog("$searchDark|Current DE value: " & Number($searchDark), $COLOR_DEBUG)
EndIf
If isDarkElixirFull() Then
SetLog("No need to zap!", $COLOR_INFO)
If $DebugSmartZap = 1 Then SetLog("isDarkElixirFull(): " & isDarkElixirFull(), $COLOR_DEBUG)
Return $performedZap
Else
If $DebugSmartZap = 1 Then SetLog("isDarkElixirFull(): " & isDarkElixirFull(), $COLOR_DEBUG)
EndIf
If $iTownHallLevel < 2 Then
SetLog("Your Townhalllevel has yet to be determined.", $COLOR_ERROR)
SetLog("It reads as TH" & $iTownHallLevel & ".", $COLOR_ERROR)
SetLog("Locate your Townhall manually at Village->Misc.", $COLOR_ERROR)
Return $performedZap
ElseIf $iTownHallLevel < 7 Then
SetLog("You do not have the ability to store Dark Elixir, time to go home!", $COLOR_ERROR)
If $DebugSmartZap = 1 Then SetLog("Your Town Hall Lvl: " & Number($iTownHallLevel), $COLOR_DEBUG)
Return $performedZap
Else
If $DebugSmartZap = 1 Then SetLog("Your Town Hall Lvl: " & Number($iTownHallLevel), $COLOR_DEBUG)
EndIf
If $DebugSmartZap = 1 Then SetLog("$ichkSmartZapDB = " & $ichkSmartZapDB, $COLOR_DEBUG)
If $ichkSmartZapDB = 1 And $g_iMatchMode <> $DB Then
SetLog("Not a dead base so lets just go home!", $COLOR_INFO)
Return $performedZap
EndIf
$drillLvlOffset = getDrillOffset()
If $DebugSmartZap = 1 Then SetLog("Drill Level Offset is: " & Number($drillLvlOffset), $COLOR_DEBUG)
$spellAdjust = getSpellOffset()
If $DebugSmartZap = 1 Then SetLog("Spell Adjust is: " & Number($spellAdjust), $COLOR_DEBUG)
Local $iTroops = PrepareAttack($g_iMatchMode, True)
If $iTroops > 0 Then
For $i = 0 To UBound($atkTroops) - 1
If $atkTroops[$i][0] = $eLSpell Then
If $aSpells[0][4] = 0 Then
If $DebugSmartZap = 1 Then SetLog(NameOfTroop($atkTroops[$i][0], 0) & ": " & $atkTroops[$i][1], $COLOR_DEBUG)
$aSpells[0][2] = $i
$aSpells[0][3] = Number($g_iLSpellLevel)
$aSpells[0][4] = $atkTroops[$i][1]
Else
If $DebugSmartZap = 1 Then SetLog("Donated " & NameOfTroop($atkTroops[$i][0], 0) & ": " & $atkTroops[$i][1], $COLOR_DEBUG)
$aSpells[1][2] = $i
$aSpells[1][3] = Number($g_iLSpellLevel)
$aSpells[1][4] = $atkTroops[$i][1]
EndIf
EndIf
If $atkTroops[$i][0] = $eESpell Then
If $DebugSmartZap = 1 Then SetLog(NameOfTroop($atkTroops[$i][0], 0) & ": " & $atkTroops[$i][1], $COLOR_DEBUG)
$aSpells[2][2] = $i
$aSpells[2][3] = Number($g_iESpellLevel)
$aSpells[2][4]= $atkTroops[$i][1]
EndIf
Next
EndIf
If $aSpells[0][4] + $aSpells[1][4] = 0 Then
SetLog("No lightning spells trained, time to go home!", $COLOR_ERROR)
Return $performedZap
Else
If $aSpells[0][4] > 0 Then
SetLog(" - Number of " & NameOfTroop($aSpells[0][1], 1) & " (Lvl " & $aSpells[0][3] & "): " & Number($aSpells[0][4]), $COLOR_INFO)
EndIf
If $aSpells[1][4] > 0 Then
SetLog(" - Number of Donated " & NameOfTroop($aSpells[1][1], 1) & " (Lvl " & $aSpells[1][3] & "): " & Number($aSpells[1][4]), $COLOR_INFO)
EndIf
EndIf
If $aSpells[2][4] > 0 And $ichkEarthQuakeZap = 1 Then
SetLog(" - Number of " & NameOfTroop($aSpells[2][1], 1) & " (Lvl " & $aSpells[2][3] & "): " & Number($aSpells[2][4]), $COLOR_INFO)
Else
$aSpells[2][4] = 0
EndIf
If(Number($searchDark) < Number($minDE)) And $ichkNoobZap = 1 Then
SetLog("Dark Elixir is below minimum value [" & Number($itxtMinDE) & "], Exiting Now!", $COLOR_INFO)
If $DebugSmartZap = 1 Then SetLog("$searchDark|Current DE value: " & Number($searchDark), $COLOR_DEBUG)
Return $performedZap
ElseIf Number($searchDark) <($g_aDrillLevelTotal[3 - $drillLvlOffset] / $g_aDrillLevelHP[3 - $drillLvlOffset] * $g_fDarkStealFactor * $g_aLSpellDmg[$aSpells[0][3] - 1] * $g_fDarkFillLevel) Then
SetLog("There is less Dark Elixir(" & Number($searchDark) & ") than", $COLOR_INFO)
SetLog("gain per zap for a single Lvl " & 3 - Number($drillLvlOffset) & " drill(" & Ceiling($g_aDrillLevelTotal[3 - $drillLvlOffset] / $g_aDrillLevelHP[3 - $drillLvlOffset] * $g_fDarkStealFactor * $g_aLSpellDmg[$aSpells[0][3] - 1] * $g_fDarkFillLevel) & ").", $COLOR_INFO)
SetLog("Base is not worth a Zap, Exiting Now!", $COLOR_INFO)
Return $performedZap
Else
If $DebugSmartZap = 1 Then SetLog("$searchDark = " & Number($searchDark) & " | $itxtMinDE = " & Number($itxtMinDE), $COLOR_DEBUG)
EndIf
If $DebugSmartZap = 1 Then
SetLog("$itxtExpectedDE| Expected DE value:" & Number($itxtExpectedDE), $COLOR_DEBUG)
SetLog("$g_abStopAtkNoLoot1Enable[$DB] = " & $g_abStopAtkNoLoot1Enable[$DB] & ", $txtDBTimeStopAtk = " & $g_aiStopAtkNoLoot1Time[$DB] & "s", $COLOR_DEBUG)
EndIf
Local $aDarkDrills = drillSearch()
If UBound($aDarkDrills) = 0 Then
SetLog("No drills found, time to go home!", $COLOR_INFO)
Return $performedZap
Else
SetLog(" - Number of Dark Elixir Drills: " & UBound($aDarkDrills), $COLOR_INFO)
EndIf
_ArraySort($aDarkDrills, 1, 0, 0, 3)
Local $itotalStrikeGain = 0
While IsAttackPage() And $aSpells[0][4] + $aSpells[1][4] + $aSpells[2][4] > 0 And UBound($aDarkDrills) > 0 And $spellAdjust <> -1
Local $Spellused = $eLSpell
Local $skippedZap = True
Local $oldSearchDark = $searchDark
CheckHeroesHealth()
If($searchDark < Number($itxtMinDE)) And $ichkNoobZap = 1 Then
SetLog("Dark Elixir is below minimum value [" & Number($itxtMinDE) & "], Exiting Now!", $COLOR_INFO)
Return $performedZap
EndIf
displayZapLog($aDarkDrills, $aSpells)
Local $aCluster = getDrillCluster($aDarkDrills)
If $aCluster <> -1 Then
If $DebugSmartZap = 1 Then SetLog("Cluster Hold: " & $aCluster[2] & ", First Drill Hold: " & $aDarkDrills[0][3], $COLOR_DEBUG)
If $aCluster[2] < $aDarkDrills[0][3] Then $aCluster = -1
EndIf
If $ichkNoobZap = 1 Then
SetLog("NoobZap is going to attack any drill.", $COLOR_ACTION)
If $aCluster <> -1 Then
$Spellused = zapDrill($aSpells, $aCluster[0] + $strikeOffsets[0], $aCluster[1] + $strikeOffsets[1])
Else
$Spellused = zapDrill($aSpells, $aDarkDrills[0][0] + $strikeOffsets[0], $aDarkDrills[0][1] + $strikeOffsets[1])
EndIf
$performedZap = True
$skippedZap = False
If _Sleep($DelaySmartZap4) Then Return
Else
If $aSpells[0][4] + $aSpells[1][4] + $aSpells[2][4] >(4 - $spellAdjust) Then
SetLog("First condition: More than " & 4 - $spellAdjust & " Spells so attack any drill.", $COLOR_INFO)
If $aCluster <> -1 Then
$Spellused = zapDrill($aSpells, $aCluster[0] + $strikeOffsets[0], $aCluster[1] + $strikeOffsets[1])
Else
$Spellused = zapDrill($aSpells, $aDarkDrills[0][0] + $strikeOffsets[0], $aDarkDrills[0][1] + $strikeOffsets[1])
EndIf
$performedZap = True
$skippedZap = False
If _Sleep($DelaySmartZap4) Then Return
ElseIf $aSpells[0][4] + $aSpells[1][4] + $aSpells[2][4] >(3 - $spellAdjust) And $aDarkDrills[0][2] >(3 - $drillLvlOffset) Then
SetLog("Second condition: Attack Lvl " & 4 - Number($drillLvlOffset) & " and greater drills if you have more than " & 3 - Number($spellAdjust) & " spells", $COLOR_INFO)
If $aCluster <> -1 Then
$Spellused = zapDrill($aSpells, $aCluster[0] + $strikeOffsets[0], $aCluster[1] + $strikeOffsets[1])
Else
$Spellused = zapDrill($aSpells, $aDarkDrills[0][0] + $strikeOffsets[0], $aDarkDrills[0][1] + $strikeOffsets[1])
EndIf
$performedZap = True
$skippedZap = False
If _Sleep($DelaySmartZap4) Then Return
ElseIf $aDarkDrills[0][2] >(4 - $drillLvlOffset) And($aDarkDrills[0][3] /($g_aDrillLevelTotal[$aDarkDrills[0][2] - 1] * $g_fDarkStealFactor)) > 0.3 Then
SetLog("Third condition: Attack Lvl " & 5 - Number($drillLvlOffset) & " drills with more then 30% estimated DE left", $COLOR_INFO)
If $aCluster <> -1 Then
$Spellused = zapDrill($aSpells, $aCluster[0] + $strikeOffsets[0], $aCluster[1] + $strikeOffsets[1])
Else
$Spellused = zapDrill($aSpells, $aDarkDrills[0][0] + $strikeOffsets[0], $aDarkDrills[0][1] + $strikeOffsets[1])
EndIf
$performedZap = True
$skippedZap = False
If _Sleep($DelaySmartZap4) Then Return
ElseIf $aCluster <> -1 Then
If $aCluster[2] >=($g_aDrillLevelTotal[5 - $drillLvlOffset] / $g_aDrillLevelHP[5 - $drillLvlOffset] * $g_fDarkStealFactor * $g_aLSpellDmg[$aSpells[0][3] - 1] * $g_fDarkFillLevel) Then
SetLog("Fourth condition: Attack, when potential left content in cluster is greater than gain for a single Lvl " & 5 - Number($drillLvlOffset) & " drill", $COLOR_INFO)
$Spellused = zapDrill($aSpells, $aCluster[0] + $strikeOffsets[0], $aCluster[1] + $strikeOffsets[1])
EndIf
$performedZap = True
$skippedZap = False
If _Sleep($DelaySmartZap4) Then Return
Else
$skippedZap = True
SetLog("Drill did not match any attack conditions, so we will remove it from the list.", $COLOR_ACTION)
_ArrayDelete($aDarkDrills, 0)
EndIf
EndIf
$searchDark = getDarkElixir()
If Not $searchDark Or $searchDark = 0 Then
SetLog("No Dark Elixir so lets just exit!", $COLOR_INFO)
SetDebugLog("$searchDark = " & Number($searchDark))
If $skippedZap = False Then
If $Spellused = $eESpell Then
$g_iNumEQSpellsUsed[$CurrentAccount] += 1
Else
$g_iNumLSpellsUsed[$CurrentAccount] += 1
EndIf
$g_iSmartZapGain[$CurrentAccount] += $oldSearchDark
EndIf
Return $performedZap
Else
If $DebugSmartZap = 1 Then SetLog("$searchDark = " & Number($searchDark), $COLOR_DEBUG)
EndIf
If $skippedZap = False Then
If $DebugSmartZap = 1 Then Setlog("$oldSearchDark = [" & Number($oldSearchDark) & "] - $searchDark = [" & Number($searchDark) & "]", $COLOR_DEBUG)
$strikeGain = Number($oldSearchDark - $searchDark)
If $DebugSmartZap = 1 Then Setlog("$strikeGain = " & Number($strikeGain), $COLOR_DEBUG)
$expectedDE = -1
If $Spellused = $eESpell Then
$g_iNumEQSpellsUsed[$CurrentAccount] += 1
If $aCluster <> -1 Then
For $i = 0 To UBound($aCluster[3]) - 1
$expectedDE = _Max(Number($expectedDE), Ceiling(Number($g_aDrillLevelTotal[$aDarkDrills[($aCluster[3])[$i]][2] - 1] * $g_fDarkStealFactor * $g_aEQSpellDmg[$aSpells[2][3] - 1] * $g_fDarkFillLevel)))
Next
Else
$expectedDE = Ceiling(Number($g_aDrillLevelTotal[$aDarkDrills[0][2] - 1] * $g_fDarkStealFactor * $g_aEQSpellDmg[$aSpells[2][3] - 1] * $g_fDarkFillLevel))
EndIf
Else
$g_iNumLSpellsUsed[$CurrentAccount] += 1
If $ichkNoobZap = 0 Then
If $aCluster <> -1 Then
For $i = 0 To UBound($aCluster[3]) - 1
$expectedDE = _Max(Number($expectedDE), Ceiling(Number($g_aDrillLevelTotal[$aDarkDrills[($aCluster[3])[$i]][2] - 1] / $g_aDrillLevelHP[$aDarkDrills[($aCluster[3])[$i]][2] - 1] * $g_fDarkStealFactor * $g_aLSpellDmg[$aSpells[0][3] - 1] * $g_fDarkFillLevel)))
Next
Else
$expectedDE = Ceiling(Number($g_aDrillLevelTotal[$aDarkDrills[0][2] - 1] / $g_aDrillLevelHP[$aDarkDrills[0][2] - 1] * $g_fDarkStealFactor * $g_aLSpellDmg[$aSpells[0][3] - 1] * $g_fDarkFillLevel))
EndIf
Else
$expectedDE = $itxtExpectedDE
EndIf
EndIf
If $DebugSmartZap = 1 Then Setlog("$expectedDE = " & Number($expectedDE), $COLOR_DEBUG)
If $strikeGain < $expectedDE And $expectedDE <> -1 Then
SetLog("Gained: " & $strikeGain & ", Expected: " & $expectedDE, $COLOR_INFO)
If $aCluster <> -1 Then
_ArrayDelete($aDarkDrills, _ArrayToString($aCluster[3], ";"))
SetLog("Last zap gained less DE then expected, removing the drills from the list.", $COLOR_ACTION)
Else
_ArrayDelete($aDarkDrills, 0)
SetLog("Last zap gained less DE then expected, removing the drill from the list.", $COLOR_ACTION)
EndIf
Else
If _Sleep($DelaySmartZap4) Then Return
If $aCluster <> -1 Then
Local $iSumTotalHP = 0
Local $sToDelete = ""
If UBound($aCluster[3]) = 2 Then
For $i = 0 To 1
$iSumTotalHP += $g_aDrillLevelTotal[$aDarkDrills[($aCluster[3])[$i]][2] - 1] * $g_aDrillLevelHP[$aDarkDrills[($aCluster[3])[Mod($i + 1, 2) ]][2] - 1]
Next
For $i = 0 To 1
Local $iSubGain = Ceiling(Number($strikeGain * $g_aDrillLevelTotal[$aDarkDrills[($aCluster[3])[$i]][2] - 1] * $g_aDrillLevelHP[$aDarkDrills[($aCluster[3])[Mod($i + 1, 2) ]][2] - 1] / $iSumTotalHP))
If ReCheckDrillExist($aDarkDrills[($aCluster[3])[$i]][0], $aDarkDrills[($aCluster[3])[$i]][1]) Then
$aDarkDrills[($aCluster[3])[$i]][3] -= $iSubGain
SetLog(($i + 1) & ".Drill Gained: " & $iSubGain & ", adjusting amount left in this drill.", $COLOR_INFO)
ElseIf $sToDelete = "" Then
$sToDelete &=($aCluster[3])[$i]
SetLog(($i + 1) & ".Drill Gained: " & $iSubGain & ", drill was destroyed.", $COLOR_INFO)
Else
$sToDelete &= ";" &($aCluster[3])[$i]
SetLog(($i + 1) & ".Drill Gained: " & $iSubGain & ", drill was destroyed.", $COLOR_INFO)
EndIf
Next
Else
For $i = 0 To 2
$iSumTotalHP += $g_aDrillLevelTotal[$aDarkDrills[($aCluster[3])[$i]][2] - 1] * $g_aDrillLevelHP[$aDarkDrills[($aCluster[3])[Mod($i + 1, 3) ]][2] - 1] * $g_aDrillLevelHP[$aDarkDrills[($aCluster[3])[Mod($i + 2, 3) ]][2] - 1]
Next
For $i = 0 To 2
Local $iSubGain = Ceiling(Number($strikeGain * $g_aDrillLevelTotal[$aDarkDrills[($aCluster[3])[$i]][2] - 1] * $g_aDrillLevelHP[$aDarkDrills[($aCluster[3])[Mod($i + 1, 3) ]][2] - 1] * $g_aDrillLevelHP[$aDarkDrills[($aCluster[3])[Mod($i + 2, 3) ]][2] - 1]/ $iSumTotalHP))
If ReCheckDrillExist($aDarkDrills[($aCluster[3])[$i]][0], $aDarkDrills[($aCluster[3])[$i]][1]) Then
$aDarkDrills[($aCluster[3])[$i]][3] -= $iSubGain
SetLog(($i + 1) & ".Drill Gained: " & $iSubGain & ", adjusting amount left in this drill.", $COLOR_INFO)
ElseIf $sToDelete = "" Then
$sToDelete &=($aCluster[3])[$i]
SetLog(($i + 1) & ".Drill Gained: " & $iSubGain & ", drill was destroyed.", $COLOR_INFO)
Else
$sToDelete &= ";" &($aCluster[3])[$i]
SetLog(($i + 1) & ".Drill Gained: " & $iSubGain & ", drill was destroyed.", $COLOR_INFO)
EndIf
Next
EndIf
If $sToDelete <> "" Then _ArrayDelete($aDarkDrills, $sToDelete)
ElseIf Not ReCheckDrillExist($aDarkDrills[0][0], $aDarkDrills[0][1]) Then
_ArrayDelete($aDarkDrills, 0)
SetLog("Gained: " & Number($strikeGain) & ", drill was destroyed.", $COLOR_INFO)
Else
$aDarkDrills[0][3] -= $strikeGain
SetLog("Gained: " & Number($strikeGain) & ", adjusting amount left in this drill.", $COLOR_INFO)
EndIf
EndIf
$itotalStrikeGain += $strikeGain
$g_iSmartZapGain[$CurrentAccount] += $strikeGain
SetLog("Total DE from SmartZap/NoobZap: " & Number($itotalStrikeGain), $COLOR_INFO)
EndIf
_ArraySort($aDarkDrills, 1, 0, 0, 3)
If _Sleep($DelaySmartZap1) Then Return
If $aSpells[0][4] = 0 Then
Local $iTroops = PrepareAttack($g_iMatchMode, True)
If $iTroops > 0 Then
For $i = 0 To UBound($atkTroops) - 1
If $atkTroops[$i][0] = $eLSpell Then
If $DebugSmartZap = 1 Then SetLog("Donated " & NameOfTroop($atkTroops[$i][0], 0) & ": " & $atkTroops[$i][1], $COLOR_DEBUG)
$aSpells[1][2] = $i
$aSpells[1][3] = Number($g_iLSpellLevel)
$aSpells[1][4] = $atkTroops[$i][1]
EndIf
Next
EndIf
If $aSpells[1][4] > 0 Then
SetLog("Woohoo, found a donated " & NameOfTroop($aSpells[1][1], 0) & " (Lvl " & $aSpells[1][3] & ")", $COLOR_INFO)
EndIf
EndIf
WEnd
Return $performedZap
EndFunc
Func zapDrill(ByRef $Spells, $x, $y)
Local $iSpell
For $i = 0 to UBound($Spells) - 1
If $Spells[$i][4] > 0 Then
$iSpell = $i
EndIf
Next
If $Spells[$iSpell][2] > -1 Then
SetLog("Dropping " & $Spells[$iSpell][0] & " " & String(NameOfTroop($Spells[$iSpell][1], 0)), $COLOR_ACTION)
SelectDropTroop($Spells[$iSpell][2])
If _Sleep($iDelayCastSpell1) Then Return
If IsAttackPage() Then Click($x, $y, 1, 0, "#0029")
$Spells[$iSpell][4] -= 1
Else
If $DebugSmartZap = 1 Then SetLog("No " & String(NameOfTroop($Spells[$iSpell][1], 0)) & " Found", $COLOR_DEBUG)
EndIf
Return $Spells[$iSpell][1]
EndFunc
Func ReCheckDrillExist($x, $y)
_CaptureRegion2($x - 25, $y - 25, $x + 25, $y + 25)
Local $directory = @ScriptDir & "\imgxml\Storages\Drills"
Local $Maxpositions = 1
Local $aResult = multiMatches($directory, $Maxpositions, "FV", "FV", "", 0, 1000, False)
If UBound($aResult) > 1 Then
If $DebugSmartZap = 1 Then SetLog("ReCheckDrillExist: Yes| " & UBound($aResult), $COLOR_SUCCESS)
Return True
Else
If $DebugSmartZap = 1 Then SetLog("ReCheckDrillExist: No| " & UBound($aResult), $COLOR_ERROR)
EndIf
Return False
EndFunc
Func ParseAttackCSV($debug = False)
Global $ATTACKVECTOR_A, $ATTACKVECTOR_B, $ATTACKVECTOR_C, $ATTACKVECTOR_D, $ATTACKVECTOR_E, $ATTACKVECTOR_F
Global $ATTACKVECTOR_G, $ATTACKVECTOR_H, $ATTACKVECTOR_I, $ATTACKVECTOR_J, $ATTACKVECTOR_K, $ATTACKVECTOR_L
Global $ATTACKVECTOR_M, $ATTACKVECTOR_N, $ATTACKVECTOR_O, $ATTACKVECTOR_P, $ATTACKVECTOR_Q, $ATTACKVECTOR_R
Global $ATTACKVECTOR_S, $ATTACKVECTOR_T, $ATTACKVECTOR_U, $ATTACKVECTOR_V, $ATTACKVECTOR_W, $ATTACKVECTOR_X
Global $ATTACKVECTOR_Y, $ATTACKVECTOR_Z
Local $rownum = 0
Local $bForceSideExist = False
If $g_iMatchMode = $DB Then
Local $filename = $g_sAttackScrScriptName[$DB]
Else
Local $filename = $g_sAttackScrScriptName[$LB]
EndIf
Setlog("execute " & $filename)
Local $f, $line, $acommand, $command, $hTimer = 0
Local $value1 = "", $value2 = "", $value3 = "", $value4 = "", $value5 = "", $value6 = "", $value7 = "", $value8 = "", $value9 = ""
If FileExists($g_sCSVAttacksPath & "\" & $filename & ".csv") Then
checkForSidePInCSV($g_sCSVAttacksPath & "\" & $filename & ".csv")
checkForDropSInCSV($g_sCSVAttacksPath & "\" & $filename & ".csv")
Local $iLine, $aLines = FileReadToArray($g_sCSVAttacksPath & "\" & $filename & ".csv")
For $iLine = 0 To UBound($aLines) - 1
$line = $aLines[$iLine]
$rownum = $line + 1
If @error = -1 Then ExitLoop
If $debug = True Then Setlog("parse line:<<" & $line & ">>")
debugAttackCSV("line content: " & $line)
$acommand = StringSplit($line, "|")
If $acommand[0] >= 8 Then
$command = StringStripWS(StringUpper($acommand[1]), $STR_STRIPTRAILING)
For $i = 2 To(UBound($acommand) - 1)
Assign("value" & Number($i - 1), StringStripWS(StringUpper($acommand[$i]), $STR_STRIPTRAILING))
Next
Switch $command
Case ""
debugAttackCSV("comment line")
Case "MAKE"
ReleaseClicks()
If CheckCsvValues("MAKE", 2, $value2) Then
Local $sidex = StringReplace($value2, "-", "_")
If $sidex = "RANDOM" Then
Switch Random(1, 4, 1)
Case 1
$sidex = "FRONT_"
If Random(0, 1, 1) = 0 Then
$sidex &= "LEFT"
Else
$sidex &= "RIGHT"
EndIf
Case 2
$sidex = "BACK_"
If Random(0, 1, 1) = 0 Then
$sidex &= "LEFT"
Else
$sidex &= "RIGHT"
EndIf
Case 3
$sidex = "LEFT_"
If Random(0, 1, 1) = 0 Then
$sidex &= "FRONT"
Else
$sidex &= "BACK"
EndIf
Case 4
$sidex = "RIGHT_"
If Random(0, 1, 1) = 0 Then
$sidex &= "FRONT"
Else
$sidex &= "BACK"
EndIf
EndSwitch
EndIf
If CheckCsvValues("MAKE", 1, $value1) And CheckCsvValues("MAKE", 5, $value5) Then
Assign("ATTACKVECTOR_" & $value1, MakeDropPoints(Eval($sidex), $value3, $value4, $value5, $value6, $value7))
For $i = 0 To UBound(Execute("$ATTACKVECTOR_" & $value1)) - 1
Local $pixel = Execute("$ATTACKVECTOR_" & $value1 & "[" & $i & "]")
debugAttackCSV($i & " - " & $pixel[0] & "," & $pixel[1])
Next
Else
Setlog("Discard row, bad value1 or value 5 parameter: row " & $rownum)
debugAttackCSV("Discard row, bad value1 or value5 parameter")
EndIf
Else
Setlog("Discard row, bad value2 parameter:row " & $rownum)
debugAttackCSV("Discard row, bad value2 parameter:row " & $rownum)
EndIf
Case "DROP"
KeepClicks()
Local $index1, $index2, $indexArray, $indexvect
$indexvect = StringSplit($value2, "-", 2)
If UBound($indexvect) > 1 Then
$indexArray = 0
If Int($indexvect[0]) > 0 And Int($indexvect[1]) > 0 Then
$index1 = Int($indexvect[0])
$index2 = Int($indexvect[1])
Else
$index1 = 1
$index2 = 1
EndIf
Else
$indexArray = StringSplit($value2, ",", 2)
If UBound($indexArray) > 1 Then
$index1 = 0
$index2 = UBound($indexArray) - 1
Else
$indexArray = 0
If Int($value2) > 0 Then
$index1 = Int($value2)
$index2 = Int($value2)
Else
$index1 = 1
$index2 = 1
EndIf
EndIf
EndIf
Local $qty1, $qty2, $qtyvect, $bUpdateQuantity = False
If StringInStr($value3, "%") > 0 Then
$qtyvect = StringSplit($value3, "%", 2)
If UBound($qtyvect) > 0 Then
If UBound($qtyvect) > 1 Then $bUpdateQuantity =(($qtyvect[1] = "U") ? True : False)
Local $theTroopPosition = -2
Local $troopName = $value4
Local $iTroopIndex = TroopIndexLookup($troopName)
If $iTroopIndex = -1 Then
Setlog("CSV CMD '%' troop name '" & $troopName & "' is unrecognized.")
Return
EndIf
For $i = 0 To UBound($atkTroops) - 1
If $atkTroops[$i][0] = $iTroopIndex Then
$theTroopPosition = $i
ExitLoop
EndIf
Next
If $bUpdateQuantity = True Then
If $theTroopPosition >= 0 Then
SetLog("Updating Available " & NameOfTroop($iTroopIndex, 1) & " Quantities", $COLOR_INFO)
$theTroopPosition = UpdateTroopQuantity($troopName)
EndIf
EndIf
If $theTroopPosition >= 0 And UBound($atkTroops) > $theTroopPosition Then
If Int($qtyvect[0]) > 0 Then
$qty1 = Round((Number($qtyvect[0]) / 100) * Number($atkTroops[Number($theTroopPosition)][1]))
$qty2 = $qty1
Else
$index1 = 1
$qty2 = 1
EndIf
Else
$qty1 = 0
$qty2 = 0
EndIf
Else
If Int($value3) > 0 Then
$qty1 = Int($value3)
$qty2 = Int($value3)
Else
$qty1 = 1
$qty2 = 1
EndIf
EndIf
Else
$qtyvect = StringSplit($value3, "-", 2)
If UBound($qtyvect) > 1 Then
If Int($qtyvect[0]) > 0 And Int($qtyvect[1]) > 0 Then
$qty1 = Int($qtyvect[0])
$qty2 = Int($qtyvect[1])
Else
$index1 = 1
$qty2 = 1
EndIf
Else
If Int($value3) > 0 Then
$qty1 = Int($value3)
$qty2 = Int($value3)
Else
$qty1 = 1
$qty2 = 1
EndIf
EndIf
EndIf
Local $delaypoints1, $delaypoints2, $delaypointsvect
$delaypointsvect = StringSplit($value5, "-", 2)
If UBound($delaypointsvect) > 1 Then
If Int($delaypointsvect[0]) >= 0 And Int($delaypointsvect[1]) >= 0 Then
$delaypoints1 = Int($delaypointsvect[0])
$delaypoints2 = Int($delaypointsvect[1])
Else
$delaypoints1 = 1
$delaypoints2 = 1
EndIf
Else
If Int($value5) >= 0 Then
$delaypoints1 = Int($value5)
$delaypoints2 = Int($value5)
Else
$delaypoints1 = 1
$delaypoints2 = 1
EndIf
EndIf
Local $delaydrop1, $delaydrop2, $delaydropvect
$delaydropvect = StringSplit($value6, "-", 2)
If UBound($delaydropvect) > 1 Then
If Int($delaydropvect[0]) >= 0 And Int($delaydropvect[1]) >= 0 Then
$delaydrop1 = Int($delaydropvect[0])
$delaydrop2 = Int($delaydropvect[1])
Else
$delaydrop1 = 1
$delaydrop2 = 1
EndIf
Else
If Int($value6) >= 0 Then
$delaydrop1 = Int($value6)
$delaydrop2 = Int($value6)
Else
$delaydrop1 = 1
$delaydrop2 = 1
EndIf
EndIf
Local $sleepdrop1, $sleepdrop2, $sleepdroppvect
$sleepdroppvect = StringSplit($value7, "-", 2)
If UBound($sleepdroppvect) > 1 Then
If Int($sleepdroppvect[0]) >= 0 And Int($sleepdroppvect[1]) >= 0 Then
$sleepdrop1 = Int($sleepdroppvect[0])
$sleepdrop2 = Int($sleepdroppvect[1])
Else
$index1 = 1
$sleepdrop2 = 1
EndIf
Else
If Int($value7) >= 0 Then
$sleepdrop1 = Int($value7)
$sleepdrop2 = Int($value7)
Else
$sleepdrop1 = 1
$sleepdrop2 = 1
EndIf
EndIf
Local $sleepbeforedrop1 = 0, $sleepbeforedrop2 = 0, $sleepbeforedroppvect
$sleepbeforedroppvect = StringSplit($value8, "-", 2)
If UBound($sleepbeforedroppvect) > 1 Then
If Int($sleepbeforedroppvect[0]) > 0 And Int($sleepbeforedroppvect[1]) > 0 Then
$sleepbeforedrop1 = Int($sleepbeforedroppvect[0])
$sleepbeforedrop2 = Int($sleepbeforedroppvect[1])
Else
$sleepbeforedrop1 = 0
$sleepbeforedrop2 = 0
EndIf
Else
If Int($value3) > 0 Then
$sleepbeforedrop1 = Int($value8)
$sleepbeforedrop2 = Int($value8)
Else
$sleepbeforedrop1 = 0
$sleepbeforedrop2 = 0
EndIf
EndIf
If $value4 = "REMAIN" Then
SetLog("dropRemain:  Dropping left over troops", $COLOR_BLUE)
If PrepareAttack($g_iMatchMode, True) > 0 Then
For $ii = $eLava To $eBarb Step -1
LauchTroop($ii, 1, 0, 1)
Next
EndIf
Else
DropTroopFromINI($value1, $index1, $index2, $indexArray, $qty1, $qty2, $value4, $delaypoints1, $delaypoints2, $delaydrop1, $delaydrop2, $sleepdrop1, $sleepdrop2, $sleepbeforedrop1, $sleepbeforedrop2, $debug)
EndIf
ReleaseClicks($g_bAndroidAdbClicksEnabled)
If _Sleep($iDelayRespond) Then
Return
EndIf
Case "DROPS"
KeepClicks()
Local $qty1, $qty2, $qtyvect
$qtyvect = StringSplit($value3, "-", 2)
If UBound($qtyvect) > 1 Then
If Int($qtyvect[0]) > 0 And Int($qtyvect[1]) > 0 Then
$qty1 = Int($qtyvect[0])
$qty2 = Int($qtyvect[1])
Else
$index1 = 1
$qty2 = 1
EndIf
Else
If Int($value3) > 0 Then
$qty1 = Int($value3)
$qty2 = Int($value3)
Else
$qty1 = 1
$qty2 = 1
EndIf
EndIf
Local $delaypoints1, $delaypoints2, $delaypointsvect
$delaypointsvect = StringSplit($value5, "-", 2)
If UBound($delaypointsvect) > 1 Then
If Int($delaypointsvect[0]) > 0 And Int($delaypointsvect[1]) > 0 Then
$delaypoints1 = Int($delaypointsvect[0])
$delaypoints2 = Int($delaypointsvect[1])
Else
$delaypoints1 = 1
$delaypoints2 = 1
EndIf
Else
If Int($value3) > 0 Then
$delaypoints1 = Int($value5)
$delaypoints2 = Int($value5)
Else
$delaypoints1 = 1
$delaypoints2 = 1
EndIf
EndIf
Local $delaydrop1, $delaydrop2, $delaydropvect
$delaydropvect = StringSplit($value6, "-", 2)
If UBound($delaydropvect) > 1 Then
If Int($delaydropvect[0]) > 0 And Int($delaydropvect[1]) > 0 Then
$delaydrop1 = Int($delaydropvect[0])
$delaydrop2 = Int($delaydropvect[1])
Else
$delaydrop1 = 1
$delaydrop2 = 1
EndIf
Else
If Int($value3) > 0 Then
$delaydrop1 = Int($value6)
$delaydrop2 = Int($value6)
Else
$delaydrop1 = 1
$delaydrop2 = 1
EndIf
EndIf
Local $sleepdrop1, $sleepdrop2, $sleepdroppvect
$sleepdroppvect = StringSplit($value7, "-", 2)
If UBound($sleepdroppvect) > 1 Then
If Int($sleepdroppvect[0]) > 0 And Int($sleepdroppvect[1]) > 0 Then
$sleepdrop1 = Int($sleepdroppvect[0])
$sleepdrop2 = Int($sleepdroppvect[1])
Else
$index1 = 1
$sleepdrop2 = 1
EndIf
Else
If Int($value3) > 0 Then
$sleepdrop1 = Int($value7)
$sleepdrop2 = Int($value7)
Else
$sleepdrop1 = 1
$sleepdrop2 = 1
EndIf
EndIf
DropSpellFromINIOnDefense($value1, $value2, $qty1, $qty2, $value4, $delaypoints1, $delaypoints2, $delaydrop1, $delaydrop2, $sleepdrop1, $sleepdrop2, $debug)
ReleaseClicks($g_bAndroidAdbClicksEnabled)
If _Sleep($iDelayRespond) Then
Return
EndIf
Case "ZINIT"
ReleaseClicks()
ZInit(String($value1 & "|" & $value2 & "|" & $value3 & "|" & $value4 & "|" & $value5 & "|" & $value6 & "|" & $value7 & "|" & $value8))
Case "ZAP"
KeepClicks()
Local $splitedVal8 = StringSplit($value8, "-", 2)
If StringInStr($value8, "-") > 0 Then $value8 = Int(Random(Number($splitedVal8[0]), Number($splitedVal8[1]), 1))
ParseZapCommand(String($value1 & "|" & $value2 & "|" & $value3 & "|" & $value4 & "|" & $value5 & "|" & $value6 & "|" & $value7 & "|" & $value8))
Case "WAIT"
ReleaseClicks()
Local $sleep1, $sleep2, $sleepvect
$sleepvect = StringSplit($value1, "-", 2)
If UBound($sleepvect) > 1 Then
If Int($sleepvect[0]) > 0 And Int($sleepvect[1]) > 0 Then
$sleep1 = Int($sleepvect[0])
$sleep2 = Int($sleepvect[1])
Else
$sleep1 = 1
$sleep2 = 1
EndIf
Else
If Int($value3) > 0 Then
$sleep1 = Int($value1)
$sleep2 = Int($value1)
Else
$sleep1 = 1
$sleep2 = 1
EndIf
EndIf
If $sleep1 <> $sleep2 Then
Local $sleep = Random(Int($sleep1), Int($sleep2), 1)
Else
Local $sleep = Int($sleep1)
EndIf
debugAttackCSV("wait " & $sleep)
Local $Gold = 0
Local $Elixir = 0
Local $DarkElixir = 0
Local $Trophies = 0
Local $exitOneStar = 0
Local $exitTwoStars = 0
Local $exitNoResources = 0
Local $hSleepTimer = TimerInit()
While TimerDiff($hSleepTimer) < $sleep
If $iActivateKQCondition = "Auto" Then CheckHeroesHealth()
$Gold = getGoldVillageSearch(48, 69)
$Elixir = getElixirVillageSearch(48, 69 + 29)
If _Sleep($iDelayRespond) Then
Return
EndIf
$Trophies = getTrophyVillageSearch(48, 69 + 99)
If $Trophies <> "" Then
$DarkElixir = getDarkElixirVillageSearch(48, 69 + 57)
Else
$DarkElixir = ""
$Trophies = getTrophyVillageSearch(48, 69 + 69)
EndIf
If $iActivateKQCondition = "Auto" Then CheckHeroesHealth()
If $g_iDebugSetlog = 1 Then SetLog("detected [G]: " & $Gold & " [E]: " & $Elixir & " [DE]: " & $DarkElixir, $COLOR_INFO)
If $g_abStopAtkNoResources[$g_iMatchMode] = 1 And Number($Gold) = 0 And Number($Elixir) = 0 And Number($DarkElixir) = 0 Then
If $g_iDebugSetlog = 0 Then SetDebugLog("detected [G]: " & $Gold & " [E]: " & $Elixir & " [DE]: " & $DarkElixir, $COLOR_INFO)
SetDebugLog("From Attackcsv: Gold & Elixir & DE = 0, end battle ", $COLOR_DEBUG)
$exitNoResources = 1
ExitLoop
EndIf
If $g_abStopAtkTwoStars[$g_iMatchMode] = 1 And _CheckPixel($aWonTwoStar, True) Then
SetDebugLog("From Attackcsv: Two Star Reach, exit", $COLOR_SUCCESS)
$exitTwoStars = 1
ExitLoop
EndIf
If $g_abStopAtkOneStar[$g_iMatchMode] = 1 And _CheckPixel($aWonOneStar, True) Then
SetDebugLog("From Attackcsv: One Star Reach, exit", $COLOR_SUCCESS)
$exitOneStar = 1
ExitLoop
EndIf
If $g_abStopAtkPctHigherEnable[$g_iMatchMode] And Number(getOcrOverAllDamage(780, 527 + $g_iBottomOffsetY)) > Int($g_aiStopAtkPctHigherAmt[$g_iMatchMode]) Then
ExitLoop
EndIf
If _Sleep($iDelayRespond) Then
Return
EndIf
WEnd
If $exitOneStar = 1 Or $exitTwoStars = 1 Or $exitNoResources = 1 Then ExitLoop
Case "RECALC"
ReleaseClicks()
PrepareAttack($g_iMatchMode, True)
Case "SIDE"
ReleaseClicks()
Local $heightTopLeft = 0, $heightTopRight = 0, $heightBottomLeft = 0, $heightBottomRight = 0
Setlog("Calculate main side... ")
If StringUpper($value8) = "EAGLE" Then
Setlog("Forced side: " & StringUpper($value8))
$hTimer = TimerInit()
Local $directory = @ScriptDir & "\imgxml\WeakBase\Eagle"
Local $return = returnHighestLevelSingleMatch($directory)
Local $NotdetectedEagle = True
If $g_iDebugSetlog = 1 Then Setlog(" »» Ubound ROW $return: " & UBound($return, $UBOUND_ROWS), $COLOR_DEBUG)
If $g_iDebugSetlog = 1 Then Setlog(" »» Ubound COLUMNS $return: " & UBound($return, $UBOUND_COLUMNS), $COLOR_DEBUG)
If $g_iDebugSetlog = 1 Then Setlog(" »» Ubound DIMENSIONS $return: " & UBound($return, $UBOUND_DIMENSIONS), $COLOR_DEBUG)
If UBound($return) > 1 And $return[1] <> "NONE" Then
If $g_iDebugSetlog = 1 Then Setlog(" »» Image: " & $return[0], $COLOR_DEBUG)
If $g_iDebugSetlog = 1 Then Setlog(" »» Build: " & $return[1], $COLOR_DEBUG)
If $g_iDebugSetlog = 1 Then Setlog(" »» Level: " & $return[2], $COLOR_DEBUG)
Local $EaglePosition = $return[5]
If $g_iDebugSetlog = 1 Then Setlog(" »» $EaglePosition[0] X: " & $EaglePosition[0][0], $COLOR_DEBUG)
If $g_iDebugSetlog = 1 Then Setlog(" »» $EaglePosition[1] Y: " & $EaglePosition[0][1], $COLOR_DEBUG)
If $g_iDebugSetlog = 1 Then Setlog(" »» Ubound ROW $EaglePosition: " & UBound($EaglePosition, $UBOUND_ROWS), $COLOR_DEBUG)
If $g_iDebugSetlog = 1 Then Setlog(" »» Ubound COLUMNS $EaglePosition: " & UBound($EaglePosition, $UBOUND_COLUMNS), $COLOR_DEBUG)
If $g_iDebugSetlog = 1 Then Setlog(" »» Ubound DIMENSIONS $EaglePosition: " & UBound($EaglePosition, $UBOUND_DIMENSIONS), $COLOR_DEBUG)
If $EaglePosition[0][0] <> "" Then
$PixelEaglePos[0] = $EaglePosition[0][0]
$PixelEaglePos[1] = $EaglePosition[0][1]
Setlog(" »» Eagle located in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds")
Switch StringLeft(Slice8($PixelEaglePos), 1)
Case 1, 2
$MAINSIDE = "BOTTOM-RIGHT"
Case 3, 4
$MAINSIDE = "TOP-RIGHT"
Case 5, 6
$MAINSIDE = "TOP-LEFT"
Case 7, 8
$MAINSIDE = "BOTTOM-LEFT"
EndSwitch
Setlog(" » Eagle located : " & $MAINSIDE, $COLOR_BLUE)
$NotdetectedEagle = False
Else
Setlog("> Eagle not detected!", $COLOR_BLUE)
DebugImageSave("EagleDetection_NotDetected_", True)
EndIf
Else
Setlog("> Eagle not Present!", $COLOR_BLUE)
DebugImageSave("EagleDetection_NotPresent_", True)
EndIf
If $MAINSIDE = "" Then $MAINSIDE = "TOP-RIGHT"
If $attackcsv_locate_townhall = 1 And $NotdetectedEagle = True Then
Local $pixel = StringSplit($thx & "-" & $thy, "-", 2)
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$MAINSIDE = "BOTTOM-RIGHT"
Case 3, 4
$MAINSIDE = "TOP-RIGHT"
Case 5, 6
$MAINSIDE = "TOP-LEFT"
Case 7, 8
$MAINSIDE = "BOTTOM-LEFT"
EndSwitch
EndIf
ElseIf StringUpper($value8) = "ADEFENSE" Or StringUpper($value8) = "AIRDEFENSE" Then
Setlog("Forced side: " & StringUpper($value8))
Local $directory = @ScriptDir & "\imgxml\WeakBase\ADefense"
Local $rADefenseSearch = multiMatchesPixelOnly($directory, 0, $ECD, $ECD)
If StringInStr($rADefenseSearch, ",") > 0 And StringLen($rADefenseSearch) > 2 Then
Local $tmpSplitedPositions
If StringInStr($rADefenseSearch, "|") > 0 Then
$tmpSplitedPositions = StringSplit($rADefenseSearch, "|", 2)
Local $splitedPositions[UBound($tmpSplitedPositions)][2]
Else
$tmpSplitedPositions = StringSplit($rADefenseSearch, ",", 2)
Local $splitedPositions[1][2] = [[-1, -1]]
EndIf
For $i = 0 To(UBound($tmpSplitedPositions) - 1)
$splitedPositions[$i][0] = StringSplit($tmpSplitedPositions[$i], ",", 2)[0]
$splitedPositions[$i][1] = StringSplit($tmpSplitedPositions[$i], ",", 2)[1]
Next
SetLog(UBound($splitedPositions) & "x Air Defenses Found")
Local $iABottomRight = 0, $iATopLeft = 0, $iATopRight = 0, $iABottomLeft = 0
For $i = 0 To(UBound($splitedPositions) - 1)
Local $Px[2] = [$splitedPositions[$i][0], $splitedPositions[$i][1]]
Switch StringLeft(Slice8($Px), 1)
Case 1, 2
$iABottomRight += 1
Case 3, 4
$iATopRight += 1
Case 5, 6
$iATopLeft += 1
Case 7, 8
$iABottomLeft += 1
EndSwitch
Next
Local $maxValue = $iABottomRight
Local $sidename = "BOTTOM-RIGHT"
If $iATopLeft > $maxValue Then
$maxValue = $iATopLeft
$sidename = "TOP-LEFT"
EndIf
If $iATopRight > $maxValue Then
$maxValue = $iATopRight
$sidename = "TOP-RIGHT"
EndIf
If $iABottomLeft > $maxValue Then
$maxValue = $iABottomLeft
$sidename = "BOTTOM-LEFT"
EndIf
$MAINSIDE = $sidename
Setlog(" » Air Defenses located : " & $MAINSIDE, $COLOR_BLUE)
Else
SetLog("No Air Defenses found to determine Main Side", $COLOR_BLUE)
$MAINSIDE = "TOP-RIGHT"
If $attackcsv_locate_townhall = 1 Then
Local $pixel = StringSplit($thx & "-" & $thy, "-", 2)
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$MAINSIDE = "BOTTOM-RIGHT"
Case 3, 4
$MAINSIDE = "TOP-RIGHT"
Case 5, 6
$MAINSIDE = "TOP-LEFT"
Case 7, 8
$MAINSIDE = "BOTTOM-LEFT"
EndSwitch
SetLog("MAINSIDE = TH Side")
Else
SetLog("MAINSIDE = TOP-RIGHT")
EndIf
EndIf
Local $heightTopLeft = 0, $heightTopRight = 0, $heightBottomLeft = 0, $heightBottomRight = 0
ElseIf StringUpper($value8) = "TOP-LEFT" Or StringUpper($value8) = "TOP-RIGHT" Or StringUpper($value8) = "BOTTOM-LEFT" Or StringUpper($value8) = "BOTTOM-RIGHT" Then
$MAINSIDE = StringUpper($value8)
Setlog("Forced side: " & StringUpper($value8), $COLOR_INFO)
$bForceSideExist = True
Else
UpdateResourcesLocations($line)
For $i = 0 To UBound($PixelMine) - 1
Local $str = ""
Local $pixel = $PixelMine[$i]
If UBound($pixel) = 2 Then
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$heightBottomRight += Int($value1)
Case 3, 4
$heightTopRight += Int($value1)
Case 5, 6
$heightTopLeft += Int($value1)
Case 7, 8
$heightBottomLeft += Int($value1)
EndSwitch
EndIf
Next
For $i = 0 To UBound($PixelElixir) - 1
Local $str = ""
Local $pixel = $PixelElixir[$i]
If UBound($pixel) = 2 Then
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$heightBottomRight += Int($value2)
Case 3, 4
$heightTopRight += Int($value2)
Case 5, 6
$heightTopLeft += Int($value2)
Case 7, 8
$heightBottomLeft += Int($value2)
EndSwitch
EndIf
Next
For $i = 0 To UBound($PixelDarkElixir) - 1
Local $str = ""
Local $pixel = $PixelDarkElixir[$i]
If UBound($pixel) = 2 Then
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$heightBottomRight += Int($value3)
Case 3, 4
$heightTopRight += Int($value3)
Case 5, 6
$heightTopLeft += Int($value3)
Case 7, 8
$heightBottomLeft += Int($value3)
EndSwitch
EndIf
Next
If IsArray($GoldStoragePos) Then
For $i = 0 To UBound($GoldStoragePos) - 1
Local $pixel = $GoldStoragePos[$i]
If UBound($pixel) = 2 Then
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$heightBottomRight += Int($value4)
Case 3, 4
$heightTopRight += Int($value4)
Case 5, 6
$heightTopLeft += Int($value4)
Case 7, 8
$heightBottomLeft += Int($value4)
EndSwitch
EndIf
Next
EndIf
If IsArray($ElixirStoragePos) Then
For $i = 0 To UBound($ElixirStoragePos) - 1
Local $pixel = $ElixirStoragePos[$i]
If UBound($pixel) = 2 Then
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$heightBottomRight += Int($value5)
Case 3, 4
$heightTopRight += Int($value5)
Case 5, 6
$heightTopLeft += Int($value5)
Case 7, 8
$heightBottomLeft += Int($value5)
EndSwitch
EndIf
Next
EndIf
Switch StringLeft(Slice8($darkelixirStoragePos), 1)
Case 1, 2
$heightBottomRight += Int($value6)
Case 3, 4
$heightTopRight += Int($value6)
Case 5, 6
$heightTopLeft += Int($value6)
Case 7, 8
$heightBottomLeft += Int($value6)
EndSwitch
Local $pixel = StringSplit($thx & "-" & $thy, "-", 2)
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$heightBottomRight += Int($value7)
Case 3, 4
$heightTopRight += Int($value7)
Case 5, 6
$heightTopLeft += Int($value7)
Case 7, 8
$heightBottomLeft += Int($value7)
EndSwitch
EndIf
If $bForceSideExist = False Then
Local $maxValue = $heightBottomRight
Local $sidename = "BOTTOM-RIGHT"
If $heightTopLeft > $maxValue Then
$maxValue = $heightTopLeft
$sidename = "TOP-LEFT"
EndIf
If $heightTopRight > $maxValue Then
$maxValue = $heightTopRight
$sidename = "TOP-RIGHT"
EndIf
If $heightBottomLeft > $maxValue Then
$maxValue = $heightBottomLeft
$sidename = "BOTTOM-LEFT"
EndIf
Setlog("Mainside: " & $sidename & " (top-left:" & $heightTopLeft & " top-right:" & $heightTopRight & " bottom-left:" & $heightBottomLeft & " bottom-right:" & $heightBottomRight & ")")
$MAINSIDE = $sidename
EndIf
Switch $MAINSIDE
Case "BOTTOM-RIGHT"
$FRONT_LEFT = "BOTTOM-RIGHT-DOWN"
$FRONT_RIGHT = "BOTTOM-RIGHT-UP"
$RIGHT_FRONT = "TOP-RIGHT-DOWN"
$RIGHT_BACK = "TOP-RIGHT-UP"
$LEFT_FRONT = "BOTTOM-LEFT-DOWN"
$LEFT_BACK = "BOTTOM-LEFT-UP"
$BACK_LEFT = "TOP-LEFT-DOWN"
$BACK_RIGHT = "TOP-LEFT-UP"
Case "BOTTOM-LEFT"
$FRONT_LEFT = "BOTTOM-LEFT-UP"
$FRONT_RIGHT = "BOTTOM-LEFT-DOWN"
$RIGHT_FRONT = "BOTTOM-RIGHT-DOWN"
$RIGHT_BACK = "BOTTOM-RIGHT-UP"
$LEFT_FRONT = "TOP-LEFT-DOWN"
$LEFT_BACK = "TOP-LEFT-UP"
$BACK_LEFT = "TOP-RIGHT-UP"
$BACK_RIGHT = "TOP-RIGHT-DOWN"
Case "TOP-LEFT"
$FRONT_LEFT = "TOP-LEFT-UP"
$FRONT_RIGHT = "TOP-LEFT-DOWN"
$RIGHT_FRONT = "BOTTOM-LEFT-UP"
$RIGHT_BACK = "BOTTOM-LEFT-DOWN"
$LEFT_FRONT = "TOP-RIGHT-UP"
$LEFT_BACK = "TOP-RIGHT-DOWN"
$BACK_LEFT = "BOTTOM-RIGHT-UP"
$BACK_RIGHT = "BOTTOM-RIGHT-DOWN"
Case "TOP-RIGHT"
$FRONT_LEFT = "TOP-RIGHT-DOWN"
$FRONT_RIGHT = "TOP-RIGHT-UP"
$RIGHT_FRONT = "TOP-LEFT-UP"
$RIGHT_BACK = "TOP-LEFT-DOWN"
$LEFT_FRONT = "BOTTOM-RIGHT-UP"
$LEFT_BACK = "BOTTOM-RIGHT-DOWN"
$BACK_LEFT = "BOTTOM-LEFT-DOWN"
$BACK_RIGHT = "BOTTOM-LEFT-UP"
EndSwitch
Case "SIDEB"
ReleaseClicks()
If $bForceSideExist = False Then
Setlog("Recalculate main side for additional defense buildings... ", $COLOR_INFO)
Switch StringLeft(Slice8($EagleArtilleryPos), 1)
Case 1, 2
$heightBottomRight += Int($value1)
Case 3, 4
$heightTopRight += Int($value1)
Case 5, 6
$heightTopLeft += Int($value1)
Case 7, 8
$heightBottomLeft += Int($value1)
EndSwitch
Local $maxValue = $heightBottomRight
Local $sidename = "BOTTOM-RIGHT"
If $heightTopLeft > $maxValue Then
$maxValue = $heightTopLeft
$sidename = "TOP-LEFT"
EndIf
If $heightTopRight > $maxValue Then
$maxValue = $heightTopRight
$sidename = "TOP-RIGHT"
EndIf
If $heightBottomLeft > $maxValue Then
$maxValue = $heightBottomLeft
$sidename = "BOTTOM-LEFT"
EndIf
Setlog("New Mainside: " & $sidename & " (top-left:" & $heightTopLeft & " top-right:" & $heightTopRight & " bottom-left:" & $heightBottomLeft & " bottom-right:" & $heightBottomRight & ")", $COLOR_INFO)
$MAINSIDE = $sidename
EndIf
Switch $MAINSIDE
Case "BOTTOM-RIGHT"
$FRONT_LEFT = "BOTTOM-RIGHT-DOWN"
$FRONT_RIGHT = "BOTTOM-RIGHT-UP"
$RIGHT_FRONT = "TOP-RIGHT-DOWN"
$RIGHT_BACK = "TOP-RIGHT-UP"
$LEFT_FRONT = "BOTTOM-LEFT-DOWN"
$LEFT_BACK = "BOTTOM-LEFT-UP"
$BACK_LEFT = "TOP-LEFT-DOWN"
$BACK_RIGHT = "TOP-LEFT-UP"
Case "BOTTOM-LEFT"
$FRONT_LEFT = "BOTTOM-LEFT-UP"
$FRONT_RIGHT = "BOTTOM-LEFT-DOWN"
$RIGHT_FRONT = "BOTTOM-RIGHT-DOWN"
$RIGHT_BACK = "BOTTOM-RIGHT-UP"
$LEFT_FRONT = "TOP-LEFT-DOWN"
$LEFT_BACK = "TOP-LEFT-UP"
$BACK_LEFT = "TOP-RIGHT-UP"
$BACK_RIGHT = "TOP-RIGHT-DOWN"
Case "TOP-LEFT"
$FRONT_LEFT = "TOP-LEFT-UP"
$FRONT_RIGHT = "TOP-LEFT-DOWN"
$RIGHT_FRONT = "BOTTOM-LEFT-UP"
$RIGHT_BACK = "BOTTOM-LEFT-DOWN"
$LEFT_FRONT = "TOP-RIGHT-UP"
$LEFT_BACK = "TOP-RIGHT-DOWN"
$BACK_LEFT = "BOTTOM-RIGHT-UP"
$BACK_RIGHT = "BOTTOM-RIGHT-DOWN"
Case "TOP-RIGHT"
$FRONT_LEFT = "TOP-RIGHT-DOWN"
$FRONT_RIGHT = "TOP-RIGHT-UP"
$RIGHT_FRONT = "TOP-LEFT-UP"
$RIGHT_BACK = "TOP-LEFT-DOWN"
$LEFT_FRONT = "BOTTOM-RIGHT-UP"
$LEFT_BACK = "BOTTOM-RIGHT-DOWN"
$BACK_LEFT = "BOTTOM-LEFT-DOWN"
$BACK_RIGHT = "BOTTOM-LEFT-UP"
EndSwitch
Case "SIDEP"
Local $sidep_locate_mine = 0, $sidep_locate_elixir = 0, $sidep_locate_drill = 0
$sidep_locate_mine = IIf(Int($value1) > 0, 1, 0)
$sidep_locate_elixir = IIf(Int($value2) > 0, 1, 0)
$sidep_locate_drill = IIf(Int($value3) > 0, 1, 0)
Local $heightTopLeft = 0, $heightTopRight = 0, $heightBottomLeft = 0, $heightBottomRight = 0
Local $rGetCountEachSide
Local $hLTimer
If $sidep_locate_mine = 1 Then
$hLTimer = TimerInit()
$rGetCountEachSide = GetCountEachSide("Mine")
If Not @error Then
SetLog("Gold Mines Located within " & Round(Number(TimerDiff($hLTimer) / 1000), 2) & " second(s)")
$heightBottomRight +=($rGetCountEachSide[0] * Int($value1))
$heightTopRight +=($rGetCountEachSide[1] * Int($value1))
$heightTopLeft +=($rGetCountEachSide[2] * Int($value1))
$heightBottomLeft +=($rGetCountEachSide[3] * Int($value1))
ElseIf @error = 2 Then
SetLog("Cannot find Gold Mines", $COLOR_ORANGE)
EndIf
EndIf
If $sidep_locate_elixir = 1 Then
$hLTimer = TimerInit()
$rGetCountEachSide = GetCountEachSide("Collector")
If Not @error Then
SetLog("Elixir Collectors Located within " & Round(Number(TimerDiff($hLTimer) / 1000), 2) & " second(s)")
$heightBottomRight +=($rGetCountEachSide[0] * Int($value2))
$heightTopRight +=($rGetCountEachSide[1] * Int($value2))
$heightTopLeft +=($rGetCountEachSide[2] * Int($value2))
$heightBottomLeft +=($rGetCountEachSide[3] * Int($value2))
ElseIf @error = 2 Then
SetLog("Cannot find Elixir Collectors", $COLOR_ORANGE)
EndIf
EndIf
If $sidep_locate_drill = 1 Then
$hLTimer = TimerInit()
$rGetCountEachSide = GetCountEachSide("Drill")
If Not @error Then
SetLog("Dark Drills Located within " & Round(Number(TimerDiff($hLTimer) / 1000), 2) & " second(s)")
$heightBottomRight +=($rGetCountEachSide[0] * Int($value3))
$heightTopRight +=($rGetCountEachSide[1] * Int($value3))
$heightTopLeft +=($rGetCountEachSide[2] * Int($value3))
$heightBottomLeft +=($rGetCountEachSide[3] * Int($value3))
ElseIf @error = 2 Then
SetLog("Cannot find Dark Drills", $COLOR_ORANGE)
EndIf
EndIf
Local $maxValue = $heightBottomRight
Local $sidename = "BOTTOM-RIGHT"
Switch $value8
Case "Highest"
If $heightTopLeft > $maxValue Then
$maxValue = $heightTopLeft
$sidename = "TOP-LEFT"
EndIf
If $heightTopRight > $maxValue Then
$maxValue = $heightTopRight
$sidename = "TOP-RIGHT"
EndIf
If $heightBottomLeft > $maxValue Then
$maxValue = $heightBottomLeft
$sidename = "BOTTOM-LEFT"
EndIf
Case "Lowest"
If $heightTopLeft < $maxValue Then
$maxValue = $heightTopLeft
$sidename = "TOP-LEFT"
EndIf
If $heightTopRight < $maxValue Then
$maxValue = $heightTopRight
$sidename = "TOP-RIGHT"
EndIf
If $heightBottomLeft < $maxValue Then
$maxValue = $heightBottomLeft
$sidename = "BOTTOM-LEFT"
EndIf
Case Else
If $heightTopLeft > $maxValue Then
$maxValue = $heightTopLeft
$sidename = "TOP-LEFT"
EndIf
If $heightTopRight > $maxValue Then
$maxValue = $heightTopRight
$sidename = "TOP-RIGHT"
EndIf
If $heightBottomLeft > $maxValue Then
$maxValue = $heightBottomLeft
$sidename = "BOTTOM-LEFT"
EndIf
EndSwitch
Setlog("SideP-Mainside: " & $sidename & " (top-left:" & $heightTopLeft & " top-right:" & $heightTopRight & " bottom-left:" & $heightBottomLeft & " bottom-right:" & $heightBottomRight & ")")
$MAINSIDE = $sidename
Switch $MAINSIDE
Case "BOTTOM-RIGHT"
$FRONT_LEFT = "BOTTOM-RIGHT-DOWN"
$FRONT_RIGHT = "BOTTOM-RIGHT-UP"
$RIGHT_FRONT = "TOP-RIGHT-DOWN"
$RIGHT_BACK = "TOP-RIGHT-UP"
$LEFT_FRONT = "BOTTOM-LEFT-DOWN"
$LEFT_BACK = "BOTTOM-LEFT-UP"
$BACK_LEFT = "TOP-LEFT-DOWN"
$BACK_RIGHT = "TOP-LEFT-UP"
Case "BOTTOM-LEFT"
$FRONT_LEFT = "BOTTOM-LEFT-UP"
$FRONT_RIGHT = "BOTTOM-LEFT-DOWN"
$RIGHT_FRONT = "BOTTOM-RIGHT-DOWN"
$RIGHT_BACK = "BOTTOM-RIGHT-UP"
$LEFT_FRONT = "TOP-LEFT-DOWN"
$LEFT_BACK = "TOP-LEFT-UP"
$BACK_LEFT = "TOP-RIGHT-UP"
$BACK_RIGHT = "TOP-RIGHT-DOWN"
Case "TOP-LEFT"
$FRONT_LEFT = "TOP-LEFT-UP"
$FRONT_RIGHT = "TOP-LEFT-DOWN"
$RIGHT_FRONT = "BOTTOM-LEFT-UP"
$RIGHT_BACK = "BOTTOM-LEFT-DOWN"
$LEFT_FRONT = "TOP-RIGHT-UP"
$LEFT_BACK = "TOP-RIGHT-DOWN"
$BACK_LEFT = "BOTTOM-RIGHT-UP"
$BACK_RIGHT = "BOTTOM-RIGHT-DOWN"
Case "TOP-RIGHT"
$FRONT_LEFT = "TOP-RIGHT-DOWN"
$FRONT_RIGHT = "TOP-RIGHT-UP"
$RIGHT_FRONT = "TOP-LEFT-UP"
$RIGHT_BACK = "TOP-LEFT-DOWN"
$LEFT_FRONT = "BOTTOM-RIGHT-UP"
$LEFT_BACK = "BOTTOM-RIGHT-DOWN"
$BACK_LEFT = "BOTTOM-LEFT-DOWN"
$BACK_RIGHT = "BOTTOM-LEFT-UP"
EndSwitch
Case Else
Setlog("attack row bad, discard :row " & $rownum, $COLOR_ERROR)
EndSwitch
Else
If StringLeft($line, 7) <> "NOTE  |" And StringLeft($line, 7) <> "      |" And StringStripWS(StringUpper($line), 2) <> "" Then Setlog("attack row error, discard.: " & $line, $COLOR_ERROR)
EndIf
CheckHeroesHealth()
If _Sleep($iDelayRespond) Then
Return
EndIf
Next
ResetSideP()
ResetZapCmd()
ResetDefensesLocation("STORED")
ResetRedLines()
ReleaseClicks()
Else
SetLog("Cannot find attack file " & $g_sCSVAttacksPath & "\" & $filename & ".csv", $COLOR_ERROR)
EndIf
EndFunc
Func UpdateResourcesLocations($lineContent)
Local $hTimer = 0
Local $hTimerTOTAL = TimerInit()
ParseAttackCSV_Read_SIDE_variables($lineContent)
_CaptureRegion2()
If $searchTH = "-" Then
If $attackcsv_locate_townhall = 1 Then
SuspendAndroid()
$hTimer = TimerInit()
Local $searchTH = imgloccheckTownHallADV2(0, 0, False)
Setlog("> Townhall located in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds", $COLOR_INFO)
ResumeAndroid()
Else
Setlog("> Townhall search not needed, skip")
EndIf
Else
Setlog("> Townhall has already been located in while searching for an image", $COLOR_INFO)
EndIf
If _Sleep($iDelayRespond) Then Return
Global $PixelMine[0]
Global $PixelElixir[0]
Global $PixelDarkElixir[0]
Local $PixelNearCollectorTopLeftSTR = ""
Local $PixelNearCollectorBottomLeftSTR = ""
Local $PixelNearCollectorTopRightSTR = ""
Local $PixelNearCollectorBottomRightSTR = ""
If $attackcsv_locate_mine = 1 Then
$hTimer = TimerInit()
SuspendAndroid()
$PixelMine = GetLocationMine()
ResumeAndroid()
If _Sleep($iDelayRespond) Then Return
CleanRedArea($PixelMine)
Local $htimerMine = Round(TimerDiff($hTimer) / 1000, 2)
If(IsArray($PixelMine)) Then
For $i = 0 To UBound($PixelMine) - 1
Local $pixel = $PixelMine[$i]
Local $str = $pixel[0] & "-" & $pixel[1] & "-" & "MINE"
If isInsideDiamond($pixel) Then
If $pixel[0] <= $InternalArea[2][0] Then
If $pixel[1] <= $InternalArea[0][1] Then
$PixelNearCollectorTopLeftSTR &= $str & "|"
Else
$PixelNearCollectorBottomLeftSTR &= $str & "|"
EndIf
Else
If $pixel[1] <= $InternalArea[0][1] Then
$PixelNearCollectorTopRightSTR &= $str & "|"
Else
$PixelNearCollectorBottomRightSTR &= $str & "|"
EndIf
EndIf
EndIf
Next
EndIf
Setlog("> Mines located in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds", $COLOR_INFO)
Else
Setlog("> Mines detection not needed, skip", $COLOR_INFO)
EndIf
If _Sleep($iDelayRespond) Then Return
If $attackcsv_locate_elixir = 1 Then
$hTimer = TimerInit()
SuspendAndroid()
$PixelElixir = GetLocationElixir()
ResumeAndroid()
If _Sleep($iDelayRespond) Then Return
CleanRedArea($PixelElixir)
Local $htimerMine = Round(TimerDiff($hTimer) / 1000, 2)
If(IsArray($PixelElixir)) Then
For $i = 0 To UBound($PixelElixir) - 1
Local $pixel = $PixelElixir[$i]
Local $str = $pixel[0] & "-" & $pixel[1] & "-" & "ELIXIR"
If isInsideDiamond($pixel) Then
If $pixel[0] <= $InternalArea[2][0] Then
If $pixel[1] <= $InternalArea[0][1] Then
$PixelNearCollectorTopLeftSTR &= $str & "|"
Else
$PixelNearCollectorBottomLeftSTR &= $str & "|"
EndIf
Else
If $pixel[1] <= $InternalArea[0][1] Then
$PixelNearCollectorTopRightSTR &= $str & "|"
Else
$PixelNearCollectorBottomRightSTR &= $str & "|"
EndIf
EndIf
EndIf
Next
EndIf
Setlog("> Elixir collectors located in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds", $COLOR_INFO)
Else
Setlog("> Elixir collectors detection not needed, skip", $COLOR_INFO)
EndIf
If _Sleep($iDelayRespond) Then Return
If $attackcsv_locate_drill = 1 Then
$hTimer = TimerInit()
SuspendAndroid()
$PixelDarkElixir = GetLocationDarkElixir()
ResumeAndroid()
If _Sleep($iDelayRespond) Then Return
CleanRedArea($PixelDarkElixir)
Local $htimerMine = Round(TimerDiff($hTimer) / 1000, 2)
If(IsArray($PixelDarkElixir)) Then
For $i = 0 To UBound($PixelDarkElixir) - 1
Local $pixel = $PixelDarkElixir[$i]
Local $str = $pixel[0] & "-" & $pixel[1] & "-" & "DRILL"
If isInsideDiamond($pixel) Then
If $pixel[0] <= $InternalArea[2][0] Then
If $pixel[1] <= $InternalArea[0][1] Then
$PixelNearCollectorTopLeftSTR &= $str & "|"
Else
$PixelNearCollectorBottomLeftSTR &= $str & "|"
EndIf
Else
If $pixel[1] <= $InternalArea[0][1] Then
$PixelNearCollectorTopRightSTR &= $str & "|"
Else
$PixelNearCollectorBottomRightSTR &= $str & "|"
EndIf
EndIf
EndIf
Next
EndIf
Setlog("> Drills located in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds", $COLOR_INFO)
Else
Setlog("> Drills detection not needed, skip", $COLOR_INFO)
EndIf
If _Sleep($iDelayRespond) Then Return
If StringLen($PixelNearCollectorTopLeftSTR) > 0 Then $PixelNearCollectorTopLeftSTR = StringLeft($PixelNearCollectorTopLeftSTR, StringLen($PixelNearCollectorTopLeftSTR) - 1)
If StringLen($PixelNearCollectorTopRightSTR) > 0 Then $PixelNearCollectorTopRightSTR = StringLeft($PixelNearCollectorTopRightSTR, StringLen($PixelNearCollectorTopRightSTR) - 1)
If StringLen($PixelNearCollectorBottomLeftSTR) > 0 Then $PixelNearCollectorBottomLeftSTR = StringLeft($PixelNearCollectorBottomLeftSTR, StringLen($PixelNearCollectorBottomLeftSTR) - 1)
If StringLen($PixelNearCollectorBottomRightSTR) > 0 Then $PixelNearCollectorBottomRightSTR = StringLeft($PixelNearCollectorBottomRightSTR, StringLen($PixelNearCollectorBottomRightSTR) - 1)
Local $PixelNearCollectorTopLeft = GetListPixel3($PixelNearCollectorTopLeftSTR)
Local $PixelNearCollectorTopRight = GetListPixel3($PixelNearCollectorTopRightSTR)
Local $PixelNearCollectorBottomLeft = GetListPixel3($PixelNearCollectorBottomLeftSTR)
Local $PixelNearCollectorBottomRight = GetListPixel3($PixelNearCollectorBottomRightSTR)
If $attackcsv_locate_gold_storage = 1 Then
SuspendAndroid()
$GoldStoragePos = GetLocationGoldStorage()
ResumeAndroid()
EndIf
If $attackcsv_locate_elixir_storage = 1 Then
SuspendAndroid()
$ElixirStoragePos = GetLocationElixirStorage()
ResumeAndroid()
EndIf
If $attackcsv_locate_dark_storage = 1 Then
$hTimer = TimerInit()
SuspendAndroid()
Local $PixelDarkElixirStorage = GetLocationDarkElixirStorageWithLevel()
ResumeAndroid()
If _Sleep($iDelayRespond) Then Return
CleanRedArea($PixelDarkElixirStorage)
Local $pixel = StringSplit($PixelDarkElixirStorage, "#", 2)
If UBound($pixel) >= 2 Then
Local $pixelpos = StringSplit($pixel[1], "-", 2)
If UBound($pixelpos) >= 2 Then
Local $temp = [Int($pixelpos[0]), Int($pixelpos[1])]
$darkelixirStoragePos = $temp
EndIf
EndIf
Setlog("> Dark Elixir Storage located in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds", $COLOR_INFO)
Else
Setlog("> Dark Elixir Storage detection not need, skip", $COLOR_INFO)
EndIf
Setlog(">> Total time: " & Round(TimerDiff($hTimerTOTAL) / 1000, 2) & " seconds", $COLOR_BLUE)
If _Sleep($iDelayRespond) Then Return
EndFunc
Func DropTroopFromINI($vectors, $indexStart, $indexEnd, $indexArray, $qtaMin, $qtaMax, $troopName, $delayPointmin, $delayPointmax, $delayDropMin, $delayDropMax, $sleepafterMin, $sleepAfterMax, $sleepBeforeMin, $sleepBeforeMax, $debug = False)
If IsArray($indexArray) = 0 Then
debugAttackCSV("drop using vectors " & $vectors & " index " & $indexStart & "-" & $indexEnd & " and using " & $qtaMin & "-" & $qtaMax & " of " & $troopName)
Else
debugAttackCSV("drop using vectors " & $vectors & " index " & _ArrayToString($indexArray, ",") & " and using " & $qtaMin & "-" & $qtaMax & " of " & $troopName)
EndIf
debugAttackCSV(" - delay for multiple troops in same point: " & $delayPointmin & "-" & $delayPointmax)
debugAttackCSV(" - delay when  change deploy point : " & $delayDropMin & "-" & $delayDropMax)
debugAttackCSV(" - delay after drop all troops : " & $sleepafterMin & "-" & $sleepAfterMax)
debugAttackCSV(" - delay before drop all troops : " & $sleepBeforeMin & "-" & $sleepBeforeMax)
Local $temp = StringSplit($vectors, "-")
Local $numbersOfVectors
If UBound($temp) > 0 Then
$numbersOfVectors = $temp[0]
Else
$numbersOfVectors = 0
EndIf
Local $vector1, $vector2, $vector3, $vector4
If UBound($temp) > 0 Then
If $temp[0] >= 1 Then $vector1 = "ATTACKVECTOR_" & $temp[1]
If $temp[0] >= 2 Then $vector2 = "ATTACKVECTOR_" & $temp[2]
If $temp[0] >= 3 Then $vector3 = "ATTACKVECTOR_" & $temp[3]
If $temp[0] >= 4 Then $vector4 = "ATTACKVECTOR_" & $temp[4]
Else
$vector1 = $vectors
EndIf
If $qtaMin <> $qtaMax Then
Local $qty = Random($qtaMin, $qtaMax, 1)
Else
Local $qty = $qtaMin
EndIf
debugAttackCSV(">> qty to deploy: " & $qty)
Local $qtyxpoint = Int($qty /($indexEnd - $indexStart + 1))
Local $extraunit = Mod($qty,($indexEnd - $indexStart + 1))
debugAttackCSV(">> qty x point: " & $qtyxpoint)
debugAttackCSV(">> qty extra: " & $extraunit)
Local $iTroopIndex = TroopIndexLookup($troopName)
If $iTroopIndex = -1 Then
Setlog("CSV troop name '" & $troopName & "' is unrecognized.")
Return
EndIf
Local $troopPosition = -1
For $i = 0 To UBound($atkTroops) - 1
If $atkTroops[$i][0] = $iTroopIndex Then
$troopPosition = $i
EndIf
Next
Local $usespell = True
Switch $iTroopIndex
Case $eLSpell
If $g_abAttackUseLightSpell[$g_iMatchMode] = False Then $usespell = False
Case $eHSpell
If $g_abAttackUseHealSpell[$g_iMatchMode] = False Then $usespell = False
Case $eRSpell
If $g_abAttackUseRageSpell[$g_iMatchMode] = False Then $usespell = False
Case $eJSpell
If $g_abAttackUseJumpSpell[$g_iMatchMode] = False Then $usespell = False
Case $eFSpell
If $g_abAttackUseFreezeSpell[$g_iMatchMode] = False Then $usespell = False
Case $eCSpell
If $g_abAttackUseCloneSpell[$g_iMatchMode] = False Then $usespell = False
Case $ePSpell
If $g_abAttackUsePoisonSpell[$g_iMatchMode] = False Then $usespell = False
Case $eESpell
If $g_abAttackUseEarthquakeSpell[$g_iMatchMode] = False Then $usespell = False
Case $eHaSpell
If $g_abAttackUseHasteSpell[$g_iMatchMode] = False Then $usespell = False
Case $eSkSpell
If $g_abAttackUseSkeletonSpell[$g_iMatchMode] = False Then $usespell = False
EndSwitch
If $troopPosition = -1 Or $usespell = False Then
If $usespell = True Then
Setlog("No troop found in your attack troops list")
debugAttackCSV("No troop found in your attack troops list")
Else
If $g_iDebugSetlog = 1 Then SetLog("discard use spell", $COLOR_DEBUG)
EndIf
Else
If $lastTroopPositionDropTroopFromINI <> $troopPosition Then
ReleaseClicks()
SelectDropTroop($troopPosition)
$lastTroopPositionDropTroopFromINI = $troopPosition
ReleaseClicks()
EndIf
Local $sleepBefore = 0
If $sleepBeforeMin <> $sleepBeforeMax Then
$sleepBefore = Random($sleepBeforeMin, $sleepBeforeMax, 1)
Else
$sleepBefore = Int($sleepBeforeMin)
EndIf
If $sleepBefore > 50 And IsKeepClicksActive() = False Then
debugAttackCSV(">> delay Before drop all troops: " & $sleepBefore)
If $sleepBefore <= 1000 Then
If _Sleep($sleepBefore) Then Return
CheckHeroesHealth()
Else
For $z = 1 To Int($sleepBefore/1000)
If _Sleep(980) Then Return
CheckHeroesHealth()
Next
If _Sleep(Mod($sleepBefore,1000)) Then Return
CheckHeroesHealth()
EndIf
EndIf
For $i = $indexStart To $indexEnd
Local $delayDrop = 0
Local $index = $i
Local $indexMax = $indexEnd
If IsArray($indexArray) = 1 Then
$index = $indexArray[$i]
$indexMax = $indexArray[$indexEnd]
EndIf
If $index <> $indexMax Then
If $delayDropMin <> $delayDropMax Then
$delayDrop = Random($delayDropMin, $delayDropMax, 1)
Else
$delayDrop = $delayDropMin
EndIf
debugAttackCSV(">> delay change drop point: " & $delayDrop)
EndIf
For $j = 1 To $numbersOfVectors
Local $delayDropLast = 0
If $j = $numbersOfVectors Then $delayDropLast = $delayDrop
If $index <= UBound(Execute("$" & Eval("vector" & $j))) Then
Local $pixel = Execute("$" & Eval("vector" & $j) & "[" & $index - 1 & "]")
Local $qty2 = $qtyxpoint
If $index < $indexStart + $extraunit Then $qty2 += 1
If $delayPointmin <> $delayPointmax Then
Local $delayPoint = Random($delayPointmin, $delayPointmax, 1)
Else
Local $delayPoint = $delayPointmin
EndIf
Switch $iTroopIndex
Case $eBarb To $eBowl
If $debug = True Then
Setlog("AttackClick( " & $pixel[0] & ", " & $pixel[1] & " , " & $qty2 & ", " & $delayPoint & ",#0666)")
Else
AttackClick($pixel[0], $pixel[1], $qty2, $delayPoint, $delayDropLast, "#0666")
EndIf
Case $eKing
If $debug = True Then
Setlog("dropHeroes(" & $pixel[0] & ", " & $pixel[1] & ", " & $King & ", -1, -1) ")
Else
dropHeroes($pixel[0], $pixel[1], $King, -1, -1)
$HeroesTimerActivation[$eHeroBarbarianKing] = 0
If $checkKPower Then $HeroesTimerActivation[$eHeroBarbarianKing] = TimerInit()
EndIf
Case $eQueen
If $debug = True Then
Setlog("dropHeroes(" & $pixel[0] & ", " & $pixel[1] & ",-1," & $Queen & ", -1) ")
Else
dropHeroes($pixel[0], $pixel[1], -1, $Queen, -1)
$HeroesTimerActivation[$eHeroArcherQueen] = 0
If $checkQPower Then $HeroesTimerActivation[$eHeroArcherQueen] = TimerInit()
EndIf
Case $eWarden
If $debug = True Then
Setlog("dropHeroes(" & $pixel[0] & ", " & $pixel[1] & ", -1, -1," & $Warden & ") ")
Else
dropHeroes($pixel[0], $pixel[1], -1, -1, $Warden)
$HeroesTimerActivation[$eHeroGrandWarden] = 0
If $checkWPower Then $HeroesTimerActivation[$eHeroGrandWarden] = TimerInit()
EndIf
Case $eCastle
If $debug = True Then
Setlog("dropCC(" & $pixel[0] & ", " & $pixel[1] & ", " & $CC & ")")
Else
dropCC($pixel[0], $pixel[1], $CC)
EndIf
Case $eLSpell To $eSkSpell
If $debug = True Then
Setlog("Drop Spell AttackClick( " & $pixel[0] & ", " & $pixel[1] & " , " & $qty2 & ", " & $delayPoint & ",#0666)")
Else
AttackClick($pixel[0], $pixel[1], $qty2, $delayPoint, $delayDropLast, "#0667")
EndIf
Case Else
Setlog("Error parsing line")
EndSwitch
debugAttackCSV($troopName & " qty " & $qty2 & " in (" & $pixel[0] & "," & $pixel[1] & ") delay " & $delayPoint)
EndIf
Next
Next
ReleaseClicks()
Local $sleepafter = 0
If $sleepafterMin <> $sleepAfterMax Then
$sleepafter = Random($sleepafterMin, $sleepAfterMax, 1)
Else
$sleepafter = Int($sleepafterMin)
EndIf
If $sleepafter > 0 And IsKeepClicksActive() = False Then
debugAttackCSV(">> delay after drop all troops: " & $sleepafter)
If $sleepafter <= 1000 Then
If _Sleep($sleepafter) Then Return
CheckHeroesHealth()
Else
For $z = 1 To Int($sleepafter/1000)
If _Sleep(980) Then Return
CheckHeroesHealth()
Next
If _Sleep(Mod($sleepafter,1000)) Then Return
CheckHeroesHealth()
EndIf
EndIf
EndIf
EndFunc
Global $ZDrillsPos[3][3] = [[-1, -1, ""], [-1, -1, ""], [-1, -1, ""]]
Global $ZMaxDrills = 3, $ZMaxLSpell = 2, $ZMaxESpell = 1
Global $ZDrillsDroppedSpells[3][2] = [[-1, -1], [-1, -1], [-1, -1]]
Global $ZOffsetDrill[2] = [0, +14]
Global $ZRandomDrop[2] = [3, 3]
Global $iIndexDrillToZapOn = -1
Global $CanZap = True
Func ZapCmd($DeploySide, $bLightning, $iLightning, $bEarthQuake, $iEarthQuake, $bCheck, $iMinDE, $DelayEachDrop)
debugAttackCSV("Ini ZapCmd")
debugAttackCSV("Parameter $DeploySide: " & $DeploySide)
debugAttackCSV("Parameter $bLightning: " & $bLightning)
debugAttackCSV("Parameter $iLightning: " & $iLightning)
debugAttackCSV("Parameter $bEarthQuake: " & $bEarthQuake)
debugAttackCSV("Parameter $iEarthQuake: " & $iEarthQuake)
debugAttackCSV("Parameter $iEarthQuake: " & $iEarthQuake)
debugAttackCSV("Parameter $bCheck: " & $bCheck)
debugAttackCSV("Parameter $iMinDE: " & $iMinDE)
debugAttackCSV("Parameter $DelayEachDrop: " & $DelayEachDrop)
If $CanZap = False Then Return True
If $bLightning = False And $bEarthQuake = False Then
SetLog("Lightning and EarthQuake Both are Disabled In Command", $COLOR_RED)
EndDropCommand(50, 150)
Return False
EndIf
If $g_abAttackUseLightSpell[$g_iMatchMode] = 0 Then
SetLog("Lightning is Un-checked in GUI, Exiting Zap", $COLOR_RED)
$CanZap = False
EndDropCommand(50, 150)
Return False
EndIf
If CheckMinDE($iMinDE) = False Then
$CanZap = False
SetLog("DE Less Than Minimum Value, Skipping Zap Command")
EndDropCommand(50, 150)
Return False
EndIf
Local $rGetZDrillToDrop = GetZDrillToDrop($DeploySide, $bCheck, $bLightning, $iLightning, $bEarthQuake, $iEarthQuake)
If $rGetZDrillToDrop[0] = -1 Then
SetLog("No Drills Found With Conditions", $COLOR_ORANGE)
EndDropCommand(50, 150)
Return False
EndIf
If $rGetZDrillToDrop[2] = -1 And $rGetZDrillToDrop[3] = -1 Then
SetLog("Limit Reach of dropping Spells on This Drill", $COLOR_BLUE)
EndDropCommand(50, 150)
Return False
EndIf
Local $rFindTroopInAttBar = -1
If $bLightning Then
$rFindTroopInAttBar = FindTroopInAttBar("LSpell")
If $rFindTroopInAttBar <> -1 Then
SelectDropTroop($rFindTroopInAttBar)
For $k = 1 To $rGetZDrillToDrop[2]
If $CanZap = False Then Return True
If $ZDrillsDroppedSpells[$iIndexDrillToZapOn][0] >= $ZMaxLSpell Then ExitLoop
If $rGetZDrillToDrop[0] < 1 Then ExitLoop
If CheckMinDE($iMinDE) = False Then
$CanZap = False
SetLog("DE Less Than Minimum Value, Exiting Zap Command")
EndDropCommand(50, 150)
Return True
EndIf
SetLog("ZapCmd | Dropping x1 Lightning On " & GetNumOrdinal($iIndexDrillToZapOn + 1) & " Drill", $COLOR_BLUE)
AttackClick($rGetZDrillToDrop[0], $rGetZDrillToDrop[1], 1, 50, 50, "#0667")
Zapped($iIndexDrillToZapOn, False, 1)
If $DelayEachDrop > 0 Then
If _Sleep($DelayEachDrop) Then Return True
EndIf
If $bCheck Then $rGetZDrillToDrop = GetZDrillToDrop($DeploySide, $bCheck, $bLightning, $iLightning, $bEarthQuake, $iEarthQuake)
If CheckZDrillResult($rGetZDrillToDrop, True) = False Then Return True
Next
EndIf
EndIf
$rFindTroopInAttBar = -1
If $bEarthQuake Then
$rFindTroopInAttBar = FindTroopInAttBar("ESpell")
If $rFindTroopInAttBar <> -1 Then
SelectDropTroop($rFindTroopInAttBar)
For $k = 1 To $rGetZDrillToDrop[3]
If $CanZap = False Then Return True
If $ZDrillsDroppedSpells[$iIndexDrillToZapOn][1] >= $ZMaxESpell Then ExitLoop
If $rGetZDrillToDrop[0] < 1 Then ExitLoop
If CheckMinDE($iMinDE) = False Then
$CanZap = False
SetLog("DE Less Than Minimum Value, Exiting Zap Command")
EndDropCommand(50, 150)
Return True
EndIf
SetLog("ZapCmd | Dropping x1 EarthQuake On " & GetNumOrdinal($iIndexDrillToZapOn + 1) & " Drill", $COLOR_BLUE)
AttackClick($rGetZDrillToDrop[0], $rGetZDrillToDrop[1], 1, 50, 50, "#0667")
Zapped($iIndexDrillToZapOn, True, 1)
If $DelayEachDrop > 0 Then
If _Sleep($DelayEachDrop) Then Return True
EndIf
If $bCheck Then $rGetZDrillToDrop = GetZDrillToDrop($DeploySide, $bCheck, $bLightning, $iLightning, $bEarthQuake, $iEarthQuake)
If CheckZDrillResult($rGetZDrillToDrop, True) = False Then Return True
Next
EndIf
EndIf
EndFunc
Func Zapped($iDrillIndex, $bIsEarthQuake, $Quantity = 1)
debugAttackCSV("Ini Zapped")
debugAttackCSV("Parameter $iDrillIndex: " & $iDrillIndex)
debugAttackCSV("Parameter $bIsEarthQuake: " & $bIsEarthQuake)
debugAttackCSV("Parameter $Quantity: " & $Quantity)
If $iDrillIndex < 0 Then Return True
If $ZDrillsDroppedSpells[$iDrillIndex][0] < 0 Then $ZDrillsDroppedSpells[$iDrillIndex][0] = 0
If $ZDrillsDroppedSpells[$iDrillIndex][1] < 0 Then $ZDrillsDroppedSpells[$iDrillIndex][1] = 0
Switch $bIsEarthQuake
Case True
$ZDrillsDroppedSpells[$iDrillIndex][1] += $Quantity
Case Else
$ZDrillsDroppedSpells[$iDrillIndex][0] += $Quantity
EndSwitch
Return True
EndFunc
Func ZInit($Values)
debugAttackCSV("Ini ZInit")
debugAttackCSV("Parameter $Values: " & $Values)
ResetZapCmd()
Local $SplitedValues = StringSplit($Values, "|", 2)
Local $Locate = $SplitedValues[0]
$ZMaxDrills = $SplitedValues[1]
$ZMaxLSpell = $SplitedValues[2]
$ZMaxESpell = $SplitedValues[3]
If $Locate Then
AssignZDrills()
EndIf
EndFunc
Func ParseZapCommand($Values)
debugAttackCSV("Ini ParseZapCommand")
debugAttackCSV("Parameter $Values: " & $Values)
Local $SplitedValues = StringSplit($Values, "|", 2)
Local $DeploySide = $SplitedValues[0]
Local $bLightning = $SplitedValues[1] = "TRUE" Or $SplitedValues[1] = "T" Or $SplitedValues[1] = "1"
Local $iLightning = $SplitedValues[2]
Local $bEarthQuake = $SplitedValues[3] = "TRUE" Or $SplitedValues[3] = "T" Or $SplitedValues[3] = "1"
Local $iEarthQuake = $SplitedValues[4]
Local $bCheck = $SplitedValues[5] = "A" Or $SplitedValues[4] = "Always"
Local $iMinDE = $SplitedValues[6]
Local $iDelayEachDrop = Int($SplitedValues[7])
ZapCmd($DeploySide, $bLightning, $iLightning, $bEarthQuake, $iEarthQuake, $bCheck, $iMinDE, $iDelayEachDrop)
EndFunc
Func GetNumOrdinal($iNum)
debugAttackCSV("Ini GetNumOrdinal")
debugAttackCSV("Parameter $iNum: " & $iNum)
Switch $iNum
Case 1
Return "1st"
Case 2
Return "2nd"
Case 3
Return "3rd"
Case Else
Return $iNum
EndSwitch
EndFunc
Func FindTroopInAttBar($troopName)
debugAttackCSV("Ini FindTroopInAttBar")
debugAttackCSV("Parameter $troopName: " & $troopName)
Local $iTroopIndex = TroopIndexLookup($troopName)
If $iTroopIndex = -1 Then
Setlog("CSV troop name '" & $troopName & "' is unrecognized.")
Return
EndIf
Local $troopPosition = -1
For $i = 0 To UBound($atkTroops) - 1
If $atkTroops[$i][0] = $iTroopIndex Then
$troopPosition = $i
EndIf
Next
If $troopPosition = -1 Then
Setlog("No troop found in your attack troops list")
debugAttackCSV("No troop found in your attack troops list")
Return -1
EndIf
Return $troopPosition
EndFunc
Func CheckMinDE($iMinDE, $showlog = False)
debugAttackCSV("Ini CheckMinDE")
debugAttackCSV("Parameter $iMinDE: " & $iMinDE)
debugAttackCSV("Parameter $showlog: " & $showlog)
Local $iAvailableDark
_CaptureRegion()
If _ColorCheck(_GetPixelColor(31, 144, True), Hex(0x282020, 6), 10) Or _ColorCheck(_GetPixelColor(31, 144, True), Hex(0x0F0617, 6), 5) Then
$iAvailableDark = getDarkElixirVillageSearch(48, 126)
If $showlog = True Then SetLog("Available Dark: " & $iAvailableDark & ", Min Dark To Zap: " & $iMinDE, $COLOR_BLUE)
Return Not(Number($iMinDE, 2) > Number($iAvailableDark, 2))
Else
Return False
EndIf
EndFunc
Func EndDropCommand($sleepafterMin, $sleepAfterMax = Default)
debugAttackCSV("Ini EndDropCommand")
debugAttackCSV("Parameter $sleepafterMin: " & $sleepafterMin)
debugAttackCSV("Parameter $sleepAfterMax: " & $sleepAfterMax)
If $sleepAfterMax = Default Then $sleepAfterMax = $sleepafterMin
ReleaseClicks()
Local $sleepafter = 0
If $sleepafterMin <> $sleepAfterMax Then
$sleepafter = Random($sleepafterMin, $sleepAfterMax, 1)
Else
$sleepafter = Int($sleepafterMin)
EndIf
If $sleepafter > 0 And IsKeepClicksActive() = False Then
debugAttackCSV(">> delay after drop all troops: " & $sleepafter)
If $sleepafter <= 1000 Then
If _Sleep($sleepafter) Then Return
CheckHeroesHealth()
Else
For $z = 1 To Int($sleepafter / 1000)
If _Sleep(980) Then Return
CheckHeroesHealth()
Next
If _Sleep(Mod($sleepafter, 1000)) Then Return
CheckHeroesHealth()
EndIf
EndIf
EndFunc
Func GetZDrillToDrop($Side, $bReLocate, $bLightning, $iLightning, $bEarthQuake, $iEarthQuake)
debugAttackCSV("Ini GetZDrillToDrop")
debugAttackCSV("Parameter $Side: " & $Side)
debugAttackCSV("Parameter $bReLocate: " & $bReLocate)
debugAttackCSV("Parameter $bLightning: " & $bLightning)
debugAttackCSV("Parameter $iLightning: " & $iLightning)
debugAttackCSV("Parameter $bEarthQuake: " & $bEarthQuake)
debugAttackCSV("Parameter $iEarthQuake: " & $iEarthQuake)
Local $ToReturn[4] = [-1, -1, -1, -1]
If $Side = 1 Or $Side = 2 Or $Side = 3 Then
Local $zDrillIndex =($Side - 1)
If $bReLocate Then AssignZDrills($zDrillIndex)
If $ZDrillsPos[$zDrillIndex][0] < 1 And $ZDrillsPos[$zDrillIndex][1] < 1 Then Return $ToReturn
If $ZDrillsDroppedSpells[$zDrillIndex][0] >= $ZMaxLSpell And $ZDrillsDroppedSpells[$zDrillIndex][1] >= $ZMaxESpell Then Return $ToReturn
If $ZMaxLSpell - $ZDrillsDroppedSpells[$zDrillIndex][0] > 0 Or $ZMaxESpell - $ZDrillsDroppedSpells[$zDrillIndex][1] > 0 Then
$ToReturn[0] = $ZDrillsPos[$zDrillIndex][0] + $ZOffsetDrill[0] + Random($ZRandomDrop[0] -($ZRandomDrop[0] * 2), $ZRandomDrop[0], 1)
$ToReturn[1] = $ZDrillsPos[$zDrillIndex][1] + $ZOffsetDrill[1] + Random($ZRandomDrop[1] -($ZRandomDrop[1] * 2), $ZRandomDrop[1], 1)
If $bLightning Then $ToReturn[2] = $iLightning
If $bEarthQuake Then $ToReturn[3] = $iEarthQuake
EndIf
$iIndexDrillToZapOn = $zDrillIndex
Return $ToReturn
Else
If $bReLocate Then AssignZDrills()
EndIf
For $i = 0 To($ZMaxDrills - 1)
If $ZDrillsPos[$i][0] < 1 And $ZDrillsPos[$i][1] < 1 Then ContinueLoop
If $ZDrillsDroppedSpells[$i][0] >= $ZMaxLSpell And $ZDrillsDroppedSpells[$i][1] >= $ZMaxESpell Then ContinueLoop
Local $pPixel[2] = [$ZDrillsPos[$i][0], $ZDrillsPos[$i][1]]
Local $sliced = Slice8($pPixel)
Local $theDrillSide
Switch StringLeft($sliced, 1)
Case 1, 2
$theDrillSide = "BOTTOM"
Case 3, 4
$theDrillSide = "TOP"
Case 5, 6
$theDrillSide = "TOP"
Case 7, 8
$theDrillSide = "BOTTOM"
EndSwitch
Local $curMainSide = StringSplit($MAINSIDE, "-", 2)[0]
If $Side = "Same" And $theDrillSide = $curMainSide Then
If $ZMaxLSpell - $ZDrillsDroppedSpells[$i][0] > 0 Or $ZMaxESpell - $ZDrillsDroppedSpells[$i][1] > 0 Then
$ToReturn[0] = $ZDrillsPos[$i][0] + $ZOffsetDrill[0] + Random($ZRandomDrop[0] -($ZRandomDrop[0] * 2), $ZRandomDrop[0], 1)
$ToReturn[1] = $ZDrillsPos[$i][1] + $ZOffsetDrill[1] + Random($ZRandomDrop[1] -($ZRandomDrop[1] * 2), $ZRandomDrop[1], 1)
If $bLightning Then $ToReturn[2] = $iLightning
If $bEarthQuake Then $ToReturn[3] = $iEarthQuake
EndIf
$iIndexDrillToZapOn = $i
Return $ToReturn
ElseIf $Side = "Opposite" And $theDrillSide <> $curMainSide Then
If $ZMaxLSpell - $ZDrillsDroppedSpells[$i][0] > 0 Or $ZMaxESpell - $ZDrillsDroppedSpells[$i][1] > 0 Then
$ToReturn[0] = $ZDrillsPos[$i][0] + $ZOffsetDrill[0] + Random($ZRandomDrop[0] -($ZRandomDrop[0] * 2), $ZRandomDrop[0], 1)
$ToReturn[1] = $ZDrillsPos[$i][1] + $ZOffsetDrill[1] + Random($ZRandomDrop[1] -($ZRandomDrop[1] * 2), $ZRandomDrop[1], 1)
If $bLightning Then $ToReturn[2] = $iLightning
If $bEarthQuake Then $ToReturn[3] = $iEarthQuake
EndIf
$iIndexDrillToZapOn = $i
Return $ToReturn
ElseIf $Side = "Any" Then
If $ZMaxLSpell - $ZDrillsDroppedSpells[$i][0] > 0 Or $ZMaxESpell - $ZDrillsDroppedSpells[$i][1] > 0 Then
$ToReturn[0] = $ZDrillsPos[$i][0] + $ZOffsetDrill[0] + Random($ZRandomDrop[0] -($ZRandomDrop[0] * 2), $ZRandomDrop[0], 1)
$ToReturn[1] = $ZDrillsPos[$i][1] + $ZOffsetDrill[1] + Random($ZRandomDrop[1] -($ZRandomDrop[1] * 2), $ZRandomDrop[1], 1)
If $bLightning Then $ToReturn[2] = $iLightning
If $bEarthQuake Then $ToReturn[3] = $iEarthQuake
EndIf
$iIndexDrillToZapOn = $i
Return $ToReturn
EndIf
Next
$iIndexDrillToZapOn = -1
Return $ToReturn
EndFunc
Func CheckZDrillResult($rGetZDrillToDrop, $showlog = True)
debugAttackCSV("Ini CheckZDrillResult")
For $i = 0 To UBound($rGetZDrillToDrop) -1
debugAttackCSV("Parameter $rGetZDrillToDrop[" & $i & "]: " & $rGetZDrillToDrop[$i])
Next
debugAttackCSV("Parameter $showlog: " & $showlog)
If $rGetZDrillToDrop[0] < 1 Then
If $showlog Then SetLog("No Drills Found With Conditions", $COLOR_ORANGE)
If $showlog Then EndDropCommand(50, 150)
Return False
EndIf
If $rGetZDrillToDrop[2] < 0 And $rGetZDrillToDrop[3] < 0 Then
If $showlog Then SetLog("Limit Reach of dropping Spells on This Drill", $COLOR_BLUE)
If $showlog Then EndDropCommand(50, 150)
Return False
EndIf
Return True
EndFunc
Func IsFirstZDetect()
debugAttackCSV("Ini IsFirstZDetect")
For $i = 0 To($ZMaxDrills - 1)
If $ZDrillsPos[$i][0] > 0 And $ZDrillsPos[$i][1] > 0 Then Return False
Next
Return True
EndFunc
Func AssignZDrills($iDrillToUpdate = -1)
debugAttackCSV("Ini AssignZDrills")
debugAttackCSV("Parameter $iDrillToUpdate: " & $iDrillToUpdate)
Local $bIsFirstDetect = IsFirstZDetect()
Switch $bIsFirstDetect
Case True
Local $aResult = GetLocDrills()
Local $sResultPoints = ""
Local $sResultPaths = ""
Local $tmp
For $i = 0 To(UBound($aResult) - 1)
$tmp = $aResult[$i]
$sResultPoints &= String($tmp[0]) & "|"
Local $iToLoop =(StringInStr($tmp[0], "|") > 0) ? UBound(StringSplit($tmp[0], "|", 2)) : 1
For $j = 1 To $iToLoop
$sResultPaths &= $tmp[1] & "|"
Next
Next
If StringRight($sResultPoints, 1) = "|" Then $sResultPoints = StringLeft($sResultPoints, StringLen($sResultPoints) - 1)
If StringRight($sResultPaths, 1) = "|" Then $sResultPaths = StringLeft($sResultPaths, StringLen($sResultPaths) - 1)
Local $AllDrills = $sResultPoints
If Not StringInStr($AllDrills, ",") > 0 Then Return SetError(1)
Local $tmpSplitedPositions
Local $tmpSplitedPaths
If StringInStr($AllDrills, "|") > 0 Then
$tmpSplitedPositions = StringSplit($AllDrills, "|", 2)
Else
$tmpSplitedPositions = _StringEqualSplit($AllDrills)
EndIf
If StringInStr($sResultPaths, "|") > 0 Then
$tmpSplitedPaths = StringSplit($sResultPaths, "|", 2)
Else
$tmpSplitedPaths = _StringEqualSplit($sResultPaths)
EndIf
Local $tmpSplitedPositions2
Local $SplitedPositions[$ZMaxDrills][3]
For $i = 0 To($ZMaxDrills - 1)
If $i >= UBound($tmpSplitedPositions) Then ExitLoop
$tmpSplitedPositions2 = StringSplit($tmpSplitedPositions[$i], ",", 2)
$SplitedPositions[$i][0] = $tmpSplitedPositions2[0]
$SplitedPositions[$i][1] = $tmpSplitedPositions2[1]
$SplitedPositions[$i][2] = $tmpSplitedPaths[$i]
Next
For $i = 0 To($ZMaxDrills - 1)
If $i >= UBound($SplitedPositions) Then ExitLoop
$ZDrillsPos[$i][0] = $SplitedPositions[$i][0]
$ZDrillsPos[$i][1] = $SplitedPositions[$i][1]
$ZDrillsPos[$i][2] = $SplitedPositions[$i][2]
Next
Case Else
Local $DrillSearch = ""
Local $X, $Y, $X1, $Y1
If $iDrillToUpdate >= 0 Then
If $ZDrillsPos[$iDrillToUpdate][0] < 1 And $ZDrillsPos[$iDrillToUpdate][1] < 1 Then
Local $aResult = GetLocDrills()
Local $sResultPoints = ""
Local $sResultPaths = ""
Local $tmp
For $i = 0 To(UBound($aResult) - 1)
$tmp = $aResult[$i]
$sResultPoints &= String($tmp[0]) & "|"
$iToLoop =(StringInStr($tmp[0], "|") > 0) ? UBound(StringSplit($tmp[0], "|", 2)) : 1
For $j = 1 To $iToLoop
$sResultPaths &= $tmp[1] & "|"
Next
Next
If StringRight($sResultPoints, 1) = "|" Then $sResultPoints = StringLeft($sResultPoints, StringLen($sResultPoints) - 1)
If StringRight($sResultPaths, 1) = "|" Then $sResultPaths = StringLeft($sResultPaths, StringLen($sResultPaths) - 1)
Local $AllDrills = $sResultPoints
Local $tmpSplitedPositions
Local $tmpSplitedPaths
If StringInStr($AllDrills, "|") > 0 Then
$tmpSplitedPositions = StringSplit($AllDrills, "|", 2)
Else
$tmpSplitedPositions = _StringEqualSplit($AllDrills)
EndIf
If StringInStr($sResultPaths, "|") > 0 Then
$tmpSplitedPaths = StringSplit($sResultPaths, "|", 2)
Else
$tmpSplitedPaths = _StringEqualSplit($sResultPaths)
EndIf
If StringInStr($AllDrills, ",") > 0 Then
Local $SplitedAllDrills = StringSplit($AllDrills, ",", 2)
$ZDrillsPos[$iDrillToUpdate][0] = $SplitedAllDrills[0]
$ZDrillsPos[$iDrillToUpdate][1] = $SplitedAllDrills[1]
$ZDrillsPos[$iDrillToUpdate][2] = $tmpSplitedPaths[0]
Else
$ZDrillsPos[$iDrillToUpdate][0] = -1
$ZDrillsPos[$iDrillToUpdate][1] = -1
$ZDrillsPos[$iDrillToUpdate][2] = ""
EndIf
Else
_CaptureRegion2()
$DrillSearch = VerifyDrillLoc($ZDrillsPos[$iDrillToUpdate][2], $ZDrillsPos[$iDrillToUpdate][0], $ZDrillsPos[$iDrillToUpdate][1])
If StringInStr($DrillSearch, ",") > 0 Then
Local $SplitedDrillSearch = StringSplit($DrillSearch, ",", 2)
$ZDrillsPos[$iDrillToUpdate][0] = $SplitedDrillSearch[0] + $X
$ZDrillsPos[$iDrillToUpdate][1] = $SplitedDrillSearch[1] + $Y
Else
$ZDrillsPos[$iDrillToUpdate][0] = -1
$ZDrillsPos[$iDrillToUpdate][1] = -1
EndIf
EndIf
Return True
EndIf
_CaptureRegion2()
For $i = 0 To($ZMaxDrills - 1)
If $ZDrillsPos[$i][0] < 1 And $ZDrillsPos[$i][1] < 1 Then ContinueLoop
$DrillSearch = VerifyDrillLoc($ZDrillsPos[$i][2], $ZDrillsPos[$i][0], $ZDrillsPos[$i][1])
If StringInStr($DrillSearch, ",") > 0 Then
Local $SplitedDrillSearch = StringSplit($DrillSearch, ",", 2)
$ZDrillsPos[$i][0] = $SplitedDrillSearch[0] + $X
$ZDrillsPos[$i][1] = $SplitedDrillSearch[1] + $Y
Else
$ZDrillsPos[$i][0] = -1
$ZDrillsPos[$i][1] = -1
$ZDrillsPos[$i][1] = ""
EndIf
Next
EndSwitch
EndFunc
Func VerifyDrillLoc($filePath, $X, $Y)
debugAttackCSV("Ini VerifyDrillLoc")
debugAttackCSV("Parameter $filePath: " & $filePath)
debugAttackCSV("Parameter $X: " & $X)
debugAttackCSV("Parameter $Y: " & $Y)
Local $searchResult = ""
$searchResult = ReCheckTile($filePath, String($X & "," & $Y), False)
Return $searchResult
EndFunc
Func GetLocDrills()
debugAttackCSV("Ini GetLocDrills")
Local $cDiamondImgLoc = "ECD", $rdImgLoc = "ECD"
Return findMultiple($dDarkDrills, $cDiamondImgLoc, $rdImgLoc, 0, 1000, 0, "objectpoints,filepath")
EndFunc
Func ResetZapCmd()
debugAttackCSV("Ini ResetZapCmd")
$ZMaxDrills = 3
$ZMaxLSpell = 2
$ZMaxESpell = 1
$iIndexDrillToZapOn = -1
$CanZap = True
For $i = 0 To(UBound($ZDrillsPos) - 1)
$ZDrillsPos[$i][0] = -1
$ZDrillsPos[$i][1] = -1
$ZDrillsPos[$i][2] = ""
Next
For $i = 0 To(UBound($ZDrillsDroppedSpells) - 1)
$ZDrillsDroppedSpells[$i][0] = -1
$ZDrillsDroppedSpells[$i][1] = -1
Next
EndFunc
Func GetCountEachSide($sToSearch)
Local $ToReturn[4] = [0, 0, 0, 0]
Local $iSearchResult = ""
Local $bSomethingFound = False
Local $splitedPositions
$iSearchResult = ValidateOldPositions($sToSearch)
If $iSearchResult <> "" And StringLen($iSearchResult) > 3 Then $bSomethingFound = True
If $bSomethingFound Then
If StringInStr($iSearchResult, "|") > 0 Then
$splitedPositions = StringSplit($iSearchResult, "|", 2)
Else
$splitedPositions = _StringEqualSplit($iSearchResult, StringLen($iSearchResult))
EndIf
EndIf
If $bSomethingFound = False Then
If $DebugSideP Then
SetLog("SomethingFound is false and" & @CRLF & "$iSearchResult = " & $iSearchResult, $COLOR_RED)
DebugImageSave("SideP_BuildingNotFound_", False)
EndIf
Return SetError(2)
Else
SetLog("x" & UBound($splitedPositions) & " " & GetObjNameSideP($sToSearch) & " Verified", $COLOR_GREEN)
EndIf
For $Pos In $splitedPositions
Switch StringLeft(Slice8(StringSplit($Pos, ",", 2)), 1)
Case 1, 2
$ToReturn[0] += 1
Case 3, 4
$ToReturn[1] += 1
Case 5, 6
$ToReturn[2] += 1
Case 7, 8
$ToReturn[3] += 1
EndSwitch
Next
If $DebugSideP Then
SetLog("==============Objects Count===============")
SetLog("BOTTOM-RIGHT Objects Count: x" & $ToReturn[0], $COLOR_BLUE)
SetLog("TOP-RIGHT Objects Count: x" & $ToReturn[1], $COLOR_BLUE)
SetLog("TOP-LEFT Objects Count: x" & $ToReturn[2], $COLOR_BLUE)
SetLog("BOTTOM-LEFT Objects Count: x" & $ToReturn[3], $COLOR_BLUE)
EndIf
Return $ToReturn
EndFunc
Func GetObjNameSideP($sToSearch, $Plural = Default)
Switch $sToSearch
Case "Mine"
If $Plural = Default Then Return "Gold Mine(s)"
If $Plural = 0 Then Return "Gold Mine"
If $Plural = 1 Then Return "Gold Mines"
Case "Collector"
If $Plural = Default Then Return "Elixir Collector(s)"
If $Plural = 0 Then Return "Elixir Collector"
If $Plural = 1 Then Return "Elixir Collectors"
Case "Drill"
Return "Dark Elixir Drill(s)"
If $Plural = Default Then Return "Dark Elixir Drill(s)"
If $Plural = 0 Then Return "Dark Elixir Drill"
If $Plural = 1 Then Return "Dark Elixir Drills"
Case Else
Return $sToSearch
EndSwitch
EndFunc
Func ResetSideP()
For $i = 0 To(UBound($allMinesFound) - 1)
$allMinesFound[$i][0] = -1
$allMinesFound[$i][1] = -1
$allMinesFound[$i][1] = ""
Next
For $i = 0 To(UBound($allCollectorsFound) - 1)
$allCollectorsFound[$i][0] = -1
$allCollectorsFound[$i][1] = -1
$allCollectorsFound[$i][1] = ""
Next
For $i = 0 To(UBound($allDrillsFound) - 1)
$allDrillsFound[$i][0] = -1
$allDrillsFound[$i][1] = -1
$allDrillsFound[$i][1] = ""
Next
EndFunc
Func checkForSidePInCSV($sFilePath)
Local $AvailableSideP = CheckSidePCommands($sFilePath)
If UBound($AvailableSideP) > 0 Then
SetLog("Initializing SideP for further uses", $COLOR_BLUE)
_CaptureRegion2()
For $i = 0 To(UBound($AvailableSideP) - 1)
If Not IsObjLocated($AvailableSideP[$i]) Then StoreSidePPositions($AvailableSideP[$i], True)
Next
Local $iMinesFound = 0, $iCollectorsFound = 0, $iDrillsFound = 0
For $i = 0 To(UBound($allMinesFound) - 1)
If $allMinesFound[$i][0] > 0 And $allMinesFound[$i][1] > 0 Then $iMinesFound += 1
Next
For $i = 0 To(UBound($allCollectorsFound) - 1)
If $allCollectorsFound[$i][0] > 0 And $allCollectorsFound[$i][1] > 0 Then $iCollectorsFound += 1
Next
For $i = 0 To(UBound($allDrillsFound) - 1)
If $allDrillsFound[$i][0] > 0 And $allDrillsFound[$i][1] > 0 Then $iDrillsFound += 1
Next
SetLog("x" & $iMinesFound & " Gold Mine(s) located", $COLOR_BLUE)
SetLog("x" & $iCollectorsFound & " Elixir Collector(s) located", $COLOR_BLUE)
SetLog("x" & $iDrillsFound & " Dark Elixir Drill(s) located", $COLOR_BLUE)
EndIf
EndFunc
Func CheckSidePCommands($sFilePath)
Local $ToReturn = ""
If $g_bRunState = False Then Return
If $g_abSearchSearchesEnable[$DB] = 1 Then
If $g_aiAttackAlgorithm[$DB] = 1 Then
$ToReturn &= GetSidePCommands($DB, $sFilePath)
EndIf
EndIf
$ToReturn = StringSplit($ToReturn, "|", 2)
ArrayRemoveDuplicates($ToReturn)
Return $ToReturn
EndFunc
Func GetSidePCommands($Mode, $sFilePath)
Local $ToReturn = ""
If $g_bRunState = False Then Return
Local $rownum = 0
If FileExists($sFilePath) Then
Local $f, $line, $acommand, $command
$f = FileOpen($sFilePath, 0)
While 1
$line = FileReadLine($f)
$rownum += 1
If @error = -1 Then ExitLoop
$acommand = StringSplit($line, "|")
If $acommand[0] >= 8 Then
$command = StringStripWS(StringUpper($acommand[1]), 2)
If $command = "SIDEP" Then
Local $EXTRGOLD = StringStripWS(StringUpper($acommand[2]), 2)
Local $EXTRELIXIR = StringStripWS(StringUpper($acommand[3]), 2)
Local $EXTRDARK = StringStripWS(StringUpper($acommand[4]), 2)
Local $DEPOGOLD = StringStripWS(StringUpper($acommand[5]), 2)
Local $DEPOELIXIR = StringStripWS(StringUpper($acommand[6]), 2)
Local $DEPODARK = StringStripWS(StringUpper($acommand[7]), 2)
Local $CTOWNHALL = StringStripWS(StringUpper($acommand[8]), 2)
If Int($EXTRGOLD) > 0 Then $ToReturn &= "Mine" & "|"
If Int($EXTRELIXIR) > 0 Then $ToReturn &= "Collector" & "|"
If Int($EXTRDARK) > 0 Then $ToReturn &= "Drill" & "|"
If Int($DEPOGOLD) > 0 Then $ToReturn &= "SMine" & "|"
If Int($DEPOELIXIR) > 0 Then $ToReturn &= "SCollector" & "|"
If Int($DEPODARK) > 0 Then $ToReturn &= "SDark" & "|"
If Int($CTOWNHALL) > 0 Then $ToReturn &= "TownHall" & "|"
EndIf
EndIf
WEnd
FileClose($f)
EndIf
Return $ToReturn
EndFunc
Func StoreSidePPositions($sToStore, $useOldCapture = True)
Local $aResult = GetSidePPositions($sToStore, $useOldCapture)
Local $sResultPoints = ""
Local $sResultPaths = ""
Local $tmp
For $i = 0 To(UBound($aResult) - 1)
$tmp = $aResult[$i]
$sResultPoints &= String($tmp[0]) & "|"
Local $iToLoop =(StringInStr($tmp[0], "|") > 0) ? UBound(StringSplit($tmp[0], "|", 2)) : 1
For $j = 1 To $iToLoop
$sResultPaths &= $tmp[1] & "|"
Next
Next
If StringRight($sResultPoints, 1) = "|" Then $sResultPoints = StringLeft($sResultPoints, StringLen($sResultPoints) - 1)
If StringRight($sResultPaths, 1) = "|" Then $sResultPaths = StringLeft($sResultPaths, StringLen($sResultPaths) - 1)
Switch $sToStore
Case "Mine"
If StringInStr($sResultPoints, ",") > 0 And StringLen($sResultPoints) > 2 Then
Local $tmpSplitedPositions
Local $tmpSplitedPaths
If StringInStr($sResultPoints, "|") > 0 Then
$tmpSplitedPositions = StringSplit($sResultPoints, "|", 2)
Else
$tmpSplitedPositions = _StringEqualSplit($sResultPoints, StringLen($sResultPoints))
EndIf
If StringInStr($sResultPaths, "|") > 0 Then
$tmpSplitedPaths = StringSplit($sResultPaths, "|", 2)
Else
$tmpSplitedPaths = _StringEqualSplit($sResultPaths, StringLen($sResultPaths))
EndIf
Local $tmpSplitedPositions2
For $i = 0 To(UBound($allMinesFound) - 1)
If $i >= UBound($tmpSplitedPositions) Then
$allMinesFound[$i][0] = -1
$allMinesFound[$i][1] = -1
$allMinesFound[$i][2] = ""
Else
$tmpSplitedPositions2 = StringSplit($tmpSplitedPositions[$i], ",", 2)
$allMinesFound[$i][0] = $tmpSplitedPositions2[0]
$allMinesFound[$i][1] = $tmpSplitedPositions2[1]
$allMinesFound[$i][2] = $tmpSplitedPaths[$i]
EndIf
Next
Else
For $i = 0 To(UBound($allMinesFound) - 1)
$allMinesFound[$i][0] = -1
$allMinesFound[$i][1] = -1
$allMinesFound[$i][2] = ""
Next
EndIf
Case "Collector"
If StringInStr($sResultPoints, ",") > 0 And StringLen($sResultPoints) > 2 Then
Local $tmpSplitedPositions
Local $tmpSplitedPaths
If StringInStr($sResultPoints, "|") > 0 Then
$tmpSplitedPositions = StringSplit($sResultPoints, "|", 2)
Else
$tmpSplitedPositions = _StringEqualSplit($sResultPoints, StringLen($sResultPoints))
EndIf
If StringInStr($sResultPaths, "|") > 0 Then
$tmpSplitedPaths = StringSplit($sResultPaths, "|", 2)
Else
$tmpSplitedPaths = _StringEqualSplit($sResultPaths, StringLen($sResultPaths))
EndIf
Local $tmpSplitedPositions2
For $i = 0 To(UBound($allCollectorsFound) - 1)
If $i >= UBound($tmpSplitedPositions) Then
$allCollectorsFound[$i][0] = -1
$allCollectorsFound[$i][1] = -1
$allCollectorsFound[$i][2] = ""
Else
$tmpSplitedPositions2 = StringSplit($tmpSplitedPositions[$i], ",", 2)
$allCollectorsFound[$i][0] = $tmpSplitedPositions2[0]
$allCollectorsFound[$i][1] = $tmpSplitedPositions2[1]
$allCollectorsFound[$i][2] = $tmpSplitedPaths[$i]
EndIf
Next
Else
For $i = 0 To(UBound($allCollectorsFound) - 1)
$allCollectorsFound[$i][0] = -1
$allCollectorsFound[$i][1] = -1
$allCollectorsFound[$i][2] = ""
Next
EndIf
Case "Drill"
If StringInStr($sResultPoints, ",") > 0 And StringLen($sResultPoints) > 2 Then
Local $tmpSplitedPositions
Local $tmpSplitedPaths
If StringInStr($sResultPoints, "|") > 0 Then
$tmpSplitedPositions = StringSplit($sResultPoints, "|", 2)
Else
$tmpSplitedPositions = _StringEqualSplit($sResultPoints, StringLen($sResultPoints))
EndIf
If StringInStr($sResultPaths, "|") > 0 Then
$tmpSplitedPaths = StringSplit($sResultPaths, "|", 2)
Else
$tmpSplitedPaths = _StringEqualSplit($sResultPaths, StringLen($sResultPaths))
EndIf
Local $tmpSplitedPositions2
For $i = 0 To(UBound($allDrillsFound) - 1)
If $i >= UBound($tmpSplitedPositions) Then
$allDrillsFound[$i][0] = -1
$allDrillsFound[$i][1] = -1
$allDrillsFound[$i][2] = ""
Else
$tmpSplitedPositions2 = StringSplit($tmpSplitedPositions[$i], ",", 2)
$allDrillsFound[$i][0] = $tmpSplitedPositions2[0]
$allDrillsFound[$i][1] = $tmpSplitedPositions2[1]
$allDrillsFound[$i][2] = $tmpSplitedPaths[$i]
EndIf
Next
Else
For $i = 0 To(UBound($allDrillsFound) - 1)
$allDrillsFound[$i][0] = -1
$allDrillsFound[$i][1] = -1
$allDrillsFound[$i][2] = ""
Next
EndIf
Case Else
Return SetError(1)
EndSwitch
EndFunc
Func ValidateOldPositions($sToFind)
Local $ToReturn = ""
Local $searchResult = ""
_CaptureRegion2()
Switch $sToFind
Case "Mine"
For $i = 0 To(UBound($allMinesFound) - 1)
If Int($allMinesFound[$i][0]) > 0 And Int($allMinesFound[$i][1]) > 0 Then
$searchResult = ReCheckTile($allMinesFound[$i][2], String($allMinesFound[$i][0] & "," & $allMinesFound[$i][1]), False)
Local $tmpSplitedPositions
If StringInStr($searchResult, ",") > 0 Then
$tmpSplitedPositions = StringSplit($searchResult, ",", 2)
$ToReturn &= $tmpSplitedPositions[0] & "," & $tmpSplitedPositions[1] & "|"
EndIf
EndIf
Next
Case "Collector"
For $i = 0 To(UBound($allCollectorsFound) - 1)
If Int($allCollectorsFound[$i][0]) > 0 And Int($allCollectorsFound[$i][1]) > 0 Then
$searchResult = ReCheckTile($allCollectorsFound[$i][2], String($allCollectorsFound[$i][0] & "," & $allCollectorsFound[$i][1]), False)
Local $tmpSplitedPositions
If StringInStr($searchResult, ",") > 0 Then
$tmpSplitedPositions = StringSplit($searchResult, ",", 2)
$ToReturn &= $tmpSplitedPositions[0] & "," & $tmpSplitedPositions[1] & "|"
EndIf
EndIf
Next
Case "Drill"
For $i = 0 To(UBound($allDrillsFound) - 1)
If Int($allDrillsFound[$i][0]) > 0 And Int($allDrillsFound[$i][1]) > 0 Then
$searchResult = ReCheckTile($allDrillsFound[$i][2], String($allDrillsFound[$i][0] & "," & $allDrillsFound[$i][1]), False)
Local $tmpSplitedPositions
If StringInStr($searchResult, ",") > 0 Then
$tmpSplitedPositions = StringSplit($searchResult, ",", 2)
$ToReturn &= $tmpSplitedPositions[0] & "," & $tmpSplitedPositions[1] & "|"
EndIf
EndIf
Next
EndSwitch
If StringRight($ToReturn, 1) = "|" Then $ToReturn = StringLeft($ToReturn,(StringLen($ToReturn) - 1))
Return $ToReturn
EndFunc
Func GetSidePPositions($sToFind, $useOldCapture = True)
Local $cDiamondImgLoc = "ECD", $rdImgLoc = "ECD"
If $iDetectedImageType = 1 Then $dGoldMines = @ScriptDir & "\imgxml\Storages\Mines_Snow"
Local $rFindMultiple
Switch $sToFind
Case "Mine"
$rFindMultiple = findMultiple($dGoldMines, $cDiamondImgLoc, $rdImgLoc, 0, 1000, 0, "objectpoints,filepath", Not $useOldCapture)
Case "Collector"
$rFindMultiple = findMultiple($dElixirCollectors, $cDiamondImgLoc, $rdImgLoc, 0, 1000, 0, "objectpoints,filepath", Not $useOldCapture)
Case "Drill"
$rFindMultiple = findMultiple($dDarkDrills, $cDiamondImgLoc, $rdImgLoc, 0, 1000, 0, "objectpoints,filepath", Not $useOldCapture)
Case Else
Return SetError(1)
EndSwitch
Return $rFindMultiple
EndFunc
Func IsObjLocated($Obj)
Switch $Obj
Case "Mine"
For $i = 0 To(UBound($allMinesFound) - 1)
If($allMinesFound[$i][0] > 0 And $allMinesFound[$i][1] > 0) Then Return True
Next
Return False
Case "Collector"
For $i = 0 To(UBound($allCollectorsFound) - 1)
If($allCollectorsFound[$i][0] > 0 And $allCollectorsFound[$i][1] > 0) Then Return True
Next
Return False
Case "Drill"
For $i = 0 To(UBound($allDrillsFound) - 1)
If($allDrillsFound[$i][0] > 0 And $allDrillsFound[$i][1] > 0) Then Return True
Next
Return False
Case Else
Return False
EndSwitch
EndFunc
Func UpdateTroopQuantity($sTroop, $bNeedNewCapture = Default)
If $bNeedNewCapture = Default Then $bNeedNewCapture = True
If $bNeedNewCapture = True Then
_CaptureRegion2()
EndIf
Local $troopName = $sTroop
Local $iTroopIndex = TroopIndexLookup($troopName)
If $iTroopIndex = -1 Then
Setlog("'UpdateTroopQuantity' troop name '" & $troopName & "' is unrecognized.")
Return
EndIf
Local $troopPosition = -1
For $i = 0 To UBound($atkTroops) - 1
If $atkTroops[$i][0] = $iTroopIndex Then
$troopPosition = $i
ExitLoop
EndIf
Next
If $g_bRunState = False Then Return
If $troopPosition <> -1 Then
Local $iQuantity = ReadTroopQuantity($troopPosition, True, Not $bNeedNewCapture)
$atkTroops[$troopPosition][1] = $iQuantity
EndIf
Return $troopPosition
EndFunc
Func IsSlotSelected($iSlotIndex, $bNeedNewCapture = Default)
If $bNeedNewCapture = Default Then $bNeedNewCapture = True
If $bNeedNewCapture = True Then
ForceCaptureRegion()
_CaptureRegion()
EndIf
Local $iOffset = 73
Local $iStartX = 75
Local $iY = 724
If $bNeedNewCapture = True Then
Return _ColorCheck(  _GetPixelColor($iStartX +($iOffset * $iSlotIndex), $iY, False), Hex(0xFFFFFF, 6), 20)
Else
Return _ColorCheck( Hex(_GDIPlus_BitmapGetPixel(_GDIPlus_BitmapCreateFromHBITMAP($hHBitmap2),($iStartX +($iOffset * $iSlotIndex)), $iY), 6), Hex(0xFFFFFF, 6), 20)
EndIf
EndFunc
Func DropSpellFromINIOnDefense($Defense, $options, $qtaMin, $qtaMax, $troopName, $delayPointmin, $delayPointmax, $delayDropMin, $delayDropMax, $sleepafterMin, $sleepAfterMax, $debug = False)
If $debugDropSCommand = 1 Then SetLog("Func DropSpellFromINIOnDefense(" & $Defense & ", " & $options & ")", $COLOR_DEBUG)
debugAttackCSV("drop using Defense " & $Defense & " and using " & $qtaMin & "-" & $qtaMax & " of " & $troopName)
debugAttackCSV(" - delay for multiple troops in same point: " & $delayPointmin & "-" & $delayPointmax)
debugAttackCSV(" - delay when  change deploy point : " & $delayDropMin & "-" & $delayDropMax)
debugAttackCSV(" - delay after drop all troops : " & $sleepafterMin & "-" & $sleepAfterMax)
Local $FullDefenseName = GetFullDefenseName($Defense)
If $qtaMin <> $qtaMax Then
Local $qty = Random($qtaMin, $qtaMax, 1)
Else
Local $qty = $qtaMin
EndIf
debugAttackCSV(">> qty to deploy: " & $qty)
Local $qtyxpoint = Int($qty)
debugAttackCSV(">> qty x point: " & $qtyxpoint)
Local $iTroopIndex = TroopIndexLookup($troopName)
If $iTroopIndex = -1 Then
Setlog("CSV troop name '" & $troopName & "' is unrecognized.")
Return
EndIf
Local $troopPosition = -1
For $i = 0 To UBound($atkTroops) - 1
If $atkTroops[$i][0] = $iTroopIndex Then
$troopPosition = $i
EndIf
Next
Local $usespell = True
Switch $iTroopIndex
Case $eLSpell
If $g_abAttackUseLightSpell[$g_iMatchMode] = 0 Then $usespell = False
Case $eHSpell
If $g_abAttackUseHealSpell[$g_iMatchMode] = 0 Then $usespell = False
Case $eRSpell
If $g_abAttackUseRageSpell[$g_iMatchMode] = 0 Then $usespell = False
Case $eJSpell
If $g_abAttackUseJumpSpell[$g_iMatchMode] = 0 Then $usespell = False
Case $eFSpell
If $g_abAttackUseFreezeSpell[$g_iMatchMode] = 0 Then $usespell = False
Case $eCSpell
If $g_abAttackUseCloneSpell[$g_iMatchMode] = 0 Then $usespell = False
Case $ePSpell
If $g_abAttackUsePoisonSpell[$g_iMatchMode] = 0 Then $usespell = False
Case $eESpell
If $g_abAttackUseEarthquakeSpell[$g_iMatchMode] = 0 Then $usespell = False
Case $eHaSpell
If $g_abAttackUseHasteSpell[$g_iMatchMode] = 0 Then $usespell = False
Case $eSkSpell
If $g_abAttackUseSkeletonSpell[$g_iMatchMode] = 0 Then $usespell = False
EndSwitch
If $troopPosition = -1 Or $usespell = False Then
If $usespell = True Then
Setlog("No troop found in your attack troops list")
debugAttackCSV("No troop found in your attack troops list")
Else
If $g_iDebugSetLog = 1 Then SetLog("discard use spell", $COLOR_DEBUG)
EndIf
Else
SelectDropTroop($troopPosition)
If $delayDropMin <> $delayDropMax Then
Local $delayDrop = Random($delayDropMin, $delayDropMax, 1)
Else
$delayDrop = $delayDropMin
EndIf
Local $delayDropLast = 0
$delayDropLast = $delayDrop
Local $DefenseResult = AssignPixelOfDefense($Defense, $options)
Local $pixel[2] = [$DefenseResult[4], $DefenseResult[5]]
If $DefenseResult[1] = False Then
CheckHeroesHealth()
ReleaseClicks()
Return
EndIf
If IsArray($pixel) Then
If UBound($pixel) >= 2 Then
If $pixel[1] <= 0 Then
CheckHeroesHealth()
ReleaseClicks()
Return
EndIf
EndIf
EndIf
If $DefenseResult[3] <> "" Then SetLog($DefenseResult[3])
If $debugDropSCommand = 1 And IsArray($pixel) Then SetLog("$pixel[0] = " & $pixel[0] & " $pixel[1] = " & $pixel[1])
Local $qty2 = $qtyxpoint
If $delayPointmin <> $delayPointmax Then
Local $delayPoint = Random($delayPointmin, $delayPointmax, 1)
Else
Local $delayPoint = $delayPointmin
EndIf
Local $plural = 0
If $qty2 > 1 Then $plural = 1
Switch $iTroopIndex
Case $eLSpell To $eSkSpell
If $debug = True Then
Setlog("Drop Spell AttackClick( " & $pixel[0] & ", " & $pixel[1] & " , " & $qty2 & ", " & $delayPoint & ",#0666)")
Else
AttackClick($pixel[0], $pixel[1], $qty2, $delayPoint, $delayDropLast, "#0667")
If $qty2 > 0 And $DefenseResult[1] = True Then Setlog(" » Dropping " & $qty2 & " of " & NameOfTroop($iTroopIndex, $plural) & IIf($DefenseResult[2] = True, " Between ", "") & IIf($DefenseResult[2] = True, $FullDefenseName, " On " & $FullDefenseName) & IIf($DefenseResult[2] = True, "(s)", ""))
EndIf
Case Else
Setlog("Error parsing line")
EndSwitch
debugAttackCSV($troopName & " qty " & $qty2 & " in (" & $pixel[0] & "," & $pixel[1] & ") delay " & $delayPoint)
ReleaseClicks()
Local $sleepafter = 0
If $sleepafterMin <> $sleepAfterMax Then
$sleepafter = Random($sleepafterMin, $sleepAfterMax, 1)
Else
$sleepafter = Int($sleepafterMin)
EndIf
If $sleepafter > 0 And IsKeepClicksActive() = False Then
debugAttackCSV(">> delay after drop all troops: " & $sleepafter)
If $sleepafter <= 1000 Then
If _Sleep($sleepafter) Then Return
CheckHeroesHealth()
Else
For $z = 1 To Int($sleepafter / 1000)
If _Sleep(980) Then Return
CheckHeroesHealth()
Next
If _Sleep(Mod($sleepafter, 1000)) Then Return
CheckHeroesHealth()
EndIf
EndIf
EndIf
EndFunc
Func GetFullDefenseName($Defense)
If $debugDropSCommand = 1 Then SetLog("Func GetFullDefenseName(" & $Defense & ")", $COLOR_DEBUG)
Select
Case $Defense = "EAGLE"
Return "Eagle"
Case $Defense = "INFERNO"
Return "Inferno Tower"
Case $Defense = "ADEFENSE"
Return "Air Defense"
Case Else
Return "Unknown Defense"
EndSelect
EndFunc
Func AssignPixelOfDefense($Defense, $options, $forceReLocate = False)
If $debugDropSCommand = 1 Then SetLog("Func AssignPixelOfDefense(" & $Defense & ", " & $options & ", " & $forceReLocate & ")", $COLOR_DEBUG)
Local $LocateResult
Switch $forceReLocate
Case True
ResetDefensesLocation($Defense)
$LocateResult = LocateDefense($Defense, $options)
Case Else
$LocateResult = LocateDefense($Defense, $options)
EndSwitch
Switch $Defense
Case "EAGLE"
_ArrayMerge($LocateResult, $PixelEaglePos)
Return $LocateResult
Case "INFERNO"
_ArrayMerge($LocateResult, $PixelInfernoPos)
Return $LocateResult
Case "ADEFENSE"
_ArrayMerge($LocateResult, $PixelADefensePos)
Return $LocateResult
EndSwitch
EndFunc
Func ResetDefensesLocation($Defense = "")
If $debugDropSCommand = 1 Then SetLog("Func ResetDefensesLocation(" & $Defense & ")", $COLOR_DEBUG)
Switch $Defense
Case ""
$PixelEaglePos[0] = -1
$PixelEaglePos[1] = -1
$PixelInfernoPos[0] = -1
$PixelInfernoPos[1] = -1
$PixelADefensePos[0] = -1
$PixelADefensePos[1] = -1
Case "EAGLE"
$PixelEaglePos[0] = -1
$PixelEaglePos[1] = -1
Case "INFERNO"
$PixelInfernoPos[0] = -1
$PixelInfernoPos[1] = -1
Case "ADEFENSE"
$PixelADefensePos[0] = -1
$PixelADefensePos[1] = -1
Case "STORED"
$storedEaglePos = ""
$storedInfernoPos = ""
$storedADefensePos = ""
EndSwitch
EndFunc
Func LocateDefense($Defense, $options)
If $debugDropSCommand = 1 Then SetLog("Func LocateDefense(" & $Defense & ", " & $options & ")", $COLOR_DEBUG)
Local $Result[4] = [False, False, False, ""]
Local $ParsedOptions = ParseCommandOptions($options)
Local $RandomizeDropPoint = $ParsedOptions[0]
Local $SideCondition = $ParsedOptions[1]
Local $DropBetween = $ParsedOptions[2]
Local $useStoredPosition = $ParsedOptions[3]
Switch $Defense
Case "EAGLE"
Local $hTimer = TimerInit()
Local $directory = @ScriptDir & "\imgxml\WeakBase\Eagle"
Local $return
Local $reLocated = False
If $useStoredPosition = True Then
$return = GetStoredPositions($Defense)
Else
$return = returnAllMatchesDefense($directory)
EndIf
$reLocated = True
Local $splitedPositions = StringSplit($return, "|", 2)
If Not(UBound($splitedPositions) >= 1 And StringLen($splitedPositions[0]) > 2) Then DebugImageSave("EagleDetection_NotDetected_", True)
Local $theEagleSide = ""
Local $NotdetectedEagle = True
Local $Counter = -1
For $eachPos In $splitedPositions
Local $splitedEachPos = StringSplit($eachPos, ",", 2)
If IsArray($splitedEachPos) And UBound($splitedEachPos) > 1 Then
$Counter += 1
If $debugDropSCommand = 1 Then SetLog("$SideCondition = " & $SideCondition, $COLOR_DEBUG)
Select
Case $SideCondition = "AnySide"
$PixelEaglePos[0] = $splitedEachPos[0]
$PixelEaglePos[1] = $splitedEachPos[1]
$NotdetectedEagle = False
ExitLoop
Case $SideCondition = "SameSide" Or $SideCondition = "OtherSide"
Local $sliced = Slice8($splitedEachPos)
If $debugDropSCommand = 1 Then SetLog("$sliced = " & $sliced, $COLOR_BLUE)
Switch StringLeft($sliced, 1)
Case 1, 2
$theEagleSide = "BOTTOM"
Case 3, 4
$theEagleSide = "TOP"
Case 5, 6
$theEagleSide = "TOP"
Case 7, 8
$theEagleSide = "BOTTOM"
EndSwitch
Local $curMainSide = StringSplit($MAINSIDE, "-", 2)[0]
If $debugDropSCommand = 1 Then SetLog("$curMainSide = " & $curMainSide, $COLOR_ORANGE)
If $debugDropSCommand = 1 Then SetLog("$theEagleSide = " & $theEagleSide, $COLOR_ORANGE)
If $SideCondition = "SameSide" Then
If $theEagleSide = $curMainSide Then
$PixelEaglePos[0] = $splitedEachPos[0]
$PixelEaglePos[1] = $splitedEachPos[1]
$NotdetectedEagle = False
ExitLoop
EndIf
Else
If $theEagleSide <> $curMainSide Then
$PixelEaglePos[0] = $splitedEachPos[0]
$PixelEaglePos[1] = $splitedEachPos[1]
$NotdetectedEagle = False
ExitLoop
EndIf
EndIf
EndSelect
Else
$PixelEaglePos[0] = -1
$PixelEaglePos[1] = -1
EndIf
Next
If $NotdetectedEagle = False Then
Local $rToDecreaseX = 4
Local $rToIncreaseY = 11
If $RandomizeDropPoint = True Then
$rToDecreaseX = Random(0, 8, 1)
$rToIncreaseY = Random(0, 19, 1)
EndIf
If $debugDropSCommand = 1 Then SetLog("$rToDecreaseX = " & $rToDecreaseX)
If $debugDropSCommand = 1 Then SetLog("$rToDecreaseY = " & $rToIncreaseY)
$PixelEaglePos[0] -= $rToDecreaseX
$PixelEaglePos[1] += $rToIncreaseY
EndIf
If UBound($splitedPositions) >= 1 And StringLen($splitedPositions[0]) > 2 Then
$Result[0] = True
Setlog(" »» Eagle located in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds")
Else
FlagAsUnDetected($Result)
EndIf
Switch $SideCondition
Case "SameSide"
If $NotdetectedEagle = False Then
$Result[1] = True
SetLog("Eagle Detected in Same Side")
Else
FlagAsUnDetected($Result)
SetLog("No Eagle Detected in same side", $COLOR_ORANGE)
EndIf
Case "OtherSide"
If $NotdetectedEagle = False Then
$Result[1] = True
SetLog("Eagle Detected in the Other Side")
Else
FlagAsUnDetected($Result)
SetLog("No Eagle Detected in the other side", $COLOR_ORANGE)
EndIf
Case "AnySide"
If $NotdetectedEagle = False Then
$Result[1] = True
SetLog("Eagle Detected")
Else
FlagAsUnDetected($Result)
SetLog("No Eagle Detected at all", $COLOR_ORANGE)
EndIf
EndSwitch
Return $Result
Case "INFERNO"
$hTimer = TimerInit()
Local $directory = @ScriptDir & "\imgxml\WeakBase\Infernos"
Local $return
Local $reLocated = False
If $useStoredPosition = True Then
$return = GetStoredPositions($Defense)
Else
$return = returnAllMatchesDefense($directory)
EndIf
$reLocated = True
Local $splitedPositions = StringSplit($return, "|", 2)
If Not(UBound($splitedPositions) >= 1 And StringLen($splitedPositions[0]) > 2) Then DebugImageSave("InfernoDetection_NotDetected_", True)
Local $theInfernoSide = ""
Local $NotdetectedInferno = True
$Counter = -1
For $eachPos In $splitedPositions
$splitedEachPos = StringSplit($eachPos, ",", 2)
If IsArray($splitedEachPos) And UBound($splitedEachPos) > 1 Then
$Counter += 1
If $debugDropSCommand = 1 Then SetLog("$SideCondition = " & $SideCondition, $COLOR_DEBUG)
Select
Case $SideCondition = "AnySide"
$PixelInfernoPos[0] = $splitedEachPos[0]
$PixelInfernoPos[1] = $splitedEachPos[1]
$NotdetectedInferno = False
ExitLoop
Case $SideCondition = "SameSide" Or $SideCondition = "OtherSide"
$sliced = Slice8($splitedEachPos)
If $debugDropSCommand = 1 Then SetLog("$sliced = " & $sliced, $COLOR_BLUE)
Switch StringLeft($sliced, 1)
Case 1, 2
$theInfernoSide = "BOTTOM"
Case 3, 4
$theInfernoSide = "TOP"
Case 5, 6
$theInfernoSide = "TOP"
Case 7, 8
$theInfernoSide = "BOTTOM"
EndSwitch
$curMainSide = StringSplit($MAINSIDE, "-", 2)[0]
If $debugDropSCommand = 1 Then SetLog("$curMainSide = " & $curMainSide, $COLOR_ORANGE)
If $debugDropSCommand = 1 Then SetLog("$theInfernoSide = " & $theInfernoSide, $COLOR_ORANGE)
If $SideCondition = "SameSide" Then
If $theInfernoSide = $curMainSide Then
$PixelInfernoPos[0] = $splitedEachPos[0]
$PixelInfernoPos[1] = $splitedEachPos[1]
$NotdetectedInferno = False
ExitLoop
EndIf
Else
If $theInfernoSide <> $curMainSide Then
$PixelInfernoPos[0] = $splitedEachPos[0]
$PixelInfernoPos[1] = $splitedEachPos[1]
$NotdetectedInferno = False
ExitLoop
EndIf
EndIf
EndSelect
Else
$PixelInfernoPos[0] = -1
$PixelInfernoPos[1] = -1
EndIf
Next
Local $isNearToTheOtherOne = IsInfernoTowersNearToTheOtherOne($splitedPositions, $DropBetween)
If $NotdetectedInferno = True And $isNearToTheOtherOne[4] = True Then
If $debugDropSCommand = 1 Then SetLog("Near To The Other One Is True But No Inferno Towers Detected!!!, Disabling Drop Between...")
$isNearToTheOtherOne[4] = False
EndIf
If $isNearToTheOtherOne[4] = True And $NotdetectedInferno = False Then
If $isNearToTheOtherOne[0] = True Then
$PixelInfernoPos[0] +=(($isNearToTheOtherOne[2] / 2) + 0 + IIf($RandomizeDropPoint = True, Random(0, 5, 1), 0))
Else
$PixelInfernoPos[0] -=(($isNearToTheOtherOne[2] / 2) - 0 - IIf($RandomizeDropPoint = True, Random(0, 5, 1), 0))
EndIf
If $isNearToTheOtherOne[1] = True Then
$PixelInfernoPos[1] +=(($isNearToTheOtherOne[3] / 2) + IIf($RandomizeDropPoint = True, 7, 9) + IIf($RandomizeDropPoint = True, Random(1, 3, 1), 0))
Else
$PixelInfernoPos[1] -=(($isNearToTheOtherOne[3] / 2) - IIf($RandomizeDropPoint = True, 7, 9) - IIf($RandomizeDropPoint = True, Random(1, 3, 1), 0))
EndIf
EndIf
If $debugDropSCommand = 1 Then SetLog("$isNearToTheOtherOne[4] = " & $isNearToTheOtherOne[4], $COLOR_BLUE)
If $NotdetectedInferno = False And $isNearToTheOtherOne[4] = False Then
Local $rToDecreaseX = 4
Local $rToIncreaseY = 11
If $RandomizeDropPoint = True Then
$rToDecreaseX = Random(0, 8, 1)
$rToIncreaseY = Random(0, 19, 1)
EndIf
If $debugDropSCommand = 1 Then SetLog("$rToDecreaseX = " & $rToDecreaseX)
If $debugDropSCommand = 1 Then SetLog("$rToDecreaseY = " & $rToIncreaseY)
$PixelInfernoPos[0] -= $rToDecreaseX
$PixelInfernoPos[1] += $rToIncreaseY
EndIf
If UBound($splitedPositions) >= 1 And StringLen($splitedPositions[0]) > 2 Then
$Result[0] = True
Setlog(" »» " & UBound($splitedPositions) & "x Inferno Tower(s) located in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds")
Else
FlagAsUnDetected($Result)
EndIf
Switch $SideCondition
Case "SameSide"
If $NotdetectedInferno = False Then
If $isNearToTheOtherOne[4] = False Then
$Result[1] = True
SetLog("Inferno Tower Detected in Same Side")
EndIf
If $isNearToTheOtherOne[4] = True Then
$Result[1] = True
$Result[2] = True
EndIf
Else
FlagAsUnDetected($Result)
SetLog("No Inferno Tower Detected in same side", $COLOR_ORANGE)
EndIf
Case "OtherSide"
If $NotdetectedInferno = False Then
If $isNearToTheOtherOne[4] = False Then
$Result[1] = True
SetLog("Inferno Tower Detected in the Other Side")
EndIf
If $isNearToTheOtherOne[4] = True Then
$Result[1] = True
$Result[2] = True
EndIf
Else
FlagAsUnDetected($Result)
SetLog("No Inferno Tower Detected in the other side", $COLOR_ORANGE)
EndIf
Case "AnySide"
If $NotdetectedInferno = False Then
If $isNearToTheOtherOne[4] = False Then
$Result[1] = True
SetLog("Inferno Tower Detected")
EndIf
If $isNearToTheOtherOne[4] = True Then
$Result[1] = True
$Result[2] = True
EndIf
Else
FlagAsUnDetected($Result)
SetLog("No Inferno Tower Detected at all", $COLOR_ORANGE)
EndIf
EndSwitch
Return $Result
Case "ADEFENSE"
$hTimer = TimerInit()
Local $directory = @ScriptDir & "\imgxml\WeakBase\ADefense"
Local $return
Local $reLocated = False
If $useStoredPosition = True Then
$return = GetStoredPositions($Defense)
Else
$return = returnAllMatchesDefense($directory)
EndIf
$reLocated = True
Local $splitedPositions = StringSplit($return, "|", 2)
If Not(UBound($splitedPositions) >= 1 And StringLen($splitedPositions[0]) > 2) Then DebugImageSave("AirDefenseDetection_NotDetected_", True)
Local $theADefenseSide = ""
Local $NotdetectedADefense = True
$Counter = -1
For $eachPos In $splitedPositions
$splitedEachPos = StringSplit($eachPos, ",", 2)
If IsArray($splitedEachPos) And UBound($splitedEachPos) > 1 Then
$Counter += 1
If $debugDropSCommand = 1 Then SetLog("$SideCondition = " & $SideCondition, $COLOR_DEBUG)
Select
Case $SideCondition = "AnySide"
$PixelADefensePos[0] = $splitedEachPos[0]
$PixelADefensePos[1] = $splitedEachPos[1]
$NotdetectedADefense = False
ExitLoop
Case $SideCondition = "SameSide" Or $SideCondition = "OtherSide"
$sliced = Slice8($splitedEachPos)
If $debugDropSCommand = 1 Then SetLog("$sliced = " & $sliced, $COLOR_BLUE)
Switch StringLeft($sliced, 1)
Case 1, 2
$theADefenseSide = "BOTTOM"
Case 3, 4
$theADefenseSide = "TOP"
Case 5, 6
$theADefenseSide = "TOP"
Case 7, 8
$theADefenseSide = "BOTTOM"
EndSwitch
$curMainSide = StringSplit($MAINSIDE, "-", 2)[0]
If $debugDropSCommand = 1 Then SetLog("$curMainSide = " & $curMainSide, $COLOR_ORANGE)
If $debugDropSCommand = 1 Then SetLog("$theADefenseSide = " & $theADefenseSide, $COLOR_ORANGE)
If $SideCondition = "SameSide" Then
If $theADefenseSide = $curMainSide Then
$PixelADefensePos[0] = $splitedEachPos[0]
$PixelADefensePos[1] = $splitedEachPos[1]
$NotdetectedADefense = False
ExitLoop
EndIf
Else
If $theADefenseSide <> $curMainSide Then
$PixelADefensePos[0] = $splitedEachPos[0]
$PixelADefensePos[1] = $splitedEachPos[1]
$NotdetectedADefense = False
ExitLoop
EndIf
EndIf
EndSelect
Else
$PixelADefensePos[0] = -1
$PixelADefensePos[1] = -1
EndIf
Next
If $NotdetectedADefense = False Then
Local $rToDecreaseX = 4
Local $rToIncreaseY = 11
If $RandomizeDropPoint = True Then
$rToDecreaseX = Random(0, 8, 1)
$rToIncreaseY = Random(0, 19, 1)
EndIf
If $debugDropSCommand = 1 Then SetLog("$rToDecreaseX = " & $rToDecreaseX)
If $debugDropSCommand = 1 Then SetLog("$rToDecreaseY = " & $rToIncreaseY)
$PixelADefensePos[0] -= $rToDecreaseX
$PixelADefensePos[1] += $rToIncreaseY
EndIf
If UBound($splitedPositions) >= 1 And StringLen($splitedPositions[0]) > 2 Then
$Result[0] = True
Setlog(" »» " & UBound($splitedPositions) & "x Air Defense(s) located in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds")
Else
FlagAsUnDetected($Result)
EndIf
Switch $SideCondition
Case "SameSide"
If $NotdetectedADefense = False Then
$Result[1] = True
SetLog("Air Defense Detected in Same Side")
Else
FlagAsUnDetected($Result)
SetLog("No Air Defense Detected in same side", $COLOR_ORANGE)
EndIf
Case "OtherSide"
If $NotdetectedADefense = False Then
$Result[1] = True
SetLog("Air Defense Detected in the Other Side")
Else
FlagAsUnDetected($Result)
SetLog("No Air Defense Detected in the other side", $COLOR_ORANGE)
EndIf
Case "AnySide"
If $NotdetectedADefense = False Then
$Result[1] = True
SetLog("Air Defense Detected")
Else
FlagAsUnDetected($Result)
SetLog("No Air Defense Detected at all", $COLOR_ORANGE)
EndIf
EndSwitch
Return $Result
EndSwitch
Return $Result
EndFunc
Func FlagAsUnDetected(ByRef $Result)
For $i = 0 To(UBound($Result) - 1)
If Not $i =(UBound($Result) - 1) Then
$Result[$i] = False
Else
$Result[$i] = ""
EndIf
Next
EndFunc
Func ParseCommandOptions($options)
If $debugDropSCommand = 1 Then SetLog("Func ParseCommandOptions(" & $options & ")", $COLOR_DEBUG)
Local $Result[4] = [False, "", True, False]
Local $splitedOptions = StringSplit($options, ",", 2)
For $Opt In $splitedOptions
Local $optSplited = StringSplit($Opt, ":", 2)
Local $optArg = $optSplited[0]
Local $optValue = $optSplited[1]
Switch $optArg
Case "R"
If $optValue = "T" Then
$Result[0] = True
Else
$Result[0] = False
EndIf
Case "B"
If $optValue = "T" Then
$Result[2] = True
Else
$Result[2] = False
EndIf
Case "S"
Switch $optValue
Case "S"
$Result[1] = "SameSide"
Case "O"
$Result[1] = "OtherSide"
Case "A"
$Result[1] = "AnySide"
EndSwitch
Case "L"
If $optValue = "T" Then
$Result[3] = True
Else
$Result[3] = False
EndIf
EndSwitch
Next
Return $Result
EndFunc
Func IsInfernoTowersNearToTheOtherOne($positions, $DropBetween)
If $debugDropSCommand = 1 Then SetLog("Func IsInfernoTowersNearToTheOtherOne(" & $positions & ", " & $DropBetween & ")", $COLOR_DEBUG)
Local $Result[5] = [False, False, 0, 0, False]
If UBound($positions) < 2 Or $DropBetween = False Then
If $debugDropSCommand = 1 Then SetLog("UBound($positions) < 2 OR $DropBetween = False")
If $debugDropSCommand = 1 Then SetLog("UBound($positions) = " & UBound($positions))
If $debugDropSCommand = 1 Then SetLog("$DropBetween = " & $DropBetween)
Return $Result
EndIf
Local $allowedXDiff = 74, $allowedYDiff = 53
If IsArray(StringSplit($positions[0], ",", 2)) And IsArray(StringSplit($positions[1], ",", 2)) Then Return $Result
Local $firstInfernoPosition[2] = [StringSplit($positions[0], ",", 2)[0], StringSplit($positions[0], ",", 2)[1]]
Local $secondInfernoPosition[2] = [StringSplit($positions[1], ",", 2)[0], StringSplit($positions[1], ",", 2)[1]]
Local $xDiff = $firstInfernoPosition[0] - $secondInfernoPosition[0], $yDiff = $firstInfernoPosition[1] - $secondInfernoPosition[1]
If StringLeft(String($xDiff), 1) = "-" Then
$xDiff = $secondInfernoPosition[0] - $firstInfernoPosition[0]
$Result[0] = True
EndIf
If StringLeft(String($yDiff), 1) = "-" Then
$yDiff = $secondInfernoPosition[1] - $firstInfernoPosition[1]
$Result[1] = True
EndIf
$Result[2] = $xDiff
$Result[3] = $yDiff
If $xDiff <= $allowedXDiff And $yDiff <= $allowedYDiff Then
$Result[4] = True
Return $Result
EndIf
SetLog("Inferno Towers are so far from the other one, Cannot Drop Between", $COLOR_ORANGE)
Return $Result
EndFunc
Func checkForDropSInCSV($sFilePath)
Local $AvailableDropS = CheckDropSCommands($sFilePath)
If UBound($AvailableDropS) > 0 Then
SetLog("Initializing DropS for further uses", $COLOR_BLUE)
For $i = 0 To(UBound($AvailableDropS) - 1)
If StringLen($AvailableDropS[$i]) > 2 Then
If Not IsObjLocatedDropS($AvailableDropS[$i]) Then GetAndStorePositions($AvailableDropS[$i])
EndIf
Next
If _ArraySearch($AvailableDropS, "EAGLE") > -1 Then SetLog("x" & IIf(StringInStr($storedEaglePos, "|") > 0, UBound(StringSplit($storedEaglePos, "|", 2)), UBound(_StringEqualSplit($storedEaglePos))) & " Eagle(s) located", $COLOR_BLUE)
If _ArraySearch($AvailableDropS, "INFERNO") > -1 Then SetLog("x" & IIf(StringInStr($storedInfernoPos, "|") > 0, UBound(StringSplit($storedInfernoPos, "|", 2)), UBound(_StringEqualSplit($storedInfernoPos))) & " Inferno Tower(s) located", $COLOR_BLUE)
If _ArraySearch($AvailableDropS, "ADEFENSE") > -1 Then SetLog("x" & IIf(StringInStr($storedADefensePos, "|") > 0, UBound(StringSplit($storedADefensePos, "|", 2)), UBound(_StringEqualSplit($storedADefensePos))) & " Air Defense(s) located", $COLOR_BLUE)
EndIf
EndFunc
Func CheckDropSCommands($sFilePath)
Local $ToReturn = ""
If $g_bRunState = False Then Return
If $g_abSearchSearchesEnable[$DB] = 1 Then
If $g_aiAttackAlgorithm[$DB] = 1 Then
$ToReturn &= GetDropSCommands($DB, $sFilePath)
EndIf
EndIf
Local $splitedToReturn = StringSplit($ToReturn, "|", 2)
ArrayRemoveDuplicates($splitedToReturn)
Return $splitedToReturn
EndFunc
Func GetDropSCommands($Mode, $sFilePath)
Local $ToReturn = ""
If $g_bRunState = False Then Return
Local $rownum = 0
If FileExists($sFilePath) Then
Local $f, $line, $acommand, $command
$f = FileOpen($sFilePath, 0)
While 1
$line = FileReadLine($f)
$rownum += 1
If @error = -1 Then ExitLoop
$acommand = StringSplit($line, "|")
If $acommand[0] >= 8 Then
$command = StringStripWS(StringUpper($acommand[1]), 2)
If $command = "DROPS" Then
Local $TheDefense = StringStripWS(StringUpper($acommand[2]), 2)
Local $TheOptions = StringUpper($acommand[3])
If StringInStr($TheOptions, "L:T") > 0 Then
$ToReturn &= $TheDefense & "|"
EndIf
EndIf
EndIf
WEnd
FileClose($f)
EndIf
Return $ToReturn
EndFunc
Func IsObjLocatedDropS($Obj)
Switch $Obj
Case "EAGLE"
Return VerifyMMPOResult($storedEaglePos)
Case "INFERNO"
Return VerifyMMPOResult($storedInfernoPos)
Case "ADEFENSE"
Return VerifyMMPOResult($storedADefensePos)
Case Else
Return False
EndSwitch
EndFunc
Func GetStoredPositions($Defense)
Switch $Defense
Case "EAGLE"
Return $storedEaglePos
Case "INFERNO"
Return $storedInfernoPos
Case "ADEFENSE"
Return $storedADefensePos
EndSwitch
EndFunc
Func GetAndStorePositions($Defense)
Local $imgSearchResult = ""
Local $directory
Switch $Defense
Case "EAGLE"
$directory = @ScriptDir & "\imgxml\WeakBase\Eagle"
$imgSearchResult = returnAllMatchesDefense($directory)
$storedEaglePos = $imgSearchResult
Case "INFERNO"
$directory = @ScriptDir & "\imgxml\WeakBase\Infernos"
$imgSearchResult = returnAllMatchesDefense($directory)
$storedInfernoPos = $imgSearchResult
Case "ADEFENSE"
$directory = @ScriptDir & "\imgxml\WeakBase\ADefense"
$imgSearchResult = returnAllMatchesDefense($directory)
$storedADefensePos = $imgSearchResult
EndSwitch
EndFunc
Func ParseAttackCSV_Read_SIDE_variables($lineContent = "")
$attackcsv_locate_mine = 0
$attackcsv_locate_elixir = 0
$attackcsv_locate_drill = 0
$attackcsv_locate_gold_storage = 0
$attackcsv_locate_elixir_storage = 0
$attackcsv_locate_dark_storage = 0
$attackcsv_locate_townhall = 0
$attackcsv_locate_Eagle = 0
If $g_iMatchMode = $DB Then
Local $filename = $g_sAttackScrScriptName[$DB]
Else
Local $filename = $g_sAttackScrScriptName[$LB]
EndIf
Local $f, $line, $acommand, $command
Local $value1, $value2, $value3, $value4, $value5, $value6, $value7, $value8, $value9
Local $bForceSideExist = False
Select
Case $lineContent = ""
If FileExists($g_sCSVAttacksPath & "\" & $filename & ".csv") Then
$f = FileOpen($g_sCSVAttacksPath & "\" & $filename & ".csv", 0)
While 1
$line = FileReadLine($f)
If @error = -1 Then ExitLoop
$acommand = StringSplit($line, "|")
If $acommand[0] >= 8 Then
$command = StringStripWS(StringUpper($acommand[1]), $STR_STRIPTRAILING)
If $command <> "SIDE" And $command <> "SIDEB" Then ContinueLoop
For $i = 2 To(UBound($acommand) - 1)
If IsDeclared("value" &($i - 1)) Then Assign("value" &($i - 1), StringStripWS(StringUpper($acommand[$i]), $STR_STRIPTRAILING), 4)
Next
If $command = "SIDE" Then
If StringUpper($value8) = "TOP-LEFT" Or StringUpper($value8) = "TOP-RIGHT" Or StringUpper($value8) = "BOTTOM-LEFT" Or StringUpper($value8) = "BOTTOM-RIGHT" Then
$bForceSideExist = True
Else
If Int($value1) > 0 Then $attackcsv_locate_mine = 1
If Int($value2) > 0 Then $attackcsv_locate_elixir = 1
If Int($value3) > 0 Then $attackcsv_locate_drill = 1
If Int($value4) > 0 Then $attackcsv_locate_gold_storage = 1
If Int($value5) > 0 Then $attackcsv_locate_elixir_storage = 1
If Int($value6) > 0 Then $attackcsv_locate_dark_storage = 1
If Int($value7) > 0 Then $attackcsv_locate_townhall = 1
EndIf
EndIf
If $command = "SIDEB" And $bForceSideExist = False Then
If Int($value1) > 0 Then $attackcsv_locate_Eagle = 1
EndIf
EndIf
WEnd
FileClose($f)
Else
SetLog("Cannot find attack file " & $g_sCSVAttacksPath & "\" & $filename & ".csv", $COLOR_ERROR)
EndIf
Case Else
$line = $lineContent
$acommand = StringSplit($line, "|")
If $acommand[0] >= 8 Then
$command = StringStripWS(StringUpper($acommand[1]), $STR_STRIPTRAILING)
For $i = 2 To(UBound($acommand) - 1)
If IsDeclared("value" &($i - 1)) Then Assign("value" &($i - 1), StringStripWS(StringUpper($acommand[$i]), $STR_STRIPTRAILING), 4)
Next
If $command = "SIDE" Then
If StringUpper($value8) = "TOP-LEFT" Or StringUpper($value8) = "TOP-RIGHT" Or StringUpper($value8) = "BOTTOM-LEFT" Or StringUpper($value8) = "BOTTOM-RIGHT" Then
$bForceSideExist = True
Else
If Int($value1) > 0 Then $attackcsv_locate_mine = 1
If Int($value2) > 0 Then $attackcsv_locate_elixir = 1
If Int($value3) > 0 Then $attackcsv_locate_drill = 1
If Int($value4) > 0 Then $attackcsv_locate_gold_storage = 1
If Int($value5) > 0 Then $attackcsv_locate_elixir_storage = 1
If Int($value6) > 0 Then $attackcsv_locate_dark_storage = 1
If Int($value7) > 0 Then $attackcsv_locate_townhall = 1
EndIf
EndIf
If $command = "SIDEB" And $bForceSideExist = False Then
If Int($value1) > 0 Then $attackcsv_locate_Eagle = 1
EndIf
EndIf
EndSelect
EndFunc
Func Click($x, $y, $times = 1, $speed = 0, $debugtxt = "")
If $g_ichkUseAltRClick = 1 Then
Local $xclick = Random($x - 5, $x, 1)
Local $yclick = Random($y, $y + 5, 1)
If $xclick <= 0 Or $xclick >= 860 Then $xclick = $x
If $yclick <= 0 Or $yclick >= 680 +($g_ibottomOffsetY) Then $yclick = $y
FClick($xclick, $yclick, $times, $speed, $debugtxt)
Else
FClick($x, $y, $times, $speed, $debugtxt)
EndIf
EndFunc
Func PureClick($x, $y, $times = 1, $speed = 0, $debugtxt = "")
If $g_ichkUseAltRClick = 1 Then
Local $xclick = Random($x - 5, $x, 1)
Local $yclick = Random($y, $y + 5, 1)
If $xclick <= 0 Or $xclick >= 860 Then $xclick = $x
If $yclick <= 0 Or $yclick >= 680 +($g_ibottomOffsetY) Then $yclick = $y
FPureClick($xclick, $yclick, $times, $speed, $debugtxt)
Else
FPureClick($x, $y, $times, $speed, $debugtxt)
EndIf
EndFunc
Func GemClick($x, $y, $times = 1, $speed = 0, $debugtxt = "")
If $g_ichkUseAltRClick = 1 Then
Local $xclick = Random($x - 5, $x, 1)
Local $yclick = Random($y, $y + 5, 1)
If $xclick <= 0 Or $xclick >= 860 Then $xclick = $x
If $yclick <= 0 Or $yclick >= 680 +($g_iBottomOffsetY) Then $yclick = $y
FGemClick($xclick, $yclick, $times, $speed, $debugtxt)
Else
FGemClick($x, $y, $times, $speed, $debugtxt)
EndIf
EndFunc
Func randomSleep($SleepTime, $Range = 0)
If $g_bRunState = False Then Return
If $Range = 0 Then $Range = Round($SleepTime / 5)
Local $SleepTimeF = Random($SleepTime - $Range, $SleepTime + $Range, 1)
If $g_iDebugClick = 1 Then Setlog("Default sleep : " & $SleepTime & " - Random sleep : " & $SleepTimeF, $COLOR_ORANGE)
If _Sleep($SleepTimeF) Then Return
EndFunc
Func QuickMIS($ValueReturned, $directory, $Left = 0, $Top = 0, $Right = $g_iGAME_WIDTH, $Bottom = $g_iGAME_HEIGHT, $Debug = False)
If($ValueReturned <> "BC1") And($ValueReturned <> "CX") And($ValueReturned <> "N1") And($ValueReturned <> "NX") And($ValueReturned <> "Q1") And($ValueReturned <> "QX") Then
SetLog("Error of parameters settings during QuickMIS call for MultiSearch...", $COLOR_RED)
Return
EndIf
Sleep(1500)
_CaptureRegion2($Left, $Top, $Right, $Bottom)
Local $Res = DllCall($g_sLibImgLocPath, "str", "SearchMultipleTilesBetweenLevels", "handle", $hHBitmap2, "str", $directory, "str", "FV", "Int", 0, "str", "FV", "Int", 0, "Int", 1000)
If IsArray($Res) Then
If $Debug Then _ArrayDisplay($Res)
If $g_iDebugSetlog = 1 Then SetLog("DLL Call succeeded " & $Res[0], $COLOR_PURPLE)
If $Res[0] = "" Or $Res[0] = "0" Then
If $g_iDebugSetlog Then SetLog("No Button found")
Switch $ValueReturned
Case "BC1"
Return False
Case "CX"
Return "-1"
Case "N1"
Return "none"
Case "NX"
Return "none"
Case "Q1"
Return 0
Case "QX"
Return 0
EndSwitch
ElseIf StringInStr($Res[0], "-1") <> 0 Then
SetLog("DLL Error", $COLOR_RED)
Else
Switch $ValueReturned
Case "BC1"
Local $Result = "", $DLLRes = Null
Local $KeyValue = StringSplit($Res[0], "|", $STR_NOCOUNT)
For $i = 0 To UBound($KeyValue) - 1
$DLLRes = DllCall($g_sLibImgLocPath, "str", "GetProperty", "str", $KeyValue[$i], "str", "objectpoints")
$Result &= $DLLRes[0] & "|"
Next
If StringRight($Result, 1) = "|" Then $Result = StringLeft($Result,(StringLen($Result) - 1))
Local $CoordsInArray = StringSplit($Result, ",", $STR_NOCOUNT)
$g_iQuickMISX = $CoordsInArray[0]
$g_iQuickMISY = $CoordsInArray[1]
Return True
Case "CX"
Local $Result = "", $DLLRes = Null
Local $KeyValue = StringSplit($Res[0], "|", $STR_NOCOUNT)
For $i = 0 To UBound($KeyValue) - 1
$DLLRes = DllCall($g_sLibImgLocPath, "str", "GetProperty", "str", $KeyValue[$i], "str", "objectpoints")
$Result &= $DLLRes[0] & "|"
Next
If StringRight($Result, 1) = "|" Then $Result = StringLeft($Result,(StringLen($Result) - 1))
$CoordsInArray = StringSplit($Result, "|", $STR_NOCOUNT)
Return $CoordsInArray
Case "N1"
Local $MultiImageSearchResult = StringSplit($Res[0], "|")
Local $FilenameFound = StringSplit($MultiImageSearchResult[1], "_")
Return $FilenameFound[1]
Case "NX"
Local $AllFilenamesFound = "", $FilenameFound = Null
Local $MultiImageSearchResult = StringSplit($Res[0], "|")
For $i = 1 To $MultiImageSearchResult[0]
$FilenameFound = StringSplit($MultiImageSearchResult[$i], "_")
$AllFilenamesFound &= $FilenameFound[1] & "|"
Next
If StringRight($AllFilenamesFound, 1) = "|" Then $AllFilenamesFound = StringLeft($AllFilenamesFound,(StringLen($AllFilenamesFound) - 1))
Return $AllFilenamesFound
Case "Q1"
Local $Result = "", $DLLRes = Null
Local $KeyValue = StringSplit($Res[0], "|", $STR_NOCOUNT)
For $i = 0 To UBound($KeyValue) - 1
$DLLRes = DllCall($g_sLibImgLocPath, "str", "GetProperty", "str", $KeyValue[$i], "str", "totalobjects")
$Result &= $DLLRes[0] & "|"
Next
If StringRight($Result, 1) = "|" Then $Result = StringLeft($Result,(StringLen($Result) - 1))
Local $QuantityInArray = StringSplit($Result, "|", $STR_NOCOUNT)
Return $QuantityInArray[0]
Case "QX"
Local $MultiImageSearchResult = StringSplit($Res[0], "|", $STR_NOCOUNT)
Return UBound($MultiImageSearchResult)
EndSwitch
EndIf
EndIf
EndFunc
Func BotHumanization()
If $g_ichkUseBotHumanization = 1 Then
Local $NoActionsToDo = 0
SetLog("Now, let the DocOc Team make your BOT more human ... :)", $COLOR_SUCCESS1)
If $g_ichkLookAtRedNotifications = 1 Then LookAtRedNotifications()
If $g_ichkCollectAchievements = 1 Then CollectAchievements()
ReturnAtHome()
For $i = 0 To 12
Local $ActionEnabled = _GUICtrlComboBox_GetCurSel($g_acmbPriority[$i])
If $ActionEnabled = 0 Then $NoActionsToDo += 1
Next
If $NoActionsToDo <> 13 Then
$g_iMaxActionsNumber = Random(1, _GUICtrlComboBox_GetCurSel($cmbMaxActionsNumber) + 1, 1)
SetLog("DocOc will do " & $g_iMaxActionsNumber & " human actions during this loop...", $COLOR_INFO)
For $i = 1 To $g_iMaxActionsNumber
randomSleep(4000)
ReturnAtHome()
RandomHumanAction()
Next
Else
SetLog("All actions disabled, skipping...", $COLOR_WARNING)
EndIf
SetLog("Bot Humanization finished !!! :)", $COLOR_SUCCESS1)
EndIf
EndFunc
Func RandomHumanAction()
For $i = 0 To 12
SetActionPriority($i)
Next
$g_iActionToDo = _ArrayMaxIndex($g_aSetActionPriority)
Switch $g_iActionToDo
Case 0
SetLog("The spirit of DocOc chose to read Clan Chat... Let's go !!! :)", $COLOR_INFO)
ReadClanChat()
Case 1
SetLog("The spirit of DocOc chose to read Global Chat... Let's go !!! :)", $COLOR_INFO)
ReadGlobalChat()
Case 2
SetLog("The spirit of DocOc chose to talk with your Clan... Let's go !!! :)", $COLOR_INFO)
SaySomeChat()
Case 3
SetLog("The spirit of DocOc chose to Watch a Defense... Let's go !!! :)", $COLOR_INFO)
WatchDefense()
Case 4
SetLog("The spirit of DocOc chose to Watch an Attack... Let's go !!! :)", $COLOR_INFO)
WatchAttack()
Case 5
SetLog("The spirit of DocOc chose to Look at War Log... Let's go !!! :)", $COLOR_INFO)
LookAtWarLog()
Case 6
SetLog("The spirit of DocOc chose to Visit Clanmates... Let's go !!! :)", $COLOR_INFO)
VisitClanmates()
Case 7
SetLog("The spirit of DocOc chose to Visit Best Players... Let's go !!! :)", $COLOR_INFO)
VisitBestPlayers()
Case 8
SetLog("The spirit of DocOc chose to Look at Best Clans... Let's go !!! :)", $COLOR_INFO)
LookAtBestClans()
Case 9
SetLog("The spirit of DocOc chose to Look at Current War... Let's go !!! :)", $COLOR_INFO)
LookAtCurrentWar()
Case 10
SetLog("The spirit of DocOc chose to Watch War replays... Let's go !!! :)", $COLOR_INFO)
WatchWarReplays()
Case 11
SetLog("The spirit of DocOc chose to do nothing... Stupid BOT... :)", $COLOR_INFO)
DoNothing()
Case 12
SetLog("The spirit of DocOc chose to launch Challenges... Let's go !!! :)", $COLOR_INFO)
LaunchChallenges()
EndSwitch
EndFunc
Func SetActionPriority($ActionNumber)
If _GUICtrlComboBox_GetCurSel($g_acmbPriority[$ActionNumber]) <> 0 Then
MatchPriorityNValue($ActionNumber)
$g_aSetActionPriority[$ActionNumber] = Random($g_iMinimumPriority, 100, 1)
Else
$g_aSetActionPriority[$ActionNumber] = 0
EndIf
EndFunc
Func MatchPriorityNValue($ActionNumber)
Switch _GUICtrlComboBox_GetCurSel($g_acmbPriority[$ActionNumber])
Case 1
$g_iMinimumPriority = 0
Case 2
$g_iMinimumPriority = 25
Case 3
$g_iMinimumPriority = 50
Case 4
$g_iMinimumPriority = 75
EndSwitch
EndFunc
Func chkUseBotHumanization()
If GUICtrlRead($chkUseBotHumanization) = $GUI_CHECKED Then
$g_ichkUseBotHumanization = 1
For $i = $Icon1 To $chkLookAtRedNotifications
GUICtrlSetState($i, $GUI_ENABLE)
Next
cmbStandardReplay()
cmbWarReplay()
Else
$g_ichkUseBotHumanization = 0
For $i = $Icon1 To $chkLookAtRedNotifications
GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
EndFunc
Func chkUseAltRClick()
If GUICtrlRead($chkUseAltRClick) = $GUI_CHECKED Then
Local $UserChoice = MsgBox(4 + 48, "Warning !!!", "Full random click is a good feature to be as less BOT-Like as possible because it makes ALL BOT clicks random..." & @CRLF & "" & @CRLF & "The crazy @RoroTiti use it all the time an he says there is no problem with it... BUT, it still an experimental feature which may cause unpredictable problems..." & @CRLF & "" & @CRLF & "So, do you want to use it ? :)" & @CRLF & "" & @CRLF & "PS : No support will be provided to you if you use this function...")
If $UserChoice = 6 Then
$g_ichkUseAltRClick = 1
Else
$g_ichkUseAltRClick = 0
GUICtrlSetState($chkUseAltRClick, $GUI_UNCHECKED)
EndIf
Else
$g_ichkUseAltRClick = 0
EndIf
EndFunc
Func chkCollectAchievements()
If GUICtrlRead($chkCollectAchievements) = $GUI_CHECKED Then
$g_ichkCollectAchievements = 1
Else
$g_ichkCollectAchievements = 0
EndIf
EndFunc
Func chkLookAtRedNotifications()
If GUICtrlRead($chkLookAtRedNotifications) = $GUI_CHECKED Then
$g_ichkLookAtRedNotifications = 1
Else
$g_ichkLookAtRedNotifications = 0
EndIf
EndFunc
Func cmbStandardReplay()
If _GUICtrlComboBox_GetCurSel($g_acmbPriority[3]) = 0 Then
If _GUICtrlComboBox_GetCurSel($g_acmbPriority[4]) = 0 Then
For $i = $Label7 To $g_acmbPause[0]
GUICtrlSetState($i, $GUI_DISABLE)
Next
Else
For $i = $Label7 To $g_acmbPause[0]
GUICtrlSetState($i, $GUI_ENABLE)
Next
EndIf
ElseIf _GUICtrlComboBox_GetCurSel($g_acmbPriority[4]) = 0 Then
If _GUICtrlComboBox_GetCurSel($g_acmbPriority[3]) = 0 Then
For $i = $Label7 To $g_acmbPause[0]
GUICtrlSetState($i, $GUI_DISABLE)
Next
Else
For $i = $Label7 To $g_acmbPause[0]
GUICtrlSetState($i, $GUI_ENABLE)
Next
EndIf
EndIf
EndFunc
Func cmbWarReplay()
If _GUICtrlComboBox_GetCurSel($g_acmbPriority[10]) = 0 Then
For $i = $Label13 To $g_acmbPause[1]
GUICtrlSetState($i, $GUI_DISABLE)
Next
Else
For $i = $Label13 To $g_acmbPause[1]
GUICtrlSetState($i, $GUI_ENABLE)
Next
EndIf
EndFunc
Func WaitForReplayWindow()
SetLog("Waiting for Replay screen...", $COLOR_ACTION)
Local $CheckStep = 0
While Not IsReplayWindow() And $CheckStep < 30
Sleep(1000)
$CheckStep += 1
WEnd
Return $g_bOnReplayWindow
EndFunc
Func IsReplayWindow()
$g_bOnReplayWindow = _ColorCheck(_GetPixelColor(799, 619, True), "FF5151", 20)
Return $g_bOnReplayWindow
EndFunc
Func GetReplayDuration()
Local $MaxSpeed = _GUICtrlComboBox_GetCurSel($g_acmbMaxSpeed[$g_iReplayToPause])
Local $Result = QuickMIS("N1", @ScriptDir & "\imgxml\Resources\Humanization Pics\Duration", 380, 600, 490, 630)
If $Result = "OneMinute" Then
$g_aReplayDuration[0] = 1
$g_aReplayDuration[1] = 90000
ElseIf $Result = "TwoMinutes" Then
$g_aReplayDuration[0] = 2
$g_aReplayDuration[1] = 150000
ElseIf $Result = "ThreeMinutes" Then
$g_aReplayDuration[0] = 3
$g_aReplayDuration[1] = 180000
Else
$g_aReplayDuration[0] = 0
$g_aReplayDuration[1] = 45000
EndIf
Switch $MaxSpeed
Case 1
$g_aReplayDuration[1] /= 2
Case 2
$g_aReplayDuration[1] /= 4
EndSwitch
SetLog("Estimated Replay Duration : " & $g_aReplayDuration[1] / 1000 & " second(s)", $COLOR_INFO)
EndFunc
Func AccelerateReplay($g_iReplayToPause)
Local $CurrentSpeed = 0
Local $MaxSpeed = _GUICtrlComboBox_GetCurSel($g_acmbMaxSpeed[$g_iReplayToPause])
If $CurrentSpeed <> $MaxSpeed Then SetLog("Let's make the replay faster...", $COLOR_ACTION1)
While $CurrentSpeed < $MaxSpeed
Click(820, 690)
randomSleep(500)
$CurrentSpeed += 1
WEnd
EndFunc
Func DoAPauseDuringReplay($g_iReplayToPause)
Local $MinimumToPause = 0, $PauseScore = 0
Local $Pause = _GUICtrlComboBox_GetCurSel($g_acmbPause[0])
If $Pause <> 0 Then
Switch $Pause
Case 1
$MinimumToPause = 80
Case 2
$MinimumToPause = 60
Case 3
$MinimumToPause = 40
Case 4
$MinimumToPause = 20
EndSwitch
$PauseScore = Random(0, 100, 1)
If $PauseScore > $MinimumToPause Then
SetLog("Let's do a small pause to see what happens...", $COLOR_ACTION1)
Click(750, 690)
randomSleep(10000, 3000)
SetLog("Pause finished, let's relaunch replay !!!", $COLOR_ACTION1)
Click(750, 690)
EndIf
EndIf
EndFunc
Func VisitAPlayer()
SetLog("Let's visit player...", $COLOR_INFO)
If QuickMIS("BC1", @ScriptDir & "\imgxml\Resources\Humanization Pics\Visit") Then
Click($g_iQuickMISX, $g_iQuickMISY)
randomSleep(8000)
For $i = 0 To Random(1, 4, 1)
SetLog("We will click on a random builing...", $COLOR_ACTION1)
Local $xInfo = Random(300, 500, 1)
Local $yInfo = Random(300, 432, 1)
Click($xInfo, $yInfo)
randomSleep(1500)
SetLog("... and open his Info window...", $COLOR_ACTION1)
Click(430, 660)
randomSleep(8000)
Click(685, 175)
randomSleep(3000)
Next
Else
SetLog("Error when trying to find Visit button... skipping...", $COLOR_WARNING)
EndIf
EndFunc
Func DoNothing()
SetLog("Let the BOT wait a little before continue...", $COLOR_ACTION1)
randomSleep(8000, 3000)
EndFunc
Func LookAtRedNotifications()
SetLog("Looking for notifications...", $COLOR_INFO)
Local $NoNotif = 0
ReturnAtHome()
If _ColorCheck(_GetPixelColor(55, 142, True), "D00818", 20) Then
SetLog("You have a new message...", $COLOR_ACTION1)
Click(40, 150)
randomSleep(8000, 3000)
Click(760, 120)
randomSleep(2000)
Else
$NoNotif += 1
EndIf
ReturnAtHome()
If _ColorCheck(_GetPixelColor(54, 83, True), "D00818", 20) Then
SetLog("You changed of league...", $COLOR_ACTION1)
Click(40, 80)
randomSleep(4000)
Click(445, 610)
randomSleep(1500)
Click(830, 80)
randomSleep(2000)
Else
$NoNotif += 1
EndIf
ReturnAtHome()
If _ColorCheck(_GetPixelColor(56, 511, True), "D00818", 20) Then
SetLog("Current War to look at...", $COLOR_ACTION1)
Click(40, 520)
randomSleep(8000, 3000)
Click(70, 680)
randomSleep(2000)
Else
$NoNotif += 1
EndIf
ReturnAtHome()
If _ColorCheck(_GetPixelColor(28, 353, True), "D00818", 20) Then
SetLog("New messages on the chat room...", $COLOR_ACTION1)
Click(20, 380)
randomSleep(3000)
Click(330, 380)
randomSleep(2000)
Else
$NoNotif += 1
EndIf
ReturnAtHome()
If _ColorCheck(_GetPixelColor(834, 512, True), "D00818", 20) Then
SetLog("New messages or events from SC to read...", $COLOR_ACTION1)
Click(820, 520)
randomSleep(3000)
If _ColorCheck(_GetPixelColor(245, 110, True), "F0F4F0", 20) Then
Click(435, 110)
randomSleep(3000)
Else
Click(245, 110)
randomSleep(3000)
EndIf
Click(760, 120)
randomSleep(2000)
Else
$NoNotif += 1
EndIf
ReturnAtHome()
If _ColorCheck(_GetPixelColor(832, 638, True), "683072", 20) Or _ColorCheck(_GetPixelColor(832, 637, True), "D00818", 20) Then
SetLog("There is something new on the shop...", $COLOR_ACTION1)
Click(800, 670)
randomSleep(2000)
Local $NeedScroll = Random(0, 1, 1)
Local $NeedScroll2 = Random(0, 1, 1)
If $NeedScroll = 1 Then
Local $xStart = Random(300, 800, 1)
Local $xEnd = Random($xStart - 250, $xStart - 220, 1)
Local $y = Random(360 - 10, 360 + 10, 1)
ClickDrag($xStart, $y, $xEnd, $y)
If $NeedScroll2 = 1 Then
randomSleep(2000)
$xEnd = Random(300, 800, 1)
$xStart = Random($xEnd - 250, $xEnd - 220, 1)
$y = Random(360 - 10, 360 + 10, 1)
ClickDrag($xStart, $y, $xEnd, $y)
EndIf
EndIf
randomSleep(2000)
Click(820, 40)
randomSleep(2000)
Else
$NoNotif += 1
EndIf
ReturnAtHome()
If _ColorCheck(_GetPixelColor(53, 24, True), "D00818", 20) Then
SetLog("Maybe you have a new friend request, lemme check...", $COLOR_ACTION1)
Click(40, 40)
randomSleep(2000)
If IsClanOverview() Then
If _ColorCheck(_GetPixelColor(772, 70, True), "D00818", 20) Then
SetLog("It's confirmed, you have a new friend request, lemme check...", $COLOR_ACTION1)
Click(700, 80)
randomSleep(2000)
If QuickMIS("BC1", @ScriptDir & "\imgxml\Resources\Humanization Pics\Friend", 720, 165, 780, 600) Then
Click($g_iQuickMISX + 720, $g_iQuickMISY + 165)
randomSleep(1500)
If QuickMIS("BC1", @ScriptDir & "\imgxml\Resources\Humanization Pics\Friend", 440, 380, 590, 470) Then
Click($g_iQuickMISX + 440, $g_iQuickMISY + 380)
Else
SetLog("Error when trying to find Okay button... skipping...", $COLOR_WARNING)
EndIf
Else
SetLog("Error when trying to find friend request... skipping...", $COLOR_WARNING)
EndIf
Else
SetLog("No friend request found... skipping...", $COLOR_WARNING)
EndIf
Else
SetLog("Error when trying to open Social tab... skipping...", $COLOR_WARNING)
EndIf
randomSleep(2000)
Else
$NoNotif += 1
EndIf
If $NoNotif = 7 Then SetLog("No notification found, nothing to look at...", $COLOR_ACTION1)
EndFunc
Func CollectAchievements()
SetLog("Looking for achievement to collect...", $COLOR_INFO)
ReturnAtHome()
If _ColorCheck(_GetPixelColor(53, 24, True), "D00818", 20) Then
SetLog("WoW, maybe an achievement to collect !!!", $COLOR_ACTION1)
Click(40, 40)
randomSleep(4000)
If IsClanOverview() Then
If QuickMIS("BC1", @ScriptDir & "\imgxml\Resources\Humanization Pics\ClaimReward", 680) Then
Click($g_iQuickMISX + 680, $g_iQuickMISY)
SetLog("Reward collected !!! Good Job Chief :D !!!", $COLOR_SUCCESS)
randomSleep(3000)
Else
SetLog('No "Claim Reward" button found... Lemme retry...', $COLOR_ERROR)
If QuickMIS("BC1", @ScriptDir & "\imgxml\Resources\Humanization Pics\ClaimReward", 680) Then
Click($g_iQuickMISX + 680, $g_iQuickMISY)
SetLog("Reward collected !!! Good Job Chief :D !!!", $COLOR_SUCCESS)
randomSleep(3000)
Else
SetLog('No "Claim Reward" button found... skipping...', $COLOR_ERROR)
EndIf
EndIf
Else
SetLog("Error when trying to open Profile tab... skipping...", $COLOR_WARNING)
EndIf
Else
SetLog("No achievement to collect...", $COLOR_ACTION1)
EndIf
EndFunc
Func Scroll($MaxScroll)
For $i = 0 To $MaxScroll
Local $x = Random(430 - 20, 430 + 20, 1)
Local $yStart = Random(600 - 20, 600 + 20, 1)
Local $yEnd = Random(200 - 20, 200 + 20, 1)
ClickDrag($x, $yStart, $x, $yEnd)
randomSleep(4000)
Next
EndFunc
Func SecureMessage($TextToClean)
Return StringRegExpReplace($TextToClean, "[^\w \-\,\?\!\:]", "")
EndFunc
Func ReturnAtHome()
Local $CheckStep = 0
While Not IsMainScreen() And $CheckStep <= 5
AndroidBackButton()
Sleep(3000)
$CheckStep += 1
WEnd
If Not IsMainScreen() Then
SetLog("Main screen not found, need to restart CoC app...", $COLOR_ERROR)
RestartAndroidCoC()
waitMainScreen()
EndIf
EndFunc
Func IsMainScreen()
Local $Result = _ColorCheck(_GetPixelColor(22, 49, True), "04579A", 20)
Return $Result
EndFunc
Func IsMessagesReplayWindow()
Local $Result = _ColorCheck(_GetPixelColor(760, 112, True), "FFFFFF", 20)
Return $Result
EndFunc
Func IsDefensesTab()
Local $Result = _ColorCheck(_GetPixelColor(180, 110, True), "F0F4F0", 20)
Return $Result
EndFunc
Func IsAttacksTab()
Local $Result = _ColorCheck(_GetPixelColor(380, 110, True), "F0F4F0", 20)
Return $Result
EndFunc
Func IsBestPlayers()
Local $Result = _ColorCheck(_GetPixelColor(530, 60, True), "F0F4F0", 20)
Return $Result
EndFunc
Func IsBestClans()
Local $Result = _ColorCheck(_GetPixelColor(350, 60, True), "F0F4F0", 20)
Return $Result
EndFunc
Func ChatOpen()
Local $Result = _ColorCheck(_GetPixelColor(330, 382, True), "FFFFFF", 20)
Return $Result
EndFunc
Func IsClanChat()
Local $Result = _ColorCheck(_GetPixelColor(220, 10, True), "787458", 20)
Return $Result
EndFunc
Func IsGlobalChat()
Local $Result = _ColorCheck(_GetPixelColor(80, 10, True), "787458", 20)
Return $Result
EndFunc
Func IsTextBox()
Local $Result = _ColorCheck(_GetPixelColor(190, 710, True), "FFFFFF", 20)
Return $Result
EndFunc
Func IsChallengeWindow()
Local $Result = _ColorCheck(_GetPixelColor(698, 56, True), "FFFFFF", 20)
Return $Result
EndFunc
Func IsChangeLayoutMenu()
Local $Result = _ColorCheck(_GetPixelColor(184, 58, True), "FFFFFF", 20)
Return $Result
EndFunc
Func IsClanOverview()
Local $Result = _ColorCheck(_GetPixelColor(822, 70, True), "FFFFFF", 20)
Return $Result
EndFunc
Func IsWarMenu()
Local $Result = _ColorCheck(_GetPixelColor(826, 34, True), "FFFFFF", 20)
Return $Result
EndFunc
Func WatchDefense()
Click(40, 150)
randomSleep(1500)
If IsMessagesReplayWindow() Then
Click(190, 130)
randomSleep(1500)
If IsDefensesTab() Then
Click(710,(230 + 145 * Random(0, 2, 1)))
WaitForReplayWindow()
If IsReplayWindow() Then
GetReplayDuration()
randomSleep(1000)
If IsReplayWindow() Then
AccelerateReplay(0)
EndIf
randomSleep($g_aReplayDuration[1] / 3)
Local $IsBoring = Random(1, 5, 1)
If $IsBoring >= 4 Then
If IsReplayWindow() Then
SetLog("This replay is boring, let me go out... ;)", $COLOR_ACTION1)
Click(70, 680)
EndIf
Else
If IsReplayWindow() Then
DoAPauseDuringReplay(0)
EndIf
randomSleep($g_aReplayDuration[1] / 3)
If IsReplayWindow() And $g_aReplayDuration[0] <> 0 Then
DoAPauseDuringReplay(0)
EndIf
If IsReplayWindow() Then Setlog("Waiting for replay end...", $COLOR_ACTION)
While IsReplayWindow()
Sleep(2000)
WEnd
randomSleep(1000)
Click(70, 680)
EndIf
EndIf
Else
SetLog("Error when trying to open Defenses menu... skipping...", $COLOR_WARNING)
EndIf
Else
SetLog("Error when trying to open Replays menu... skipping...", $COLOR_WARNING)
EndIf
EndFunc
Func WatchAttack()
Click(40, 150)
randomSleep(1500)
If IsMessagesReplayWindow() Then
Click(380, 130)
randomSleep(1500)
If IsAttacksTab() Then
Click(710,(230 + 145 * Random(0, 2, 1)))
WaitForReplayWindow()
If IsReplayWindow() Then
GetReplayDuration()
randomSleep(1000)
If IsReplayWindow() Then
AccelerateReplay(0)
EndIf
randomSleep($g_aReplayDuration[1] / 3)
Local $IsBoring = Random(1, 5, 1)
If $IsBoring >= 4 Then
If IsReplayWindow() Then
SetLog("This replay is boring, let me go out... ;)", $COLOR_ACTION1)
randomSleep(1000)
Click(70, 680)
EndIf
Else
If IsReplayWindow() Then
DoAPauseDuringReplay(0)
EndIf
randomSleep($g_aReplayDuration[1] / 3)
If IsReplayWindow() And $g_aReplayDuration[0] <> 0 Then
DoAPauseDuringReplay(0)
EndIf
If IsReplayWindow() Then Setlog("Waiting for replay end...", $COLOR_ACTION)
While IsReplayWindow()
Sleep(2000)
WEnd
randomSleep(1000)
Click(70, 680)
EndIf
EndIf
Else
SetLog("Error when trying to open Defenses menu... skipping...", $COLOR_WARNING)
EndIf
Else
SetLog("Error when trying to open Replays menu... skipping...", $COLOR_WARNING)
EndIf
EndFunc
Func VisitBestPlayers()
Click(40, 80)
randomSleep(1500)
If IsClanOverview() Then
Click(540, 80)
randomSleep(3000)
If IsBestPlayers() Then
Local $PlayerList = Random(1, 2, 1)
Switch $PlayerList
Case 1
Click(270, 140)
Click(580, 350 + 52 * Random(0, 6, 1))
randomSleep(500)
VisitAPlayer()
Click(70, 680)
Case 2
Click(640, 140)
Click(580, 190 + 52 * Random(0, 9, 1))
randomSleep(500)
VisitAPlayer()
Click(70, 680)
EndSwitch
Else
SetLog("Error when trying to open Best Players menu... skipping...", $COLOR_WARNING)
EndIf
Else
SetLog("Error when trying to open League menu... skipping...", $COLOR_WARNING)
EndIf
EndFunc
Func LookAtBestClans()
Click(40, 80)
randomSleep(1500)
If IsClanOverview() Then
Click(360, 80)
randomSleep(3000)
If IsBestClans() Then
Local $PlayerList = Random(1, 2, 1)
Switch $PlayerList
Case 1
Click(270, 140)
Click(580, 330 + 52 * Random(0, 6, 1))
Case 2
Click(640, 140)
Click(580, 190 + 52 * Random(0, 9, 1))
EndSwitch
randomSleep(1500)
If QuickMIS("BC1", @ScriptDir & "\imgxml\Resources\Humanization Pics\WarLog") Then
SetLog("We have found a War log button, let's look at it...", $COLOR_ACTION1)
Click(100, 340)
randomSleep(1500)
SetLog("Let's scrolling the War log...", $COLOR_ACTION1)
Scroll(Random(0, 2, 1))
SetLog("Exiting War log window...", $COLOR_ACTION1)
Click(50, 80)
EndIf
randomSleep(1500)
SetLog("Let's scrolling the Clan member list...", $COLOR_ACTION1)
Scroll(Random(3, 5, 1))
Click(830, 80)
Else
SetLog("Error when trying to open Best Players menu... skipping...", $COLOR_WARNING)
EndIf
Else
SetLog("Error when trying to open League menu... skipping...", $COLOR_WARNING)
EndIf
EndFunc
Func ReadClanChat()
Click(20, 380)
randomSleep(3000)
If ChatOpen() Then
Click(230, 20)
randomSleep(1500)
If Not IsClanChat() Then SetLog("Warning, we will scroll Global chat...", $COLOR_WARNING)
Local $MaxScroll = Random(0, 3, 1)
SetLog("Let's scrolling the Chat...", $COLOR_ACTION1)
For $i = 0 To $MaxScroll
Local $x = Random(280 - 10, 280 + 10, 1)
Local $yStart = Random(110 - 10, 110 + 10, 1)
Local $yEnd = Random(660 - 10, 660 + 10, 1)
ClickDrag($x, $yStart, $x, $yEnd)
randomSleep(10000, 3000)
Next
Click(330, 380)
Else
SetLog("Error when trying to open Chat... skipping...", $COLOR_WARNING)
EndIf
EndFunc
Func ReadGlobalChat()
Click(20, 380)
randomSleep(3000)
If ChatOpen() Then
Click(80, 20)
randomSleep(1500)
If Not IsGlobalChat() Then SetLog("Warning, we will scroll Clan chat...", $COLOR_WARNING)
Local $MaxScroll = Random(0, 3, 1)
SetLog("Let's scrolling the Chat...", $COLOR_ACTION1)
For $i = 0 To $MaxScroll
Local $x = Random(280 - 10, 280 + 10, 1)
Local $yStart = Random(110 - 10, 110 + 10, 1)
Local $yEnd = Random(660 - 10, 660 + 10, 1)
ClickDrag($x, $yStart, $x, $yEnd)
randomSleep(10000, 3000)
Next
Click(330, 380)
Else
SetLog("Error when trying to open Chat... skipping...", $COLOR_WARNING)
EndIf
EndFunc
Func SaySomeChat()
Click(20, 380)
randomSleep(3000)
If ChatOpen() Then
Click(230, 20)
randomSleep(1500)
If Not IsClanChat() Then SetLog("Warning, we will chat on Global chat...", $COLOR_WARNING)
Click(280, 710)
randomSleep(2000)
If IsTextBox() Then
Local $ChatToSay = Random(0, 1, 1)
Local $CleanMessage = SecureMessage(GUICtrlRead($g_ahumanMessage[$ChatToSay]))
SetLog("Writing """ & $CleanMessage & """ to the chat box...", $COLOR_ACTION1)
SendText($CleanMessage)
randomSleep(500)
Click(830, 710)
randomSleep(1500)
Click(330, 380)
Else
SetLog("Error when trying to open Text Box for chatting... skipping...", $COLOR_WARNING)
EndIf
Else
SetLog("Error when trying to open Chat... skipping...", $COLOR_WARNING)
EndIf
EndFunc
Func LaunchChallenges()
Click(20, 380)
randomSleep(3000)
If ChatOpen() Then
Click(230, 20)
randomSleep(1500)
If IsClanChat() Then
Click(260, 60)
randomSleep(1500)
If IsChallengeWindow() Then
Click(530, 110)
SendText(SecureMessage(GUICtrlRead($challengeMessage)))
randomSleep(1500)
Local $Layout = Random(1, 2, 1)
If $Layout <> $g_iLastLayout Then
Click(240, 250)
randomSleep(1000)
If IsChangeLayoutMenu() Then
Switch $Layout
Case 1
$g_iLastLayout = 1
Local $y = Random(190 - 10, 190 + 10, 1)
Local $xStart = Random(170 - 10, 170 + 10, 1)
Local $xEnd = Random(830 - 10, 830 + 10, 1)
ClickDrag($xStart, $y, $xEnd, $y)
Case 2
$g_iLastLayout = 2
Local $y = Random(190 - 10, 190 + 10, 1)
Local $xStart = Random(690 - 10, 690 + 10, 1)
Local $xEnd = Random(20 - 10, 20 + 10, 1)
ClickDrag($xStart, $y, $xEnd, $y)
EndSwitch
randomSleep(2000)
Click(240, 180)
randomSleep(1500)
Click(180, 60)
Else
SetLog("Error when trying to open Change Layout menu... skipping...", $COLOR_WARNING)
EndIf
EndIf
If IsChallengeWindow() Then
randomSleep(1500)
Click(530, 250)
randomSleep(1500)
Click(330, 380)
Else
SetLog("We are not anymore on Start Challenge window... skipping...", $COLOR_WARNING)
EndIf
Else
SetLog("Error when trying to open Start Challenge window... skipping...", $COLOR_WARNING)
EndIf
Else
SetLog("Error when trying to open Clan Chat... skipping...", $COLOR_WARNING)
EndIf
Else
SetLog("Error when trying to open Chat... skipping...", $COLOR_WARNING)
EndIf
EndFunc
Func LookAtWarLog()
Click(20, 380)
randomSleep(3000)
If ChatOpen() Then
Click(230, 20)
randomSleep(1500)
If IsClanChat() Then
Click(120, 60)
randomSleep(1500)
If IsClanOverview() Then
If QuickMIS("BC1", @ScriptDir & "\imgxml\Resources\Humanization Pics\WarLog", 20, 320, 70, 360) Then
Click(100, 340)
randomSleep(1500)
SetLog("Let's scrolling the War log...", $COLOR_ACTION1)
Scroll(Random(1, 3, 1))
Else
SetLog("No War log button found... skipping...", $COLOR_WARNING)
EndIf
Click(830, 180)
randomSleep(1000)
Click(330, 380)
Else
SetLog("Error when trying to open Clan overview... skipping...", $COLOR_WARNING)
EndIf
Else
SetLog("Error when trying to open Clan Chat... skipping...", $COLOR_WARNING)
EndIf
Else
SetLog("Error when trying to open Chat... skipping...", $COLOR_WARNING)
EndIf
EndFunc
Func VisitClanmates()
Click(20, 380)
randomSleep(3000)
If ChatOpen() Then
Click(230, 20)
randomSleep(1500)
If IsClanChat() Then
Click(120, 60)
randomSleep(1500)
If IsClanOverview() Then
SetLog("Let's visit a random Player...", $COLOR_ACTION1)
Click(660, 400 + 52 * Random(0, 5, 1))
randomSleep(500)
VisitAPlayer()
Click(70, 680)
Else
SetLog("Error when trying to open Clan overview... skipping...", $COLOR_WARNING)
EndIf
Else
SetLog("Error when trying to open Clan Chat... skipping...", $COLOR_WARNING)
EndIf
Else
SetLog("Error when trying to open Chat... skipping...", $COLOR_WARNING)
EndIf
EndFunc
Func LookAtCurrentWar()
Click(40, 530)
randomSleep(5000)
If IsWarMenu() Then
If QuickMIS("BC1", @ScriptDir & "\imgxml\Resources\Humanization Pics\CurrentWar", 740, 320, 830, 420) Then
SetLog("Let's examine the map...", $COLOR_ACTION1)
Scroll(Random(2, 5, 1))
randomSleep(3000)
Local $LookAtHome = Random(0, 1, 1)
If $LookAtHome = 1 Then
SetLog("Looking at home territory...", $COLOR_ACTION1)
Click(790, 370)
Scroll(Random(2, 5, 1))
randomSleep(3000)
EndIf
SetLog("Open War details menu...", $COLOR_ACTION1)
Click(800, 670)
randomSleep(1500)
If IsClanOverview() Then
Local $FirstMenu = Random(1, 2, 1)
Switch $FirstMenu
Case 1
SetLog("Looking at first tab...", $COLOR_ACTION1)
Click(180, 80)
Case 2
SetLog("Looking at second tab...", $COLOR_ACTION1)
Click(360, 80)
EndSwitch
randomSleep(1500)
Scroll(Random(1, 3, 1))
Local $SecondMenu = Random(1, 2, 1)
Switch $SecondMenu
Case 1
SetLog("Looking at third tab...", $COLOR_ACTION1)
Click(530, 80)
Case 2
SetLog("Looking at fourth tab...", $COLOR_ACTION1)
Click(700, 80)
EndSwitch
randomSleep(1500)
Scroll(Random(2, 4, 1))
Click(830, 80)
randomSleep(1500)
Click(70, 680)
Else
SetLog("Error when trying to open War Details window... skipping...", $COLOR_WARNING)
EndIf
Else
SetLog("Your Clan is not in active war yet... skipping...", $COLOR_WARNING)
randomSleep(1500)
Click(70, 680)
EndIf
Else
SetLog("Error when trying to open War window... skipping...", $COLOR_WARNING)
EndIf
EndFunc
Func WatchWarReplays()
Click(40, 530)
randomSleep(5000)
If QuickMIS("BC1", @ScriptDir & "\imgxml\Resources\Humanization Pics\WarDetails", 740, 620, 850, 720) And QuickMIS("BC1", @ScriptDir & "\imgxml\Resources\Humanization Pics\CurrentWar", 740, 320, 830, 420) Then
SetLog("Open War details menu...", $COLOR_ACTION1)
Click(800, 670)
randomSleep(1500)
If IsClanOverview() Then
SetLog("Looking at second tab...", $COLOR_ACTION1)
Click(360, 80)
randomSleep(1500)
If IsBestClans() Then
Local $ReplayNumber = QuickMIS("Q1", @ScriptDir & "\imgxml\Resources\Humanization Pics\Replay", 780, 240, 840, 670)
If $ReplayNumber > 0 Then
SetLog("There are " & $ReplayNumber & " replays to watch... We will choose one of them...", $COLOR_INFO)
Local $ReplayToLaunch = Random(1, $ReplayNumber, 1)
Click(810, 269 + 74 *($ReplayToLaunch - 1))
WaitForReplayWindow()
If IsReplayWindow() Then
GetReplayDuration()
randomSleep(1000)
If IsReplayWindow() Then
AccelerateReplay(0)
EndIf
randomSleep($g_aReplayDuration[1] / 3)
If IsReplayWindow() Then
DoAPauseDuringReplay(0)
EndIf
randomSleep($g_aReplayDuration[1] / 3)
If IsReplayWindow() And $g_aReplayDuration[0] <> 0 Then
DoAPauseDuringReplay(0)
EndIf
Setlog("Waiting for replay end...", $COLOR_ACTION)
While IsReplayWindow()
Sleep(2000)
WEnd
randomSleep(1000)
Click(70, 680)
EndIf
Else
SetLog("No replay to watch yet... skipping...", $COLOR_WARNING)
EndIf
Else
SetLog("Error when trying to open Replays menu... skipping...", $COLOR_WARNING)
EndIf
Else
SetLog("Error when trying to open War Details window... skipping...", $COLOR_WARNING)
EndIf
Click(830, 80)
randomSleep(2500)
Click(70, 680)
Else
SetLog("Your Clan is not in active war yet... skipping...", $COLOR_WARNING)
randomSleep(1500)
Click(70, 680)
EndIf
EndFunc
Func SaveConfig_DocOc()
IniWriteS($g_sProfileConfigPath, "Humanization", "chkUseBotHumanization", $g_ichkUseBotHumanization)
IniWriteS($g_sProfileConfigPath, "Humanization", "chkUseAltRClick", $g_ichkUseAltRClick)
IniWriteS($g_sProfileConfigPath, "Humanization", "chkCollectAchievements", $g_ichkCollectAchievements)
IniWriteS($g_sProfileConfigPath, "Humanization", "chkLookAtRedNotifications", $g_ichkLookAtRedNotifications)
For $i = 0 To 12
IniWriteS($g_sProfileConfigPath, "Humanization", "cmbPriority[" & $i & "]", _GUICtrlComboBox_GetCurSel($g_acmbPriority[$i]))
Next
For $i = 0 To 1
IniWriteS($g_sProfileConfigPath, "Humanization", "cmbMaxSpeed[" & $i & "]", _GUICtrlComboBox_GetCurSel($g_iacmbMaxSpeed[$i]))
Next
For $i = 0 To 1
IniWriteS($g_sProfileConfigPath, "Humanization", "cmbPause[" & $i & "]", _GUICtrlComboBox_GetCurSel($g_acmbPause[$i]))
Next
For $i = 0 To 1
IniWriteS($g_sProfileConfigPath, "Humanization", "humanMessage[" & $i & "]", GUICtrlRead($g_ahumanMessage[$i]))
Next
IniWriteS($g_sProfileConfigPath, "Humanization", "cmbMaxActionsNumber", _GUICtrlComboBox_GetCurSel($g_icmbMaxActionsNumber))
IniWriteS($g_sProfileConfigPath, "Treasury", "chkEnableTrCollect", $g_ichkEnableTrCollect)
IniWriteS($g_sProfileConfigPath, "Treasury", "chkForceTrCollect", $g_ichkForceTrCollect)
IniWriteS($g_sProfileConfigPath, "Treasury", "chkGoldTrCollect", $g_ichkGoldTrCollect)
IniWriteS($g_sProfileConfigPath, "Treasury", "chkElxTrCollect", $g_ichkElxTrCollect)
IniWriteS($g_sProfileConfigPath, "Treasury", "chkDarkTrCollect", $g_ichkDarkTrCollect)
IniWriteS($g_sProfileConfigPath, "Treasury", "txtMinGoldTrCollect", GUICtrlRead($txtMinGoldTrCollect))
IniWriteS($g_sProfileConfigPath, "Treasury", "txtMinElxTrCollect", GUICtrlRead($txtMinElxTrCollect))
IniWriteS($g_sProfileConfigPath, "Treasury", "txtMinDarkTrCollect", GUICtrlRead($txtMinDarkTrCollect))
IniWriteS($g_sProfileConfigPath, "Treasury", "chkFullGoldTrCollect", $g_ichkFullGoldTrCollect)
IniWriteS($g_sProfileConfigPath, "Treasury", "chkFullElxTrCollect", $g_ichkFullElxTrCollect)
IniWriteS($g_sProfileConfigPath, "Treasury", "chkFullDarkTrCollect", $g_ichkFullDarkTrCollect)
IniWriteS($g_sProfileConfigPath, "attack", "EnableSuperXP", $ichkEnableSuperXP)
IniWriteS($g_sProfileConfigPath, "attack", "SXTraining", $irbSXTraining)
IniWriteS($g_sProfileConfigPath, "attack", "SXBK", $ichkSXBK)
IniWriteS($g_sProfileConfigPath, "attack", "SXAQ", $ichkSXAQ)
IniWriteS($g_sProfileConfigPath, "attack", "SXGW", $ichkSXGW)
IniWriteS($g_sProfileConfigPath, "attack", "MaxXptoGain", GUICtrlRead($txtMaxXPtoGain))
IniWriteS($g_sProfileConfigPath, "donate", "chkExtraPersian", $ichkExtraPersian)
IniWrite($SSAConfig, "SwitchAccount", "chkEnableSwitchAccount", $ichkSwitchAccount)
IniWrite($SSAConfig, "SwitchAccount", "cmbAccountsQuantity", _GUICtrlComboBox_GetCurSel($cmbAccountsQuantity))
For $i = 1 To 8
IniWrite($SSAConfig, "SwitchAccount", "chkCanUse[" & $i & "]", $ichkCanUse[$i])
IniWrite($SSAConfig, "SwitchAccount", "chkDonateAccount[" & $i & "]", $ichkDonateAccount[$i])
IniWrite($SSAConfig, "SwitchAccount", "cmbAccount[" & $i & "]", _GUICtrlComboBox_GetCurSel($cmbAccount[$i]))
Next
EndFunc
Func ReadConfig_DocOc()
IniReadS($g_ichkUseBotHumanization, $g_sProfileConfigPath, "Humanization", "chkUseBotHumanization", 0, "int")
IniReadS($g_ichkUseAltRClick, $g_sProfileConfigPath, "Humanization", "chkUseAltRClick", 0, "int")
IniReadS($g_ichkCollectAchievements, $g_sProfileConfigPath, "Humanization", "chkCollectAchievements", 0, "int")
IniReadS($g_ichkLookAtRedNotifications, $g_sProfileConfigPath, "Humanization", "chkLookAtRedNotifications", 0, "int")
For $i = 0 To 12
IniReadS($g_iacmbPriority[$i], $g_sProfileConfigPath, "Humanization", "cmbPriority[" & $i & "]", 0, "int")
Next
For $i = 0 To 1
IniReadS($g_iacmbMaxSpeed[$i], $g_sProfileConfigPath, "Humanization", "cmbMaxSpeed[" & $i & "]", 1, "int")
Next
For $i = 0 To 1
IniReadS($g_iacmbPause[$i], $g_sProfileConfigPath, "Humanization", "cmbPause[" & $i & "]", 0, "int")
Next
For $i = 0 To 1
$g_iahumanMessage[$i] = IniRead($g_sProfileConfigPath, "Humanization", "humanMessage[" & $i & "]", "")
Next
IniReadS($g_icmbMaxActionsNumber, "Humanization", "cmbMaxActionsNumber", 1, "int")
IniReadS($g_ichkEnableTrCollect, $g_sProfileConfigPath, "Treasury", "chkEnableTrCollect", 0, "int")
IniReadS($g_ichkForceTrCollect, $g_sProfileConfigPath, "Treasury", "chkForceTrCollect", 0, "int")
IniReadS($g_ichkGoldTrCollect, $g_sProfileConfigPath, "Treasury", "chkGoldTrCollect", 0, "int")
IniReadS($g_ichkElxTrCollect, $g_sProfileConfigPath, "Treasury", "chkElxTrCollect", 0, "int")
IniReadS($g_ichkDarkTrCollect, $g_sProfileConfigPath, "Treasury", "chkDarkTrCollect", 0, "int")
IniReadS($g_itxtMinGoldTrCollect, $g_sProfileConfigPath, "Treasury", "txtMinGoldTrCollect", 200000, "int")
IniReadS($g_itxtMinElxTrCollect, $g_sProfileConfigPath, "Treasury", "txtMinElxTrCollect", 200000, "int")
IniReadS($g_itxtMinDarkTrCollect, $g_sProfileConfigPath, "Treasury", "txtMinDarkTrCollect", 50000, "int")
IniReadS($g_ichkFullGoldTrCollect, $g_sProfileConfigPath, "Treasury", "chkFullGoldTrCollect", 0, "int")
IniReadS($g_ichkFullElxTrCollect, $g_sProfileConfigPath, "Treasury", "chkFullElxTrCollect", 0, "int")
IniReadS($g_ichkFullDarkTrCollect, $g_sProfileConfigPath, "Treasury", "chkFullDarkTrCollect", 0, "int")
IniReadS($ichkEnableSuperXP, $g_sProfileConfigPath, "attack", "EnableSuperXP", 0, "int")
IniReadS($irbSXTraining, $g_sProfileConfigPath, "attack", "SXTraining", 1, "int")
IniReadS($itxtMaxXPtoGain, $g_sProfileConfigPath, "attack", "MaxXptoGain", 500, "int")
IniReadS($ichkSXBK, $g_sProfileConfigPath, "attack", "SXBK", $eHeroNone)
IniReadS($ichkSXAQ, $g_sProfileConfigPath, "attack", "SXAQ", $eHeroNone)
IniReadS($ichkSXGW, $g_sProfileConfigPath, "attack", "SXGW", $eHeroNone)
IniReadS($ichkExtraPersian, $g_sProfileConfigPath, "donate", "chkExtraPersian", 0, "int")
IniReadS($ichkSwitchAccount, $SSAConfig, "SwitchAccount", "chkEnableSwitchAccount", "0")
IniReadS($icmbAccountsQuantity, $SSAConfig, "SwitchAccount", "cmbAccountsQuantity", "0")
For $i = 1 To 8
IniReadS($ichkCanUse[$i], $SSAConfig, "SwitchAccount", "chkCanUse[" & $i & "]", "0")
IniReadS($ichkDonateAccount[$i], $SSAConfig, "SwitchAccount", "chkDonateAccount[" & $i & "]", "0")
IniReadS($icmbAccount[$i], $SSAConfig, "SwitchAccount", "cmbAccount[" & $i & "]", "0")
If $icmbAccount[$i] = -1 Then $icmbAccount[$i] = 0
Next
EndFunc
Func ApplyConfig_DocOc($TypeReadSave)
Switch $TypeReadSave
Case "Save"
$g_ichkUseBotHumanization = GUICtrlRead($chkUseBotHumanization) = $GUI_CHECKED ? 1 : 0
$g_ichkUseAltRClick = GUICtrlRead($chkUseAltRClick) = $GUI_CHECKED ? 1 : 0
$g_ichkCollectAchievements = GUICtrlRead($chkCollectAchievements) = $GUI_CHECKED ? 1 : 0
$g_ichkLookAtRedNotifications = GUICtrlRead($chkLookAtRedNotifications) = $GUI_CHECKED ? 1 : 0
For $i = 0 To 12
$g_iacmbPriority[$i] = _GUICtrlComboBox_GetCurSel($g_acmbPriority[$i])
Next
For $i = 0 To 1
$g_iacmbMaxSpeed[$i] = _GUICtrlComboBox_GetCurSel($g_acmbMaxSpeed[$i])
Next
For $i = 0 To 1
$g_iacmbPause[$i] = _GUICtrlComboBox_GetCurSel($g_acmbPause[$i])
Next
For $i = 0 To 1
$g_iahumanMessage[$i] = GUICtrlRead($g_ahumanMessage[$i])
Next
$g_icmbMaxActionsNumber = _GUICtrlComboBox_GetCurSel($g_icmbMaxActionsNumber)
$g_ichkEnableTrCollect = GUICtrlRead($chkEnableTrCollect) = $GUI_CHECKED ? 1 : 0
$g_ichkForceTrCollect = GUICtrlRead($chkForceTrCollect) = $GUI_CHECKED ? 1 : 0
$g_ichkGoldTrCollect = GUICtrlRead($chkGoldTrCollect) = $GUI_CHECKED ? 1 : 0
$g_ichkElxTrCollect = GUICtrlRead($chkElxTrCollect) = $GUI_CHECKED ? 1 : 0
$g_ichkDarkTrCollect = GUICtrlRead($chkDarkTrCollect) = $GUI_CHECKED ? 1 : 0
$g_ichkFullGoldTrCollect = GUICtrlRead($chkFullGoldTrCollect) = $GUI_CHECKED ? 1 : 0
$g_ichkFullElxTrCollect = GUICtrlRead($chkFullElxTrCollect) = $GUI_CHECKED ? 1 : 0
$g_ichkFullDarkTrCollect = GUICtrlRead($chkFullDarkTrCollect) = $GUI_CHECKED ? 1 : 0
$g_itxtMinGoldTrCollect = GUICtrlRead($txtMinGoldTrCollect)
$g_itxtMinElxTrCollect = GUICtrlRead($txtMinElxTrCollect)
$g_itxtMinDarkTrCollect = GUICtrlRead($txtMinDarkTrCollect)
$ichkEnableSuperXP = GUICtrlRead($chkEnableSuperXP) = $GUI_CHECKED ? 1 : 0
$irbSXTraining = GUICtrlRead($rbSXTraining) = $GUI_CHECKED ? 1 : 2
$ichkSXBK =(GUICtrlRead($chkSXBK) = $GUI_CHECKED) ? $eHeroKing : $eHeroNone
$ichkSXAQ =(GUICtrlRead($chkSXAQ) = $GUI_CHECKED) ? $eHeroQueen : $eHeroNone
$ichkSXGW =(GUICtrlRead($chkSXGW) = $GUI_CHECKED) ? $eHeroWarden : $eHeroNone
$itxtMaxXPtoGain = Int(GUICtrlRead($txtMaxXPtoGain))
$ichkExtraPersian =(GUICtrlRead($chkExtraPersian) = $GUI_CHECKED) ? 1 : 0
$ichkSwitchAccount =(GUICtrlRead($chkEnableSwitchAccount) = $GUI_CHECKED) ? 1 : 0
$icmbAccountsQuantity = _GUICtrlComboBox_GetCurSel($cmbAccountsQuantity)
For $i = 1 To 8
$ichkCanUse[$i] =(GUICtrlRead($chkCanUse) = $GUI_CHECKED) ? 1 : 0
$ichkDonateAccount[$i] =(GUICtrlRead($chkDonateAccount) = $GUI_CHECKED) ? 1 : 0
$icmbAccount[$i] = _GUICtrlComboBox_GetCurSel($cmbAccount[$i])
Next
Case "Read"
GUICtrlSetState($chkUseBotHumanization, $g_ichkUseBotHumanization = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($chkUseAltRClick, $g_ichkUseAltRClick = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($chkCollectAchievements, $g_ichkCollectAchievements = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($chkLookAtRedNotifications, $g_ichkLookAtRedNotifications = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
chkUseBotHumanization()
For $i = 0 To 12
_GUICtrlComboBox_SetCurSel($g_acmbPriority[$i], $g_iacmbPriority[$i])
Next
For $i = 0 To 1
_GUICtrlComboBox_SetCurSel($g_acmbMaxSpeed[$i], $g_iacmbMaxSpeed[$i])
Next
For $i = 0 To 1
_GUICtrlComboBox_SetCurSel($g_acmbPause[$i], $g_iacmbPause[$i])
Next
For $i = 0 To 1
_GUICtrlComboBox_SetCurSel($g_ahumanMessage[$i], $g_iahumanMessage[$i])
Next
_GUICtrlComboBox_SetCurSel($g_icmbMaxActionsNumber, $g_icmbMaxActionsNumber)
cmbStandardReplay()
cmbWarReplay()
GUICtrlSetState($chkEnableTrCollect, $g_ichkEnableTrCollect = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($chkForceTrCollect, $g_ichkForceTrCollect = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($chkGoldTrCollect, $g_ichkGoldTrCollect = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($chkElxTrCollect, $g_ichkElxTrCollect = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($chkDarkTrCollect, $g_ichkDarkTrCollect = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($chkFullGoldTrCollect, $g_ichkFullGoldTrCollect = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($chkFullElxTrCollect, $g_ichkFullElxTrCollect = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($chkFullDarkTrCollect, $g_ichkFullDarkTrCollect = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($txtMinGoldTrCollect, $g_itxtMinGoldTrCollect)
GUICtrlSetData($txtMinElxTrCollect, $g_itxtMinElxTrCollect)
GUICtrlSetData($txtMinDarkTrCollect, $g_itxtMinDarkTrCollect)
chkEnableTrCollect()
GUICtrlSetState($chkEnableSuperXP, $ichkEnableSuperXP = 1 ? $GUI_CHECKED : $GUI_UNCHECKED)
chkEnableSuperXP()
GUICtrlSetState($rbSXTraining,($irbSXTraining = 1) ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($rbSXIAttacking,($irbSXTraining = 2) ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetData($txtMaxXPtoGain, $itxtMaxXPtoGain)
GUICtrlSetState($chkSXBK, $ichkSXBK = $eHeroKing ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($chkSXAQ, $ichkSXAQ = $eHeroQueen ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($chkSXGW, $ichkSXGW = $eHeroWarden ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($chkExtraPersian,($ichkExtraPersian = 1) ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($chkEnableSwitchAccount,($ichkSwitchAccount = 1) ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($cmbAccountsQuantity, $icmbAccountsQuantity)
For $i = 1 To 8
GUICtrlSetState($chkCanUse[$i],($ichkCanUse[$i] = 1) ? $GUI_CHECKED : $GUI_UNCHECKED)
GUICtrlSetState($chkDonateAccount[$i],($ichkDonateAccount[$i] = 1) ? $GUI_CHECKED : $GUI_UNCHECKED)
_GUICtrlComboBox_SetCurSel($cmbAccount[$i], $icmbAccount[$i])
Next
chkSwitchAccount()
EndSwitch
EndFunc
Global $PrepDon[4] = [False, False, False, False]
Global $iTotalDonateCapacity, $iTotalDonateSpellCapacity
Global $iDonTroopsLimit = 8, $iDonSpellsLimit = 1, $iDonTroopsAv = 0, $iDonSpellsAv = 0
Global $iDonTroopsQuantityAv = 0, $iDonTroopsQuantity = 0, $iDonSpellsQuantityAv = 0, $iDonSpellsQuantity = 0
Global $bSkipDonTroops = False, $bSkipDonSpells = False
Global $bDonateAllRespectBlk = False
Global $DonatePixel
Func PrepareDonateCC()
$PrepDon[0] = 0
$PrepDon[1] = 0
For $i = 0 To $eTroopCount-1 + $g_iCustomDonateConfigs
$PrepDon[0] = BitOR($PrepDon[0],($g_abChkDonateTroop[$i] ? 1 : 0))
$PrepDon[1] = BitOR($PrepDon[1],($g_abChkDonateAllTroop[$i] ? 1 : 0))
Next
$PrepDon[2] = 0
$PrepDon[3] = 0
For $i = 0 To $eSpellCount - 1
If $i <> $eSpellClone Then
$PrepDon[2] = BitOR($PrepDon[2],($g_abChkDonateSpell[$i] ? 1 : 0))
$PrepDon[3] = BitOR($PrepDon[3],($g_abChkDonateAllSpell[$i] ? 1 : 0))
EndIf
Next
$bActiveDonate = BitOR($PrepDon[0], $PrepDon[1], $PrepDon[2], $PrepDon[3])
EndFunc
Func DonateCC($Check = False)
Local $bDonateTroop = $PrepDon[0]
Local $bDonateAllTroop = $PrepDon[1]
Local $bDonateSpell = $PrepDon[2]
Local $bDonateAllSpell = $PrepDon[3]
Local $bDonate = $bActiveDonate
Local $bOpen = True, $bClose = False
Local $ClanString = ""
If $bDonate = False Or $bDonationEnabled = False Then
If $g_iDebugSetlog = 1 Then Setlog("Donate Clan Castle troops skip", $COLOR_DEBUG)
Return
EndIf
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If $g_abDonateHours[$hour[0]] = False And $g_bDonateHoursEnable = True Then
If $g_iDebugSetlog = 1 Then SetLog("Donate Clan Castle troops not planned, Skipped..", $COLOR_DEBUG)
Return
EndIf
Local $y = 90
If $Check = True Then
If _ColorCheck(_GetPixelColor(26, 312 + $g_iMidOffsetY, True), Hex(0xf00810, 6), 20) = False And $g_iCommandStop <> 3 Then
Return
EndIf
EndIf
ClickP($aAway, 1, 0, "#0167")
Setlog("Checking for Donate Requests in Clan Chat", $COLOR_INFO)
ForceCaptureRegion()
If _CheckPixel($aChatTab, $g_bCapturePixel) = False Then ClickP($aOpenChat, 1, 0, "#0168")
If _Sleep($iDelayDonateCC4) Then Return
Local $icount = 0
While 1
If _ColorCheck(_GetPixelColor(189, 24, True), Hex(0x706C50, 6), 20) = True Then
ExitLoop
EndIf
If _ColorCheck(_GetPixelColor(189, 24, True), Hex(0x383828, 6), 20) = True Then
If _Sleep($iDelayDonateCC1) Then Return
ClickP($aClanTab, 1, 0, "#0169")
ExitLoop
EndIf
$icount += 1
If $icount >= 15 Then
SetLog("Clan Chat Did Not Open - Abandon Donate")
AndroidPageError("DonateCC")
Return
EndIf
If _Sleep($iDelayDonateCC1) Then Return
WEnd
Local $Scroll
Local $donateCCfilter = False
While 1
ForceCaptureRegion()
$y = 90
$Scroll = _PixelSearch(293, 8 + $y, 295, 23 + $y, Hex(0xFFFFFF, 6), 20)
If IsArray($Scroll) And _ColorCheck(_GetPixelColor(300, 110, True), Hex(0x509808, 6), 20) = True Then
$bDonate = True
Click($Scroll[0], $Scroll[1], 1, 0, "#0172")
$y = 90
If _Sleep($iDelayDonateCC2 + 100) Then ExitLoop
ContinueLoop
EndIf
ExitLoop
WEnd
While $bDonate
checkAttackDisable($iTaBChkIdle)
$ClanString = ""
If _Sleep($iDelayDonateCC2) Then ExitLoop
ForceCaptureRegion()
$DonatePixel = _MultiPixelSearch(202, $y, 224, 660 + $g_iBottomOffsetY, 50, 1, Hex(0x98D057, 6), $aChatDonateBtnColors, 15)
If IsArray($DonatePixel) Then
If $g_iDebugSetlog = 1 Then Setlog("$DonatePixel: (" & $DonatePixel[0] & "," & $DonatePixel[1] & ")", $COLOR_DEBUG)
$donateCCfilter= donateCCWBLUserImageCollect($DonatePixel[0],$DonatePixel[1])
$bDonate = False
$bSkipDonTroops = False
$bSkipDonSpells = False
If($bDonateTroop Or $bDonateSpell Or $bDonateAllTroop Or $bDonateAllSpell) And $donateCCfilter Then
If $g_bChkExtraAlphabets Then
Setlog("Using OCR to read Latin and Cyrillic derived alphabets..", $COLOR_ACTION)
$ClanString = ""
$ClanString = getChatString(30, $DonatePixel[1] - 50, "coc-latin-cyr")
If $ClanString = "" Then
$ClanString = getChatString(30, $DonatePixel[1] - 36, "coc-latin-cyr")
Else
$ClanString &= " " & getChatString(30, $DonatePixel[1] - 36, "coc-latin-cyr")
EndIf
If $ClanString = "" Or $ClanString = " " Then
$ClanString = getChatString(30, $DonatePixel[1] - 23, "coc-latin-cyr")
Else
$ClanString &= " " & getChatString(30, $DonatePixel[1] - 23, "coc-latin-cyr")
EndIf
If _Sleep($iDelayDonateCC2) Then ExitLoop
Else
Setlog("Using OCR to read Latin derived alphabets..", $COLOR_ACTION)
$ClanString = ""
$ClanString = getChatString(30, $DonatePixel[1] - 50, "coc-latinA")
If $ClanString = "" Then
$ClanString = getChatString(30, $DonatePixel[1] - 36, "coc-latinA")
Else
$ClanString &= " " & getChatString(30, $DonatePixel[1] - 36, "coc-latinA")
EndIf
If $ClanString = "" Or $ClanString = " " Then
$ClanString = getChatString(30, $DonatePixel[1] - 23, "coc-latinA")
Else
$ClanString &= " " & getChatString(30, $DonatePixel[1] - 23, "coc-latinA")
EndIf
If _Sleep($iDelayDonateCC2) Then ExitLoop
EndIf
If $g_bChkExtraChinese Then
Setlog("Using OCR to read the Chinese alphabet..", $COLOR_ACTION)
If $ClanString = "" Then
$ClanString = getChatStringChinese(30, $DonatePixel[1] - 24)
Else
$ClanString &= " " & getChatStringChinese(30, $DonatePixel[1] - 24)
EndIf
If _Sleep($iDelayDonateCC2) Then ExitLoop
EndIf
If $g_bChkExtraKorean Then
Setlog("Using OCR to read the Korean alphabet..", $COLOR_ACTION)
If $ClanString = "" Then
$ClanString = getChatStringKorean(30, $DonatePixel[1] - 24)
Else
$ClanString &= " " & getChatStringKorean(30, $DonatePixel[1] - 24)
EndIf
If _Sleep($iDelayDonateCC2) Then ExitLoop
EndIf
If $ichkExtraPersian = 1 Then
Setlog("Using OCR to read the Persian alphabet..", $COLOR_ACTION)
If $ClanString = "" Then
$ClanString = getChatStringPersian(30, $DonatePixel[1] - 31)
Else
$ClanString &= " " & getChatStringPersian(30, $DonatePixel[1] - 31)
EndIf
If _Sleep($iDelayDonateCC2) Then ExitLoop
EndIf
If $ClanString = "" Or $ClanString = " " Then
SetLog("Unable to read Chat Request!", $COLOR_ERROR)
$bDonate = True
$y = $DonatePixel[1] + 50
ContinueLoop
Else
If $g_bChkExtraAlphabets Then
ClipPut($ClanString)
Local $tempClip = ClipGet()
SetLog("Chat Request: " & $tempClip)
Else
SetLog("Chat Request: " & $ClanString)
EndIf
EndIf
EndIf
RemainingCCcapacity()
If $donateCCfilter = False Then
Setlog("Skip Donation at this Clan Mate...", $COLOR_ACTION)
$bSkipDonTroops = True
$bSkipDonSpells = True
Else
If $iTotalDonateCapacity <= 0 Then
Setlog("Clan Castle troops are full, skip troop donation...", $COLOR_ACTION)
$bSkipDonTroops = True
EndIf
If $iTotalDonateSpellCapacity = 0 Then
Setlog("Clan Castle spells are full, skip spell donation...", $COLOR_ACTION)
$bSkipDonSpells = True
ElseIf $iTotalDonateSpellCapacity = -1 Then
If $g_iDebugSetlog = 1 Then Setlog("This CC cannot accept spells, skip spell donation...", $COLOR_DEBUG)
$bSkipDonSpells = True
ElseIf $CurSFactory = 0 Then
If $g_iDebugSetlog = 1 Then Setlog("No spells available, skip spell donation...", $COLOR_DEBUG)
Setlog("No spells available, skip spell donation...", $COLOR_ORANGE)
$bSkipDonSpells = True
EndIf
EndIf
If $bSkipDonTroops And $bSkipDonSpells Then
$bDonate = True
$y = $DonatePixel[1] + 50
ContinueLoop
EndIf
If _Sleep(1000) Then Return
If($bSkipDonTroops = True And $bSkipDonSpells = True) Or DonateWindow($bOpen) = False Then
$bDonate = True
$y = $DonatePixel[1] + 50
SetLog("Donate Window did not open - Exiting Donate", $COLOR_RED)
ExitLoop
EndIf
If $bDonateTroop Or $bDonateSpell Then
If $g_iDebugSetlog = 1 Then Setlog("Troop/Spell checkpoint.", $COLOR_DEBUG)
DonateWindowCap($bSkipDonTroops, $bSkipDonSpells)
If $bSkipDonTroops And $bSkipDonSpells Then
DonateWindow($bClose)
$bDonate = True
$y = $DonatePixel[1] + 50
If _Sleep($iDelayDonateCC2) Then ExitLoop
ContinueLoop
EndIf
If $bDonateTroop = 1 And $bSkipDonTroops = False Then
If $g_iDebugSetlog = 1 Then Setlog("Troop checkpoint.", $COLOR_DEBUG)
If $g_abChkDonateTroop[$eCustomA] And CheckDonateTroop(99, $g_asTxtDonateTroop[$eCustomA], $g_asTxtBlacklistTroop[$eCustomA], $ClanString) Then
For $i = 0 To 2
If $g_aiDonateCustomTrpNumA[$i][0] < $eBarb Then
$g_aiDonateCustomTrpNumA[$i][0] = $eArch
ElseIf $g_aiDonateCustomTrpNumA[$i][0] > $eBowl Then
ContinueLoop
EndIf
If $g_aiDonateCustomTrpNumA[$i][1] < 1 Then
ContinueLoop
ElseIf $g_aiDonateCustomTrpNumA[$i][1] > 8 Then
$g_aiDonateCustomTrpNumA[$i][1] = 8
EndIf
DonateTroopType($g_aiDonateCustomTrpNumA[$i][0], $g_aiDonateCustomTrpNumA[$i][1], $g_abChkDonateTroop[$eCustomA])
Next
EndIf
If $g_abChkDonateTroop[$eCustomB] And CheckDonateTroop(99, $g_asTxtDonateTroop[$eCustomB], $g_asTxtBlacklistTroop[$eCustomB], $ClanString) Then
For $i = 0 To 2
If $g_aiDonateCustomTrpNumB[$i][0] < $eBarb Then
$g_aiDonateCustomTrpNumB[$i][0] = $eArch
ElseIf $g_aiDonateCustomTrpNumB[$i][0] > $eBowl Then
ContinueLoop
EndIf
If $g_aiDonateCustomTrpNumB[$i][1] < 1 Then
ContinueLoop
ElseIf $g_aiDonateCustomTrpNumB[$i][1] > 8 Then
$g_aiDonateCustomTrpNumB[$i][1] = 8
EndIf
DonateTroopType($g_aiDonateCustomTrpNumB[$i][0], $g_aiDonateCustomTrpNumB[$i][1], $g_abChkDonateTroop[$eCustomB])
Next
EndIf
If $bSkipDonTroops = False Then
For $i = 0 To UBound($g_aiDonateTroopPriority) - 1
Local $iTroopIndex = $g_aiDonateTroopPriority[$i]
If $g_abChkDonateTroop[$iTroopIndex] Then
If CheckDonateTroop($iTroopIndex, $g_asTxtDonateTroop[$iTroopIndex], $g_asTxtBlacklistTroop[$iTroopIndex], $ClanString) Then
DonateTroopType($iTroopIndex)
EndIf
EndIf
Next
EndIf
EndIf
If $bDonateSpell = 1 And $bSkipDonSpells = False Then
If $g_iDebugSetlog = 1 Then Setlog("Spell checkpoint.", $COLOR_DEBUG)
For $i = 0 To UBound($g_aiDonateSpellPriority) - 1
Local $iSpellIndex = $g_aiDonateSpellPriority[$i]
If $g_abChkDonateSpell[$iSpellIndex] Then
If CheckDonateSpell($iSpellIndex, $g_asTxtDonateSpell[$iSpellIndex], $g_asTxtBlacklistSpell[$iSpellIndex], $ClanString) Then
DonateSpellType($iSpellIndex)
EndIf
EndIf
Next
EndIf
EndIf
If $bDonateAllTroop Or $bDonateAllSpell Then
If $g_iDebugSetlog = 1 Then Setlog("Troop/Spell All checkpoint.", $COLOR_DEBUG)
$bDonateAllRespectBlk = True
If $bDonateAllTroop And $bSkipDonTroops = False Then
DonateWindowCap($bSkipDonTroops, $bSkipDonSpells)
If $bSkipDonTroops And $bSkipDonSpells Then
DonateWindow($bClose)
$bDonate = True
$y = $DonatePixel[1] + 50
If _Sleep($iDelayDonateCC2) Then ExitLoop
ContinueLoop
EndIf
If $g_iDebugSetlog = 1 Then Setlog("Troop All checkpoint.", $COLOR_DEBUG)
Select
Case $g_abChkDonateAllTroop[$eCustomA]
For $i = 0 To 2
If $g_aiDonateCustomTrpNumA[$i][0] < $eBarb Then
$g_aiDonateCustomTrpNumA[$i][0] = $eArch
ElseIf $g_aiDonateCustomTrpNumA[$i][0] > $eBowl Then
DonateWindow($bClose)
$bDonate = True
$y = $DonatePixel[1] + 50
If _Sleep($iDelayDonateCC2) Then ExitLoop
ContinueLoop
EndIf
If $g_aiDonateCustomTrpNumA[$i][1] < 1 Then
DonateWindow($bClose)
$bDonate = True
$y = $DonatePixel[1] + 50
If _Sleep($iDelayDonateCC2) Then ExitLoop
ContinueLoop
ElseIf $g_aiDonateCustomTrpNumA[$i][1] > 8 Then
$g_aiDonateCustomTrpNumA[$i][1] = 8
EndIf
DonateTroopType($g_aiDonateCustomTrpNumA[$i][0], $g_aiDonateCustomTrpNumA[$i][1], $g_abChkDonateAllTroop[$eCustomA], $bDonateAllTroop)
Next
Case $g_abChkDonateAllTroop[$eCustomB]
For $i = 0 To 2
If $g_aiDonateCustomTrpNumB[$i][0] < $eBarb Then
$g_aiDonateCustomTrpNumB[$i][0] = $eArch
ElseIf $g_aiDonateCustomTrpNumB[$i][0] > $eBowl Then
DonateWindow($bClose)
$bDonate = True
$y = $DonatePixel[1] + 50
If _Sleep($iDelayDonateCC2) Then ExitLoop
ContinueLoop
EndIf
If $g_aiDonateCustomTrpNumB[$i][1] < 1 Then
DonateWindow($bClose)
$bDonate = True
$y = $DonatePixel[1] + 50
If _Sleep($iDelayDonateCC2) Then ExitLoop
ContinueLoop
ElseIf $g_aiDonateCustomTrpNumB[$i][1] > 8 Then
$g_aiDonateCustomTrpNumB[$i][1] = 8
EndIf
DonateTroopType($g_aiDonateCustomTrpNumB[$i][0], $g_aiDonateCustomTrpNumB[$i][1], $g_abChkDonateAllTroop[$eCustomB], $bDonateAllTroop)
Next
Case Else
For $i = 0 To UBound($g_aiDonateTroopPriority) - 1
Local $iTroopIndex = $g_aiDonateTroopPriority[$i]
If $g_abChkDonateAllTroop[$iTroopIndex] Then
If CheckDonateTroop($iTroopIndex, $g_asTxtDonateTroop[$iTroopIndex], $g_asTxtBlacklistTroop[$iTroopIndex], $ClanString) Then
DonateTroopType($iTroopIndex, 0, False, $bDonateAllTroop)
EndIf
ExitLoop
EndIf
Next
EndSelect
EndIf
If $bDonateAllSpell And $bSkipDonSpells = False Then
If $g_iDebugSetlog = 1 Then Setlog("Spell All checkpoint.", $COLOR_DEBUG)
For $i = 0 To UBound($g_aiDonateSpellPriority) - 1
Local $iSpellIndex = $g_aiDonateSpellPriority[$i]
If $g_abChkDonateAllSpell[$iSpellIndex] Then
If CheckDonateSpell($iSpellIndex, $g_asTxtDonateSpell[$iSpellIndex], $g_asTxtBlacklistSpell[$iSpellIndex], $ClanString) Then
DonateSpellType($iSpellIndex, 0, False, $bDonateAllSpell)
EndIf
ExitLoop
EndIf
Next
EndIf
$bDonateAllRespectBlk = False
EndIf
DonateWindow($bClose)
$bDonate = True
$y = $DonatePixel[1] + 50
ClickP($aAway, 1, 0, "#0171")
If _Sleep($iDelayDonateCC2) Then ExitLoop
EndIf
ForceCaptureRegion()
$DonatePixel = _MultiPixelSearch(202, $y, 224, 660 + $g_iBottomOffsetY, 50, 1, Hex(0x98D057, 6), $aChatDonateBtnColors, 15)
If IsArray($DonatePixel) Then
If $g_iDebugSetlog = 1 Then Setlog("More Donate buttons found, new $DonatePixel: (" & $DonatePixel[0] & "," & $DonatePixel[1] & ")", $COLOR_DEBUG)
ContinueLoop
Else
If $g_iDebugSetlog = 1 Then Setlog("No more Donate buttons found, closing chat ($y=" & $y & ")", $COLOR_DEBUG)
EndIf
ForceCaptureRegion()
$Scroll = _PixelSearch(293, 687 - 30, 295, 693 - 30, Hex(0xFFFFFF, 6), 20)
If IsArray($Scroll) Then
$bDonate = True
Click($Scroll[0], $Scroll[1], 1, 0, "#0172")
$y = 600
If _Sleep($iDelayDonateCC2) Then ExitLoop
ContinueLoop
EndIf
$bDonate = False
WEnd
UpdateStats()
ClickP($aAway, 1, 0, "#0176")
If _Sleep($iDelayDonateCC2) Then Return
$i = 0
While 1
If _Sleep(100) Then Return
If _ColorCheck(_GetPixelColor($aCloseChat[0], $aCloseChat[1], True), Hex($aCloseChat[2], 6), $aCloseChat[3]) Then
Click($aCloseChat[0], $aCloseChat[1], 1, 0, "#0173")
ExitLoop
Else
If _Sleep(100) Then Return
$i += 1
If $i > 30 Then
SetLog("Error finding Clan Tab to close...", $COLOR_ERROR)
AndroidPageError("DonateCC")
ExitLoop
EndIf
EndIf
WEnd
If _Sleep($iDelayDonateCC2) Then Return
EndFunc
Func CheckDonateTroop(Const $iTroopIndex, Const $sDonateTroopString, Const $sBlacklistTroopString, Const $sClanString)
Local $sName =($iTroopIndex = 99 ? "Custom" : $g_asTroopNames[$iTroopIndex])
Return CheckDonate($sName, $sDonateTroopString, $sBlacklistTroopString, $sClanString)
EndFunc
Func CheckDonateSpell(Const $iSpellIndex, Const $sDonateSpellString, Const $sBlacklistSpellString, Const $sClanString)
Local $sName = $g_asSpellNames[$iSpellIndex]
Return CheckDonate($sName, $sDonateSpellString, $sBlacklistSpellString, $sClanString)
EndFunc
Func CheckDonate(Const $sName, Const $sDonateString, Const $sBlacklistString, Const $sClanString)
Local $asSplitDonate = StringSplit($sDonateString, @CRLF, $STR_ENTIRESPLIT)
Local $asSplitBlacklist = StringSplit($sBlacklistString, @CRLF, $STR_ENTIRESPLIT)
Local $asSplitGeneralBlacklist = StringSplit($g_sTxtGeneralBlacklist, @CRLF, $STR_ENTIRESPLIT)
For $i = 1 To UBound($asSplitGeneralBlacklist) - 1
If CheckDonateString($asSplitGeneralBlacklist[$i], $sClanString) Then
SetLog("General Blacklist Keyword found: " & $asSplitGeneralBlacklist[$i], $COLOR_ERROR)
Return False
EndIf
Next
For $i = 1 To UBound($asSplitBlacklist) - 1
If CheckDonateString($asSplitBlacklist[$i], $sClanString) Then
SetLog($sName & " Blacklist Keyword found: " & $asSplitBlacklist[$i], $COLOR_ERROR)
Return False
EndIf
Next
If $bDonateAllRespectBlk = False Then
For $i = 1 To UBound($asSplitDonate) - 1
If CheckDonateString($asSplitDonate[$i], $sClanString) Then
Setlog($sName & " Keyword found: " & $asSplitDonate[$i], $COLOR_SUCCESS)
Return True
EndIf
Next
EndIf
If $bDonateAllRespectBlk = True Then Return True
If $g_iDebugSetlog = 1 Then Setlog("Bad call of CheckDonateTroop: " & $sName, $COLOR_DEBUG)
Return False
EndFunc
Func CheckDonateString($String, $ClanString)
Local $Contains = StringMid($String, 1, 1) & StringMid($String, StringLen($String), 1)
If $Contains = "[]" Then
If $ClanString = StringMid($String, 2, StringLen($String) - 2) Then
Return True
Else
Return False
EndIf
Else
If StringInStr($ClanString, $String, 2) Then
Return True
Else
Return False
EndIf
EndIf
EndFunc
Func DonateTroopType(Const $iTroopIndex, $Quant = 0, Const $Custom = False, Const $bDonateAll = False)
Local $Slot = -1, $detectedSlot = -1
Local $YComp = 0, $donaterow = -1
Local $donateposinrow = -1
Local $sTextToAll = ""
If $iTotalDonateCapacity = 0 Then Return
If $g_iDebugSetlog = 1 Then Setlog("$DonateTroopType Start: " & $g_asTroopNames[$iTroopIndex], $COLOR_DEBUG)
$iDonTroopsQuantityAv = Floor($iTotalDonateCapacity / $g_aiTroopSpace[$iTroopIndex])
If $iDonTroopsQuantityAv < 1 Then
Setlog("Sorry Chief! " & $g_asTroopNamesPlural[$iTroopIndex] & " don't fit in the remaining space!")
Return
EndIf
If $iDonTroopsQuantityAv >= $iDonTroopsLimit Then
$iDonTroopsQuantity = $iDonTroopsLimit
Else
$iDonTroopsQuantity = $iDonTroopsQuantityAv
EndIf
If $g_iDebugOCRdonate = 1 Then
Local $oldDebugOcr = $g_iDebugOcr
$g_iDebugOcr = 1
EndIf
$Slot = DetectSlotTroop($iTroopIndex)
$detectedSlot = $Slot
If $g_iDebugSetlog = 1 Then setlog("slot found = " & $Slot, $COLOR_DEBUG)
If $g_iDebugOCRdonate = 1 Then $g_iDebugOcr = $oldDebugOcr
If $Slot = -1 Then Return
If $Slot < 0 Or $Slot > 11 Then
setlog("Invalid slot # found = " & $Slot & " for " & $g_asTroopNames[$iTroopIndex], $COLOR_ERROR)
Return
EndIf
$donaterow = 1
$donateposinrow = $Slot
If $Slot >= 6 And $Slot <= 11 Then
$donaterow = 2
$Slot = $Slot - 6
$donateposinrow = $Slot
$YComp = 88
EndIf
SetLog("Troops Condition Matched", $COLOR_ORANGE)
If _ColorCheck(_GetPixelColor(350 +($Slot * 68), $DonationWindowY + 105 + $YComp, True), Hex(0x306ca8, 6), 20) Or  _ColorCheck(_GetPixelColor(355 +($Slot * 68), $DonationWindowY + 106 + $YComp, True), Hex(0x306ca8, 6), 20) Or  _ColorCheck(_GetPixelColor(360 +($Slot * 68), $DonationWindowY + 107 + $YComp, True), Hex(0x306ca8, 6), 20) Then
If $Custom Then
If $bDonateAll Then $sTextToAll = " (to all requests)"
SetLog("Donating " & $Quant & " " &($Quant > 1 ? $g_asTroopNamesPlural[$iTroopIndex] : $g_asTroopNames[$iTroopIndex]) & $sTextToAll, $COLOR_SUCCESS)
If $g_iDebugOCRdonate = 1 Then
Setlog("donate", $COLOR_ERROR)
Setlog("row: " & $donaterow, $COLOR_ERROR)
Setlog("pos in row: " & $donateposinrow, $COLOR_ERROR)
setlog("coordinate: " & 365 +($Slot * 68) & "," & $DonationWindowY + 100 + $YComp, $COLOR_ERROR)
debugimagesave("LiveDonateCC-r" & $donaterow & "-c" & $donateposinrow & "-" & $g_asTroopNames[$iTroopIndex] & "_")
EndIf
If $g_iDebugOCRdonate = 0 Then
If $g_bQuickTrainEnable = True Then
Local $icount = 0
For $x = 0 To $Quant
If _ColorCheck(_GetPixelColor(350 +($Slot * 68), $DonationWindowY + 105 + $YComp, True), Hex(0x306ca8, 6), 20) Or  _ColorCheck(_GetPixelColor(355 +($Slot * 68), $DonationWindowY + 106 + $YComp, True), Hex(0x306ca8, 6), 20) Or  _ColorCheck(_GetPixelColor(360 +($Slot * 68), $DonationWindowY + 107 + $YComp, True), Hex(0x306ca8, 6), 20) Then
Click(365 +($Slot * 68), $DonationWindowY + 100 + $YComp, 1, $iDelayDonateCC3, "#0175")
If $g_iCommandStop = 3 Then
$g_iCommandStop = 0
$fullArmy = False
EndIf
If _Sleep(1000) Then Return
$icount += 1
EndIf
Next
$Quant = $icount
$g_aiDonateStatsTroops[$iTroopIndex][0] += $Quant
Else
If _ColorCheck(_GetPixelColor(350 +($Slot * 68), $DonationWindowY + 105 + $YComp, True), Hex(0x306ca8, 6), 20) Or  _ColorCheck(_GetPixelColor(355 +($Slot * 68), $DonationWindowY + 106 + $YComp, True), Hex(0x306ca8, 6), 20) Or  _ColorCheck(_GetPixelColor(360 +($Slot * 68), $DonationWindowY + 107 + $YComp, True), Hex(0x306ca8, 6), 20) Then
Click(365 +($Slot * 68), $DonationWindowY + 100 + $YComp, $Quant, $iDelayDonateCC3, "#0175")
$g_aiDonateStatsTroops[$iTroopIndex][0] += $Quant
If $g_iCommandStop = 3 Then
$g_iCommandStop = 0
$fullArmy = False
EndIf
EndIf
EndIf
If $iTroopIndex >= $eTroopBarbarian And $iTroopIndex <= $eTroopBowler Then
$iTotalDonateCapacity -=($Quant * $g_aiTroopSpace[$iTroopIndex])
If $iDonTroopsLimit = $Quant Then
$bSkipDonTroops = True
EndIf
EndIf
EndIf
Else
If $g_iDebugOCRdonate = 1 Then
Setlog("donate", $color_RED)
Setlog("row: " & $donaterow, $color_RED)
Setlog("pos in row: " & $donateposinrow, $color_red)
setlog("coordinate: " & 365 +($Slot * 68) & "," & $DonationWindowY + 100 + $YComp, $color_red)
debugimagesave("LiveDonateCC-r" & $donaterow & "-c" & $donateposinrow & "-" & $g_asTroopNames[$iTroopIndex] & "_")
EndIf
If $g_iDebugOCRdonate = 0 Then
If $g_bQuickTrainEnable = True Then
Local $icount = 0
For $x = 0 To $iDonTroopsQuantity
If _ColorCheck(_GetPixelColor(350 +($Slot * 68), $DonationWindowY + 105 + $YComp, True), Hex(0x306ca8, 6), 20) Or  _ColorCheck(_GetPixelColor(355 +($Slot * 68), $DonationWindowY + 106 + $YComp, True), Hex(0x306ca8, 6), 20) Or  _ColorCheck(_GetPixelColor(360 +($Slot * 68), $DonationWindowY + 107 + $YComp, True), Hex(0x306ca8, 6), 20) Then
Click(365 +($Slot * 68), $DonationWindowY + 100 + $YComp, 1, $iDelayDonateCC3, "#0175")
$icount += 1
If $g_iCommandStop = 3 Then
$g_iCommandStop = 0
$fullArmy = False
EndIf
If _Sleep(1000) Then Return
EndIf
Next
$iDonTroopsQuantity = $icount
$g_aiDonateStatsTroops[$iTroopIndex][0] += $iDonTroopsQuantity
Else
If _ColorCheck(_GetPixelColor(350 +($Slot * 68), $DonationWindowY + 105 + $YComp, True), Hex(0x306ca8, 6), 20) Or  _ColorCheck(_GetPixelColor(355 +($Slot * 68), $DonationWindowY + 106 + $YComp, True), Hex(0x306ca8, 6), 20) Or  _ColorCheck(_GetPixelColor(360 +($Slot * 68), $DonationWindowY + 107 + $YComp, True), Hex(0x306ca8, 6), 20) Then
Click(365 +($Slot * 68), $DonationWindowY + 100 + $YComp, $iDonTroopsQuantity, $iDelayDonateCC3, "#0175")
$g_aiDonateStatsTroops[$iTroopIndex][0] += $iDonTroopsQuantity
If $g_iCommandStop = 3 Then
$g_iCommandStop = 0
$fullArmy = False
EndIf
EndIf
EndIf
If $bDonateAll Then $sTextToAll = " (to all requests)"
SetLog("Donating " & $iDonTroopsQuantity & " " &($iDonTroopsQuantity > 1 ? $g_asTroopNamesPlural[$iTroopIndex] : $g_asTroopNames[$iTroopIndex]) & $sTextToAll, $COLOR_GREEN)
If $iTroopIndex >= $eTroopBarbarian And $iTroopIndex <= $eTroopBowler Then
$iTotalDonateCapacity -=($iDonTroopsQuantity * $g_aiTroopSpace[$iTroopIndex])
If $iDonTroopsLimit = $iDonTroopsQuantity Then
$bSkipDonTroops = True
EndIf
EndIf
EndIf
EndIf
If $Custom Then
$g_aiDonateTroops[$iTroopIndex] += $Quant
Else
$g_aiDonateTroops[$iTroopIndex] += $iDonTroopsQuantity
EndIf
ElseIf $DonatePixel[1] - 5 + $YComp > 675 Then
Setlog("Unable to donate " & $g_asTroopNames[$iTroopIndex] & ". Donate screen not visible, will retry next run.", $COLOR_ERROR)
Else
SetLog("No " & $g_asTroopNames[$iTroopIndex] & " available to donate..", $COLOR_ERROR)
EndIf
EndFunc
Func DonateSpellType(Const $iSpellIndex, $Quant = 0, Const $Custom = False, Const $bDonateAll = False)
Local $Slot = -1, $detectedSlot = -1
Local $YComp = 0, $donaterow = -1
Local $donateposinrow = -1
If $iTotalDonateSpellCapacity = 0 Then Return
If $g_iDebugSetlog = 1 Then Setlog("DonateSpellType Start: " & $g_asSpellNames[$iSpellIndex], $COLOR_DEBUG)
$iDonSpellsQuantityAv = Floor($iTotalDonateSpellCapacity / $g_aiSpellSpace[$iSpellIndex])
If $iDonSpellsQuantityAv < 1 Then
Setlog("Sorry Chief! " & $g_asSpellNames[$iSpellIndex] & " spells don't fit in the remaining space!")
Return
EndIf
If $iDonSpellsQuantityAv >= $iDonSpellsLimit Then
$iDonSpellsQuantity = $iDonSpellsLimit
Else
$iDonSpellsQuantity = $iDonSpellsQuantityAv
EndIf
If $g_iDebugOCRdonate = 1 Then
Local $oldDebugOcr = $g_iDebugOcr
$g_iDebugOcr = 1
EndIf
$Slot = DetectSlotSpell($iSpellIndex)
$detectedSlot = $Slot
If $g_iDebugSetlog = 1 Then setlog("slot found = " & $Slot, $COLOR_DEBUG)
If $g_iDebugOCRdonate = 1 Then $g_iDebugOcr = $oldDebugOcr
If $Slot = -1 Then Return
If $Slot < 12 Or $Slot > 17 Then
setlog("Invalid slot # found = " & $Slot & " for " & $g_asSpellNames[$iSpellIndex], $COLOR_ERROR)
Return
EndIf
$donaterow = 3
$Slot = $Slot - 12
$donateposinrow = $Slot
$YComp = 203
SetLog("Spells Condition Matched", $COLOR_ORANGE)
If _ColorCheck(_GetPixelColor(350 +($Slot * 68), $DonationWindowY + 105 + $YComp, True), Hex(0x6038B0, 6), 20) Or  _ColorCheck(_GetPixelColor(355 +($Slot * 68), $DonationWindowY + 106 + $YComp, True), Hex(0x6038B0, 6), 20) Or  _ColorCheck(_GetPixelColor(360 +($Slot * 68), $DonationWindowY + 107 + $YComp, True), Hex(0x6038B0, 6), 20) Then
If $g_iDebugOCRdonate = 1 Then
Setlog("donate", $COLOR_ERROR)
Setlog("row: " & $donaterow, $COLOR_ERROR)
Setlog("pos in row: " & $donateposinrow, $COLOR_ERROR)
setlog("coordinate: " & 365 +($Slot * 68) & "," & $DonationWindowY + 100 + $YComp, $COLOR_ERROR)
debugimagesave("LiveDonateCC-r" & $donaterow & "-c" & $donateposinrow & "-" & $g_asSpellNames[$iSpellIndex] & "_")
EndIf
If $g_iDebugOCRdonate = 0 Then
Click(365 +($Slot * 68), $DonationWindowY + 100 + $YComp, $iDonSpellsQuantity, $iDelayDonateCC3, "#0600")
$bFullArmySpells = False
$fullArmy = False
$g_aiDonateSpells[$iSpellIndex] += 1
If $g_iCommandStop = 3 Then
$g_iCommandStop = 0
$bFullArmySpells = False
EndIf
$g_aiDonateStatsSpells[$iSpellIndex][0] += $iDonSpellsQuantity
EndIf
ElseIf $DonatePixel[1] - 5 + $YComp > 675 Then
Setlog("Unable to donate " & $g_asSpellNames[$iSpellIndex] & ". Donate screen not visible, will retry next run.", $COLOR_ERROR)
Else
SetLog("No " & $g_asSpellNames[$iSpellIndex] & " available to donate..", $COLOR_ERROR)
EndIf
EndFunc
Func DonateWindow($Open = True)
If $g_iDebugSetlog = 1 And $Open = True Then Setlog("DonateWindow Open Start", $COLOR_DEBUG)
If $g_iDebugSetlog = 1 And $Open = False Then Setlog("DonateWindow Close Start", $COLOR_DEBUG)
If $Open = False Then
ClickP($aAway, 1, 0, "#0176")
If _Sleep($iDelayDonateWindow1) Then Return
If $g_iDebugSetlog = 1 Then Setlog("DonateWindow Close Exit", $COLOR_DEBUG)
Return
EndIf
Local $iLeft = 0, $iTop = 0, $iRight = 0, $iBottom = 0, $i
For $i = 0 To UBound($aChatDonateBtnColors) - 1
If $aChatDonateBtnColors[$i][1] < $iLeft Then $iLeft = $aChatDonateBtnColors[$i][1]
If $aChatDonateBtnColors[$i][1] > $iRight Then $iRight = $aChatDonateBtnColors[$i][1]
If $aChatDonateBtnColors[$i][2] < $iTop Then $iTop = $aChatDonateBtnColors[$i][2]
If $aChatDonateBtnColors[$i][2] > $iBottom Then $iBottom = $aChatDonateBtnColors[$i][2]
Next
$iLeft += $DonatePixel[0]
$iTop += $DonatePixel[1]
$iRight += $DonatePixel[0] + 1
$iBottom += $DonatePixel[1] + 1
ForceCaptureRegion()
Local $DonatePixelCheck = _MultiPixelSearch($iLeft, $iTop, $iRight, $iBottom, 50, 1, Hex(0x98D057, 6), $aChatDonateBtnColors, 15)
If IsArray($DonatePixelCheck) Then
Click($DonatePixel[0] + 50, $DonatePixel[1] + 10, 1, 0, "#0174")
Else
If $g_iDebugSetlog = 1 Then SetLog("Could not find the Donate Button!", $COLOR_DEBUG)
Return False
EndIf
If _Sleep($iDelayDonateWindow1) Then Return
Local $icount = 0
While Not(_ColorCheck(_GetPixelColor(331, $DonatePixel[1], True), Hex(0xffffff, 6), 0))
If _Sleep($iDelayDonateWindow1) Then Return
$icount += 1
If $icount = 20 Then ExitLoop
WEnd
$DonationWindowY = 0
Local $aDonWinOffColors[2][3] = [[0xFFFFFF, 0, 2], [0xc7c5bc, 0, 209]]
Local $aDonationWindow = _MultiPixelSearch(409, 0, 410, $g_iDEFAULT_HEIGHT, 1, 1, Hex(0xFFFFFF, 6), $aDonWinOffColors, 10)
If IsArray($aDonationWindow) Then
$DonationWindowY = $aDonationWindow[1]
If _Sleep($iDelayDonateWindow1) Then Return
If $g_iDebugSetlog = 1 Then Setlog("$DonationWindowY: " & $DonationWindowY, $COLOR_DEBUG)
Else
SetLog("Could not find the Donate Window!", $COLOR_ERROR)
Return False
EndIf
If $g_iDebugSetlog = 1 Then Setlog("DonateWindow Open Exit", $COLOR_DEBUG)
Return True
EndFunc
Func DonateWindowCap(ByRef $bSkipDonTroops, ByRef $bSkipDonSpells)
If $g_iDebugSetlog = 1 Then Setlog("DonateCapWindow Start", $COLOR_DEBUG)
If $bSkipDonTroops = False Then
Local $sReadCCTroopsCap = getCastleDonateCap(427, $DonationWindowY + 15)
If $g_iDebugSetlog = 1 Then Setlog("$sReadCCTroopsCap: " & $sReadCCTroopsCap, $COLOR_DEBUG)
Local $aTempReadCCTroopsCap = StringSplit($sReadCCTroopsCap, "#")
If $aTempReadCCTroopsCap[0] >= 2 Then
If $g_iDebugSetlog = 1 Then Setlog("$aTempReadCCTroopsCap splitted :" & $aTempReadCCTroopsCap[1] & "/" & $aTempReadCCTroopsCap[2], $COLOR_DEBUG)
If $aTempReadCCTroopsCap[2] > 0 Then
$iDonTroopsAv = $aTempReadCCTroopsCap[1]
$iDonTroopsLimit = $aTempReadCCTroopsCap[2]
EndIf
Else
Setlog("Error reading the Castle Troop Capacity...", $COLOR_ERROR)
$iDonTroopsAv = 0
$iDonTroopsLimit = 0
EndIf
EndIf
If $bSkipDonSpells = False Then
Local $sReadCCSpellsCap = getCastleDonateCap(420, $DonationWindowY + 220)
If $g_iDebugSetlog = 1 Then Setlog("$sReadCCSpellsCap: " & $sReadCCSpellsCap, $COLOR_DEBUG)
Local $aTempReadCCSpellsCap = StringSplit($sReadCCSpellsCap, "#")
If $aTempReadCCSpellsCap[0] >= 2 Then
If $g_iDebugSetlog = 1 Then Setlog("$aTempReadCCSpellsCap splitted :" & $aTempReadCCSpellsCap[1] & "/" & $aTempReadCCSpellsCap[2], $COLOR_DEBUG)
If $aTempReadCCSpellsCap[2] > 0 Then
$iDonSpellsAv = $aTempReadCCSpellsCap[1]
$iDonSpellsLimit = $aTempReadCCSpellsCap[2]
EndIf
Else
Setlog("Error reading the Castle Spells Capacity...", $COLOR_ERROR)
$iDonSpellsAv = 0
$iDonSpellsLimit = 0
EndIf
EndIf
If $iDonTroopsAv = $iDonTroopsLimit Then
$bSkipDonTroops = True
SetLog("Donate Troop Limit Reached")
EndIf
If $iDonSpellsAv = $iDonSpellsLimit Then
$bSkipDonSpells = True
SetLog("Donate Spell Limit Reached")
EndIf
If $bSkipDonTroops = True And $bSkipDonSpells = True And $iDonTroopsAv < $iDonTroopsLimit And $iDonSpellsAv < $iDonSpellsLimit Then
Setlog("Donate Troops: " & $iDonTroopsAv & "/" & $iDonTroopsLimit & ", Spells: " & $iDonSpellsAv & "/" & $iDonSpellsLimit)
EndIf
If $bSkipDonSpells = False And $iDonTroopsAv < $iDonTroopsLimit And $iDonSpellsAv = $iDonSpellsLimit Then Setlog("Donate Troops: " & $iDonTroopsAv & "/" & $iDonTroopsLimit)
If $bSkipDonTroops = False And $iDonTroopsAv = $iDonTroopsLimit And $iDonSpellsAv < $iDonSpellsLimit Then Setlog("Donate Spells: " & $iDonSpellsAv & "/" & $iDonSpellsLimit)
If $g_iDebugSetlog = 1 Then Setlog("$bSkipDonTroops: " & $bSkipDonTroops, $COLOR_DEBUG)
If $g_iDebugSetlog = 1 Then Setlog("$bSkipDonSpells: " & $bSkipDonSpells, $COLOR_DEBUG)
If $g_iDebugSetlog = 1 Then Setlog("DonateCapWindow End", $COLOR_DEBUG)
EndFunc
Func RemainingCCcapacity()
Local $aCapTroops = "", $aTempCapTroops = "", $aCapSpells = "", $aTempCapSpells
Local $iDonatedTroops = 0, $iDonatedSpells = 0
Local $iCapTroopsTotal = 0, $iCapSpellsTotal = 0
$iTotalDonateCapacity = -1
$iTotalDonateSpellCapacity = -1
If $g_iDebugSetlog = 1 Then Setlog("Started dual getOcrSpaceCastleDonate", $COLOR_DEBUG)
$aCapTroops = getOcrSpaceCastleDonate(49, $DonatePixel[1])
$aCapSpells = getOcrSpaceCastleDonate(154, $DonatePixel[1])
If $g_iDebugSetlog = 1 Then Setlog("$aCapTroops :" & $aCapTroops, $COLOR_DEBUG)
If $g_iDebugSetlog = 1 Then Setlog("$aCapSpells :" & $aCapSpells, $COLOR_DEBUG)
If Not(StringInStr($aCapTroops, "#") Or StringInStr($aCapSpells, "#")) Then
If $g_iDebugSetlog = 1 Then Setlog("Started single getOcrSpaceCastleDonate", $COLOR_DEBUG)
$aCapTroops = getOcrSpaceCastleDonate(78, $DonatePixel[1])
If $g_iDebugSetlog = 1 Then Setlog("$aCapTroops :" & $aCapTroops, $COLOR_DEBUG)
$aCapSpells = -1
EndIf
If $aCapTroops <> "" Then
$aTempCapTroops = StringSplit($aCapTroops, "#")
If $aTempCapTroops[0] >= 2 Then
If $g_iDebugSetlog = 1 Then Setlog("$aTempCapTroops splitted :" & $aTempCapTroops[1] & "/" & $aTempCapTroops[2], $COLOR_DEBUG)
If $aTempCapTroops[2] > 0 Then
$iDonatedTroops = $aTempCapTroops[1]
$iCapTroopsTotal = $aTempCapTroops[2]
If $iCapTroopsTotal = 0 Then
$iCapTroopsTotal = 30
EndIf
If $iCapTroopsTotal = 5 Then
$iCapTroopsTotal = 35
EndIf
EndIf
Else
Setlog("Error reading the Castle Troop Capacity...", $COLOR_ERROR)
$iDonatedTroops = 0
$iCapTroopsTotal = 0
EndIf
Else
Setlog("Error reading the Castle Troop Capacity...", $COLOR_ERROR)
$iDonatedTroops = 0
$iCapTroopsTotal = 0
EndIf
If $aCapSpells <> -1 Then
If $aCapSpells <> "" Then
$aTempCapSpells = StringSplit($aCapSpells, "#")
If $aTempCapSpells[0] >= 2 Then
If $g_iDebugSetlog = 1 Then Setlog("$aTempCapSpells splitted :" & $aTempCapSpells[1] & "/" & $aTempCapSpells[2], $COLOR_DEBUG)
If $aTempCapSpells[2] > 0 Then
$iDonatedSpells = $aTempCapSpells[1]
$iCapSpellsTotal = $aTempCapSpells[2]
EndIf
Else
Setlog("Error reading the Castle Spell Capacity...", $COLOR_ERROR)
$iDonatedSpells = 0
$iCapSpellsTotal = 0
EndIf
Else
Setlog("Error reading the Castle Spell Capacity...", $COLOR_ERROR)
$iDonatedSpells = 0
$iCapSpellsTotal = 0
EndIf
EndIf
$iTotalDonateCapacity =($iCapTroopsTotal - $iDonatedTroops)
If $aCapSpells <> -1 Then $iTotalDonateSpellCapacity =($iCapSpellsTotal - $iDonatedSpells)
If $iTotalDonateCapacity < 0 Then
SetLog("Unable to read Castle Capacity!", $COLOR_ERROR)
Else
If $aCapSpells <> -1 Then
SetLog("Chat Troops: " & $iDonatedTroops & "/" & $iCapTroopsTotal & ", Spells: " & $iDonatedSpells & "/" & $iCapSpellsTotal)
Else
SetLog("Chat Troops: " & $iDonatedTroops & "/" & $iCapTroopsTotal)
EndIf
EndIf
EndFunc
Func DetectSlotTroop(Const $iTroopIndex)
Local $FullTemp
For $Slot = 0 To 5
Local $x = 343 +(68 * $Slot)
Local $y = $DonationWindowY + 37
Local $x1 = $x + 75
Local $y1 = $y + 43
$FullTemp = SearchImgloc(@ScriptDir & "\imgxml\DonateCC", $x ,$y, $x1, $y1)
If $g_iDebugSetlog = 1 Then Setlog("Troop Slot: " & $Slot & " SearchImgloc returned >>" & $FullTemp[0] & "<<", $COLOR_DEBUG)
If StringInStr($FullTemp[0] & " ", "empty") > 0 Then ExitLoop
If $FullTemp[0] <> "" Then
For $i = $eTroopBarbarian To $eTroopBowler
Local $sTmp = StringStripWS(StringLeft($g_asTroopNames[$i], 4), $STR_STRIPTRAILING)
If StringInStr($FullTemp[0] & " ", $sTmp) > 0 Then
If $g_iDebugSetlog = 1 Then Setlog("Detected " & $g_asTroopNames[$i], $COLOR_DEBUG)
If $iTroopIndex = $i Then Return $Slot
ExitLoop
EndIf
If $i = $eTroopBowler Then
If $g_iDebugSetlog = 1 Then Setlog("Slot: " & $Slot & "Troop Detection Failed", $COLOR_DEBUG)
EndIf
Next
EndIf
Next
For $Slot = 6 To 11
Local $x = 343 +(68 *($Slot - 6))
Local $y = $DonationWindowY + 124
Local $x1 = $x + 75
Local $y1 = $y + 43
$FullTemp = SearchImgloc(@ScriptDir & "\imgxml\DonateCC", $x, $y, $x1, $y1)
If $g_iDebugSetlog = 1 Then Setlog("Troop Slot: " & $Slot & " SearchImgloc returned >>" & $FullTemp[0] & "<<", $COLOR_DEBUG)
If StringInStr($FullTemp[0] & " ", "empty") > 0 Then ExitLoop
If $FullTemp[0] <> "" Then
For $i = $eTroopBalloon To $eTroopBowler
Local $sTmp = StringStripWS(StringLeft($g_asTroopNames[$i], 4), $STR_STRIPTRAILING)
If StringInStr($FullTemp[0] & " ", $sTmp) > 0 Then
If $g_iDebugSetlog = 1 Then Setlog("Detected " & $g_asTroopNames[$i], $COLOR_DEBUG)
If $iTroopIndex = $i Then Return $Slot
ExitLoop
EndIf
If $i = $eTroopBowler Then
If $g_iDebugSetlog = 1 Then Setlog("Slot: " & $Slot & "Troop Detection Failed", $COLOR_DEBUG)
EndIf
Next
EndIf
Next
Return -1
EndFunc
Func DetectSlotSpell(Const $iSpellIndex)
Local $FullTemp
For $Slot = 12 To 17
Local $x = 343 +(68 *($Slot - 12))
Local $y = $DonationWindowY + 241
Local $x1 = $x + 75
Local $y1 = $y + 43
$FullTemp = SearchImgloc(@ScriptDir & "\imgxml\DonateCCSpells", $x, $y, $x1, $y1)
If $g_iDebugSetlog = 1 Then Setlog("Spell Slot: " & $Slot & " SearchImgloc returned >>" & $FullTemp[0] & "<<", $COLOR_DEBUG)
If StringInStr($FullTemp[0] & " ", "empty") > 0 Then ExitLoop
If $FullTemp[0] <> "" Then
For $i = $eSpellLightning To $eSpellSkeleton
Local $sTmp = StringLeft($g_asSpellNames[$i], 4)
If StringInStr($FullTemp[0] & " ", $sTmp) > 0 Then
If $g_iDebugSetlog = 1 Then Setlog("Detected " & $g_asSpellNames[$i], $COLOR_DEBUG)
If $iSpellIndex = $i Then Return $Slot
ExitLoop
EndIf
If $i = $eSpellSkeleton Then
If $g_iDebugSetlog = 1 Then Setlog("Slot: " & $Slot & "Spell Detection Failed", $COLOR_DEBUG)
EndIf
Next
EndIf
Next
Return -1
EndFunc
Func SkipDonateNearFullTroops($setlog = False, $aHeroResult = Default)
If $bDonationEnabled = False Then Return True
If $g_bDonateSkipNearFullEnable = False Then Return False
If $g_iCommandStop = 0 And $bTrainEnabled = True Then Return False
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If $g_abDonateHours[$hour[0]] = False And $g_bDonateHoursEnable = True Then Return True
If $g_bDonateSkipNearFullEnable = True Then
If(Number($ArmyCapacity) > Number($g_iDonateSkipNearFullPercent)) Then
Local $rIsWaitforHeroesActive = IsWaitforHeroesActive()
If $rIsWaitforHeroesActive = True Then
If $aHeroResult = Default Or IsArray($aHeroResult) = False Then
If OpenArmyWindow() = False Then Return False
$aHeroResult = getArmyHeroTime("all")
EndIf
If @error Or UBound($aHeroResult) < 3 Then
Setlog("getArmyHeroTime return error: #" & @error & "|IA:" & IsArray($aHeroResult) & "," & UBound($aHeroResult) & ", exit SkipDonateNearFullTroops!", $COLOR_ERROR)
Return False
EndIf
If $g_iDebugSetlog = 1 Then SetLog("getArmyHeroTime returned: " & $aHeroResult[0] & ":" & $aHeroResult[1] & ":" & $aHeroResult[2], $COLOR_DEBUG)
Local $iActiveHero = 0
Local $iHighestTime = -1
For $pTroopType = $eKing To $eWarden
For $pMatchMode = $DB To $g_iModeCount - 1
$iActiveHero = -1
If IsSearchModeActiveMini($pMatchMode) And IsSpecialTroopToBeUsed($pMatchMode, $pTroopType) And $iHeroUpgrading[$pTroopType - $eKing] <> 1 And $iHeroWaitAttackNoBit[$pMatchMode][$pTroopType - $eKing] = 1 Then
$iActiveHero = $pTroopType - $eKing
EndIf
If $iActiveHero <> -1 And $aHeroResult[$iActiveHero] > 0 Then
If $aHeroResult[$iActiveHero] > $iHighestTime Then
$iHighestTime = $aHeroResult[$iActiveHero]
EndIf
EndIf
Next
If _Sleep($iDelayRespond) Then Return
Next
If $g_iDebugSetlog = 1 Then SetLog("$iHighestTime = " & $iHighestTime & "|" & String($iHighestTime > 5), $COLOR_DEBUG)
If $iHighestTime > 5 Then
If $setlog Then Setlog("» Donations enabled, Heroes recover time is long", $COLOR_INFO)
Return False
Else
If $setlog Then Setlog("» Donation disabled, available troops " & $ArmyCapacity & "%, limit " & $g_iDonateSkipNearFullPercent & "%", $COLOR_INFO)
Return True
EndIf
Else
If $setlog Then Setlog("» Donation disabled, available troops " & $ArmyCapacity & "%, limit " & $g_iDonateSkipNearFullPercent & "%", $COLOR_INFO)
Return True
EndIf
Else
If $setlog Then Setlog("» Donations enabled, available troops " & $ArmyCapacity & "%, limit " & $g_iDonateSkipNearFullPercent & "%", $COLOR_INFO)
Return False
EndIf
Else
Return False
EndIf
EndFunc
Func BalanceDonRec($bSetlog = False)
If $bDonationEnabled = False Then Return False
If $iChkUseCCBalanced = 0 Then Return True
If $g_iCommandStop = 0 And $bTrainEnabled = True Then Return True
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If $g_abDonateHours[$hour[0]] = False And $g_bDonateHoursEnable = True Then Return False
If $iChkUseCCBalanced = 1 Then
If $TroopsDonated = 0 And $TroopsReceived = 0 Then ProfileReport()
If Number($TroopsReceived) <> 0 Then
If Number(Number($TroopsDonated) / Number($TroopsReceived)) >=(Number($iCmbCCDonated) / Number($iCmbCCReceived)) Then
If $bSetlog Then SetLog("Skipping Donation because Donate/Recieve Ratio is wrong", $COLOR_INFO)
Return False
Else
Return True
EndIf
EndIf
Else
Return True
EndIf
EndFunc
Func SearchImgloc($directory = "", $x = 0, $y = 0, $x1 = 0, $y1 = 0)
Local $aResult[1], $aCoordArray[1][2], $aCoords, $aCoordsSplit, $aValue
Local $Redlines = "FV"
_CaptureRegion2($x, $y, $x1, $y1)
Local $res = DllCall($g_hLibImgLoc, "str", "SearchMultipleTilesBetweenLevels", "handle", $hHBitmap2, "str", $directory, "str", "FV", "Int", 0, "str", $Redlines, "Int", 0, "Int", 1000)
If $res[0] <> "" Then
Local $aKeys = StringSplit($res[0], "|", $STR_NOCOUNT)
ReDim $aResult[UBound($aKeys)]
For $i = 0 To UBound($aKeys) - 1
$aResult[$i] = returnPropertyValue($aKeys[$i], "objectname")
Next
Return $aResult
EndIf
$aResult[0] = "queued"
Return $aResult
EndFunc
Func getChatStringPersian($x_start, $y_start, $bConvert = True)
Local $bUseOcrImgLoc = True
Local $OCRString = getOcrAndCapture("persian-bundle", $x_start, $y_start, 240, 20, Default, $bUseOcrImgLoc, True)
If $bConvert = True Then
$OCRString = StringReverse($OCRString)
$OCRString = StringReplace($OCRString, "A", "ا")
$OCRString = StringReplace($OCRString, "B", "ب")
$OCRString = StringReplace($OCRString, "C", "چ")
$OCRString = StringReplace($OCRString, "D", "د")
$OCRString = StringReplace($OCRString, "F", "ف")
$OCRString = StringReplace($OCRString, "G", "گ")
$OCRString = StringReplace($OCRString, "J", "ج")
$OCRString = StringReplace($OCRString, "H", "ه")
$OCRString = StringReplace($OCRString, "R", "ر")
$OCRString = StringReplace($OCRString, "K", "ک")
$OCRString = StringReplace($OCRString, "K", "ل")
$OCRString = StringReplace($OCRString, "M", "م")
$OCRString = StringReplace($OCRString, "N", "ن")
$OCRString = StringReplace($OCRString, "P", "پ")
$OCRString = StringReplace($OCRString, "S", "س")
$OCRString = StringReplace($OCRString, "T", "ت")
$OCRString = StringReplace($OCRString, "V", "و")
$OCRString = StringReplace($OCRString, "Y", "ی")
$OCRString = StringReplace($OCRString, "L", "ل")
$OCRString = StringReplace($OCRString, "Z", "ز")
$OCRString = StringReplace($OCRString, "X", "خ")
$OCRString = StringReplace($OCRString, "Q", "ق")
$OCRString = StringReplace($OCRString, ",", ",")
$OCRString = StringReplace($OCRString, "0", " ")
$OCRString = StringReplace($OCRString, "1", ".")
$OCRString = StringReplace($OCRString, "22", "ع")
$OCRString = StringReplace($OCRString, "44", "ش")
$OCRString = StringReplace($OCRString, "55", "ح")
$OCRString = StringReplace($OCRString, "66", "ض")
$OCRString = StringReplace($OCRString, "77", "ط")
$OCRString = StringReplace($OCRString, "88", "لا")
$OCRString = StringReplace($OCRString, "99", "ث")
$OCRString = StringStripWS($OCRString, 1 + 2)
EndIf
Return $OCRString
EndFunc
Func imglocTHSearch($bReTest = False, $myVillage = False, $bForceCapture = True)
Local $xdirectory = @ScriptDir & "\imgxml\Resources\TH"
Local $xdirectoryb = @ScriptDir & "\imgxml\Resources\TH2"
Local $sCocDiamond = "ECD"
Local $redLines = ""
Local $minLevel = 6
Local $maxLevel = 100
Local $maxReturnPoints = 1
Local $returnProps = "objectname,objectlevel,objectpoints,nearpoints,farpoints,redlinedistance"
If $myVillage = False Then
ResetTHsearch()
Else
$redLines = "ECD"
EndIf
Local $propsNames = StringSplit($returnProps, ",", $STR_NOCOUNT)
If $g_iDebugSetlog = 1 Then SetLog("imgloc TH search Start", $COLOR_DEBUG)
Local $numRetry = 2
For $retry = 0 To $numRetry
if $retry > 0 then $xdirectory = $xdirectoryb
IF $iDetectedImageType = 1 Then
$xdirectory = "snow-imglocth-bundle"
$xdirectoryb = "snow-imglocth2-bundle"
EndIF
if $retry > 0 and $IMGLOCREDLINE <> "" then
$redLines = $IMGLOCREDLINE
endif
Local $hTimer = TimerInit()
Local $result = findMultiple($xdirectory, $sCocDiamond, $redLines, $minLevel, $maxLevel, $maxReturnPoints, $returnProps, $bForceCapture)
If IsArray($result) Then
$redLines = $IMGLOCREDLINE
If UBound($result) = 1 Then
If $g_iDebugSetlog = 1 Then SetLog("imgloc Found TH : ", $COLOR_INFO)
Local $propsValues = $result[0]
For $pv = 0 To UBound($propsValues) - 1
If $g_iDebugSetlog = 1 Then SetLog("imgloc Found : " & $propsNames[$pv] & " - " & $propsValues[$pv], $COLOR_INFO)
Switch $propsNames[$pv]
Case "objectname"
Local $PathFile = $propsValues[$pv]
Case "objectlevel"
If $myVillage = False Then
$IMGLOCTHLEVEL = Number($propsValues[$pv])
$aTownHall[2] = Number($propsValues[$pv])
$searchTH = Number($propsValues[$pv])
Else
$iTownHallLevel = Number($propsValues[$pv])
EndIf
Case "objectpoints"
If $propsValues[$pv] = "0" Then
DebugImageSave("imglocTHSearch_NoTHFound_", True)
ResetTHsearch()
Return
EndIf
If $myVillage = False Then
$IMGLOCTHLOCATION = decodeSingleCoord($propsValues[$pv])
$aTownHall[0] = Number($IMGLOCTHLOCATION[0])
$aTownHall[1] = Number($IMGLOCTHLOCATION[1])
$THx = Number($IMGLOCTHLOCATION[0])
$THy = Number($IMGLOCTHLOCATION[1])
$THLocation = 1
If $g_iDebugImageSave = 1 and $retry > 0 then
_CaptureRegion()
Local $editedImage = $hBitmap
Local $subDirectory = @ScriptDir & "\Thdetection\"
DirCreate($subDirectory)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
Local $fileName = "Thdetection_" & $retry & "_" & $Date & "_" & $Time & ".png"
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($editedImage)
Local $hPen = _GDIPlus_PenCreate(0xFFFF0000, 2)
addInfoToDebugImage($hGraphic, $hPen, String($PathFile & "_" & $IMGLOCTHLEVEL), $THx, $THy)
_GDIPlus_ImageSaveToFile($editedImage, $subDirectory & $fileName)
_GDIPlus_PenDispose($hPen)
_GDIPlus_GraphicsDispose($hGraphic)
EndIf
Else
$TownHallPos = decodeSingleCoord($propsValues[$pv])
ConvertFromVillagePos($TownHallPos[0], $TownHallPos[1])
EndIf
Case "nearpoints"
If $myVillage = False Then
$IMGLOCTHNEAR = $propsValues[$pv]
EndIf
Case "farpoints"
If $myVillage = False Then
$IMGLOCTHFAR = $propsValues[$pv]
EndIf
Case "redlinedistance"
If $myVillage = False Then
$IMGLOCTHRDISTANCE = $propsValues[$pv]
EndIf
EndSwitch
If $myVillage = False Then
$aTownHall[3] = 1
EndIf
Next
If $g_iDebugSetlog = 1 Then SetLog("imgloc THSearch Calculated  (in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds) :")
Else
If $g_iDebugSetlog = 1 Then SetLog("imgloc Found Multiple TH : ", $COLOR_INFO)
If $g_iDebugImageSave = 1 Then DebugImageSave("imglocTHSearch_MultiMatched_", True)
If $g_iDebugSetlog = 1 Then SetLog("imgloc THSearch Calculated  (in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds) :")
EndIf
Else
If $g_iDebugSetlog = 1 and $retry > 0 Then SetLog("imgloc Could not find TH", $COLOR_WARNING)
If $g_iDebugImageSave = 1 and $retry > 0 Then DebugImageSave("imglocTHSearch_NoTHFound_", True)
If $g_iDebugSetlog = 1 and $retry > 0 Then SetLog("imgloc THSearch Calculated  (in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds) :")
EndIf
If $IMGLOCTHLEVEL > 0 Then
ExitLoop
Else
If $g_iDebugImageSave = 1 and $retry > 0 Then DebugImageSave("imglocTHSearch_NoTHFound_", True)
If $g_iDebugSetlog = 1 Then SetLog("imgloc THSearch Notfound, Retry:  " & $retry)
EndIf
$retry = $retry + 1
Next
EndFunc
Func ResetTHsearch()
$IMGLOCREDLINE = ""
$IMGLOCTHLEVEL = 0
$IMGLOCTHLOCATION = StringSplit(",", ",", $STR_NOCOUNT)
$IMGLOCTHNEAR = ""
$IMGLOCTHFAR = ""
$IMGLOCTHRDISTANCE = ""
$aTownHall[0] = -1
$aTownHall[1] = -1
$aTownHall[2] = -1
$aTownHall[3] = -1
$THx = 0
$THy = 0
$searchTH = "-"
$THLocation = 0
EndFunc
Func imgloccheckTownHallADV2($limit = 0, $tolerancefix = 0, $captureRegion = True)
imglocTHSearch(True, False, $captureRegion)
If $IMGLOCTHLEVEL = 0 Then
Return "-"
Else
Return $IMGLOCTHLEVEL
EndIf
EndFunc
Func decodeMultipleCoords($coords)
Local $retCoords[1] = [""]
Local $p, $pOff = 0
If $g_iDebugSetlog = 1 Then SetLog("**decodeMultipleCoords: " & $coords, $COLOR_ORANGE)
Local $aCoordsSplit = StringSplit($coords, "|", $STR_NOCOUNT)
If StringInStr($aCoordsSplit[0], ",") > 0 Then
Local $retCoords[UBound($aCoordsSplit)]
Else
$pOff = 1
Local $retCoords[Number($aCoordsSplit[0])]
EndIf
For $p = 0 To UBound($retCoords) - 1
$retCoords[$p] = decodeSingleCoord($aCoordsSplit[$p + $pOff])
Next
Return $retCoords
EndFunc
Func decodeSingleCoord($coords)
Local $aCoordsSplit = StringSplit($coords, ",", $STR_NOCOUNT)
If UBound($aCoordsSplit) > 1 Then
$aCoordsSplit[0] = Int($aCoordsSplit[0])
$aCoordsSplit[1] = Int($aCoordsSplit[1])
EndIf
Return $aCoordsSplit
EndFunc
Func returnImglocProperty($key, $property)
Local $aValue = DllCall($g_hLibImgLoc, "str", "GetProperty", "str", $key, "str", $property)
If checkImglocError($aValue, "returnImglocProperty") = True Then
Return ""
EndIf
Return $aValue[0]
EndFunc
Func checkImglocError($imglocvalue, $funcName)
If IsArray($imglocvalue) Then
If $imglocvalue[0] = "0" Or $imglocvalue[0] = "" Then
If $g_iDebugSetlog = 1 Then SetLog($funcName & " imgloc search returned no results!", $COLOR_RED)
Return True
ElseIf StringLeft($imglocvalue[0], 2) = "-1" Then
If $g_iDebugSetlog = 1 Then SetLog($funcName & " - Imgloc DLL Error: " + $imglocvalue[0], $COLOR_RED)
Return True
ElseIf StringLeft($imglocvalue[0], 2) = "-2" Then
SetLog($funcName & " - Imgloc DLL Critical Error", $COLOR_RED)
SetLog(StringMid($imglocvalue[0], 4), $COLOR_RED)
BotStop()
Return True
Else
Return False
EndIf
Else
If $g_iDebugSetlog = 1 Then SetLog($funcName & " - Imgloc  Error: Not an Array Result", $COLOR_RED)
Return True
EndIf
EndFunc
Func findButton($sButtonName, $buttonTileArrayOrPatternOrFullPath = Default, $maxReturnPoints = 1, $bForceCapture = True)
If $buttonTileArrayOrPatternOrFullPath = Default Then $buttonTileArrayOrPatternOrFullPath = $sButtonName & "*"
Local $error, $extError
Local $searchArea = GetButtonDiamond($sButtonName)
Local $aCoords = ""
Local $aButtons
Local $sButtons = ""
If IsString($buttonTileArrayOrPatternOrFullPath) Then
$sButtons = $buttonTileArrayOrPatternOrFullPath
If StringInStr($buttonTileArrayOrPatternOrFullPath, "*") > 0 Then
Local $aFiles = _FileListToArray(@ScriptDir & "\imgxml\imglocbuttons", $sButtons, $FLTA_FILES, True)
If UBound($aFiles) < 2 Or $aFiles[0] < 1 Then
Return SetError(1, 1, "No files in " & @ScriptDir & "\imgxml\imglocbuttons")
EndIf
Local $a[0], $j
$j = 0
For $i = 1 To $aFiles[0]
If StringRegExp($aFiles[$i], ".+[.](xml|png|bmp)$") Then
$j += 1
ReDim $a[$j]
$a[$i - 1] = $aFiles[$i]
EndIf
Next
$aButtons = $a
Else
Local $a[1] = [$sButtons]
$aButtons = $a
EndIf
ElseIf IsArray($buttonTileArrayOrPatternOrFullPath) Then
$aButtons = $buttonTileArrayOrPatternOrFullPath
$sButtons = _ArrayToString($aButtons)
Else
Return SetError(1, 2, "Bad Input Values : " & $buttonTileArrayOrPatternOrFullPath)
EndIf
If Not IsString($sButtonName) Or UBound($aButtons) < 1 Then
Return SetError(1, 3, "Bad Input Values : " & $sButtons)
EndIf
For $buttonTile In $aButtons
If FileExists($buttonTile) = 0 Then
Return SetError(1, 4, "Bad Input Values : Button Image NOT FOUND : " & $buttonTile)
EndIf
If $bForceCapture Then _CaptureRegion2()
If $g_iDebugSetlog Then SetLog(" imgloc searching for: " & $sButtonName & " : " & $buttonTile)
Local $result = DllCall($g_sLibImgLocPath, "str", "FindTile", "handle", $hHBitmap2, "str", $buttonTile, "str", $searchArea, "Int", $maxReturnPoints)
$error = @error
$extError = @extended
If $error Then
_logErrorDLLCall($g_sLibImgLocPath, $error)
SetDebugLog(" imgloc DLL Error imgloc " & $error & " --- " & $extError)
Return SetError(2, 1, $extError)
EndIf
If $result[0] <> "" And checkImglocError($result, "imglocFindButton") = False Then
If $g_iDebugSetlog Then SetLog($sButtonName & " Button Image Found in: " & $result[0])
$aCoords = StringSplit($result[0], "|", $STR_NOCOUNT)
If $maxReturnPoints = 1 Then
Return StringSplit($aCoords[1], ",", $STR_NOCOUNT)
Else
Return $result[0]
EndIf
EndIf
Next
SetDebugLog($sButtonName & " Button Image(s) NOT FOUND : " & $sButtons, $COLOR_ERROR)
Return $aCoords
EndFunc
Func GetButtonDiamond($sButtonName)
Local $btnDiamond = "FV"
Switch $sButtonName
Case "FindMatch"
$btnDiamond = "133,515|360,515|360,620|133,620"
Case "CloseFindMatch"
$btnDiamond = "780,15|830,15|830,60|780,60"
Case "CloseFindMatch"
$btnDiamond = "780,15|830,15|830,60|780,60"
Case "Attack"
$btnDiamond = "15,620|112,620|112,715|15,715"
Case "OpenTrainWindow"
$btnDiamond = "15,560|65,560|65,610|15,610"
Case "OK"
$btnDiamond = "440,395|587,395|587,460|440,460"
Case "CANCEL"
$btnDiamond = "272,395|420,395|420,460|272,460"
Case "ReturnHome"
$btnDiamond = "357,545|502,545|502,607|357,607"
Case "Next"
$btnDiamond = "697,542|850,542|850,610|697,610"
Case "ObjectButtons", "BoostOne"
$btnDiamond = GetDiamondFromRect("200,617(460,83)")
Case "GEM"
$btnDiamond = GetDiamondFromRect("359,412(148,66)")
Case "EnterShop"
$btnDiamond = GetDiamondFromRect("359,392(148,66)")
Case "EndBattleSurrender"
$btnDiamond = "12,577|125,577|125,615|12,615"
Case "ExpandChat"
$btnDiamond = "2,330|35,350|35,410|2,430"
Case "CollapseChat"
$btnDiamond = "315,334|350,350|350,410|315,430"
Case "ChatOpenRequestPage"
$btnDiamond = "5,688|65,688|65,615|5,725"
Case "Profile"
$btnDiamond = "172,15|205,15|205,48|172,48"
Case "DonateWindow"
$btnDiamond = "310,0|360,0|360,732|310,732"
Case "DonateButton"
$btnDiamond = "200,85|305,85|305,680|200,680"
Case "UpDonation"
$btnDiamond = "282,85|306,85|306,130|282,130"
Case "DownDonation"
$btnDiamond = "282,635|306,635|306,680|282,680"
Case Else
$btnDiamond = "FV"
EndSwitch
Return $btnDiamond
EndFunc
Func findImage($sImageName, $sImageTile, $sImageArea, $maxReturnPoints = 1, $bForceCapture = True)
Local $aCoords = ""
Local $iPattern = StringInStr($sImageTile, "*")
If $iPattern > 0 Then
Local $dir = ""
Local $pat = $sImageTile
Local $iLastBS = StringInStr($sImageTile, "\", 0, -1)
If $iLastBS > 0 Then
$dir = StringLeft($sImageTile, $iLastBS)
$pat = StringMid($sImageTile, $iLastBS + 1)
EndIf
Local $files = _FileListToArray($dir, $pat, $FLTA_FILES, True)
If @error Or UBound($files) < 2 Then
If $g_iDebugSetlog = 1 Then SetLog("findImage files not found : " & $sImageTile, $COLOR_ERROR)
SetError(1, 0, $aCoords)
Return
EndIf
For $i = 1 To $files[0]
$aCoords = findImage($sImageName, $files[$i], $sImageArea, $maxReturnPoints, $bForceCapture)
If UBound(decodeSingleCoord($aCoords)) > 1 Then Return $aCoords
Next
Return $aCoords
EndIf
Local $error, $extError
If Not FileExists($sImageTile) Then
If $g_iDebugSetlog = 1 Then SetLog("findImage file not found : " & $sImageTile, $COLOR_ERROR)
SetError(1, 1, $aCoords)
Return
EndIf
If $bForceCapture Then _CaptureRegion2()
If $g_iDebugSetlog Then SetLog("findImage Looking for : " & $sImageName & " : " & $sImageTile & " on " & $sImageArea)
Local $result = DllCall($g_sLibImgLocPath, "str", "FindTile", "handle", $hHBitmap2, "str", $sImageTile, "str", $sImageArea, "Int", $maxReturnPoints)
$error = @error
$extError = @extended
If $error Then
_logErrorDLLCall($g_sLibImgLocPath, $error)
If $g_iDebugSetlog Then SetLog(" imgloc DLL Error imgloc " & $error & " --- " & $extError)
SetError(2, $extError, $aCoords)
Return
EndIf
If checkImglocError($result, "findImage") = True Then
If $g_iDebugSetlog = 1 Then SetLog("findImage Returned Error or No values : ", $COLOR_DEBUG)
If $g_iDebugSetlog = 1 And $g_iDebugImageSave = 1 Then DebugImageSave("findImage_" & $sImageName, True)
Return $aCoords
EndIf
If $result[0] <> "" Then
If $g_iDebugSetlog Then SetLog("findImage : " & $sImageName & " Found in: " & $result[0])
$aCoords = StringSplit($result[0], "|", $STR_NOCOUNT)
If $maxReturnPoints = 1 Then
Return $aCoords[1]
Else
Return $result[0]
EndIf
Else
If $g_iDebugSetlog = 1 Then SetLog("findImage : " & $sImageName & " NOT FOUND " & $sImageTile)
If $g_iDebugSetlog = 1 And $g_iDebugImageSave = 1 Then DebugImageSave("findImage_" & $sImageName, True)
Return $aCoords
EndIf
EndFunc
Func GetDeployableNextTo($sPoints, $distance = 3, $redlineoverride="")
Local $result = DllCall($g_sLibImgLocPath, "str", "GetDeployableNextTo", "str", $sPoints, "int", $distance, "str" , $redlineoverride)
Local $error = @error
Local $extError = @extended
If $error Then
_logErrorDLLCall($g_sLibImgLocPath, $error)
If $g_iDebugSetlog Then SetLog(" imgloc DLL Error imgloc " & $error & " --- " & $extError)
SetError(2, $extError, "")
Return ""
EndIf
If UBound($result) = 0 Then Return ""
If $g_iDebugSetlog = 1 Then SetLog("GetDeployableNextTo : " & $sPoints & ", dist. = " & $distance & " : " & $result[0], $COLOR_ORANGE)
Return $result[0]
EndFunc
Func GetOffsetRedline($sArea = "TL", $distance = 3)
Local $result = DllCall($g_sLibImgLocPath, "str", "GetOffSetRedline", "str", $sArea, "int", $distance)
Local $error = @error
Local $extError = @extended
If $error Then
_logErrorDLLCall($g_sLibImgLocPath, $error)
If $g_iDebugSetlog Then SetLog(" imgloc DLL Error imgloc " & $error & " --- " & $extError)
SetError(2, $extError, "")
Return ""
EndIf
If UBound($result) = 0 Then Return ""
If $g_iDebugSetlog = 1 Then SetLog("GetOffSetRedline : " & $sArea & ", dist. = " & $distance & " : " & $result[0], $COLOR_ORANGE)
Return $result[0]
EndFunc
Func findMultiple($directory, $sCocDiamond, $redLines, $minLevel = 0, $maxLevel = 1000, $maxReturnPoints = 0, $returnProps = "objectname,objectlevel,objectpoints", $bForceCapture = True)
If $g_iDebugSetlog = 1 Then
SetLog("******** findMultiple *** START ***", $COLOR_ORANGE)
SetLog("findMultiple : directory : " & $directory, $COLOR_ORANGE)
SetLog("findMultiple : sCocDiamond : " & $sCocDiamond, $COLOR_ORANGE)
SetLog("findMultiple : redLines : " & $redLines, $COLOR_ORANGE)
SetLog("findMultiple : minLevel : " & $minLevel, $COLOR_ORANGE)
SetLog("findMultiple : maxLevel : " & $maxLevel, $COLOR_ORANGE)
SetLog("findMultiple : maxReturnPoints : " & $maxReturnPoints, $COLOR_ORANGE)
SetLog("findMultiple : returnProps : " & $returnProps, $COLOR_ORANGE)
SetLog("******** findMultiple *** START ***", $COLOR_ORANGE)
EndIf
Local $error, $extError
Local $aCoords = ""
Local $returnData = StringSplit($returnProps, ",", $STR_NOCOUNT)
Local $returnLine[UBound($returnData)]
Local $returnValues[0]
If $bForceCapture Then _CaptureRegion2()
Local $result = DllCall($g_sLibImgLocPath, "str", "SearchMultipleTilesBetweenLevels", "handle", $hHBitmap2, "str", $directory, "str", $sCocDiamond, "Int", $maxReturnPoints, "str", $redLines, "Int", $minLevel, "Int", $maxLevel)
$error = @error
$extError = @extended
If $error Then
_logErrorDLLCall($g_sLibImgLocPath, $error)
If $g_iDebugSetlog = 1 Then SetLog(" imgloc DLL Error : " & $error & " --- " & $extError)
SetError(2, $extError, $aCoords)
Return ""
EndIf
If checkImglocError($result, "findMultiple") = True Then
If $g_iDebugSetlog = 1 Then SetLog("findMultiple Returned Error or No values : ", $COLOR_DEBUG)
If $g_iDebugSetlog = 1 Then SetLog("******** findMultiple *** END ***", $COLOR_ORANGE)
Return ""
Else
If $g_iDebugSetlog = 1 Then SetLog("findMultiple found : " & $result[0])
EndIf
If $result[0] <> "" Then
Local $resultArr = StringSplit($result[0], "|", $STR_NOCOUNT)
ReDim $returnValues[UBound($resultArr)]
For $rs = 0 To UBound($resultArr) - 1
For $rD = 0 To UBound($returnData) - 1
$returnLine[$rD] = returnImglocProperty($resultArr[$rs], $returnData[$rD])
If $g_iDebugSetlog = 1 Then SetLog("findMultiple : " & $resultArr[$rs] & "->" & $returnData[$rD] & " -> " & $returnLine[$rD])
Next
$returnValues[$rs] = $returnLine
Next
If $redLines = "" Then
$IMGLOCREDLINE = returnImglocProperty("redline", "")
If $g_iDebugSetlog = 1 Then SetLog("findMultiple : Redline argument is emty, seting global Redlines")
EndIf
If $g_iDebugSetlog = 1 Then SetLog("******** findMultiple *** END ***", $COLOR_ORANGE)
Return $returnValues
Else
If $g_iDebugSetlog = 1 Then SetLog(" ***  findMultiple has no result **** ", $COLOR_ORANGE)
If $g_iDebugSetlog = 1 Then SetLog("******** findMultiple *** END ***", $COLOR_ORANGE)
Return ""
EndIf
EndFunc
Func ReCheckTile($filePath, $coords, $bForceCapture = True)
Local $ToReturn = ""
If $bForceCapture Then _CaptureRegion2()
Local $result = DllCall($g_sLibImgLocPath, "str", "RecheckTile", "handle", $hHBitmap2, "str", $filePath, "str", $coords)
Local $error = @error
Local $extError = @extended
If $error Then
_logErrorDLLCall($g_sLibImgLocPath, $error)
If $g_iDebugSetlog = 1 Then SetLog(" imgloc DLL Error : " & $error & " --- " & $extError)
SetError(2, $extError, $ToReturn)
Return ""
EndIf
If $result[0] <> "" Then
$ToReturn = $result[0]
EndIf
Return $ToReturn
EndFunc
Func GetDiamondFromRect($rect)
Local $returnvalue = "", $i
If $g_iDebugSetlog = 1 Then SetLog("GetDiamondFromRect : > " & $rect, $COLOR_INFO)
Local $RectValues = StringSplit($rect, ",", $STR_NOCOUNT)
If UBound($RectValues) = 3 Then
ReDim $RectValues[4]
$i = StringInStr($RectValues[2], ")")
If $i = 0 Then
SetDebugLog("GetDiamondFromRect : Bad Input Values : " & $rect, $COLOR_ERROR)
Return SetError(1, 1, $returnvalue)
EndIf
$RectValues[3] = $RectValues[1] + StringLeft($RectValues[2], $i - 1) - 1
$i = StringInStr($RectValues[1], "(")
If $i = 0 Then
SetDebugLog("GetDiamondFromRect : Bad Input Values : " & $rect, $COLOR_ERROR)
Return SetError(1, 2, $returnvalue)
EndIf
$RectValues[2] = $RectValues[0] + StringMid($RectValues[1], $i + 1) - 1
$RectValues[1] = StringLeft($RectValues[1], $i - 1)
EndIf
If UBound($RectValues) < 4 Then
SetDebugLog("GetDiamondFromRect : Bad Input Values : " & $rect, $COLOR_ERROR)
Return SetError(1, 3, $returnvalue)
EndIf
Local $DiamdValues[4]
Local $X = Number($RectValues[0])
Local $Y = Number($RectValues[1])
Local $Ex = Number($RectValues[2])
Local $Ey = Number($RectValues[3])
$DiamdValues[0] = $X & "," & $Y
$DiamdValues[1] = $Ex & "," & $Y
$DiamdValues[2] = $Ex & "," & $Ey
$DiamdValues[3] = $X & "," & $Ey
$returnvalue = $DiamdValues[0] & "|" & $DiamdValues[1] & "|" & $DiamdValues[2] & "|" & $DiamdValues[3]
If $g_iDebugSetlog = 1 Then SetLog("GetDiamondFromRect : < " & $returnvalue, $COLOR_INFO)
Return $returnvalue
EndFunc
Func FindImageInPlace($sImageName, $sImageTile, $place, $bForceCaptureRegion = True)
If $g_iDebugSetlog = 1 Then SetLog("FindImageInPlace : > " & $sImageName & " - " & $sImageTile & " - " & $place, $COLOR_INFO)
Local $returnvalue = ""
Local $sImageArea = GetDiamondFromRect($place)
Local $aPlaces = StringSplit($place, ",", $STR_NOCOUNT)
If $bForceCaptureRegion = True Then
$sImageArea = "FV"
_CaptureRegion2(Number($aPlaces[0]), Number($aPlaces[1]), Number($aPlaces[2]), Number($aPlaces[3]))
EndIf
Local $coords = findImage($sImageName, $sImageTile, $sImageArea, 1, False)
Local $aCoords = decodeSingleCoord($coords)
If UBound($aCoords) < 2 Then
If $g_iDebugSetlog = 1 Then SetLog("FindImageInPlace : " & $sImageName & " NOT Found", $COLOR_INFO)
Return ""
EndIf
If $bForceCaptureRegion = True Then
$returnvalue = Number($aCoords[0]) + Number($aPlaces[0]) & "," & Number($aCoords[1]) + Number($aPlaces[1])
Else
$returnvalue = Number($aCoords[0]) & "," & Number($aCoords[1])
EndIf
If $g_iDebugSetlog = 1 Then SetLog("FindImageInPlace : < " & $sImageName & " Found in " & $returnvalue, $COLOR_INFO)
Return $returnvalue
EndFunc
Func SearchRedLines($sCocDiamond = "ECD")
If $IMGLOCREDLINE <> "" Then Return $IMGLOCREDLINE
Local $result = DllCall($g_hLibImgLoc, "str", "SearchRedLines", "handle", $hHBITMAP2, "str", $sCocDiamond)
Local $error = @error
Local $extError = @extended
If $error Then
_logErrorDLLCall($g_sLibImgLocPath, $error)
If $g_iDebugSetlog = 1 Then SetLog(" imgloc DLL Error : " & $error & " --- " & $extError)
SetError(2, $extError)
Return ""
EndIf
If checkImglocError($result, "SearchRedLines") = True Then
If $g_iDebugSetlog = 1 Then SetLog("SearchRedLines Returned Error or No values : ", $COLOR_DEBUG)
If $g_iDebugSetlog = 1 Then SetLog("******** SearchRedLines *** END ***", $COLOR_ORANGE)
Return ""
Else
If $g_iDebugSetlog = 1 Then SetLog("SearchRedLines found : " & $result[0])
EndIf
$IMGLOCREDLINE = $result[0]
Return $IMGLOCREDLINE
EndFunc
Func SearchRedLinesMultipleTimes($sCocDiamond = "ECD", $iCount = 3, $iDelay = 300)
Local $bHBITMAP_synced =($hHBITMAP = $hHBITMAP2)
Local $hHBITMAP2_old = $hHBITMAP2
Local $IMGLOCREDLINE_old
SearchRedLines($sCocDiamond)
Local $iRedlinePoints = [UBound(StringSplit($IMGLOCREDLINE, "|", $STR_NOCOUNT)), 0]
SetDebugLog("Initial # of redline points: " & $iRedlinePoints[0])
$hHBITMAP2 = 0
Local $iCaptureTime = 0
Local $iRedlineTime = 0
Local $aiTotals = [0, 0]
Local $iBest = 0
For $i = 1 To $iCount
$IMGLOCREDLINE_old = $IMGLOCREDLINE
Local $hTimer = TimerInit()
ForceCaptureRegion()
_CaptureRegion2()
$iCaptureTime = TimerDiff($hTimer)
$IMGLOCREDLINE = ""
SearchRedLines($sCocDiamond)
$iRedlineTime = TimerDiff($hTimer) - $iCaptureTime
$aiTotals[0] += $iCaptureTime
$aiTotals[1] += $iRedlineTime
$iRedlinePoints[1] = UBound(StringSplit($IMGLOCREDLINE, "|", $STR_NOCOUNT))
SetDebugLog($i & ". # of redline points: " & $iRedlinePoints[1])
If $iRedlinePoints[1] > $iRedlinePoints[0] Then
$iRedlinePoints[0] = $iRedlinePoints[1]
$iBest = $i
Else
$IMGLOCREDLINE = $IMGLOCREDLINE_old
EndIf
If $i < $iCount Then
Local $iDelayCompensated = $iDelay - TimerDiff($hTimer)
If $iDelayCompensated >= 10 Then Sleep($iDelayCompensated)
EndIf
Next
If $iBest = 0 Then
SetDebugLog("Using initial redline with " & $iRedlinePoints[0] & " points")
Else
SetDebugLog("Using " & $iBest & ". redline with " & $iRedlinePoints[0] & " points (capture/redline avg. time: " & Int($aiTotals[0] / $iCount) & "/" & Int($aiTotals[1] / $iCount) & ")")
EndIf
_WinAPI_DeleteObject($hHBITMAP2)
If $bHBITMAP_synced Then
_CaptureRegion2Sync()
Else
$hHBITMAP2 = $hHBITMAP2_old
EndIf
Return $IMGLOCREDLINE
EndFunc
Func decodeTroopEnum($tEnum)
Switch $tEnum
Case $eBarb
Return "Barbarian"
Case $eArch
Return "Archer"
Case $eBall
Return "Balloon"
Case $eDrag
Return "Dragon"
Case $eGiant
Return "Giant"
Case $eGobl
Return "Goblin"
Case $eGole
Return "Golem"
Case $eHeal
Return "Healer"
Case $eHogs
Return "HogRider"
Case $eKing
Return "King"
Case $eLava
Return "LavaHound"
Case $eMini
Return "Minion"
Case $ePekk
Return "Pekka"
Case $eQueen
Return "Queen"
Case $eValk
Return "Valkyrie"
Case $eWall
Return "WallBreaker"
Case $eWarden
Return "Warden"
Case $eWitc
Return "Witch"
Case $eWiza
Return "Wizard"
Case $eBabyD
Return "BabyDragon"
Case $eMine
Return "Miner"
Case $eBowl
Return "Bowler"
Case $eESpell
Return "EarthquakeSpell"
Case $eFSpell
Return "FreezeSpell"
Case $eHaSpell
Return "HasteSpell"
Case $eHSpell
Return "HealSpell"
Case $eJSpell
Return "JumpSpell"
Case $eLSpell
Return "LightningSpell"
Case $ePSpell
Return "PoisonSpell"
Case $eRSpell
Return "RageSpell"
Case $eSkSpell
Return "SkeletonSpell"
Case $eCSpell
Return "CloneSpell"
Case $eCastle
Return "Castle"
EndSwitch
EndFunc
Func decodeTroopName($sName)
Switch $sName
Case "Barbarian"
Return $eBarb
Case "Archer"
Return $eArch
Case "Balloon"
Return $eBall
Case "Dragon"
Return $eDrag
Case "Giant"
Return $eGiant
Case "Goblin"
Return $eGobl
Case "Golem"
Return $eGole
Case "Healer"
Return $eHeal
Case "HogRider"
Return $eHogs
Case "King"
Return $eKing
Case "LavaHound"
Return $eLava
Case "Minion"
Return $eMini
Case "Pekka"
Return $ePekk
Case "Queen"
Return $eQueen
Case "Valkyrie"
Return $eValk
Case "WallBreaker"
Return $eWall
Case "Warden"
Return $eWarden
Case "Witch"
Return $eWitc
Case "Wizard"
Return $eWiza
Case "BabyDragon"
Return $eBabyD
Case "Miner"
Return $eMine
Case "Bowler"
Return $eBowl
Case "EarthquakeSpell"
Return $eESpell
Case "FreezeSpell"
Return $eFSpell
Case "HasteSpell"
Return $eHaSpell
Case "HealSpell"
Return $eHSpell
Case "JumpSpell"
Return $eJSpell
Case "LightningSpell"
Return $eLSpell
Case "PoisonSpell"
Return $ePSpell
Case "RageSpell"
Return $eRSpell
Case "SkeletonSpell"
Return $eSkSpell
Case "CloneSpell"
Return $eCSpell
Case "Castle"
Return $eCastle
EndSwitch
EndFunc
Func GetDummyRectangle($sCoords, $ndistance)
Local $aCoords = StringSplit($sCoords, ",", $STR_NOCOUNT)
Return Number($aCoords[0]) - $ndistance & "," & Number($aCoords[1]) - $ndistance & "," & Number($aCoords[0]) + $ndistance & "," & Number($aCoords[1]) + $ndistance
EndFunc
Global $ResetStats = 0
Func UpdateStats($bForceUpdateAll = False)
Local $bDonateTroopsStatsChanged = False, $bDonateSpellsStatsChanged = False
Local Static $iOldFreeBuilderCount[9], $iOldTotalBuilderCount[9], $iOldGemAmount[9]
Local Static $iOldGoldCurrent[9], $iOldElixirCurrent[9], $iOldDarkCurrent[9], $iOldTrophyCurrent[9]
Local Static $iOldSkippedVillageCount[9], $iOldDroppedTrophyCount[9]
Local Static $iOldSearchCost[9], $iOldTrainCostElixir[9], $iOldTrainCostDElixir[9]
Local Static $iOldGoldFromMines[9], $iOldElixirFromCollectors[9], $iOldDElixirFromDrills[9]
Local Static $iOldNbrOfWallsUppedGold[9], $iOldNbrOfWallsUppedElixir[9], $iOldNbrOfBuildingsUppedGold[9], $iOldNbrOfBuildingsUppedElixir[9], $iOldNbrOfHeroesUpped[9]
Local Static $iOldCostGoldWall[9], $iOldCostElixirWall[9], $iOldCostGoldBuilding[9], $iOldCostElixirBuilding[9], $iOldCostDElixirHero[9]
Local Static $iOldAttackedCount = 0, $iOldAttackedVillageCount[9][$g_iModeCount + 1]
Local Static $iOldTotalGoldGain[9][$g_iModeCount + 1], $iOldTotalElixirGain[9][$g_iModeCount + 1], $iOldTotalDarkGain[9][$g_iModeCount + 1], $iOldTotalTrophyGain[9][$g_iModeCount + 1]
Local Static $iOldNbrOfDetectedMines[9][$g_iModeCount + 1], $iOldNbrOfDetectedCollectors[9][$g_iModeCount + 1], $iOldNbrOfDetectedDrills[9][$g_iModeCount + 1]
Local Static $iOldNbrOfTHSnipeFails[9], $iOldNbrOfTHSnipeSuccess[9]
Local static $s_iOldSmartZapGain[9], $s_iOldNumLSpellsUsed[9], $s_iOldNumEQSpellsUsed[9]
Local Static $iOldGoldTotal = 0, $iOldElixirTotal = 0, $iOldDarkTotal = 0, $iOldTrophyTotal = 0
Local Static $iOldGoldLast = 0, $iOldElixirLast = 0, $iOldDarkLast = 0, $iOldTrophyLast = 0
Local Static $iOldGoldLastBonus = 0, $iOldElixirLastBonus = 0, $iOldDarkLastBonus = 0
Local Static $iOldNbrOfOoS = 0
Local Static $topgoldloot = 0
Local Static $topelixirloot = 0
Local Static $topdarkloot = 0
Local Static $topTrophyloot = 0
If $g_iFirstRun = 1 Then
GUICtrlSetState($g_hLblVillageReportTemp, $GUI_HIDE)
GUICtrlSetState($g_hPicResultGoldTemp, $GUI_HIDE)
GUICtrlSetState($g_hPicResultElixirTemp, $GUI_HIDE)
GUICtrlSetState($g_hPicResultDETemp, $GUI_HIDE)
GUICtrlSetState($g_hLblResultGoldNow, $GUI_SHOW + $GUI_DISABLE)
GUICtrlSetState($g_hPicResultGoldNow, $GUI_SHOW)
GUICtrlSetState($g_hLblResultElixirNow, $GUI_SHOW)
GUICtrlSetState($g_hPicResultElixirNow, $GUI_SHOW)
If $iDarkCurrent <> "" Then
GUICtrlSetState($g_hLblResultDeNow, $GUI_SHOW)
GUICtrlSetState($g_hPicResultDeNow, $GUI_SHOW)
Else
GUICtrlSetState($g_hPicResultDEStart, $GUI_HIDE)
GUICtrlSetState($g_hPicDarkLoot, $GUI_HIDE)
GUICtrlSetState($g_hPicDarkLastAttack, $GUI_HIDE)
GUICtrlSetState($g_hPicHourlyStatsDark, $GUI_HIDE)
EndIf
GUICtrlSetState($g_hLblResultTrophyNow, $GUI_SHOW)
GUICtrlSetState($g_hLblResultBuilderNow, $GUI_SHOW)
GUICtrlSetState($g_hLblResultGemNow, $GUI_SHOW)
btnVillageStat("UpdateStats")
$g_iStatsStartedWith[$CurrentAccount][$eLootGold] = $iGoldCurrent
$g_iStatsStartedWith[$CurrentAccount][$eLootElixir] = $iElixirCurrent
$g_iStatsStartedWith[$CurrentAccount][$eLootDarkElixir] = $iDarkCurrent
$g_iStatsStartedWith[$CurrentAccount][$eLootTrophy] = $iTrophyCurrent
$g_iFirstRun = 0
EndIf
GUICtrlSetState($btnResetStats, $GUI_ENABLE)
If $g_iFirstAttack = 1 Then
$g_iFirstAttack = 2
EndIf
GUICtrlSetData($g_ahLblStatsStartedWith[$eLootGold], _NumberFormat($g_iStatsStartedWith[$CurrentAccount][$eLootGold], True))
GUICtrlSetData($g_ahLblStatsStartedWith[$eLootElixir], _NumberFormat($g_iStatsStartedWith[$CurrentAccount][$eLootElixir], True))
GUICtrlSetData($g_ahLblStatsStartedWith[$eLootTrophy], _NumberFormat($g_iStatsStartedWith[$CurrentAccount][$eLootTrophy], True))
If $g_iStatsStartedWith[$CurrentAccount][$eLootDarkElixir] <> "" Then
GUICtrlSetData($g_ahLblStatsStartedWith[$eLootDarkElixir], _NumberFormat($g_iStatsStartedWith[$CurrentAccount][$eLootDarkElixir], True))
EndIf
If $g_iFirstAttack = 2 Then
GUICtrlSetData($g_ahLblStatsGainPerHour[$eLootGold], _NumberFormat(Round($g_iStatsTotalGain[$CurrentAccount][$eLootGold] /(Int(TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600)) & "k / h")
GUICtrlSetData($g_ahLblStatsGainPerHour[$eLootElixir], _NumberFormat(Round($g_iStatsTotalGain[$CurrentAccount][$eLootElixir] /(Int(TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600)) & "k / h")
If $g_iStatsStartedWith[$CurrentAccount][$eLootDarkElixir] <> "" Then
GUICtrlSetData($g_ahLblStatsGainPerHour[$eLootDarkElixir], _NumberFormat(Round($g_iStatsTotalGain[$CurrentAccount][$eLootDarkElixir] /(Int(TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600 * 1000)) & " / h")
EndIf
GUICtrlSetData($g_ahLblStatsGainPerHour[$eLootTrophy], _NumberFormat(Round($g_iStatsTotalGain[$CurrentAccount][$eLootTrophy] /(Int(TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600 * 1000)) & " / h")
GUICtrlSetData($g_hLblResultGoldHourNow, _NumberFormat(Round($g_iStatsTotalGain[$CurrentAccount][$eLootGold] /(Int(TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600)) & "k / h")
GUICtrlSetData($g_hLblResultElixirHourNow, _NumberFormat(Round($g_iStatsTotalGain[$CurrentAccount][$eLootElixir] /(Int(TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600)) & "k / h")
If $g_iStatsStartedWith[$CurrentAccount][$eLootDarkElixir] <> "" Then
GUICtrlSetData($g_hLblResultDEHourNow, _NumberFormat(Round($g_iStatsTotalGain[$CurrentAccount][$eLootDarkElixir] /(Int(TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600 * 1000)) & " / h")
EndIf
EndIf
If $bForceUpdateAll = True Or($iOldGoldTotal <> $g_iStatsTotalGain[$CurrentAccount][$eLootGold] And($g_iFirstAttack = 2 Or $ResetStats = 1)) Then
GUICtrlSetData($g_ahLblStatsTotalGain[$eLootGold], _NumberFormat($g_iStatsTotalGain[$CurrentAccount][$eLootGold]))
$iOldGoldTotal = $g_iStatsTotalGain[$CurrentAccount][$eLootGold]
EndIf
If $bForceUpdateAll = True Or($iOldElixirTotal <> $g_iStatsTotalGain[$CurrentAccount][$eLootElixir] And($g_iFirstAttack = 2 Or $ResetStats = 1)) Then
GUICtrlSetData($g_ahLblStatsTotalGain[$eLootElixir], _NumberFormat($g_iStatsTotalGain[$CurrentAccount][$eLootElixir]))
$iOldElixirTotal = $g_iStatsTotalGain[$CurrentAccount][$eLootElixir]
EndIf
If $bForceUpdateAll = True Or($iOldDarkTotal <> $g_iStatsTotalGain[$CurrentAccount][$eLootDarkElixir] And(($g_iFirstAttack = 2 And $g_iStatsStartedWith[$CurrentAccount][$eLootDarkElixir] <> "") Or $ResetStats = 1)) Then
GUICtrlSetData($g_ahLblStatsTotalGain[$eLootDarkElixir], _NumberFormat($g_iStatsTotalGain[$CurrentAccount][$eLootDarkElixir]))
$iOldDarkTotal = $g_iStatsTotalGain[$CurrentAccount][$eLootDarkElixir]
EndIf
If $bForceUpdateAll = True Or($iOldTrophyTotal <> $g_iStatsTotalGain[$CurrentAccount][$eLootTrophy] And($g_iFirstAttack = 2 Or $ResetStats = 1)) Then
GUICtrlSetData($g_ahLblStatsTotalGain[$eLootTrophy], _NumberFormat($g_iStatsTotalGain[$CurrentAccount][$eLootTrophy]))
$iOldTrophyTotal = $g_iStatsTotalGain[$CurrentAccount][$eLootTrophy]
EndIf
If $bForceUpdateAll = True Or $iOldGoldLast <> $g_iStatsLastAttack[$CurrentAccount][$eLootGold] Then
GUICtrlSetData($g_ahLblStatsLastAttack[$eLootGold], _NumberFormat($g_iStatsLastAttack[$CurrentAccount][$eLootGold]))
$iOldGoldLast = $g_iStatsLastAttack[$CurrentAccount][$eLootGold]
EndIf
If $bForceUpdateAll = True Or $iOldElixirLast <> $g_iStatsLastAttack[$CurrentAccount][$eLootElixir] Then
GUICtrlSetData($g_ahLblStatsLastAttack[$eLootElixir], _NumberFormat($g_iStatsLastAttack[$CurrentAccount][$eLootElixir]))
$iOldElixirLast = $g_iStatsLastAttack[$CurrentAccount][$eLootElixir]
EndIf
If $bForceUpdateAll = True Or $iOldDarkLast <> $g_iStatsLastAttack[$CurrentAccount][$eLootDarkElixir] Then
GUICtrlSetData($g_ahLblStatsLastAttack[$eLootDarkElixir], _NumberFormat($g_iStatsLastAttack[$CurrentAccount][$eLootDarkElixir]))
$iOldDarkLast = $g_iStatsLastAttack[$CurrentAccount][$eLootDarkElixir]
EndIf
If $bForceUpdateAll = True Or $iOldTrophyLast <> $g_iStatsLastAttack[$CurrentAccount][$eLootTrophy] Then
GUICtrlSetData($g_ahLblStatsLastAttack[$eLootTrophy], _NumberFormat($g_iStatsLastAttack[$CurrentAccount][$eLootTrophy]))
$iOldTrophyLast = $g_iStatsLastAttack[$CurrentAccount][$eLootTrophy]
EndIf
If $bForceUpdateAll = True Or $iOldGoldLastBonus <> $g_iStatsBonusLast[$CurrentAccount][$eLootGold] Then
GUICtrlSetData($g_ahLblStatsBonusLast[$eLootGold], _NumberFormat($g_iStatsBonusLast[$CurrentAccount][$eLootGold]))
$iOldGoldLastBonus = $g_iStatsBonusLast[$CurrentAccount][$eLootGold]
EndIf
If $bForceUpdateAll = True Or $iOldElixirLastBonus <> $g_iStatsBonusLast[$CurrentAccount][$eLootElixir] Then
GUICtrlSetData($g_ahLblStatsBonusLast[$eLootElixir], _NumberFormat($g_iStatsBonusLast[$CurrentAccount][$eLootElixir]))
$iOldElixirLastBonus = $g_iStatsBonusLast[$CurrentAccount][$eLootElixir]
EndIf
If $bForceUpdateAll = True Or $iOldDarkLastBonus <> $g_iStatsBonusLast[$CurrentAccount][$eLootDarkElixir] Then
GUICtrlSetData($g_ahLblStatsBonusLast[$eLootDarkElixir], _NumberFormat($g_iStatsBonusLast[$CurrentAccount][$eLootDarkElixir]))
$iOldDarkLastBonus = $g_iStatsBonusLast[$CurrentAccount][$eLootDarkElixir]
EndIf
If Number($g_iStatsLastAttack[$CurrentAccount][$eLootGold]) > Number($topgoldloot) Then
$topgoldloot = $g_iStatsLastAttack[$CurrentAccount][$eLootGold]
GUICtrlSetData($g_ahLblStatsTop[$eLootGold], _NumberFormat($topgoldloot))
EndIf
If Number($g_iStatsLastAttack[$CurrentAccount][$eLootElixir]) > Number($topelixirloot) Then
$topelixirloot = $g_iStatsLastAttack[$CurrentAccount][$eLootElixir]
GUICtrlSetData($g_ahLblStatsTop[$eLootElixir], _NumberFormat($topelixirloot))
EndIf
If Number($g_iStatsLastAttack[$CurrentAccount][$eLootDarkElixir]) > Number($topdarkloot) Then
$topdarkloot = $g_iStatsLastAttack[$CurrentAccount][$eLootDarkElixir]
GUICtrlSetData($g_ahLblStatsTop[$eLootDarkElixir], _NumberFormat($topdarkloot))
EndIf
If Number($g_iStatsLastAttack[$CurrentAccount][$eLootTrophy]) > Number($topTrophyloot) Then
$topTrophyloot = $g_iStatsLastAttack[$CurrentAccount][$eLootTrophy]
GUICtrlSetData($g_ahLblStatsTop[$eLootTrophy], _NumberFormat($topTrophyloot))
EndIf
If $bForceUpdateAll = True Or $iOldNbrOfOoS <> $iNbrOfOoS Then
GUICtrlSetData($g_hLblNbrOfOoS, $iNbrOfOoS)
$iOldNbrOfOoS = $iNbrOfOoS
EndIf
If $bForceUpdateAll = True Or $iOldSkippedVillageCount[$CurrentAccount] <> $g_iSkippedVillageCount[$CurrentAccount] Then
GUICtrlSetData($g_hLblResultVillagesSkipped, _NumberFormat($g_iSkippedVillageCount[$CurrentAccount], True))
GUICtrlSetData($g_hLblResultSkippedHourNow, _NumberFormat($g_iSkippedVillageCount[$CurrentAccount], True))
$iOldSkippedVillageCount[$CurrentAccount] = $g_iSkippedVillageCount[$CurrentAccount]
EndIf
If $bForceUpdateAll = True Or $iOldDroppedTrophyCount[$CurrentAccount] <> $g_iDroppedTrophyCount[$CurrentAccount] Then
GUICtrlSetData($g_hLblResultTrophiesDropped, _NumberFormat($g_iDroppedTrophyCount[$CurrentAccount], True))
$iOldDroppedTrophyCount[$CurrentAccount] = $g_iDroppedTrophyCount[$CurrentAccount]
EndIf
If $bForceUpdateAll = True Or $iOldSearchCost[$CurrentAccount] <> $g_iSearchCost[$CurrentAccount] Then
GUICtrlSetData($g_hLblSearchCost, _NumberFormat($g_iSearchCost[$CurrentAccount], True))
$iOldSearchCost[$CurrentAccount] = $g_iSearchCost[$CurrentAccount]
EndIf
If $bForceUpdateAll = True Or $iOldTrainCostElixir[$CurrentAccount] <> $g_iTrainCostElixir[$CurrentAccount] Then
GUICtrlSetData($g_hLblTrainCostElixir, _NumberFormat($g_iTrainCostElixir[$CurrentAccount], True))
$iOldTrainCostElixir[$CurrentAccount] = $g_iTrainCostElixir[$CurrentAccount]
EndIf
If $bForceUpdateAll = True Or $iOldTrainCostDElixir[$CurrentAccount] <> $g_iTrainCostDElixir[$CurrentAccount] Then
GUICtrlSetData($g_hLblTrainCostDElixir, _NumberFormat($g_iTrainCostDElixir[$CurrentAccount], True))
$iOldTrainCostDElixir[$CurrentAccount] = $g_iTrainCostDElixir[$CurrentAccount]
EndIf
If $bForceUpdateAll = True Or $iOldGoldFromMines[$CurrentAccount] <> $g_iGoldFromMines[$CurrentAccount] Then
GUICtrlSetData($g_hLblGoldFromMines, _NumberFormat($g_iGoldFromMines[$CurrentAccount], True))
$iOldGoldFromMines[$CurrentAccount] = $g_iGoldFromMines[$CurrentAccount]
EndIf
If $bForceUpdateAll = True Or $iOldElixirFromCollectors[$CurrentAccount] <> $g_iElixirFromCollectors[$CurrentAccount] Then
GUICtrlSetData($g_hLblElixirFromCollectors, _NumberFormat($g_iElixirFromCollectors[$CurrentAccount], True))
$iOldElixirFromCollectors[$CurrentAccount] = $g_iElixirFromCollectors[$CurrentAccount]
EndIf
If $bForceUpdateAll = True Or $iOldDElixirFromDrills[$CurrentAccount] <> $g_iDElixirFromDrills[$CurrentAccount] Then
GUICtrlSetData($g_hLblDElixirFromDrills, _NumberFormat($g_iDElixirFromDrills[$CurrentAccount], True))
$iOldDElixirFromDrills[$CurrentAccount] = $g_iDElixirFromDrills[$CurrentAccount]
EndIf
If $bForceUpdateAll = True Or $iOldNbrOfWallsUppedGold[$CurrentAccount] <> Number($g_iNbrOfWallsUppedGold[$CurrentAccount]) Then
GUICtrlSetData($g_hLblWallGoldMake, Number($g_iNbrOfWallsUppedGold[$CurrentAccount]))
$iOldNbrOfWallsUppedGold[$CurrentAccount] = Number($g_iNbrOfWallsUppedGold[$CurrentAccount])
WallsStatsMAJ()
EndIf
If $bForceUpdateAll = True Or $iOldNbrOfWallsUppedElixir[$CurrentAccount] <> Number($g_iNbrOfWallsUppedElixir[$CurrentAccount]) Then
GUICtrlSetData($g_hLblWallElixirMake, Number($g_iNbrOfWallsUppedElixir[$CurrentAccount]))
$iOldNbrOfWallsUppedElixir[$CurrentAccount] = Number($g_iNbrOfWallsUppedElixir[$CurrentAccount])
WallsStatsMAJ()
EndIf
If $bForceUpdateAll = True Or $iOldNbrOfBuildingsUppedGold[$CurrentAccount] <> $g_iNbrOfBuildingsUppedGold[$CurrentAccount] Then
GUICtrlSetData($g_hLblNbrOfBuildingUpgGold, $g_iNbrOfBuildingsUppedGold[$CurrentAccount])
$iOldNbrOfBuildingsUppedGold[$CurrentAccount] = $g_iNbrOfBuildingsUppedGold[$CurrentAccount]
EndIf
If $bForceUpdateAll = True Or $iOldNbrOfBuildingsUppedElixir[$CurrentAccount] <> $g_iNbrOfBuildingsUppedElixir[$CurrentAccount] Then
GUICtrlSetData($g_hLblNbrOfBuildingUpgElixir, $g_iNbrOfBuildingsUppedElixir[$CurrentAccount])
$iOldNbrOfBuildingsUppedElixir[$CurrentAccount] = $g_iNbrOfBuildingsUppedElixir[$CurrentAccount]
EndIf
If $bForceUpdateAll = True Or $iOldNbrOfHeroesUpped[$CurrentAccount] <> $g_iNbrOfHeroesUpped[$CurrentAccount] Then
GUICtrlSetData($g_hLblNbrOfHeroUpg, $g_iNbrOfHeroesUpped[$CurrentAccount])
$iOldNbrOfHeroesUpped[$CurrentAccount] = $g_iNbrOfHeroesUpped[$CurrentAccount]
EndIf
If $bForceUpdateAll = True Or $iOldCostGoldWall[$CurrentAccount] <> $g_iCostGoldWall[$CurrentAccount] Then
GUICtrlSetData($g_hLblWallUpgCostGold, _NumberFormat($g_iCostGoldWall[$CurrentAccount], True))
$iOldCostGoldWall[$CurrentAccount] = $g_iCostGoldWall[$CurrentAccount]
EndIf
If $bForceUpdateAll = True Or $iOldCostElixirWall[$CurrentAccount] <> $g_iCostElixirWall[$CurrentAccount] Then
GUICtrlSetData($g_hLblWallUpgCostElixir, _NumberFormat($g_iCostElixirWall[$CurrentAccount], True))
$iOldCostElixirWall[$CurrentAccount] = $g_iCostElixirWall[$CurrentAccount]
EndIf
If $bForceUpdateAll = True Or $iOldCostGoldBuilding[$CurrentAccount] <> $g_iCostGoldBuilding[$CurrentAccount] Then
GUICtrlSetData($g_hLblBuildingUpgCostGold, _NumberFormat($g_iCostGoldBuilding[$CurrentAccount], True))
$iOldCostGoldBuilding[$CurrentAccount] = $g_iCostGoldBuilding[$CurrentAccount]
EndIf
If $bForceUpdateAll = True Or $iOldCostElixirBuilding[$CurrentAccount] <> $g_iCostElixirBuilding[$CurrentAccount] Then
GUICtrlSetData($g_hLblBuildingUpgCostElixir, _NumberFormat($g_iCostElixirBuilding[$CurrentAccount], True))
$iOldCostElixirBuilding[$CurrentAccount] = $g_iCostElixirBuilding[$CurrentAccount]
EndIf
If $bForceUpdateAll = True Or $iOldCostDElixirHero[$CurrentAccount] <> $g_iCostDElixirHero[$CurrentAccount] Then
GUICtrlSetData($g_hLblHeroUpgCost, _NumberFormat($g_iCostDElixirHero[$CurrentAccount], True))
$iOldCostDElixirHero[$CurrentAccount] = $g_iCostDElixirHero[$CurrentAccount]
EndIf
$iAttackedCount = 0
For $i = 0 To $g_iModeCount
If $bForceUpdateAll = True Or $iOldAttackedVillageCount[$CurrentAccount][$i] <> $g_iAttackedVillageCount[$CurrentAccount][$i] Then
GUICtrlSetData($g_hLblAttacked[$i], _NumberFormat($g_iAttackedVillageCount[$CurrentAccount][$i], True))
$iOldAttackedVillageCount[$CurrentAccount][$i] = $g_iAttackedVillageCount[$CurrentAccount][$i]
EndIf
$iAttackedCount += $g_iAttackedVillageCount[$CurrentAccount][$i]
If $bForceUpdateAll = True Or $iOldTotalGoldGain[$CurrentAccount][$i] <> $g_iTotalGoldGain[$CurrentAccount][$i] Then
GUICtrlSetData($g_hLblTotalGoldGain[$i], _NumberFormat($g_iTotalGoldGain[$CurrentAccount][$i], True))
$iOldTotalGoldGain[$CurrentAccount][$i] = $g_iTotalGoldGain[$CurrentAccount][$i]
EndIf
If $bForceUpdateAll = True Or $iOldTotalElixirGain[$CurrentAccount][$i] <> $g_iTotalElixirGain[$CurrentAccount][$i] Then
GUICtrlSetData($g_hLblTotalElixirGain[$i], _NumberFormat($g_iTotalElixirGain[$CurrentAccount][$i], True))
$iOldTotalElixirGain[$CurrentAccount][$i] = $g_iTotalElixirGain[$CurrentAccount][$i]
EndIf
If $bForceUpdateAll = True Or $iOldTotalDarkGain[$CurrentAccount][$i] <> $g_iTotalDarkGain[$CurrentAccount][$i] Then
GUICtrlSetData($g_hLblTotalDElixirGain[$i], _NumberFormat($g_iTotalDarkGain[$CurrentAccount][$i], True))
$iOldTotalDarkGain[$CurrentAccount][$i] = $g_iTotalDarkGain[$CurrentAccount][$i]
EndIf
If $bForceUpdateAll = True Or $iOldTotalTrophyGain[$CurrentAccount][$i] <> $g_iTotalTrophyGain[$CurrentAccount][$i] Then
GUICtrlSetData($g_hLblTotalTrophyGain[$i], _NumberFormat($g_iTotalTrophyGain[$CurrentAccount][$i], True))
$iOldTotalTrophyGain[$CurrentAccount][$i] = $g_iTotalTrophyGain[$CurrentAccount][$i]
EndIf
Next
If $bForceUpdateAll = True Or $iOldAttackedCount <> $iAttackedCount Then
GUICtrlSetData($g_hLblResultVillagesAttacked, _NumberFormat($iAttackedCount, True))
GUICtrlSetData($g_hLblResultAttackedHourNow, _NumberFormat($iAttackedCount, True))
$iOldAttackedCount = $iAttackedCount
EndIf
For $i = 0 To $g_iModeCount
If $i = $TS Then ContinueLoop
If $bForceUpdateAll = True Or $iOldNbrOfDetectedMines[$CurrentAccount][$i] <> $g_iNbrOfDetectedMines[$CurrentAccount][$i] Then
GUICtrlSetData($g_hLblNbrOfDetectedMines[$i], $g_iNbrOfDetectedMines[$CurrentAccount][$i])
$iOldNbrOfDetectedMines[$CurrentAccount][$i] = $g_iNbrOfDetectedMines[$CurrentAccount][$i]
EndIf
If $bForceUpdateAll = True Or $iOldNbrOfDetectedCollectors[$CurrentAccount][$i] <> $g_iNbrOfDetectedCollectors[$CurrentAccount][$i] Then
GUICtrlSetData($g_hLblNbrOfDetectedCollectors[$i], $g_iNbrOfDetectedCollectors[$CurrentAccount][$i])
$iOldNbrOfDetectedCollectors[$CurrentAccount][$i] = $g_iNbrOfDetectedCollectors[$CurrentAccount][$i]
EndIf
If $bForceUpdateAll = True Or $iOldNbrOfDetectedDrills[$CurrentAccount][$i] <> $g_iNbrOfDetectedDrills[$CurrentAccount][$i] Then
GUICtrlSetData($g_hLblNbrOfDetectedDrills[$i], $g_iNbrOfDetectedDrills[$CurrentAccount][$i])
$iOldNbrOfDetectedDrills[$CurrentAccount][$i] = $g_iNbrOfDetectedDrills[$CurrentAccount][$i]
EndIf
Next
If $bForceUpdateAll = True Or $iOldNbrOfTHSnipeFails[$CurrentAccount] <> $g_iNbrOfTHSnipeFails[$CurrentAccount] Then
GUICtrlSetData($g_hLblNbrOfTSFailed, $g_iNbrOfTHSnipeFails[$CurrentAccount])
$iOldNbrOfTHSnipeFails[$CurrentAccount] = $g_iNbrOfTHSnipeFails[$CurrentAccount]
EndIf
If $bForceUpdateAll = True Or $iOldNbrOfTHSnipeSuccess[$CurrentAccount] <> $g_iNbrOfTHSnipeSuccess[$CurrentAccount] Then
GUICtrlSetData($g_hLblNbrOfTSSuccess, $g_iNbrOfTHSnipeSuccess[$CurrentAccount])
$iOldNbrOfTHSnipeSuccess[$CurrentAccount] = $g_iNbrOfTHSnipeSuccess[$CurrentAccount]
EndIf
If $bForceUpdateAll = True Or $s_iOldSmartZapGain[$CurrentAccount] <> $g_iSmartZapGain[$CurrentAccount] Then
GUICtrlSetData($g_hLblSmartZap, _NumberFormat($g_iSmartZapGain[$CurrentAccount], True))
$s_iOldSmartZapGain[$CurrentAccount] = $g_iSmartZapGain[$CurrentAccount]
EndIf
If $bForceUpdateAll = True Or $s_iOldNumLSpellsUsed[$CurrentAccount] <> $g_iNumLSpellsUsed[$CurrentAccount] Then
GUICtrlSetData($g_hLblSmartLightningUsed, _NumberFormat($g_iNumLSpellsUsed[$CurrentAccount], True))
$s_iOldNumLSpellsUsed[$CurrentAccount] = $g_iNumLSpellsUsed[$CurrentAccount]
EndIf
If $bForceUpdateAll = True Or $s_iOldNumEQSpellsUsed[$CurrentAccount] <> $g_iNumEQSpellsUsed[$CurrentAccount] Then
GUICtrlSetData($g_hLblSmartEarthQuakeUsed, _NumberFormat($g_iNumEQSpellsUsed[$CurrentAccount], True))
$s_iOldNumEQSpellsUsed[$CurrentAccount] = $g_iNumEQSpellsUsed[$CurrentAccount]
EndIf
For $i = 0 To $eTroopCount - 1
If $g_aiDonateStatsTroops[$i][0] <> $g_aiDonateStatsTroops[$i][1] Then
GUICtrlSetData($g_hLblDonTroop[$i], _NumberFormat($g_aiDonateStatsTroops[$i][0], True))
$g_iTotalDonateStatsTroops +=($g_aiDonateStatsTroops[$i][0] - $g_aiDonateStatsTroops[$i][1])
$g_iTotalDonateStatsTroopsXP +=(($g_aiDonateStatsTroops[$i][0] - $g_aiDonateStatsTroops[$i][1]) * $g_aiTroopDonateXP[$i])
$g_aiDonateStatsTroops[$i][1] = $g_aiDonateStatsTroops[$i][0]
$bDonateTroopsStatsChanged = True
EndIf
Next
If $bDonateTroopsStatsChanged Then
GUICtrlSetData($g_hLblTotalTroopsQ, _NumberFormat($g_iTotalDonateStatsTroops, True))
GUICtrlSetData($g_hLblTotalTroopsXP, _NumberFormat($g_iTotalDonateStatsTroopsXP, True))
$bDonateTroopsStatsChanged = False
EndIf
For $i = 0 To $eSpellCount - 1
If $g_aiDonateStatsSpells[$i][0] <> $g_aiDonateStatsSpells[$i][1] And $i <> $eSpellClone Then
GUICtrlSetData($g_hLblDonSpell[$i], _NumberFormat($g_aiDonateStatsSpells[$i][0], True))
$g_iTotalDonateStatsSpells +=($g_aiDonateStatsSpells[$i][0] - $g_aiDonateStatsSpells[$i][1])
$g_iTotalDonateStatsSpellsXP +=(($g_aiDonateStatsSpells[$i][0] - $g_aiDonateStatsSpells[$i][1]) * $g_aiSpellDonateXP[$i])
$g_aiDonateStatsSpells[$i][1] = $g_aiDonateStatsSpells[$i][0]
$bDonateSpellsStatsChanged = True
EndIf
Next
If $bDonateSpellsStatsChanged Then
GUICtrlSetData($g_hLblTotalSpellsQ, _NumberFormat($g_iTotalDonateStatsSpells, True))
GUICtrlSetData($g_hLblTotalSpellsXP, _NumberFormat($g_iTotalDonateStatsSpellsXP, True))
$bDonateSpellsStatsChanged = False
EndIf
If $bForceUpdateAll = True Or $iOldFreeBuilderCount[$CurrentAccount] <> $g_iFreeBuilderCount[$CurrentAccount] Or $iOldTotalBuilderCount[$CurrentAccount] <> $g_iTotalBuilderCount[$CurrentAccount] Then
GUICtrlSetData($g_hLblResultBuilderNow, $g_iFreeBuilderCount[$CurrentAccount] & "/" & $g_iTotalBuilderCount[$CurrentAccount])
$iOldFreeBuilderCount[$CurrentAccount] = $g_iFreeBuilderCount[$CurrentAccount]
$iOldTotalBuilderCount[$CurrentAccount] = $g_iTotalBuilderCount[$CurrentAccount]
EndIf
If $bForceUpdateAll = True Or $iOldGemAmount[$CurrentAccount] <> $g_iGemAmount[$CurrentAccount] Then
GUICtrlSetData($g_hLblResultGemNow, _NumberFormat($g_iGemAmount[$CurrentAccount], True))
$iOldGemAmount[$CurrentAccount] = $g_iGemAmount[$CurrentAccount]
EndIf
If $bForceUpdateAll = True Or $iOldGoldCurrent[$CurrentAccount] <> $g_iStatsCurrent[$CurrentAccount][$eLootGold] Then
GUICtrlSetData($g_hLblResultGoldNow, _NumberFormat($g_iStatsCurrent[$CurrentAccount][$eLootGold], True))
$iOldGoldCurrent[$CurrentAccount] = $g_iStatsCurrent[$CurrentAccount][$eLootGold]
EndIf
If $bForceUpdateAll = True Or $iOldElixirCurrent[$CurrentAccount] <> $g_iStatsCurrent[$CurrentAccount][$eLootElixir] Then
GUICtrlSetData($g_hLblResultElixirNow, _NumberFormat($g_iStatsCurrent[$CurrentAccount][$eLootElixir], True))
$iOldElixirCurrent[$CurrentAccount] = $g_iStatsCurrent[$CurrentAccount][$eLootElixir]
EndIf
If $bForceUpdateAll = True Or($iOldDarkCurrent[$CurrentAccount] <> $g_iStatsCurrent[$CurrentAccount][$eLootDarkElixir] And $g_iStatsStartedWith[$CurrentAccount][$eLootDarkElixir] <> "") Then
GUICtrlSetData($g_hLblResultDeNow, _NumberFormat($g_iStatsCurrent[$CurrentAccount][$eLootDarkElixir], True))
$iOldDarkCurrent[$CurrentAccount] = $g_iStatsCurrent[$CurrentAccount][$eLootDarkElixir]
EndIf
If $bForceUpdateAll = True Or $iOldTrophyCurrent[$CurrentAccount] <> $g_iStatsCurrent[$CurrentAccount][$eLootTrophy] Then
GUICtrlSetData($g_hLblResultTrophyNow, _NumberFormat($g_iStatsCurrent[$CurrentAccount][$eLootTrophy], True))
$iOldTrophyCurrent[$CurrentAccount] = $g_iStatsCurrent[$CurrentAccount][$eLootTrophy]
EndIf
If $ResetStats = 1 Then
GUICtrlSetData($g_ahLblStatsStartedWith[$eLootGold], _NumberFormat($iGoldCurrent, True))
GUICtrlSetData($g_ahLblStatsStartedWith[$eLootElixir], _NumberFormat($iElixirCurrent, True))
If $g_iStatsStartedWith[$CurrentAccount][$eLootDarkElixir] <> "" Then
GUICtrlSetData($g_ahLblStatsStartedWith[$eLootDarkElixir], _NumberFormat($iDarkCurrent, True))
EndIf
GUICtrlSetData($g_ahLblStatsStartedWith[$eLootTrophy], _NumberFormat($iTrophyCurrent, True))
GUICtrlSetData($g_ahLblStatsGainPerHour[$eLootGold], "")
GUICtrlSetData($g_ahLblStatsGainPerHour[$eLootElixir], "")
GUICtrlSetData($g_ahLblStatsGainPerHour[$eLootDarkElixir], "")
GUICtrlSetData($g_ahLblStatsGainPerHour[$eLootTrophy], "")
GUICtrlSetData($g_hLblResultGoldHourNow, "")
GUICtrlSetData($g_hLblResultElixirHourNow, "")
GUICtrlSetData($g_hLblResultDEHourNow, "")
$ResetStats = 0
EndIf
UpdateStatsSwitchMode($bForceUpdateAll)
EndFunc
Func ResetStats()
$ResetStats = 1
$g_iFirstAttack = 0
$g_iTimePassed = 0
$g_hTimerSinceStarted = TimerInit()
GUICtrlSetData($g_hLblResultRuntime, "00:00:00")
GUICtrlSetData($g_hLblResultRuntimeNow, "00:00:00")
$g_iStatsStartedWith[$CurrentAccount][$eLootGold] = $iGoldCurrent
$g_iStatsStartedWith[$CurrentAccount][$eLootElixir] = $iElixirCurrent
$g_iStatsStartedWith[$CurrentAccount][$eLootDarkElixir] = $iDarkCurrent
$g_iStatsStartedWith[$CurrentAccount][$eLootTrophy] = $iTrophyCurrent
Dim $g_iStatsTotalGain[9][$eLootCount]
Dim $g_iStatsLastAttack[9][$eLootCount]
Dim $g_iStatsBonusLast[9][$eLootCount]
Dim $g_iSkippedVillageCount[9]
Dim $g_iDroppedTrophyCount[9]
Dim $g_iSearchCost[9]
Dim $g_iTrainCostElixir[9]
Dim $g_iTrainCostDElixir[9]
Dim $g_iGoldFromMines[9]
Dim $g_iElixirFromCollectors[9]
Dim $g_iDElixirFromDrills[9]
Dim $iNbrOfWallsUppedGold[9]
Dim $iNbrOfWallsUppedElixir[9]
Dim $iNbrOfBuildingsUppedGold[9]
Dim $iNbrOfBuildingsUppedElixir[9]
Dim $iNbrOfHeroesUpped[9]
Dim $g_iCostGoldWall[9]
Dim $g_iCostElixirWall[9]
Dim $g_iCostGoldBuilding[9]
Dim $g_iCostElixirBuilding[9]
Dim $g_iCostDElixirHero[9]
Dim $g_iAttackedVillageCount[9][$g_iModeCount + 3]
Dim $g_iTotalGoldGain[9][$g_iModeCount + 3]
Dim $g_iTotalElixirGain[9][$g_iModeCount + 3]
Dim $g_iTotalDarkGain[9][$g_iModeCount + 3]
Dim $g_iTotalTrophyGain[9][$g_iModeCount + 3]
Dim $iNbrOfDetectedMines[9][$g_iModeCount + 3]
Dim $iNbrOfDetectedCollectors[9][$g_iModeCount + 3]
Dim $iNbrOfDetectedDrills[9][$g_iModeCount + 3]
Dim $iNbrOfTHSnipeFails[9]
Dim $iNbrOfTHSnipeSuccess[9]
Dim $g_iSmartZapGain[9]
Dim $g_iNumLSpellsUsed[9]
Dim $g_iNumEQSpellsUsed[9]
$iNbrOfOoS = 0
For $i = 0 To $eTroopCount - 1
$g_aiDonateStatsTroops[$i][0] = 0
Next
For $i = 0 To $eSpellCount - 1
If $i <> $eSpellClone Then
$g_aiDonateStatsSpells[$i][0] = 0
EndIf
Next
$g_iTotalDonateStatsTroops = 0
$g_iTotalDonateStatsTroopsXP = 0
$g_iTotalDonateStatsSpells = 0
$g_iTotalDonateStatsSpellsXP = 0
UpdateStats()
EndFunc
Func WallsStatsMAJ()
$g_aiWallsCurrentCount[$g_iCmbUpgradeWallsLevel + 4] -= Number($iNbrOfWallsUpped)
$g_aiWallsCurrentCount[$g_iCmbUpgradeWallsLevel + 5] += Number($iNbrOfWallsUpped)
$iNbrOfWallsUpped = 0
For $i = 4 To 12
GUICtrlSetData($g_ahWallsCurrentCount[$i], $g_aiWallsCurrentCount[$i])
Next
SaveConfig()
EndFunc
Func SwitchAccount($Init = False, $ConfirmSync = False)
Local $iRetry = 0
If $ichkSwitchAccount = 1 And $g_bSwitchAcctPrereq Then
If $Init Then $FirstInit = False
checkMainScreen()
Setlog("Starting SmartSwitchAccount...", $COLOR_SUCCESS)
If Not $ConfirmSync Then MakeSummaryLog()
If Not $Init And Not $ConfirmSync And $ichkDonateAccount[$CurrentAccount] = 0 Then GetWaitTime()
If $ConfirmSync = True Then
SetLog("ReSync of SmartSwitchAccount...", $COLOR_INFO)
$NextAccount = $CurrentAccount
$CurrentAccount = 0
GetYCoordinates($NextAccount)
ElseIf $Init Then
SetLog("Initialization of SmartSwitchAccount...", $COLOR_INFO)
$CurrentAccount = 1
$FirstLoop = 2
FindFirstAccount()
$NextAccount = $CurrentAccount
GetYCoordinates($NextAccount)
$g_iFirstRun = 1
ElseIf $FirstLoop <= $TotalAccountsInUse And Not $Init Then
SetLog("Continue initialization of SmartSwitchAccount...", $COLOR_INFO)
$NextAccount = $CurrentAccount
Do
$NextAccount += 1
If $NextAccount > $TotalAccountsOnEmu Then $NextAccount = 1
Until $ichkCanUse[$NextAccount] = 1
$FirstLoop += 1
SetLog("Next Account will be : " & $NextAccount, $COLOR_INFO)
GetYCoordinates($NextAccount)
$g_iFirstRun = 1
ElseIf $FirstLoop > $TotalAccountsInUse And Not $Init Then
SetLog("Switching to next Account...", $COLOR_INFO)
GetNextAccount()
GetYCoordinates($NextAccount)
EndIf
If $ichkDonateAccount[$CurrentAccount] = 1 Then
GUICtrlSetData($g_lblTimeNowSW[$CurrentAccount], "Donating")
GUICtrlSetBkColor($g_lblTimeNowSW[$CurrentAccount], $COLOR_GREEN)
GUICtrlSetColor($g_lblTimeNowSW[$CurrentAccount], $COLOR_BLACK)
GUICtrlSetData($g_lblTimeNowPO[$CurrentAccount], "Donating")
GUICtrlSetBkColor($g_lblTimeNowPO[$CurrentAccount], $COLOR_GREEN)
GUICtrlSetColor($g_lblTimeNowPO[$CurrentAccount], $COLOR_BLACK)
Else
GUICtrlSetData($g_lblTimeNowSW[$CurrentAccount], "Looting")
GUICtrlSetBkColor($g_lblTimeNowSW[$CurrentAccount], $COLOR_GREEN)
GUICtrlSetColor($g_lblTimeNowSW[$CurrentAccount], $COLOR_BLACK)
GUICtrlSetData($g_lblTimeNowPO[$CurrentAccount], "Looting")
GUICtrlSetBkColor($g_lblTimeNowPO[$CurrentAccount], $COLOR_GREEN)
GUICtrlSetColor($g_lblTimeNowPO[$CurrentAccount], $COLOR_BLACK)
EndIf
If _Sleep($iDelayRespond) Then Return
If $NextAccount = $CurrentAccount And Not $Init And $FirstLoop >= $TotalAccountsInUse Then
SetLog("Next Account is already the account we are on, no need to change...", $COLOR_SUCCESS)
Else
If Not $Init And Not $ConfirmSync And $ichkDonateAccount[$CurrentAccount] = 0 Then
SetLog("Trying to Request Troops before switching...", $COLOR_INFO)
RequestCC()
If _Sleep(500) Then Return
EndIf
Switch SWProcess()
Case 4 To 6
$iRetry += 1
If $iRetry >= 3 Then
$iRetry = 0
$Init = False
$FirstInit = True
CloseCoC(True)
ZoomOut()
If Not $g_bRunState Then Return
checkMainScreen()
runBot()
EndIf
If $Init Then
SwitchAccount(True)
Else
SwitchAccount()
EndIf
Case 3
$Init = False
$FirstInit = True
CloseCoC(True)
ZoomOut()
If Not $g_bRunState Then Return
checkMainScreen()
runBot()
Case 1 To 2
Setlog(">>Switch Process Successful<<")
EndSwitch
$iRetry = 0
If Not $Init Then
If $ichkDonateAccount[$CurrentAccount] = 1 Then
GUICtrlSetData($g_lblTimeNowSW[$CurrentAccount], "Donate")
GUICtrlSetBkColor($g_lblTimeNowSW[$CurrentAccount], $COLOR_YELLOW)
GUICtrlSetColor($g_lblTimeNowSW[$CurrentAccount], $COLOR_BLACK)
GUICtrlSetData($g_lblTimeNowPO[$CurrentAccount], "Donate")
GUICtrlSetBkColor($g_lblTimeNowPO[$CurrentAccount], $COLOR_YELLOW)
GUICtrlSetColor($g_lblTimeNowPO[$CurrentAccount], $COLOR_BLACK)
Else
GUICtrlSetData($g_lblTimeNowSW[$CurrentAccount], Round($CurrentAccountWaitTime, 2))
GUICtrlSetBkColor($g_lblTimeNowSW[$CurrentAccount], $COLOR_YELLOW)
GUICtrlSetColor($g_lblTimeNowSW[$CurrentAccount], $COLOR_BLACK)
GUICtrlSetData($g_lblTimeNowPO[$CurrentAccount], Round($CurrentAccountWaitTime, 2))
GUICtrlSetBkColor($g_lblTimeNowPO[$CurrentAccount], $COLOR_YELLOW)
GUICtrlSetColor($g_lblTimeNowPO[$CurrentAccount], $COLOR_BLACK)
EndIf
If $ichkDonateAccount[$NextAccount] = 1 Then
GUICtrlSetData($g_lblTimeNowSW[$NextAccount], "Donating")
GUICtrlSetBkColor($g_lblTimeNowSW[$NextAccount], $COLOR_GREEN)
GUICtrlSetColor($g_lblTimeNowSW[$NextAccount], $COLOR_BLACK)
GUICtrlSetData($g_lblTimeNowPO[$NextAccount], "Donating")
GUICtrlSetBkColor($g_lblTimeNowPO[$NextAccount], $COLOR_GREEN)
GUICtrlSetColor($g_lblTimeNowPO[$NextAccount], $COLOR_BLACK)
Else
GUICtrlSetData($g_lblTimeNowSW[$NextAccount], "Looting")
GUICtrlSetBkColor($g_lblTimeNowSW[$NextAccount], $COLOR_GREEN)
GUICtrlSetColor($g_lblTimeNowSW[$NextAccount], $COLOR_BLACK)
GUICtrlSetData($g_lblTimeNowPO[$NextAccount], "Looting")
GUICtrlSetBkColor($g_lblTimeNowPO[$NextAccount], $COLOR_GREEN)
GUICtrlSetColor($g_lblTimeNowPO[$NextAccount], $COLOR_BLACK)
EndIf
EndIf
$CurrentAccount = $NextAccount
If $Init Or $ConfirmSync Then
$NextProfile = _GUICtrlComboBox_GetCurSel($cmbAccount[$CurrentAccount])
_GUICtrlComboBox_SetCurSel($g_hcmbProfile, $NextProfile)
cmbProfile()
Else
$NextProfile = _GUICtrlComboBox_GetCurSel($cmbAccount[$NextAccount])
_GUICtrlComboBox_SetCurSel($g_hcmbProfile, $NextProfile)
cmbProfile()
EndIf
If _Sleep($iDelayRespond) Then Return
IdentifyDonateOnly()
waitMainScreen()
VillageReport(False, False, True)
CheckArmyCamp(True, True)
If _Sleep(500) Then Return
If $ichkDonateAccount[$CurrentAccount] = 1 Then
TrainDonateOnlyLoop()
Else
runBot()
EndIf
EndIf
Else
$FirstInit = False
EndIf
EndFunc
Func SWProcess()
Local $iCount
Click(820, 590, 1, 0, "Click Setting")
If _Sleep(100) Then Return
$iCount = 0
While Not _ColorCheck(_GetPixelColor(766, 101, True), Hex(0xF88088, 6), 20)
If _Sleep(100) Then Return
$iCount += 1
If $iCount = 50 Then
Setlog("Settings Page did not open")
Return 4
EndIf
WEnd
If _Sleep(100) Then Return
If _ColorCheck(_GetPixelColor(408, 408, True), "D0E878", 20) Then
Click(440, 420, 2, 750, "Click Connect Twice with long pause")
ElseIf _ColorCheck(_GetPixelColor(408, 408, True), "F07078", 20) Then
Click(440, 420, 1, 750, "Click Connect Once with long pause")
EndIf
If _Sleep(100) Then Return
$iCount = 0
While Not _ColorCheck(_GetPixelColor(550, 450, True), Hex(0x0B8043, 6), 20)
If _Sleep(50) Then Return
$iCount += 1
If $iCount = 100 Then ExitLoop
WEnd
If $iCount < 100 Then
ClickP($aAway, 1, 0, "#0167")
EndIf
If _Sleep(100) Then Return
If _Sleep(50) Then Return
$iCount = 0
While Not _ColorCheck(_GetPixelColor(165, 330, True), Hex(0xFFFFFF, 6), 20)
If _Sleep(100) Then Return
$iCount += 1
If $iCount = 100 Then
Setlog("Account List Not Found")
Return 5
EndIf
WEnd
If _Sleep(100) Then Return
Click(430, $yCoord)
If _Sleep(100) Then Return
If _Sleep($iDelayRespond) Then Return
WaitForNextStep()
If $NextStep = 1 Then
Setlog("Load button appeared", $COLOR_SUCCESS)
If _Sleep(100) Then Return
Click(520, 430)
If _Sleep(100) Then Return
$iCount = 0
While Not _ColorCheck(_GetPixelColor(587, 16, True), Hex(0xF88088, 6), 20)
If _Sleep(100) Then Return
$iCount += 1
If $iCount = 50 Then ExitLoop
WEnd
If _Sleep(100) Then Return
Click(360, 195)
If _Sleep(250) Then Return
AndroidSendText("CONFIRM")
$iCount = 0
While Not _ColorCheck(_GetPixelColor(480, 200, True), "71BB1E", 20)
If _Sleep(100) Then Return
$iCount += 1
If $iCount = 100 Then
SetLog("Confirm Button did Not Appear")
Return 6
EndIf
WEnd
If _Sleep(100) Then Return
Click(530, 195)
If _Sleep(100) Then Return
Return 1
ElseIf $NextStep = 2 Then
Setlog("Already on the right account...", $COLOR_SUCCESS)
If _Sleep(100) Then Return
ClickP($aAway, 1, 0, "#0167")
If _Sleep(100) Then Return
Return 2
ElseIf $NextStep = 0 Then
SetLog("Error when trying to go to the next step... skipping...", $COLOR_ERROR)
Return 3
EndIf
EndFunc
Func GetYCoordinates($AccountNumber)
Local $res
$res = DllCall($g_sLibPath & "\SmartSwitchAcc_Formulas.dll", "int", "SwitchAccY", "int", $TotalAccountsOnEmu, "int", $AccountNumber)
$yCoord = $res[0]
EndFunc
Func GetWaitTime()
$aTimeTrain[0] = 0
$aTimeTrain[1] = 0
Local $HeroesRemainingWait[3] = [0, 0, 0]
openArmyOverview()
Sleep(1500)
getArmyTroopTime()
If IsWaitforSpellsActive() Then getArmySpellTime()
If IsWaitforHeroesActive() Then
If _Sleep($iDelayRespond) Then Return
If GUICtrlRead($g_hChkABActivateSearches) = $GUI_CHECKED Then
If GUICtrlRead($g_hchkABKingWait) = $GUI_CHECKED Then
$HeroesRemainingWait[0] = getArmyHeroTime($eKing)
EndIf
If GUICtrlRead($g_hChkABQueenWait) = $GUI_CHECKED Then
$HeroesRemainingWait[1] = getArmyHeroTime($eQueen)
EndIf
If GUICtrlRead($g_hChkABWardenWait) = $GUI_CHECKED Then
$HeroesRemainingWait[2] = getArmyHeroTime($eWarden)
EndIf
EndIf
If GUICtrlRead($g_hchkDBActivateSearches) = $GUI_CHECKED Then
If GUICtrlRead($g_hchkDBKingWait) = $GUI_CHECKED Then
$HeroesRemainingWait[0] = getArmyHeroTime($eKing)
EndIf
If GUICtrlRead($g_hchkDBQueenWait) = $GUI_CHECKED Then
$HeroesRemainingWait[1] = getArmyHeroTime($eQueen)
EndIf
If GUICtrlRead($g_hchkDBWardenWait) = $GUI_CHECKED Then
$HeroesRemainingWait[2] = getArmyHeroTime($eWarden)
EndIf
EndIf
If GUICtrlRead($g_hchkTSActivateSearches) = $GUI_CHECKED Then
If GUICtrlRead($g_hchkTSKingAttack) = $GUI_CHECKED Then
$HeroesRemainingWait[0] = getArmyHeroTime($eKing)
EndIf
If GUICtrlRead($g_hchkTSQueenAttack) = $GUI_CHECKED Then
$HeroesRemainingWait[1] = getArmyHeroTime($eQueen)
EndIf
If GUICtrlRead($g_hchkTSWardenAttack) = $GUI_CHECKED Then
$HeroesRemainingWait[2] = getArmyHeroTime($eWarden)
EndIf
EndIf
If $HeroesRemainingWait[0] > 0 Then SetLog("King time: " & $HeroesRemainingWait[0] & ".00 min", $COLOR_INFO)
If $HeroesRemainingWait[1] > 0 Then SetLog("Queen time: " & $HeroesRemainingWait[0] & ".00 min", $COLOR_INFO)
If $HeroesRemainingWait[2] > 0 Then SetLog("Warden time: " & $HeroesRemainingWait[0] & ".00 min", $COLOR_INFO)
If _Sleep($iDelayRespond) Then Return
EndIf
ClickP($aAway, 1, 0, "#0167")
Local $MaxTime[3] = [$aTimeTrain[0], $aTimeTrain[1], _ArrayMax($HeroesRemainingWait)]
$CurrentAccountWaitTime = _ArrayMax($MaxTime)
$AllAccountsWaitTime[$CurrentAccount] = $CurrentAccountWaitTime
$TimerDiffStart[$CurrentAccount] = TimerInit()
If $CurrentAccountWaitTime = 0 Then
SetLog("Wait time for current Account : training finished, Chief ;P !", $COLOR_SUCCESS)
Else
SetLog("Wait time for current Account : " & Round($CurrentAccountWaitTime, 2) & " minutes", $COLOR_SUCCESS)
EndIf
If _Sleep($iDelayRespond) Then Return
EndFunc
Func FindFirstAccount()
For $x = 1 To 8
$NextAccount = $x
If $ichkCanUse[$x] = 1 Then ExitLoop
Next
$CurrentAccount = $NextAccount
$NextProfile = _GUICtrlComboBox_GetCurSel($cmbAccount[$NextAccount])
_GUICtrlComboBox_SetCurSel($g_hCmbProfile, $NextProfile)
cmbProfile()
EndFunc
Func GetNextAccount()
Local $FinishedSince
Local $NextDAccount
If $MustGoToDonateAccount = 1 And $TotalDAccountsInUse <> 0 And $ichkDonateAccount[$CurrentAccount] = 0 Then
SetLog("Time to go to Donate Account...", $COLOR_SUCCESS)
$NextDAccount = $CurrentDAccount
Do
$NextDAccount += 1
If $NextDAccount > $TotalAccountsOnEmu Then $NextDAccount = 1
Until $ichkCanUse[$NextDAccount] = 1 And $ichkDonateAccount[$NextDAccount] = 1
If _Sleep($iDelayRespond) Then Return
SetLog("So, next Account will be : " & $NextDAccount, $COLOR_SUCCESS)
If _Sleep($iDelayRespond) Then Return
$CurrentDAccount = $NextDAccount
$NextAccount = $NextDAccount
$MustGoToDonateAccount = 0
Else
For $x = 1 To 8
If $ichkCanUse[$x] = 1 And $ichkDonateAccount[$x] = 0 Then
$TimerDiffEnd[$x] = TimerDiff($TimerDiffStart[$x])
$AllAccountsWaitTimeDiff[$x] = Round($AllAccountsWaitTime[$x] * 60 * 1000 - $TimerDiffEnd[$x])
If Round($AllAccountsWaitTimeDiff[$x] / 60 / 1000, 2) < 0 Then
$FinishedSince = StringReplace(Round($AllAccountsWaitTimeDiff[$x] / 60 / 1000, 2), "-", "")
SetLog("Account " & $x & " wait time left : training finished since " & $FinishedSince & " minutes", $COLOR_SUCCESS)
Else
SetLog("Account " & $x & " wait time left : " & Round($AllAccountsWaitTimeDiff[$x] / 60 / 1000, 2) & " minutes", $COLOR_SUCCESS)
EndIf
EndIf
Next
If _Sleep($iDelayRespond) Then Return
$NextAccount = _ArrayMinIndex($AllAccountsWaitTimeDiff, 1, 1, 8)
SetLog("So, next Account will be : " & $NextAccount, $COLOR_SUCCESS)
If _Sleep($iDelayRespond) Then Return
$MustGoToDonateAccount = 1
EndIf
EndFunc
Func MakeSummaryLog()
CheckAccountsInUse()
CheckDAccountsInUse()
SetLog("SmartSwitchAccount Summary : " & $TotalAccountsOnEmu & " Accounts - " & $TotalAccountsInUse & " in use - " & $TotalDAccountsInUse & " Donate Accounts", $COLOR_ORANGE)
EndFunc
Func TrainDonateOnlyLoop()
If $ichkDonateAccount[$CurrentAccount] = 1 Then
$g_iCommandStop = 3
VillageReport()
Collect()
randomSleep(2000)
DonateCC()
randomSleep(2000)
DonateCC()
randomSleep(2000)
CheckArmyCamp(True, True)
If _Sleep($iDelayIdle1) Then Return
If($fullArmy = False Or $bFullArmySpells = False) And $bTrainEnabled = True Then
SetLog("Army Camp and Barracks are not full, Training Continues...", $COLOR_ACTION)
$g_iCommandStop = 0
TrainRevamp()
randomSleep(10000)
EndIf
DonateCC()
randomSleep(2000)
DonateCC()
randomSleep(2000)
CheckArmyCamp(True, True)
If _Sleep($iDelayIdle1) Then Return
If($fullArmy = False Or $bFullArmySpells = False) And $bTrainEnabled = True Then
SetLog("Army Camp and Barracks are not full, Training Continues...", $COLOR_ACTION)
$g_iCommandStop = 0
TrainRevamp()
randomSleep(2000)
EndIf
SwitchAccount()
EndIf
EndFunc
Func CheckAccountsInUse()
$TotalAccountsInUse = 8
For $x = 1 To 8
If $ichkCanUse[$x] = 0 Then
$AllAccountsWaitTimeDiff[$x] = 999999999999
$TotalAccountsInUse -= 1
EndIf
Next
EndFunc
Func CheckDAccountsInUse()
$TotalDAccountsInUse = 0
For $x = 1 To 8
If $ichkDonateAccount[$x] = 1 Then
$AllAccountsWaitTimeDiff[$x] = 999999999999
$TotalDAccountsInUse += 1
EndIf
Next
EndFunc
Func cmbAccountsQuantity()
$TotalAccountsOnEmu = _GUICtrlComboBox_GetCurSel($cmbAccountsQuantity) + 2
For $i = $chkCanUse[1] To $chkDonateAccount[8]
GUICtrlSetState($i, $GUI_SHOW)
Next
If $TotalAccountsOnEmu >= 1 And $TotalAccountsOnEmu < 8 Then
For $i = $chkCanUse[$TotalAccountsOnEmu + 1] To $chkDonateAccount[8]
GUICtrlSetState($i, $GUI_HIDE)
GUICtrlSetState($i, $GUI_UNCHECKED)
Next
EndIf
chkAccountsProperties()
EndFunc
Func chkSwitchAccount()
If GUICtrlRead($chkEnableSwitchAccount) = $GUI_CHECKED Then
GUICtrlSetState($g_icnPopOutSW[0], $GUI_HIDE)
For $i = $lblNB To $chkDonateAccount[8]
GUICtrlSetState($i, $GUI_ENABLE)
Next
cmbAccountsQuantity()
$ichkSwitchAccount = 1
Else
GUICtrlSetState($g_icnPopOutSW[0], $GUI_SHOW)
HideShowMultiStat("HIDE")
For $i = $lblNB To $chkDonateAccount[8]
GUICtrlSetState($i, $GUI_DISABLE)
Next
$ichkSwitchAccount = 0
EndIf
EndFunc
Func chkAccountsProperties()
For $h = 1 To 8
If GUICtrlRead($chkCanUse[$h]) = $GUI_CHECKED Then
For $i = $cmbAccount[$h] To $chkDonateAccount[$h]
GUICtrlSetState($i, $GUI_ENABLE)
Next
$ichkCanUse[$h] = 1
GUICtrlSetState($g_icnGoldSW[$h], $GUI_SHOW)
GUICtrlSetState($g_icnElixirSW[$h], $GUI_SHOW)
GUICtrlSetState($g_icnDarkSW[$h], $GUI_SHOW)
GUICtrlSetState($g_icnGemSW[$h], $GUI_SHOW)
GUICtrlSetState($g_icnBuliderSW[$h], $GUI_SHOW)
GUICtrlSetState($g_icnHourGlassSW[$h], $GUI_SHOW)
If GUICtrlGetState($g_lblKingStatus[$h]) <> BitOR($GUI_HIDE, $GUI_ENABLE) Then
GUICtrlSetState($g_lblKingStatus[$h], $GUI_SHOW)
EndIf
If GUICtrlGetState($g_lblQueenStatus[$h]) <> BitOR($GUI_HIDE, $GUI_ENABLE) Then
GUICtrlSetState($g_lblQueenStatus[$h], $GUI_SHOW)
EndIf
If GUICtrlGetState($g_lblWardenStatus[$h]) <> BitOR($GUI_HIDE, $GUI_ENABLE) Then
GUICtrlSetState($g_lblWardenStatus[$h], $GUI_SHOW)
EndIf
GUICtrlSetState($g_lblLabStatus[$h], $GUI_SHOW)
GUICtrlSetState($g_lblUnitMeasureSW1[$h], $GUI_SHOW)
GUICtrlSetState($g_lblUnitMeasureSW2[$h], $GUI_SHOW)
GUICtrlSetState($g_lblUnitMeasureSW3[$h], $GUI_SHOW)
GUICtrlSetState($g_lblTimeNowSW[$h], $GUI_SHOW)
GUICtrlSetState($g_grpVillageSW[$h], $GUI_SHOW)
GUICtrlSetState($g_icnPopOutSW[$h], $GUI_SHOW)
Else
For $i = $cmbAccount[$h] To $chkDonateAccount[$h]
GUICtrlSetState($i, $GUI_DISABLE)
GUICtrlSetState($i, $GUI_UNCHECKED)
Next
$ichkCanUse[$h] = 0
GUICtrlSetState($g_icnGoldSW[$h], $GUI_HIDE)
GUICtrlSetState($g_icnElixirSW[$h], $GUI_HIDE)
GUICtrlSetState($g_icnDarkSW[$h], $GUI_HIDE)
GUICtrlSetState($g_icnGemSW[$h], $GUI_HIDE)
GUICtrlSetState($g_icnBuliderSW[$h], $GUI_HIDE)
GUICtrlSetState($g_icnHourGlassSW[$h], $GUI_HIDE)
GUICtrlSetState($g_lblKingStatus[$h], $GUI_HIDE)
GUICtrlSetState($g_lblQueenStatus[$h], $GUI_HIDE)
GUICtrlSetState($g_lblWardenStatus[$h], $GUI_HIDE)
GUICtrlSetState($g_lblLabStatus[$h], $GUI_HIDE)
GUICtrlSetState($g_lblUnitMeasureSW1[$h], $GUI_HIDE)
GUICtrlSetState($g_lblUnitMeasureSW2[$h], $GUI_HIDE)
GUICtrlSetState($g_lblUnitMeasureSW3[$h], $GUI_HIDE)
GUICtrlSetState($g_lblTimeNowSW[$h], $GUI_HIDE)
GUICtrlSetState($g_grpVillageSW[$h], $GUI_HIDE)
GUICtrlSetState($g_icnPopOutSW[$h], $GUI_HIDE)
EndIf
If GUICtrlRead($chkDonateAccount[$h]) = $GUI_CHECKED Then
$ichkDonateAccount[$h] = 1
Else
$ichkDonateAccount[$h] = 0
EndIf
Next
EndFunc
Func IdentifyDonateOnly()
If $ichkDonateAccount[$CurrentAccount] = 1 Then
SetLog("Current Account is a Train/Donate Only Account...", $COLOR_DEBUG1)
Else
SetLog("Current Account is not a Train/Donate Only Account...", $COLOR_DEBUG1)
EndIf
EndFunc
Func WaitForNextStep()
Local $CheckStep
SetLog("Waiting for Load button or Already Connected...", $COLOR_INFO)
$CheckStep = 0
While(Not(IsLoadButton() Or AlreadyConnected())) And $CheckStep < 150
If _Sleep(200) Then Return
$CheckStep += 1
WEnd
If $IsLoadButton Then
$NextStep = 1
ElseIf $AlreadyConnected Then
$NextStep = 2
Else
$NextStep = 0
EndIf
EndFunc
Func IsLoadButton()
$IsLoadButton = _ColorCheck(_GetPixelColor(480, 441, True), "60B010", 20)
Return $IsLoadButton
EndFunc
Func AlreadyConnected()
$AlreadyConnected = _ColorCheck(_GetPixelColor(408, 408, True), "D0E878", 20)
Return $AlreadyConnected
EndFunc
Func AppendLineToSSALog($AtkReportLine)
If $ichkSwitchAccount = 1 Then
If $LastDate <> _NowDate() Then
$LastDate = _NowDate()
FileWriteLine($SSAAtkLog, @CRLF)
FileWriteLine($SSAAtkLog, _NowDate())
FileWriteLine($SSAAtkLog, @CRLF)
FileWriteLine($SSAAtkLog, "                    --------  LOOT --------       ----- BONUS ------")
FileWriteLine($SSAAtkLog, @CRLF)
FileWriteLine($SSAAtkLog, "Ac| TIME|TROP.| SRC|   GOLD| ELIXIR|DARK EL|TR.|S|  GOLD|ELIXIR|  DE|L.")
EndIf
If FileWriteLine($SSAAtkLog, $AtkReportLine) = 0 Then Setlog("Error when trying to add Attack Report line to multi account log...", $COLOR_ERROR)
EndIf
EndFunc
Func LabStatus()
Static $sLabUpgradeTimeStatic[9]
Local $TimeDiff, $aArray, $Result
Local $iRemainingTimeMin, $sTime
If $aLabPos[0] <= 0 Or $aLabPos[1] <= 0 Then
SetLog("Laboratory Location not found!", $COLOR_ERROR)
LocateLab()
If $aLabPos[0] = 0 Or $aLabPos[1] = 0 Then
SetLog("Problem locating Laboratory, train laboratory position before proceeding", $COLOR_ERROR)
GUICtrlSetBkColor($g_lblLabStatus[$CurrentAccount], $COLOR_RED)
GUICtrlSetBkColor($g_lblLabStatusPO[$CurrentAccount], $COLOR_RED)
Return False
EndIf
EndIf
If $sLabUpgradeTimeStatic[$CurrentAccount] <> "" Then $TimeDiff = _DateDiff("n", _NowCalc(), $sLabUpgradeTimeStatic[$CurrentAccount])
If @error Then _logErrorDateDiff(@error)
If $g_iDebugSetlog = 1 Then SetLog(" Lab end time: " & $sLabUpgradeTimeStatic[$CurrentAccount] & ", DIFF= " & $TimeDiff, $COLOR_DEBUG)
If $g_bRunState = False Then Return
If $TimeDiff <= 0 Then
SetLog("Checking Laboratory Activity Status ...", $COLOR_INFO)
Else
SetLog("Laboratory is Running. ", $COLOR_INFO)
Return True
EndIf
BuildingClickP($aLabPos, "#0197")
If _Sleep($iDelayLaboratory1) Then Return
Local $offColors[4][3] = [[0x708CB0, 37, 34], [0x603818, 50, 43], [0xD5FC58, 61, 8], [0x000000, 82, 0]]
Global $ButtonPixel = _MultiPixelSearch(433, 565 + $g_iBottomOffsetY, 562, 619 + $g_iBottomOffsetY, 1, 1, Hex(0x000000, 6), $offColors, 30)
If IsArray($ButtonPixel) Then
If $g_iDebugSetlog = 1 Then
Setlog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("#1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 37, $ButtonPixel[1] + 34, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 50, $ButtonPixel[1] + 43, True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 61, $ButtonPixel[1] + 8, True), $COLOR_DEBUG)
EndIf
If $g_iDebugImageSave = 1 Then DebugImageSave("LabUpgrade_")
Click($ButtonPixel[0] + 40, $ButtonPixel[1] + 25, 1, 0, "#0198")
If _Sleep($iDelayLaboratory1) Then Return
Else
Setlog("Trouble finding research button, try again...", $COLOR_WARNING)
ClickP($aAway, 2, $iDelayLaboratory4, "#0199")
GUICtrlSetBkColor($g_lblLabStatus[$CurrentAccount], $COLOR_YELLOW)
GUICtrlSetBkColor($g_lblLabStatusPO[$CurrentAccount], $COLOR_YELLOW)
Return False
EndIf
If _ColorCheck(_GetPixelColor(625, 250 + $g_iMidOffsetY, True), Hex(0x60AC10, 6), 20) Or _ColorCheck(_GetPixelColor(660, 250 + $g_imidOffsetY, True), Hex(0x60AC10, 6), 20) Then
SetLog("Laboratory is Running. ", $COLOR_INFO)
If _Sleep($iDelayLaboratory2) Then Return
If $sLabUpgradeTimeStatic[$CurrentAccount] = "" Or $TimeDiff <= 0 Then
$Result = getRemainTLaboratory(336, 260)
If $g_iDebugSetlog = 1 Then Setlog($aLabTroops[$g_iCmbLaboratory][3] & " OCR Remaining Lab Time = " & $Result, $COLOR_DEBUG)
$aArray = StringSplit($Result, ' ', BitOR($STR_CHRSPLIT, $STR_NOCOUNT))
If IsArray($aArray) Then
$iRemainingTimeMin = 0
For $i = 0 To UBound($aArray) - 1
$sTime = ""
Select
Case StringInStr($aArray[$i], "d", $STR_NOCASESENSEBASIC) > 0
$sTime = StringTrimRight($aArray[$i], 1)
$iRemainingTimeMin +=(Int($sTime) * 24 * 60)
Case StringInStr($aArray[$i], "h", $STR_NOCASESENSEBASIC) > 0
$sTime = StringTrimRight($aArray[$i], 1)
$iRemainingTimeMin +=(Int($sTime) * 60)
Case StringInStr($aArray[$i], "m", $STR_NOCASESENSEBASIC) > 0
$sTime = StringTrimRight($aArray[$i], 1)
$iRemainingTimeMin += Int($sTime)
Case StringInStr($aArray[$i], "s", $STR_NOCASESENSEBASIC) > 0
$sTime = StringTrimRight($aArray[$i], 1)
$iRemainingTimeMin += Int($sTime) / 60
Case Else
Setlog("Remaining lab time OCR invalid:" & $aArray[$i], $COLOR_WARNING)
ClickP($aAway, 2, $iDelayLaboratory4, "#0328")
GUICtrlSetBkColor($g_lblLabStatus[$CurrentAccount], $COLOR_RED)
GUICtrlSetBkColor($g_lblLabStatusPO[$CurrentAccount], $COLOR_RED)
Return False
EndSelect
If $g_iDebugSetlog = 1 Then Setlog("Remain Lab Time: " & $aArray[$i] & ", Minutes= " & $iRemainingTimeMin, $COLOR_DEBUG)
Next
$sLabUpgradeTimeStatic[$CurrentAccount] = _DateAdd('n', Ceiling($iRemainingTimeMin), _NowCalc())
If @error Then _logErrorDateAdd(@error)
SetLog("Updated Lab finishing time: " & $sLabUpgradeTimeStatic[$CurrentAccount], $COLOR_SUCCESS)
Else
If $g_iDebugSetlog = 1 Then Setlog("Invalid getRemainTLaboratory OCR", $COLOR_DEBUG)
EndIf
EndIf
ClickP($aAway, 2, $iDelayLaboratory4, "#0359")
Return True
Else
SetLog("Laboratory has Stopped", $COLOR_INFO)
ClickP($aAway, 2, $iDelayLaboratory4, "#0359")
GUICtrlSetBkColor($g_lblLabStatus[$CurrentAccount], $COLOR_RED)
GUICtrlSetBkColor($g_lblLabStatusPO[$CurrentAccount], $COLOR_RED)
Return False
EndIf
EndFunc
Func HeroStatsStaus()
Local $sKingStatus, $sQueenStatus, $sWardenStatus
If ISArmyWindow(False, $ArmyTAB) = False Then
OpenArmyWindow()
If _Sleep(1500) Then Return
EndIf
$sKingStatus = ArmyHeroStatus(0)
$sQueenStatus = ArmyHeroStatus(1)
$sWardenStatus = ArmyHeroStatus(2)
ClickP($aAway, 2, 0, "#0346")
If _Sleep(1000) Then Return
EndFunc
Func setupProfileComboBox()
Local $profileString = ""
Local $aProfiles = _FileListToArray($g_sProfilePath, "*", $FLTA_FOLDERS)
If @error Then
$profileString = "<No Profiles>"
Else
Local $aProfileList[$aProfiles[0]]
For $i = 1 To $aProfiles[0]
$aProfileList[$i - 1] = $aProfiles[$i]
Next
$profileString = _ArrayToString($aProfileList, "|")
EndIf
GUICtrlSetData($g_hCmbProfile, "", "")
GUICtrlSetData($g_hCmbProfile, $profileString, "<No Profiles>")
For $x = 1 To 8
GUICtrlSetData($cmbAccount[$x], "", "")
GUICtrlSetData($cmbAccount[$x], $profileString, "<No Profiles>")
_GUICtrlComboBox_SetCurSel($cmbAccount[$x], 0)
Next
EndFunc
Func renameProfile()
Local $originalPath = $g_sProfilePath & "\" & GUICtrlRead($g_hCmbProfile)
Local $newPath = $g_sProfilePath & "\" & $g_sProfileCurrentName
If FileExists($originalPath) Then
If $g_hLogFile <> 0 Then
FileClose($g_hLogFile)
$g_hLogFile = 0
EndIf
If $g_hAttackLogFile <> 0 Then
FileClose($g_hAttackLogFile)
$g_hAttackLogFile = 0
EndIf
DirMove($originalPath, $newPath, $FC_NOOVERWRITE)
EndIf
EndFunc
Func deleteProfile()
Local $sProfile = GUICtrlRead($g_hCmbProfile)
Local $deletePath = $g_sProfilePath & "\" & $sProfile
If FileExists($deletePath) Then
If $sProfile = $g_sProfileCurrentName Then
If $g_hLogFile <> 0 Then
FileClose($g_hLogFile)
$g_hLogFile = 0
EndIf
If $g_hAttackLogFile <> 0 Then
FileClose($g_hAttackLogFile)
$g_hAttackLogFile = 0
EndIf
EndIf
DirRemove($deletePath, $DIR_REMOVE)
EndIf
EndFunc
Func createProfile($bCreateNew = False)
If $bCreateNew = True Then
setupProfileComboBox()
setupProfile()
saveConfig()
setupProfileComboBox()
selectProfile()
Return
EndIf
DirCreate($g_sProfilePath & "\" & $g_sProfileCurrentName)
If Not FileExists($g_sProfilePath & "\profile.ini") Then
Local $hFile = FileOpen($g_sProfilePath & "\profile.ini", $FO_APPEND + $FO_CREATEPATH)
FileWriteLine($hFile, "[general]")
FileClose($hFile)
EndIf
IniWrite($g_sProfilePath & "\profile.ini", "general", "defaultprofile", $g_sProfileCurrentName)
SetupProfileFolder()
DirCreate($g_sProfileLogsPath)
DirCreate($g_sProfileLootsPath)
DirCreate($g_sProfileTempPath)
DirCreate($g_sProfileTempDebugPath)
DirCreate($g_sProfileDonateCapturePath)
DirCreate($g_sProfileDonateCaptureWhitelistPath)
DirCreate($g_sProfileDonateCaptureBlacklistPath)
If FileExists($g_sProfileConfigPath) = 0 Then SetLog("New Profile '" & $g_sProfileCurrentName & "' created")
EndFunc
Func setupProfile()
If GUICtrlRead($g_hCmbProfile) = "<No Profiles>" Then
$g_sProfileCurrentName = StringRegExpReplace(GUICtrlRead($g_hTxtVillageName), '[/:*?"<>|]', '_')
Else
$g_sProfileCurrentName = GUICtrlRead($g_hCmbProfile)
EndIf
createProfile()
GUICtrlSetData($g_hGrpVillage, GetTranslated(603, 32, "Village") & ": " & $g_sProfileCurrentName)
GUICtrlSetData($g_hTxtNotifyOrigin, $g_sProfileCurrentName)
EndFunc
Func selectProfile()
If _GUICtrlComboBox_FindStringExact($g_hCmbProfile, String($g_sProfileCurrentName)) <> -1 Then
_GUICtrlComboBox_SelectString($g_hCmbProfile, String($g_sProfileCurrentName))
Else
Local $comboBoxArray = _GUICtrlComboBox_GetListArray($g_hCmbProfile)
$g_sProfileCurrentName = $comboBoxArray[1]
createProfile()
readConfig()
applyConfig()
_GUICtrlComboBox_SetCurSel($g_hCmbProfile, 0)
EndIf
GUICtrlSetData($g_hGrpVillage, GetTranslated(603, 32, "Village") & ": " & $g_sProfileCurrentName)
GUICtrlSetData($g_hTxtNotifyOrigin, $g_sProfileCurrentName)
EndFunc
Func CheckPrerequisites($bSilent = False)
Local $isAllOK = True
Local $isNetFramework4dot5Installed = isNetFramework4dot5Installed()
Local $isVC2010Installed = isVC2010Installed()
If($isNetFramework4dot5Installed = False Or $isVC2010Installed = False) Then
If($isNetFramework4dot5Installed = False And Not $bSilent) Then
SetLog("The .Net Framework 4.5 is not installed", $COLOR_ERROR)
SetLog("Please download here : https://www.microsoft.com/en-US/download/details.aspx?id=30653", $COLOR_ERROR)
EndIf
If($isVC2010Installed = False And Not $bSilent) Then
SetLog("The VC 2010 x86 is not installed", $COLOR_ERROR)
SetLog("Please download here : https://www.microsoft.com/en-US/download/details.aspx?id=5555", $COLOR_ERROR)
EndIf
$isAllOK = False
EndIf
If isEveryFileInstalled($bSilent) = False Then $isAllOK = False
If Not checkAutoitVersion($bSilent) Then $isAllOK = False
checkIsAdmin($bSilent)
If $isAllOK = False And Not $bSilent Then
GUICtrlSetState($g_hBtnStart, $GUI_DISABLE)
EndIf
If IsNetFramework452Installed() Then
$g_bSwitchAcctPrereq = True
Else
$g_bSwitchAcctPrereq = False
EndIf
Return $isAllOK
EndFunc
Func IsNetFramework452Installed()
Local $sKeyValue, $success = False
$sKeyValue = RegRead("HKLM\SOFTWARE\Microsoft\NET Framework Setup\NDP\v4\Full\", "Release")
If Number($sKeyValue) >= 379893 Then $success = True
Return $success
EndFunc
Func isNetFramework4dot5Installed()
Local $z = 0, $sKeyValue, $success = False
$sKeyValue = RegRead("HKLM\SOFTWARE\Microsoft\NET Framework Setup\NDP\v4\Full\", "Release")
If Number($sKeyValue) >= 378389 Then $success = True
Return $success
EndFunc
Func isVC2010Installed()
Local $listRegistry[4] = ["HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\10.0\VC\VCRedist\x86", "HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\VisualStudio\10.0\VC\VCRedist\x86", "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\12.0\VC\Runtimes\x86", "HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\VisualStudio\12.0\VC\Runtimes\x86" ]
Local $success = False
For $reg In $listRegistry
Local $sKeyName = RegRead($reg, "Version")
If $sKeyName <> "" Then
$success = True
ExitLoop
EndIf
Next
Return $success
EndFunc
Func isEveryFileInstalled($bSilent = False)
Local $bResult = False, $iCount = 0
Local $aCheckFiles[9] = [@ScriptDir & "\COCBot", $g_sLibPath, @ScriptDir & "\Images", $g_sLibFunctionsPath, $g_sLibImageSearchPath, $g_sLibImgLocPath, $g_sLibIconPath, $g_sLibPath & "\opencv_core220.dll", $g_sLibPath & "\opencv_imgproc220.dll"]
For $vElement In $aCheckFiles
$iCount += FileExists($vElement)
Next
If $iCount = UBound($aCheckFiles) Then
$bResult = True
ElseIf Not $bSilent Then
GUICtrlSetState($g_hBtnStart, $GUI_DISABLE)
Local $sText1="", $sText2="", $sText3="", $MsgBox=0
$sText1 = GetTranslated(640,11,"Hey Chief, we are missing some files!")
$sText2 = GetTranslated(640,12,"Please extract all files and folders and start this program again!")
$sText3 = GetTranslated(640,13,"Sorry, Start button disabled until fixed!")
Setlog($sText1, $COLOR_ERROR)
Setlog($sText2, $COLOR_ERROR)
Setlog($sText3, $COLOR_ERROR)
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$MsgBox = _ExtMsgBox(48, GetTranslated(640,14,"Ok"), $sText1, $sText2, 0)
GUICtrlSetState($g_hBtnStart, $GUI_DISABLE)
EndIf
If @Compiled Then
If Not StringInStr(@ScriptFullPath, "MyBot.run.exe", 1) Then
If Not $bSilent Then
Local $sText1, $sText2, $MsgBox
$sText1 = GetTranslated(640,15,"Hey Chief, file name incorrect!")
$sText2 = GetTranslated(640,16,'You have renamed the file "MyBot.run.exe"! Please change it back to MyBot.run.exe and restart the bot!')
$sText3 = GetTranslated(640,13,"Sorry, Start button disabled until fixed!")
Setlog($sText1, $COLOR_ERROR)
Setlog($sText2, $COLOR_ERROR)
Setlog($sText3, $COLOR_ERROR)
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$MsgBox = _ExtMsgBox(48, GetTranslated(640,14,"Ok"), $sText1, $sText2, 0)
GUICtrlSetState($g_hBtnStart, $GUI_DISABLE)
EndIf
$bResult = False
EndIf
EndIf
Return $bResult
EndFunc
Func checkAutoitVersion($bSilent = False)
If @Compiled = True Then Return 1
Local $requiredAutoit = "3.3.14.2"
Local $result = _VersionCompare(@AutoItVersion, $requiredAutoit)
If $result = 0 Or $result = 1 Then Return 1
If Not $bSilent Then
Local $sText1 = "Hey Chief, your AutoIt version is out of date!"
Local $sText3 = "Click OK to download the latest version of AutoIt."
Local $sText2 = "The bot requires AutoIt version "&$requiredAutoit&" or above. Your version of AutoIt is "&@AutoItVersion&"." & @CRLF & $sText3 & @CRLF &"After installing the new version, open the bot again."
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
Local $MsgBox = _ExtMsgBox(48, "OK|Cancel", $sText1, $sText2, 0)
If $MsgBox = 1 Then ShellExecute("https://www.autoitscript.com/site/autoit/downloads/")
EndIf
Return 0
EndFunc
Func checkIsAdmin($bSilent = False)
If IsAdmin() Then Return True
If Not $bSilent Then SetLog("My Bot running without admin privileges", $COLOR_ERROR)
Return False
EndFunc
Func VillageReport($bBypass = False, $bSuppressLog = False, $bForceUpdateAll = False)
PureClickP($aAway, 1, 0, "#0319")
If _Sleep($iDelayVillageReport1) Then Return
Switch $bBypass
Case False
If Not $bSuppressLog Then SetLog("Village Report", $COLOR_INFO)
Case True
If Not $bSuppressLog Then SetLog("Updating Village Resource Values", $COLOR_INFO)
Case Else
If Not $bSuppressLog Then SetLog("Village Report Error, You have been a BAD programmer!", $COLOR_ERROR)
EndSwitch
getBuilderCount($bSuppressLog)
If _Sleep($iDelayRespond) Then Return
$iTrophyCurrent = getTrophyMainScreen($aTrophies[0], $aTrophies[1])
If Not $bSuppressLog Then Setlog(" [T]: " & _NumberFormat($iTrophyCurrent), $COLOR_SUCCESS)
If _ColorCheck(_GetPixelColor(837, 134, True), Hex(0x302030, 6), 15) Then
$iGoldCurrent = getResourcesMainScreen(696, 23)
$iElixirCurrent = getResourcesMainScreen(696, 74)
$iDarkCurrent = getResourcesMainScreen(728, 123)
$iGemAmount = getResourcesMainScreen(740, 171)
If Not $bSuppressLog Then SetLog(" [G]: " & _NumberFormat($iGoldCurrent) & " [E]: " & _NumberFormat($iElixirCurrent) & " [D]: " & _NumberFormat($iDarkCurrent) & " [GEM]: " & _NumberFormat($iGemAmount), $COLOR_SUCCESS)
Else
$iGoldCurrent = getResourcesMainScreen(701, 23)
$iElixirCurrent = getResourcesMainScreen(701, 74)
$iDarkCurrent = ""
$iGemAmount = getResourcesMainScreen(719, 123)
If Not $bSuppressLog Then SetLog(" [G]: " & _NumberFormat($iGoldCurrent) & " [E]: " & _NumberFormat($iElixirCurrent) & " [GEM]: " & _NumberFormat($iGemAmount), $COLOR_SUCCESS)
EndIf
$g_iStatsCurrent[$CurrentAccount][$eLootGold] = $iGoldCurrent
$g_iStatsCurrent[$CurrentAccount][$eLootElixir] = $iElixirCurrent
$g_iStatsCurrent[$CurrentAccount][$eLootDarkElixir] = $iDarkCurrent
$g_iStatsCurrent[$CurrentAccount][$eLootTrophy] = $iTrophyCurrent
$g_iGemAmount[$CurrentAccount] = $iGemAmount
$g_iFreeBuilderCount[$CurrentAccount] = $iFreeBuilderCount
$g_iTotalBuilderCount[$CurrentAccount] = $iTotalBuilderCount
If $bBypass = False Then
UpdateStats($bForceUpdateAll)
EndIf
Local $i = 0
While _ColorCheck(_GetPixelColor(819, 39, True), Hex(0xF8FCFF, 6), 20) = True
$i += 1
If _Sleep($iDelayVillageReport1) Then Return
If $i >= 20 Then ExitLoop
WEnd
EndFunc
Func CheckDisplay()
Local $aPos, $sBSDisplaySize
Local $bDisplayDPI = False, $bDisplayFound = False
Local Const $iDisplaySizeMin = 780
Local $iDPIRatio = GetDPI_Ratio()
If $iDPIRatio <> 1 Then
ShowDPIHelp($iDPIRatio * 100)
Else
If $g_iDebugSetlog = 1 Then SetLog(_PadStringCenter("  Display DPI setting = " & $iDPIRatio & "  ", 53, "+"), $COLOR_INFO)
ConsoleWrite('DPI= ' & $iDPIRatio & @CRLF)
$bDisplayDPI = True
EndIf
Local $hMonitor = _WinAPI_MonitorFromWindow($HWnD)
ConsoleWrite('Handle: ' & $hMonitor & @CRLF)
Local $aMonitorData = _WinAPI_EnumDisplayMonitors()
If IsArray($aMonitorData) Then
ReDim $aMonitorData[$aMonitorData[0][0] + 1][5]
For $i = 1 To $aMonitorData[0][0]
$aPos = _WinAPI_GetPosFromRect($aMonitorData[$i][1])
For $j = 0 To 3
$aMonitorData[$i][$j + 1] = $aPos[$j]
Next
Next
ConsoleWrite('NumberDisplays: ' & $aMonitorData[0][0] & @CRLF)
For $i = 1 To $aMonitorData[0][0]
ConsoleWrite('DisplayHandle: ' & $aMonitorData[$i][0] & ', DisplayX: ' & $aMonitorData[$i][3] & ', DisplayY: ' & $aMonitorData[$i][4] & @CRLF)
If $aMonitorData[$i][0] = $hMonitor Then
$bDisplayFound = True
$sBSDisplaySize = $aMonitorData[$i][3] & "x" & $aMonitorData[$i][4]
$g_iMonitorX = $aMonitorData[$i][3]
$g_iMonitorY = $aMonitorData[$i][4]
ConsoleWrite("DisplaySizeFound: " & $sBSDisplaySize & @CRLF)
If($aMonitorData[$i][3] < $iDisplaySizeMin) Or($aMonitorData[$i][4] < $iDisplaySizeMin) Then
SetLog(_PadStringCenter(" Warning!! Display size smaller than recommended = " & $sBSDisplaySize & " ", 53, "+"), $COLOR_ERROR)
SetLog(_PadStringCenter(" MBR will attempt to auto adjust Emulator size ", 53, "+"), $COLOR_ERROR)
SetLog(_PadStringCenter(" Make sure task bar isn't covering Emulator ", 53, "+"), $COLOR_ERROR)
SetLog(_PadStringCenter(" Search MyBot.run forums if any problems ", 53, "+"), $COLOR_ERROR)
SetLog(_PadStringCenter(" Click ""Start Bot"" to proceed ", 53, "+"), $COLOR_ERROR)
Setlog(" ")
Else
ConsoleWrite("Display Check Pass!" & @CRLF)
If $g_iDebugSetlog = 1 Then SetLog(_PadStringCenter(" Display size= " & $sBSDisplaySize & " ", 50, "+"), $COLOR_INFO)
ExitLoop
EndIf
EndIf
Next
If $bDisplayFound = False Then
SetLog(" Error finding Android Emulator display device size, proceed with caution!", $COLOR_ERROR)
EndIf
Else
SetLog(" Error finding Android Emulator display device, proceed with caution!", $COLOR_ERROR)
EndIf
Return $bDisplayDPI And $bDisplayFound
EndFunc
Func ShowDPIHelp($currentDPI)
Local $text = GetTranslated(640,4,"Your DPI is incorrect. It is set to") & " " & $currentDPI & GetTranslated(640,5,"%. You must set it to 100% for this bot to work.") & @CRLF & GetTranslated(640,6,"When you have changed the DPI to the correct value, reboot your computer and run the bot again.") & @CRLF & GetTranslated(640,7,"You won't be able to use the bot until you make this change.") & @CRLF & @CRLF & GetTranslated(640,8,"Click OK to view instructions on how to change DPI")
Local $button = MsgBox($MB_OKCANCEL + $MB_ICONWARNING, GetTranslated(640,3,"DPI incorrect"), $text)
If $button = $IDOK Then
Switch @OSVersion
Case "WIN_10"
ShellExecute("https://mybot.run/forums/index.php?/topic/15137-change-dpi-to-100/#comment-141136")
Case "WIN_8", "WIN_81"
ShellExecute("https://mybot.run/forums/index.php?/topic/15137-change-dpi-to-100/#comment-141160")
Case "WIN_7"
ShellExecute("https://mybot.run/forums/index.php?/topic/15137-change-dpi-to-100/#comment-141159")
Case "WIN_VISTA"
ShellExecute("https://mybot.run/forums/index.php?/topic/15137-change-dpi-to-100/#comment-141161")
Case "WIN_2012"
ShellExecute("https://mybot.run/forums/index.php?/topic/15137-change-dpi-to-100/#comment-141160")
Case Else
MsgBox($MB_OK, GetTranslated(640,9,"Unsupported"), GetTranslated(640,10,"Sorry, your operating system isn't supported by the bot."))
EndSwitch
EndIf
btnStop()
GUICtrlSetState($g_hBtnStart, $GUI_DISABLE)
EndFunc
Func AttackReport()
Static $iBonusLast = 0
Local $LeagueShort = ""
Local $iCount
$iCount = 0
While _CheckPixel($aEndFightSceneAvl, True) = False
$iCount += 1
If _Sleep($iDelayAttackReport1) Then Return
If $g_iDebugSetlog = 1 Then Setlog("Waiting Attack Report Ready, " &($iCount / 2) & " Seconds.", $COLOR_DEBUG)
If $iCount > 30 Then ExitLoop
WEnd
If $iCount > 30 Then Setlog("End of Attack scene slow to appear, attack values my not be correct", $COLOR_INFO)
$iCount = 0
While getResourcesLoot(333, 289 + $g_iMidOffsetY) = ""
$iCount += 1
If _Sleep($iDelayAttackReport1) Then Return
If $g_iDebugSetlog = 1 Then Setlog("Waiting Attack Report Ready, " &($iCount / 2) & " Seconds.", $COLOR_DEBUG)
If $iCount > 20 Then ExitLoop
WEnd
If $iCount > 20 Then Setlog("End of Attack scene read gold error, attack values my not be correct", $COLOR_INFO)
If _ColorCheck(_GetPixelColor($aAtkRprtDECheck[0], $aAtkRprtDECheck[1], True), Hex($aAtkRprtDECheck[2], 6), $aAtkRprtDECheck[3]) Then
$g_iStatsLastAttack[$CurrentAccount][$eLootGold] = getResourcesLoot(333, 289 + $g_iMidOffsetY)
If _Sleep($iDelayAttackReport2) Then Return
$g_iStatsLastAttack[$CurrentAccount][$eLootElixir] = getResourcesLoot(333, 328 + $g_iMidOffsetY)
If _Sleep($iDelayAttackReport2) Then Return
$g_iStatsLastAttack[$CurrentAccount][$eLootDarkElixir] = getResourcesLootDE(365, 365 + $g_iMidOffsetY)
If _Sleep($iDelayAttackReport2) Then Return
$g_iStatsLastAttack[$CurrentAccount][$eLootTrophy] = getResourcesLootT(403, 402 + $g_iMidOffsetY)
If _ColorCheck(_GetPixelColor($aAtkRprtTrophyCheck[0], $aAtkRprtTrophyCheck[1], True), Hex($aAtkRprtTrophyCheck[2], 6), $aAtkRprtTrophyCheck[3]) Then
$g_iStatsLastAttack[$CurrentAccount][$eLootTrophy] = -$g_iStatsLastAttack[$CurrentAccount][$eLootTrophy]
EndIf
SetLog("Loot: [G]: " & _NumberFormat($g_iStatsLastAttack[$CurrentAccount][$eLootGold]) & " [E]: " & _NumberFormat($g_iStatsLastAttack[$CurrentAccount][$eLootElixir]) & " [DE]: " & _NumberFormat($g_iStatsLastAttack[$CurrentAccount][$eLootDarkElixir]) & " [T]: " & $g_iStatsLastAttack[$CurrentAccount][$eLootTrophy], $COLOR_SUCCESS)
Else
$g_iStatsLastAttack[$CurrentAccount][$eLootGold] = getResourcesLoot(333, 289 + $g_iMidOffsetY)
If _Sleep($iDelayAttackReport2) Then Return
$g_iStatsLastAttack[$CurrentAccount][$eLootElixir] = getResourcesLoot(333, 328 + $g_iMidOffsetY)
If _Sleep($iDelayAttackReport2) Then Return
$g_iStatsLastAttack[$CurrentAccount][$eLootTrophy] = getResourcesLootT(403, 365 + $g_iMidOffsetY)
If _ColorCheck(_GetPixelColor($aAtkRprtTrophyCheck[0], $aAtkRprtTrophyCheck[1], True), Hex($aAtkRprtTrophyCheck[2], 6), $aAtkRprtTrophyCheck[3]) Then
$g_iStatsLastAttack[$CurrentAccount][$eLootTrophy] = -$g_iStatsLastAttack[$CurrentAccount][$eLootTrophy]
EndIf
$g_iStatsLastAttack[$CurrentAccount][$eLootDarkElixir] = ""
SetLog("Loot: [G]: " & _NumberFormat($g_iStatsLastAttack[$CurrentAccount][$eLootGold]) & " [E]: " & _NumberFormat($g_iStatsLastAttack[$CurrentAccount][$eLootElixir]) & " [T]: " & $g_iStatsLastAttack[$CurrentAccount][$eLootTrophy], $COLOR_SUCCESS)
EndIf
If $g_iStatsLastAttack[$CurrentAccount][$eLootTrophy] >= 0 Then
$iBonusLast = Number(getResourcesBonusPerc(570, 309 + $g_iMidOffsetY))
If $iBonusLast > 0 Then
SetLog("Bonus Percentage: " & $iBonusLast & "%")
Local $iCalcMaxBonus = 0, $iCalcMaxBonusDark = 0
If _ColorCheck(_GetPixelColor($aAtkRprtDECheck2[0], $aAtkRprtDECheck2[1], True), Hex($aAtkRprtDECheck2[2], 6), $aAtkRprtDECheck2[3]) Then
If _Sleep($iDelayAttackReport2) Then Return
$g_iStatsBonusLast[$CurrentAccount][$eLootGold] = getResourcesBonus(590, 340 + $g_iMidOffsetY)
$g_iStatsBonusLast[$CurrentAccount][$eLootGold] = StringReplace($g_iStatsBonusLast[$CurrentAccount][$eLootGold], "+", "")
If _Sleep($iDelayAttackReport2) Then Return
$g_iStatsBonusLast[$CurrentAccount][$eLootElixir] = getResourcesBonus(590, 371 + $g_iMidOffsetY)
$g_iStatsBonusLast[$CurrentAccount][$eLootElixir] = StringReplace($g_iStatsBonusLast[$CurrentAccount][$eLootElixir], "+", "")
If _Sleep($iDelayAttackReport2) Then Return
$g_iStatsBonusLast[$CurrentAccount][$eLootDarkElixir] = getResourcesBonus(621, 402 + $g_iMidOffsetY)
$g_iStatsBonusLast[$CurrentAccount][$eLootDarkElixir] = StringReplace($g_iStatsBonusLast[$CurrentAccount][$eLootDarkElixir], "+", "")
If $iBonusLast = 100 Then
$iCalcMaxBonus = $g_iStatsBonusLast[$CurrentAccount][$eLootGold]
SetLog("Bonus [G]: " & _NumberFormat($g_iStatsBonusLast[$CurrentAccount][$eLootGold]) & " [E]: " & _NumberFormat($g_iStatsBonusLast[$CurrentAccount][$eLootElixir]) & " [DE]: " & _NumberFormat($g_iStatsBonusLast[$CurrentAccount][$eLootDarkElixir]), $COLOR_SUCCESS)
Else
$iCalcMaxBonus = Number($g_iStatsBonusLast[$CurrentAccount][$eLootGold] /($iBonusLast / 100))
$iCalcMaxBonusDark = Number($g_iStatsBonusLast[$CurrentAccount][$eLootDarkElixir] /($iBonusLast / 100))
SetLog("Bonus [G]: " & _NumberFormat($g_iStatsBonusLast[$CurrentAccount][$eLootGold]) & " out of " & _NumberFormat($iCalcMaxBonus) & " [E]: " & _NumberFormat($g_iStatsBonusLast[$CurrentAccount][$eLootElixir]) & " out of " & _NumberFormat($iCalcMaxBonus) & " [DE]: " & _NumberFormat($g_iStatsBonusLast[$CurrentAccount][$eLootDarkElixir]) & " out of " & _NumberFormat($iCalcMaxBonusDark), $COLOR_SUCCESS)
EndIf
Else
If _Sleep($iDelayAttackReport2) Then Return
$g_iStatsBonusLast[$CurrentAccount][$eLootGold] = getResourcesBonus(590, 340 + $g_iMidOffsetY)
$g_iStatsBonusLast[$CurrentAccount][$eLootGold] = StringReplace($g_iStatsBonusLast[$CurrentAccount][$eLootGold], "+", "")
If _Sleep($iDelayAttackReport2) Then Return
$g_iStatsBonusLast[$CurrentAccount][$eLootElixir] = getResourcesBonus(590, 371 + $g_iMidOffsetY)
$g_iStatsBonusLast[$CurrentAccount][$eLootElixir] = StringReplace($g_iStatsBonusLast[$CurrentAccount][$eLootElixir], "+", "")
$g_iStatsBonusLast[$CurrentAccount][$eLootDarkElixir] = 0
If $iBonusLast = 100 Then
$iCalcMaxBonus = $g_iStatsBonusLast[$CurrentAccount][$eLootGold]
SetLog("Bonus [G]: " & _NumberFormat($g_iStatsBonusLast[$CurrentAccount][$eLootGold]) & " [E]: " & _NumberFormat($g_iStatsBonusLast[$CurrentAccount][$eLootElixir]), $COLOR_SUCCESS)
Else
$iCalcMaxBonus = Number($g_iStatsBonusLast[$CurrentAccount][$eLootGold] /($iBonusLast / 100))
SetLog("Bonus [G]: " & _NumberFormat($g_iStatsBonusLast[$CurrentAccount][$eLootGold]) & " out of " & _NumberFormat($iCalcMaxBonus) & " [E]: " & _NumberFormat($g_iStatsBonusLast[$CurrentAccount][$eLootElixir]) & " out of " & _NumberFormat($iCalcMaxBonus), $COLOR_SUCCESS)
EndIf
EndIf
$LeagueShort = "--"
For $i = 1 To 21
If _Sleep($iDelayAttackReport2) Then Return
If $League[$i][0] = $iCalcMaxBonus Then
SetLog("Your league level is: " & $League[$i][1])
$LeagueShort = $League[$i][3]
ExitLoop
EndIf
Next
Else
SetLog("No Bonus")
$LeagueShort = "--"
If $iTrophyCurrent + $g_iStatsLastAttack[$CurrentAccount][$eLootTrophy] >= 400 And $iTrophyCurrent + $g_iStatsLastAttack[$CurrentAccount][$eLootTrophy] < 500 Then
SetLog("Your league level is: " & $League[0][1])
$LeagueShort = $League[0][3]
EndIf
EndIf
GUICtrlSetData($g_hLblLeague, "")
If StringInStr($LeagueShort, "1") > 1 Then
GUICtrlSetData($g_hLblLeague, "1")
ElseIf StringInStr($LeagueShort, "2") > 1 Then
GUICtrlSetData($g_hLblLeague, "2")
ElseIf StringInStr($LeagueShort, "3") > 1 Then
GUICtrlSetData($g_hLblLeague, "3")
EndIf
_GUI_Value_STATE("HIDE", $groupLeague)
If StringInStr($LeagueShort, "B") > 0 Then
GUICtrlSetState($g_ahPicLeague[$eLeagueBronze], $GUI_SHOW)
ElseIf StringInStr($LeagueShort, "S") > 0 Then
GUICtrlSetState($g_ahPicLeague[$eLeagueSilver], $GUI_SHOW)
ElseIf StringInStr($LeagueShort, "G") > 0 Then
GUICtrlSetState($g_ahPicLeague[$eLeagueGold], $GUI_SHOW)
ElseIf StringInStr($LeagueShort, "c", $STR_CASESENSE) > 0 Then
GUICtrlSetState($g_ahPicLeague[$eLeagueCrystal], $GUI_SHOW)
ElseIf StringInStr($LeagueShort, "M") > 0 Then
GUICtrlSetState($g_ahPicLeague[$eLeagueMaster], $GUI_SHOW)
ElseIf StringInStr($LeagueShort, "C", $STR_CASESENSE) > 0 Then
GUICtrlSetState($g_ahPicLeague[$eLeagueChampion], $GUI_SHOW)
ElseIf StringInStr($LeagueShort, "T") > 0 Then
GUICtrlSetState($g_ahPicLeague[$eLeagueTitan], $GUI_SHOW)
ElseIf StringInStr($LeagueShort, "LE") > 0 Then
GUICtrlSetState($g_ahPicLeague[$eLeagueLegend], $GUI_SHOW)
Else
GUICtrlSetState($g_ahPicLeague[$eLeagueUnranked],$GUI_SHOW)
EndIf
Else
$g_iStatsBonusLast[$CurrentAccount][$eLootGold] = 0
$g_iStatsBonusLast[$CurrentAccount][$eLootElixir] = 0
$g_iStatsBonusLast[$CurrentAccount][$eLootDarkElixir] = 0
$LeagueShort = "--"
EndIf
Local $starsearned = 0
If _ColorCheck(_GetPixelColor($aWonOneStarAtkRprt[0], $aWonOneStarAtkRprt[1], True), Hex($aWonOneStarAtkRprt[2], 6), $aWonOneStarAtkRprt[3]) Then $starsearned += 1
If _ColorCheck(_GetPixelColor($aWonTwoStarAtkRprt[0], $aWonTwoStarAtkRprt[1], True), Hex($aWonTwoStarAtkRprt[2], 6), $aWonTwoStarAtkRprt[3]) Then $starsearned += 1
If _ColorCheck(_GetPixelColor($aWonThreeStarAtkRprt[0], $aWonThreeStarAtkRprt[1], True), Hex($aWonThreeStarAtkRprt[2], 6), $aWonThreeStarAtkRprt[3]) Then $starsearned += 1
SetLog("Stars earned: " & $starsearned)
Local $AtkLogTxt
If $ichkSwitchAccount = 1 Then
$AtkLogTxt = String($CurrentAccount) & " |" & _NowTime(4) & "|"
$AtkLogTxt &= StringFormat("%5d", $iTrophyCurrent) & "|"
$AtkLogTxt &= StringFormat("%4d", $SearchCount) & "|"
$AtkLogTxt &= StringFormat("%7d", $g_iStatsLastAttack[$CurrentAccount][$eLootGold]) & "|"
$AtkLogTxt &= StringFormat("%7d", $g_iStatsLastAttack[$CurrentAccount][$eLootElixir]) & "|"
$AtkLogTxt &= StringFormat("%7d", $g_iStatsLastAttack[$CurrentAccount][$eLootDarkElixir]) & "|"
$AtkLogTxt &= StringFormat("%3d", $g_iStatsLastAttack[$CurrentAccount][$eLootTrophy]) & "|"
$AtkLogTxt &= StringFormat("%1d", $starsearned) & "|"
$AtkLogTxt &= StringFormat("%6d", $g_iStatsBonusLast[$CurrentAccount][$eLootGold]) & "|"
$AtkLogTxt &= StringFormat("%6d", $g_iStatsBonusLast[$CurrentAccount][$eLootElixir]) & "|"
$AtkLogTxt &= StringFormat("%4d", $g_iStatsBonusLast[$CurrentAccount][$eLootDarkElixir]) & "|"
$AtkLogTxt &= $LeagueShort & "|"
Else
$AtkLogTxt = "" & _NowTime(4) & "|"
$AtkLogTxt &= StringFormat("%5d", $iTrophyCurrent) & "|"
$AtkLogTxt &= StringFormat("%6d", $SearchCount) & "|"
$AtkLogTxt &= StringFormat("%7d", $g_iStatsLastAttack[$CurrentAccount][$eLootGold]) & "|"
$AtkLogTxt &= StringFormat("%7d", $g_iStatsLastAttack[$CurrentAccount][$eLootElixir]) & "|"
$AtkLogTxt &= StringFormat("%7d", $g_iStatsLastAttack[$CurrentAccount][$eLootDarkElixir]) & "|"
$AtkLogTxt &= StringFormat("%3d", $g_iStatsLastAttack[$CurrentAccount][$eLootTrophy]) & "|"
$AtkLogTxt &= StringFormat("%1d", $starsearned) & "|"
$AtkLogTxt &= StringFormat("%6d", $g_iStatsBonusLast[$CurrentAccount][$eLootGold]) & "|"
$AtkLogTxt &= StringFormat("%6d", $g_iStatsBonusLast[$CurrentAccount][$eLootElixir]) & "|"
$AtkLogTxt &= StringFormat("%4d", $g_iStatsBonusLast[$CurrentAccount][$eLootDarkElixir]) & "|"
$AtkLogTxt &= $LeagueShort & "|"
EndIf
Local $AtkLogTxtExtend
$AtkLogTxtExtend = "|"
$AtkLogTxtExtend &= $CurCamp & "/" & $TotalCamp & "|"
If Int($g_iStatsLastAttack[$CurrentAccount][$eLootTrophy]) >= 0 Then
SetAtkLog($AtkLogTxt, $AtkLogTxtExtend, $COLOR_BLACK)
Else
SetAtkLog($AtkLogTxt, $AtkLogTxtExtend, $COLOR_ERROR)
EndIf
AppendLineToSSALog($AtkLogTxt)
If $g_iDebugDeadBaseImage = 1 Then
setZombie($g_iStatsLastAttack[$CurrentAccount][$eLootElixir])
EndIf
If $iShareAttack = 1 Then
If(Number($g_iStatsLastAttack[$CurrentAccount][$eLootGold]) >= Number($iShareminGold)) And(Number($g_iStatsLastAttack[$CurrentAccount][$eLootElixir]) >= Number($iShareminElixir)) And(Number($g_iStatsLastAttack[$CurrentAccount][$eLootDarkElixir]) >= Number($iSharemindark)) Then
SetLog("Reached miminum Loot values... Share Replay")
$iShareAttackNow = 1
Else
SetLog("Below miminum Loot values... No Share Replay")
$iShareAttackNow = 0
EndIf
EndIf
If $g_iFirstAttack = 0 Then $g_iFirstAttack = 1
$g_iStatsTotalGain[$CurrentAccount][$eLootGold] += $g_iStatsLastAttack[$CurrentAccount][$eLootGold] + $g_iStatsBonusLast[$CurrentAccount][$eLootGold]
$g_iTotalGoldGain[$CurrentAccount][$g_iMatchMode] += $g_iStatsLastAttack[$CurrentAccount][$eLootGold] + $g_iStatsBonusLast[$CurrentAccount][$eLootGold]
$g_iStatsTotalGain[$CurrentAccount][$eLootElixir] += $g_iStatsLastAttack[$CurrentAccount][$eLootElixir] + $g_iStatsBonusLast[$CurrentAccount][$eLootElixir]
$g_iTotalElixirGain[$CurrentAccount][$g_iMatchMode] += $g_iStatsLastAttack[$CurrentAccount][$eLootElixir] + $g_iStatsBonusLast[$CurrentAccount][$eLootElixir]
If $g_iStatsStartedWith[$CurrentAccount][$eLootDarkElixir] <> "" Then
$g_iStatsTotalGain[$CurrentAccount][$eLootDarkElixir] += $g_iStatsLastAttack[$CurrentAccount][$eLootDarkElixir] + $g_iStatsBonusLast[$CurrentAccount][$eLootDarkElixir]
$g_iTotalDarkGain[$CurrentAccount][$g_iMatchMode] += $g_iStatsLastAttack[$CurrentAccount][$eLootDarkElixir] + $g_iStatsBonusLast[$CurrentAccount][$eLootDarkElixir]
EndIf
$g_iStatsTotalGain[$CurrentAccount][$eLootTrophy] += $g_iStatsLastAttack[$CurrentAccount][$eLootTrophy]
$g_iTotalTrophyGain[$CurrentAccount][$g_iMatchMode] += $g_iStatsLastAttack[$CurrentAccount][$eLootTrophy]
If $g_iMatchMode = $TS Then
If $starsearned > 0 Then
$g_iNbrOfTHSnipeSuccess[$CurrentAccount] += 1
Else
$g_iNbrOfTHSnipeFails[$CurrentAccount] += 1
EndIf
EndIf
$g_iAttackedVillageCount[$CurrentAccount][$g_iMatchMode] += 1
UpdateStats()
$actual_train_skip = 0
EndFunc
Global $aTxtLogInitText[0][6] = [[]]
Global $aTxtAtkLogInitText[0][6] = [[]]
Func SetLog($String, $Color = Default, $Font = Default, $FontSize = Default, $statusbar = Default, $time = Default, $bConsoleWrite = True, $LogPrefix = "L ", $bPostponed = $g_bCriticalMessageProcessing)
If $Color = Default Then $Color = $COLOR_BLACK
If $Font = Default Then $Font = "Verdana"
If $FontSize = Default Then $FontSize = 7.5
If $statusbar = Default Then $statusbar = 1
If $time = Default Then $time = Time()
Local $log = $LogPrefix & TimeDebug() & $String
If $bConsoleWrite = True And $String <> "" Then
Local $sLevel = GetLogLevel($Color)
ConsoleWrite($sLevel & $log & @CRLF)
EndIf
If $g_hLogFile = 0 Then CreateLogFile()
__FileWriteLog($g_hLogFile, $log)
If $g_bSilentSetLog = True Then
Return
EndIf
Local $txtLogMutex = AcquireMutex("txtLog")
Local $iIndex = UBound($aTxtLogInitText)
ReDim $aTxtLogInitText[$iIndex + 1][6]
$aTxtLogInitText[$iIndex][0] = $String
$aTxtLogInitText[$iIndex][1] = $Color
$aTxtLogInitText[$iIndex][2] = $Font
$aTxtLogInitText[$iIndex][3] = $FontSize
$aTxtLogInitText[$iIndex][4] = $statusbar
$aTxtLogInitText[$iIndex][5] = $time
ReleaseMutex($txtLogMutex)
If $g_hTxtLog <> 0 And $g_bRunState = False Or($bPostponed = False And TimerDiff($g_hTxtLogTimer) >= $g_iTxtLogTimerTimeout) Then
CheckPostponedLog()
EndIf
EndFunc
Func GetLogLevel($Color)
Local $sLevel = ""
Switch $Color
Case $COLOR_ERROR
$sLevel = "ERROR    "
Case $COLOR_WARNING
$sLevel = "WARN     "
Case $COLOR_SUCCESS
$sLevel = "SUCCESS  "
Case $COLOR_SUCCESS1
$sLevel = "SUCCESS1 "
Case $COLOR_INFO
$sLevel = "INFO     "
Case $COLOR_DEBUG
$sLevel = "DEBUG    "
Case $COLOR_DEBUG1
$sLevel = "DEBUG1   "
Case $COLOR_DEBUG2
$sLevel = "DEBUG2   "
Case $COLOR_DEBUGS
$sLevel = "DEBUGS   "
Case $COLOR_ACTION
$sLevel = "ACTION   "
Case $COLOR_ACTION1
$sLevel = "ACTION1  "
Case $COLOR_ORANGE
$sLevel = "ORANGE   "
Case $COLOR_BLACK
$sLevel = "NORMAL   "
Case Else
$sLevel = Hex($Color, 6) & "   "
EndSwitch
Return $sLevel
EndFunc
Func SetLogText(ByRef $hTxtLog, ByRef $String, ByRef $Color, ByRef $Font, ByRef $FontSize, ByRef $time)
If $time Then
_GUICtrlRichEdit_SetFont($hTxtLog, 6, "Lucida Console")
_GUICtrlRichEdit_AppendTextColor($hTxtLog, $time, 0x000000, False)
EndIf
_GUICtrlRichEdit_SetFont($hTxtLog, $FontSize, $Font)
_GUICtrlRichEdit_AppendTextColor($hTxtLog, $String & @CRLF, _ColorConvert($Color), False)
EndFunc
Func SetDebugLog($String, $Color = Default, $bSilentSetLog = Default, $Font = Default, $FontSize = Default, $statusbar = Default)
If $Color = Default Then $Color = $COLOR_DEBUG
If $bSilentSetLog = Default Then $bSilentSetLog = False
If $statusbar = Default Then $statusbar = 0
Local $LogPrefix = "D "
Local $log = $LogPrefix & TimeDebug() & $String
If $g_iDebugSetlog = 1 And $bSilentSetLog = False Then
SetLog($String, $Color, $Font, $FontSize, $statusbar, Time(), True, $LogPrefix)
Else
If $String <> "" Then ConsoleWrite(GetLogLevel($Color) & $log & @CRLF)
If $g_hLogFile = 0 Then CreateLogFile()
__FileWriteLog($g_hLogFile, $log)
EndIf
EndFunc
Func SetGuiLog($String, $Color = Default, $bGuiLog = Default)
If $bGuiLog = Default Then $bGuiLog = True
If $bGuiLog = True Then
Return SetLog($String, $Color)
EndIf
Return SetDebugLog($String, $Color)
EndFunc
Func FlushGuiLog(ByRef $hTxtLog, ByRef $aTxtLog, $bUpdateStatus = False, $sLogMutexName = "txtLog")
Local $wasLock = AndroidShieldLock(True)
Local $txtLogMutex = AcquireMutex($sLogMutexName)
Local $activeBot = _WinAPI_GetActiveWindow() = $g_hFrmBot
Local $hCtrl = _WinAPI_GetFocus()
_SendMessage($hTxtLog, $WM_SETREDRAW, False, 0)
_WinAPI_EnableWindow($hTxtLog, False)
_GUICtrlRichEdit_SetSel($hTxtLog, -1, -1)
Local $i
For $i = 0 To UBound($aTxtLog) - 1
If $i < UBound($aTxtLog) And UBound($aTxtLog, 2) > 5 Then
SetLogText($hTxtLog, $aTxtLog[$i][0], $aTxtLog[$i][1], $aTxtLog[$i][2], $aTxtLog[$i][3], $aTxtLog[$i][5])
EndIf
Next
Local $iLogs = UBound($aTxtLog)
If $bUpdateStatus = True And $iLogs - 1 >= 0 And $aTxtLog[$iLogs - 1][4] = 1 And $g_hStatusBar <> 0 Then
_GUICtrlStatusBar_SetText($g_hStatusBar, "Status : " & $aTxtLog[$iLogs - 1][0])
EndIf
$iLogs = UBound($aTxtLog)
Redim $aTxtLog[0][6]
_WinAPI_EnableWindow($hTxtLog, True)
_GUICtrlRichEdit_SetSel($hTxtLog, -1, -1)
_SendMessage($hTxtLog, $WM_SETREDRAW, True, 0)
_WinAPI_RedrawWindow($hTxtLog, 0, 0, $RDW_INVALIDATE)
If $activeBot And $hCtrl <> $hTxtLog Then _WinAPI_SetFocus($hCtrl)
ReleaseMutex($txtLogMutex)
AndroidShieldLock($wasLock)
Return $iLogs
EndFunc
Func CheckPostponedLog()
Local $iLogs = 0
If $g_bCriticalMessageProcessing Or TimerDiff($g_hTxtLogTimer) < $g_iTxtLogTimerTimeout Then Return 0
If UBound($aTxtLogInitText) > 0 And $g_hTxtLog <> 0 Then
$iLogs += FlushGuiLog($g_hTxtLog, $aTxtLogInitText, True, "txtLog")
EndIf
If UBound($aTxtAtkLogInitText) > 0 And $g_hTxtAtkLog <> 0 Then
$iLogs += FlushGuiLog($g_hTxtAtkLog, $aTxtAtkLogInitText, False, "txtAtkLog")
EndIf
$g_hTxtLogTimer = TimerInit()
Return $iLogs
EndFunc
Func _GUICtrlRichEdit_AppendTextColor($hWnd, $sText, $iColor, $bGotoEnd = True)
If $bGotoEnd Then _GUICtrlRichEdit_SetSel($hWnd, -1, -1)
_GUICtrlRichEdit_SetCharColor($hWnd, $iColor)
_GUICtrlRichEdit_AppendText($hWnd, $sText)
EndFunc
Func _ColorConvert($nColor)
Return BitOR(BitShift(BitAND($nColor, 0x000000FF), -16), BitAND($nColor, 0x0000FF00), BitShift(BitAND($nColor, 0x00FF0000), 16))
EndFunc
Func SetAtkLog($String1, $String2 = "", $Color = $COLOR_BLACK, $Font = "Lucida Console", $FontSize = 7.5)
If $g_hAttackLogFile = 0 Then CreateAttackLogFile()
_FileWriteLog($g_hAttackLogFile, $String1 & $String2)
Local $txtLogMutex = AcquireMutex("txtAtkLog")
Local $iIndex = UBound($aTxtAtkLogInitText)
ReDim $aTxtAtkLogInitText[$iIndex + 1][6]
$aTxtAtkLogInitText[$iIndex][0] = $String1
$aTxtAtkLogInitText[$iIndex][1] = $Color
$aTxtAtkLogInitText[$iIndex][2] = $Font
$aTxtAtkLogInitText[$iIndex][3] = $FontSize
$aTxtAtkLogInitText[$iIndex][4] = 0
$aTxtAtkLogInitText[$iIndex][5] = 0
ReleaseMutex($txtLogMutex)
EndFunc
Func AtkLogHead()
If $ichkSwitchAccount = 1 Then
SetAtkLog(_PadStringCenter(" " & GetTranslated(601, 15, "ATTACK LOG") & " ", 71, "="), "", $COLOR_BLACK, "MS Shell Dlg", 8.5)
SetAtkLog(GetTranslated(601, 16, "                    --------  LOOT --------       ----- BONUS ------"), "")
SetAtkLog(GetTranslated(601, 17, "Ac| TIME|TROP.| SRC|   GOLD| ELIXIR|DARK EL|TR.|S|  GOLD|ELIXIR|  DE|L."), "")
Else
SetAtkLog(_PadStringCenter(" " & GetTranslated(601, 15, "ATTACK LOG") & " ", 71, "="), "", $COLOR_BLACK, "MS Shell Dlg", 8.5)
SetAtkLog(GetTranslated(601, 16, "                   --------  LOOT --------       ----- BONUS ------"), "")
SetAtkLog(GetTranslated(601, 17, " TIME|TROP.|SEARCH|   GOLD| ELIXIR|DARK EL|TR.|S|  GOLD|ELIXIR|  DE|L."), "")
EndIf
EndFunc
Func __FileWriteLog($handle, $text)
FileWriteLine($handle, $text)
EndFunc
Global $checkObstaclesActive = False
Func checkObstacles()
If TestCapture() = False And WinGetAndroidHandle() = 0 Then
Return True
EndIf
If $checkObstaclesActive = True Then Return True
Local $wasForce = OcrForceCaptureRegion(False)
$checkObstaclesActive = True
Local $Result = _checkObstacles()
OcrForceCaptureRegion($wasForce)
$checkObstaclesActive = False
Return $Result
EndFunc
Func _checkObstacles()
Static $hCocReconnectingTimer = 0
Local $msg, $x, $y, $result
$MinorObstacle = False
_CaptureRegion()
_CaptureRegion2Sync()
If UBound(decodeSingleCoord(FindImageInPlace("CocReconnecting", $CocReconnecting, "420,355,440,375", False))) > 1 Then
If $hCocReconnectingTimer = 0 Then
SetLog("Network Connection lost...", $COLOR_ERROR)
$hCocReconnectingTimer = TimerInit()
ElseIf TimerDiff($hCocReconnectingTimer) > $g_iCoCReconnectingTimeout Then
SetLog("Network Connection really lost, Reloading CoC...", $COLOR_ERROR)
$hCocReconnectingTimer = 0
Return checkObstacles_ReloadCoC()
Else
SetLog("Network Connection lost, waiting...", $COLOR_ERROR)
EndIf
Else
$hCocReconnectingTimer = 0
EndIf
If $g_sAndroidGameDistributor <> $g_sGoogle Then
Local $aXButton = FindAdsXButton()
If IsArray($aXButton) Then
SetDebugLog("checkObstacles: Found " & $g_sAndroidGameDistributor & " ADS X button to close")
PureClickP($aXButton)
$MinorObstacle = True
If _Sleep($iDelaycheckObstacles1) Then Return
Return False
EndIf
EndIf
Local $aMessage = _PixelSearch($aIsReloadError[0], $aIsReloadError[1], $aIsReloadError[0] + 3, $aIsReloadError[1] + 11, Hex($aIsReloadError[2], 6), $aIsReloadError[3], $g_bNoCapturePixel)
If IsArray($aMessage) Then
If $g_iDebugSetlog = 1 Then SetLog("(Inactive=" & _GetPixelColor($aIsInactive[0], $aIsInactive[1]) & ")(DC=" & _GetPixelColor($aIsConnectLost[0], $aIsConnectLost[1]) & ")(OoS=" & _GetPixelColor($aIsCheckOOS[0], $aIsCheckOOS[1]) & ")", $COLOR_DEBUG)
If $g_iDebugSetlog = 1 Then SetLog("(Maintenance=" & _GetPixelColor($aIsMaintenance[0], $aIsMaintenance[1]) & ")(RateCoC=" & ")", $COLOR_DEBUG)
If $g_iDebugSetlog = 1 Then SetLog("33B5E5=>true, 282828=>false", $COLOR_DEBUG)
$result = getOcrMaintenanceTime(184, 325 + $g_iMidOffsetY, "Another Device OCR:")
If StringInStr($result, "device", $STR_NOCASESENSEBASIC) Or UBound(decodeSingleCoord(FindImageInPlace("Device", $device, "220,330,300,390", False))) > 1 Then
If TestCapture() Then Return "Another Device has connected"
If $sTimeWakeUp > 3600 Then
SetLog("Another Device has connected, waiting " & Floor(Floor($sTimeWakeUp / 60) / 60) & " hours " & Floor(Mod(Floor($sTimeWakeUp / 60), 60)) & " minutes " & Floor(Mod($sTimeWakeUp, 60)) & " seconds", $COLOR_ERROR)
PushMsg("AnotherDevice3600")
ElseIf $sTimeWakeUp > 60 Then
SetLog("Another Device has connected, waiting " & Floor(Mod(Floor($sTimeWakeUp / 60), 60)) & " minutes " & Floor(Mod($sTimeWakeUp, 60)) & " seconds", $COLOR_ERROR)
PushMsg("AnotherDevice60")
Else
SetLog("Another Device has connected, waiting " & Floor(Mod($sTimeWakeUp, 60)) & " seconds", $COLOR_ERROR)
PushMsg("AnotherDevice")
EndIf
If _SleepStatus($sTimeWakeUp * 1000) Then Return
checkObstacles_ReloadCoC($aReloadButton, "#0127")
If $ichkSinglePBTForced = 1 Then $g_bGForcePBTUpdate = True
checkObstacles_ResetSearch()
Return True
EndIf
If UBound(decodeSingleCoord(FindImageInPlace("Break", $break, "165,287,335,325", False))) > 1 Then
SetLog("Village must take a break, wait ...", $COLOR_ERROR)
PushMsg("TakeBreak")
If _SleepStatus($iDelaycheckObstacles4) Then Return
checkObstacles_ReloadCoC($aReloadButton, "#0128")
If $ichkSinglePBTForced = 1 Then $g_bGForcePBTUpdate = True
checkObstacles_ResetSearch()
Return True
EndIf
Select
Case _CheckPixel($aIsInactive, $g_bNoCapturePixel)
SetLog("Village was Inactive, Reloading CoC...", $COLOR_ERROR)
If $ichkSinglePBTForced = 1 Then $g_bGForcePBTUpdate = True
Case _CheckPixel($aIsConnectLost, $g_bNoCapturePixel)
$result = getOcrMaintenanceTime(171, 358 + $g_iMidOffsetY, "Check Obstacles OCR 'policy at super'=")
If StringInStr($result, "policy", $STR_NOCASESENSEBASIC) Then
$msg = "Sorry but account has been banned, Bot must stop!!"
BanMsgBox()
Return checkObstacles_StopBot($msg)
EndIf
$result = getOcrMaintenanceTime(171, 337 + $g_iMidOffsetY, "Check Obstacles OCR 'prohibited 3rd'= ")
If StringInStr($result, "3rd", $STR_NOCASESENSEBASIC) Then
$msg = "Sorry but account has been banned, Bot must stop!!"
BanMsgBox()
Return checkObstacles_StopBot($msg)
EndIf
SetLog("Connection lost, Reloading CoC...", $COLOR_ERROR)
Case _CheckPixel($aIsCheckOOS, $g_bNoCapturePixel)
SetLog("Out of Sync Error, Reloading CoC...", $COLOR_ERROR)
Case _CheckPixel($aIsMaintenance, $g_bNoCapturePixel)
$result = getOcrMaintenanceTime(171, 345 + $g_iMidOffsetY, "Check Obstacles OCR Maintenance Break=")
Local $iMaintenanceWaitTime = 0
Select
Case $result = ""
$iMaintenanceWaitTime = $iDelaycheckObstacles4
Case StringInStr($result, "few", $STR_NOCASESENSEBASIC)
$iMaintenanceWaitTime = $iDelaycheckObstacles4
Case StringInStr($result, "10", $STR_NOCASESENSEBASIC)
$iMaintenanceWaitTime = $iDelaycheckObstacles6
Case StringInStr($result, "15", $STR_NOCASESENSEBASIC)
$iMaintenanceWaitTime = $iDelaycheckObstacles6
Case StringInStr($result, "20", $STR_NOCASESENSEBASIC)
$iMaintenanceWaitTime = $iDelaycheckObstacles7
Case StringInStr($result, "30", $STR_NOCASESENSEBASIC)
$iMaintenanceWaitTime = $iDelaycheckObstacles8
Case StringInStr($result, "45", $STR_NOCASESENSEBASIC)
$iMaintenanceWaitTime = $iDelaycheckObstacles9
Case StringInStr($result, "hour", $STR_NOCASESENSEBASIC)
$iMaintenanceWaitTime = $iDelaycheckObstacles10
Case Else
$iMaintenanceWaitTime = $iDelaycheckObstacles4
SetLog("Error reading Maintenance Break time?", $COLOR_ERROR)
EndSelect
SetLog("Maintenance Break, waiting: " & $iMaintenanceWaitTime / 60000 & " minutes....", $COLOR_ERROR)
If($g_bNotifyPBEnable = True Or $g_bNotifyTGEnable = True) And $g_bNotifyAlertMaintenance = True Then NotifyPushToBoth("Maintenance Break, waiting: " & $iMaintenanceWaitTime / 60000 & " minutes....")
If $ichkSinglePBTForced = 1 Then $g_bGForcePBTUpdate = True
If _SleepStatus($iMaintenanceWaitTime) Then Return
checkObstacles_ResetSearch()
Case Else
If $g_iDebugImageSave = 1 Then DebugImageSave("ChkObstaclesReloadMsg_")
$result = getOcrRateCoc(228, 390 + $g_iMidOffsetY,"Check Obstacles getOCRRateCoC= ")
If StringInStr($result, "never", $STR_NOCASESENSEBASIC) Or UBound(decodeSingleCoord(FindImageInPlace("RateNever", $AppRateNever, "228,420,273,448", False))) > 1 Then
SetLog("Clash feedback window found, permanently closed!", $COLOR_ERROR)
PureClick(248, 408 + $g_iMidOffsetY, 1, 0, "#9999")
$MinorObstacle = True
Return True
EndIf
$result = getOcrMaintenanceTime(171, 325 + $g_iMidOffsetY, "Check Obstacles OCR 'Good News!'=")
If StringInStr($result, "new", $STR_NOCASESENSEBASIC) Then
$msg = "Game Update is required, Bot must stop!!"
Return checkObstacles_StopBot($msg)
ElseIf StringInStr($result, "rate", $STR_NOCASESENSEBASIC) Then
SetLog("Clash feedback window found, permanently closed!", $COLOR_ERROR)
PureClick(248, 408 + $g_iMidOffsetY, 1, 0, "#9999")
$MinorObstacle = True
Return True
EndIf
$result = getOcrMaintenanceTime(171, 358 + $g_iMidOffsetY, "Check Obstacles OCR 'policy at super'=")
If StringInStr($result, "policy", $STR_NOCASESENSEBASIC) Then
$msg = "Sorry but account has been banned, Bot must stop!!"
BanMsgBox()
Return checkObstacles_StopBot($msg)
EndIf
$result = getOcrMaintenanceTime(171, 337 + $g_iMidOffsetY, "Check Obstacles OCR 'prohibited 3rd'= ")
If StringInStr($result, "3rd", $STR_NOCASESENSEBASIC) Then
$msg = "Sorry but account has been banned, Bot must stop!!"
BanMsgBox()
Return checkObstacles_StopBot($msg)
EndIf
SetLog("Warning: Can not find type of Reload error message", $COLOR_ERROR)
EndSelect
Return checkObstacles_ReloadCoC($aReloadButton, "#0131")
EndIf
If TestCapture() = 0 And GetAndroidProcessPID() = 0 Then
Return checkObstacles_ReloadCoC()
EndIf
Local $bHasTopBlackBar = _ColorCheck(_GetPixelColor(10, 3), Hex(0x000000, 6), 1) And _ColorCheck(_GetPixelColor(300, 6), Hex(0x000000, 6), 1) And _ColorCheck(_GetPixelColor(600, 9), Hex(0x000000, 6), 1)
If _ColorCheck(_GetPixelColor(235, 209 + $g_iMidOffsetY), Hex(0x9E3826, 6), 20) Then
SetDebugLog("checkObstacles: Found Window to close")
PureClick(429, 493 + $g_iMidOffsetY, 1, 0, "#0132")
$NotNeedAllTime[0] = 1
$NotNeedAllTime[1] = 1
$MinorObstacle = True
If _Sleep($iDelaycheckObstacles1) Then Return
Return False
EndIf
If Not $bHasTopBlackBar And _CheckPixel($aIsMainGrayed, $g_bNoCapturePixel) Then
SetDebugLog("checkObstacles: Found gray Window to close")
If _ColorCheck(_GetPixelColor(290, 450), Hex(0xCA3A17, 6), 20) Then
SetDebugLog("checkObstacles: Found Load Village With Cancel button")
PureClick(290,450, 1, 0, "#0134")
$MinorObstacle = True
If _Sleep($iDelaycheckObstacles1) Then Return
Return False
Else
PureClickP($aAway, 1, 0, "#0133")
$MinorObstacle = True
If _Sleep($iDelaycheckObstacles1) Then Return
Return False
EndIf
EndIf
If _ColorCheck(_GetPixelColor(792, 39), Hex(0xDC0408, 6), 20) Then
SetDebugLog("checkObstacles: Found Window with Close Button to close")
PureClick(792, 39, 1, 0, "#0134")
$MinorObstacle = True
If _Sleep($iDelaycheckObstacles1) Then Return
Return False
EndIf
If _CheckPixel($aCancelFight, $g_bNoCapturePixel) Or _CheckPixel($aCancelFight2, $g_bNoCapturePixel) Then
SetDebugLog("checkObstacles: Found Cancel Fight to close")
PureClickP($aCancelFight, 1, 0, "#0135")
$MinorObstacle = True
If _Sleep($iDelaycheckObstacles1) Then Return
Return False
EndIf
If _CheckPixel($aChatTab, $g_bNoCapturePixel) Then
SetDebugLog("checkObstacles: Found Chat Tab to close")
PureClickP($aChatTab, 1, 0, "#0136")
$MinorObstacle = True
If _Sleep($iDelaycheckObstacles1) Then Return
Return False
EndIf
If _CheckPixel($aEndFightSceneBtn, $g_bNoCapturePixel) Then
SetDebugLog("checkObstacles: Found End Fight Scene to close")
PureClickP($aEndFightSceneBtn, 1, 0, "#0137")
Return True
EndIf
If _CheckPixel($aSurrenderButton, $g_bNoCapturePixel) Then
SetDebugLog("checkObstacles: Found End Battle to close")
ReturnHome(False, False)
Return True
EndIf
If _CheckPixel($aNoCloudsAttack, $g_bNoCapturePixel) Then
$aMessage = _PixelSearch(23, 566 + $g_iBottomOffsetY, 36, 580 + $g_iBottomOffsetY, Hex(0xF4F7E3, 6), 10)
If IsArray($aMessage) Then
SetDebugLog("checkObstacles: Found Return Home button")
PureClick(67, 602 + $g_iBottomOffsetY, 1, 0, "#0138")
If _Sleep($iDelaycheckObstacles2) Then Return
Return True
EndIf
EndIf
If IsPostDefenseSummaryPage() Then
$aMessage = _PixelSearch(23, 566 + $g_iBottomOffsetY, 36, 580 + $g_iBottomOffsetY, Hex(0xE0E1CE, 6), 10)
If IsArray($aMessage) Then
SetDebugLog("checkObstacles: Found Post Defense Summary to close")
PureClick(67, 602 + $g_iBottomOffsetY, 1, 0, "#0138")
If _Sleep($iDelaycheckObstacles2) Then Return
Return True
EndIf
EndIf
Local $CSFoundCoords = decodeSingleCoord(FindImageInPlace("CocStopped", $CocStopped, "250,358,618,432", False))
if UBound($CSFoundCoords) > 1 Then
SetLog("CoC Has Stopped Error .....", $COLOR_ERROR)
If TestCapture() Then Return "CoC Has Stopped Error ....."
PushMsg("CoCError")
If _Sleep($iDelaycheckObstacles1) Then Return
PureClick($CSFoundCoords[0], $CSFoundCoords[1], 1, 0, "#0129")
If _Sleep($iDelaycheckObstacles2) Then Return
Return checkObstacles_ReloadCoC()
EndIf
If $bHasTopBlackBar Then
SetDebugLog("checkObstacles: Found Android Screen")
EndIf
Return False
EndFunc
Func checkObstacles_ReloadCoC($point = $aAway, $debugtxt = "")
If TestCapture() Then Return "Reload CoC"
OcrForceCaptureRegion(True)
CloseCoC(True)
If _Sleep($iDelaycheckObstacles3) Then Return
Return True
EndFunc
Func checkObstacles_StopBot($msg)
SetLog($msg, $COLOR_ERROR)
If($g_bNotifyPBEnable = True Or $g_bNotifyTGEnable = True) And $g_bNotifyAlertMaintenance = True Then NotifyPushToBoth($msg)
If TestCapture() Then Return $msg
OcrForceCaptureRegion(True)
Btnstop()
Return True
EndFunc
Func checkObstacles_ResetSearch()
$Is_ClientSyncError = False
$Is_SearchLimit = False
$NotNeedAllTime[0] = 1
$NotNeedAllTime[1] = 1
$g_bRestart = True
EndFunc
Func BanMsgBox()
Local $MsgBox
Local $stext = "Sorry, your account is banned!!" & @CRLF & "Bot will stop now..."
While 1
PushMsg("BAN")
_ExtMsgBoxSet(4, 1, 0x004080, 0xFFFF00, 20, "Comic Sans MS", 600)
$MsgBox = _ExtMsgBox(48, "Ok", "Banned", $stext, 1)
If $MsgBox = 1 Then Return
_ExtMsgBoxSet(4, 1, 0xFFFF00, 0x004080, 20, "Comic Sans MS", 600)
$MsgBox = _ExtMsgBox(48, "Ok", "Banned", $stext, 1)
If $MsgBox = 1 Then Return
WEnd
EndFunc
Func UpdateStatsSwitchMode($bForceUpdateAll = False)
Local Static $g_iOLDGoldNowSW[9], $g_iOLDElixirNowSW[9], $g_iOLDDarkNowSW[9], $g_iOLDGemNowSW[9]
Local Static $g_iOLDFreeBuilders[9], $g_sProfileName[9]
If $bForceUpdateAll = True Or $g_sProfileName[$CurrentAccount] <> $g_sProfileCurrentName Or $CurrentAccount = 0 Then
$g_sProfileName[$CurrentAccount] = $g_sProfileCurrentName
GUICtrlSetData($g_grpVillageSW[$CurrentAccount], GetTranslated(603, 32, "Village") & ": " & $g_sProfileName[$CurrentAccount])
If WinGetState(Eval($hGuiPopOut & $CurrentAccount)) <> -1 Then
GUICtrlSetData($g_grpVillagePO[$CurrentAccount], GetTranslated(603, 32, "Village") & ": " & $g_sProfileName[$CurrentAccount])
EndIf
EndIf
For $i = 1 To 8
If $CurrentAccount = 0 Then $i = 0
GUICtrlSetData($g_lblHrStatsGoldSW[$CurrentAccount], _NumberFormat(Round($g_iStatsTotalGain[$CurrentAccount][$eLootGold] /(Int(TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600)) )
GUICtrlSetData($g_lblHrStatsElixirSW[$CurrentAccount], _NumberFormat(Round($g_iStatsTotalGain[$CurrentAccount][$eLootElixir] /(Int(TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600)) )
If $g_iStatsStartedWith[$CurrentAccount][$eLootDarkElixir] <> "" Then
GUICtrlSetData($g_lblHrStatsDarkSW[$CurrentAccount], _NumberFormat(Round($g_iStatsTotalGain[$CurrentAccount][$eLootDarkElixir] /(Int(TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600 * 1000)) )
EndIf
If WinGetState(Eval($hGuiPopOut & $i)) <> -1 Then
GUICtrlSetData($g_lblHrStatsGoldPO[$CurrentAccount], _NumberFormat(Round($g_iStatsTotalGain[$CurrentAccount][$eLootGold] /(Int(TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600)) )
GUICtrlSetData($g_lblHrStatsElixirPO[$CurrentAccount], _NumberFormat(Round($g_iStatsTotalGain[$CurrentAccount][$eLootElixir] /(Int(TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600)) )
If $g_iStatsStartedWith[$CurrentAccount][$eLootDarkElixir] <> "" Then
GUICtrlSetData($g_lblHrStatsDarkPO[$CurrentAccount], _NumberFormat(Round($g_iStatsTotalGain[$CurrentAccount][$eLootDarkElixir] /(Int(TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600 * 1000)) )
EndIf
EndIf
If $CurrentAccount = 0 Then ExitLoop
Next
If $bForceUpdateAll = True Or $g_iStatsCurrent[$CurrentAccount][$eLootGold] <> $g_iOLDGoldNowSW[$CurrentAccount] Or $g_iStatsCurrent[$CurrentAccount][$eLootGold] = "" Or $CurrentAccount = 0 Then
GUICtrlSetData($g_lblGoldNowSW[$CurrentAccount], _NumberFormat($g_iStatsCurrent[$CurrentAccount][$eLootGold]))
GUICtrlSetData($g_lblGoldNowPO[$CurrentAccount], _NumberFormat($g_iStatsCurrent[$CurrentAccount][$eLootGold]))
$g_iOLDGoldNowSW[$CurrentAccount] = $g_iStatsCurrent[$CurrentAccount][$eLootGold]
EndIf
If $bForceUpdateAll = True Or $g_iStatsCurrent[$CurrentAccount][$eLootElixir] <> $g_iOLDElixirNowSW[$CurrentAccount] Or $g_iStatsCurrent[$CurrentAccount][$eLootElixir] = "" Or $CurrentAccount = 0 Then
GUICtrlSetData($g_lblElixirNowSW[$CurrentAccount], _NumberFormat($g_iStatsCurrent[$CurrentAccount][$eLootElixir]))
GUICtrlSetData($g_lblElixirNowPO[$CurrentAccount], _NumberFormat($g_iStatsCurrent[$CurrentAccount][$eLootElixir]))
$g_iOLDElixirNowSW[$CurrentAccount] = $g_iStatsCurrent[$CurrentAccount][$eLootElixir]
EndIf
If $bForceUpdateAll = True Or $g_iStatsCurrent[$CurrentAccount][$eLootDarkElixir] <> $g_iOLDDarkNowSW[$CurrentAccount] Or $g_iStatsCurrent[$CurrentAccount][$eLootDarkElixir] = "" Or $CurrentAccount = 0 Then
If $g_iStatsStartedWith[$CurrentAccount][$eLootDarkElixir] <> "" Then
GUICtrlSetData($g_lblDarkNowSW[$CurrentAccount], _NumberFormat($g_iStatsCurrent[$CurrentAccount][$eLootDarkElixir]))
GUICtrlSetData($g_lblDarkNowPO[$CurrentAccount], _NumberFormat($g_iStatsCurrent[$CurrentAccount][$eLootDarkElixir]))
$g_iOLDDarkNowSW[$CurrentAccount] = $g_iStatsCurrent[$CurrentAccount][$eLootDarkElixir]
EndIf
EndIf
If $bForceUpdateAll = True Or $g_iGemAmount[$CurrentAccount] <> $g_iOLDGemNowSW[$CurrentAccount] Or $g_iGemAmount[$CurrentAccount] = "" Or $CurrentAccount = 0 Then
GUICtrlSetData($g_lblGemNowSW[$CurrentAccount], $g_iGemAmount[$CurrentAccount] )
GUICtrlSetData($g_lblGemNowPO[$CurrentAccount], $g_iGemAmount[$CurrentAccount] )
$g_iOLDGemNowSW[$CurrentAccount] = $g_iGemAmount[$CurrentAccount]
EndIf
If $bForceUpdateAll = True Or $g_iFreeBuilderCount[$CurrentAccount] <> $g_iOLDFreeBuilders[$CurrentAccount] Or $g_iFreeBuilderCount[$CurrentAccount] = "" Or $CurrentAccount = 0 Then
GUICtrlSetData($g_lblBuilderNowSW[$CurrentAccount], $g_iFreeBuilderCount[$CurrentAccount] & "/" & $g_iTotalBuilderCount[$CurrentAccount])
GUICtrlSetData($g_lblBuilderNowPO[$CurrentAccount], $g_iFreeBuilderCount[$CurrentAccount] & "/" & $g_iTotalBuilderCount[$CurrentAccount])
$g_iOLDFreeBuilders[$CurrentAccount] = $g_iFreeBuilderCount[$CurrentAccount]
EndIf
EndFunc
Global Const $g_sCurlPath = $g_sLibPath & "\curl\curl.exe"
Global $g_bNotifyForced = False
Global $g_sTGChatID = ""
Global $g_bPBRequestScreenshot = False
Global $g_bPBRequestScreenshotHD = False
Global $g_bPBRequestBuilderInfo = False
Global $g_bPBRequestShieldInfo = False
Global $g_bTGRequestScreenshot = False
Global $g_bTGRequestScreenshotHD = False
Global $g_bTGRequestBuilderInfo = False
Global $g_bTGRequestShieldInfo = False
Global $g_iTGLastRemote = 0
Global $g_sTGLast_UID = ""
Global $g_sTGLastMessage = ""
Global $g_sAttackFile = ""
Func NotifyRemoteControl()
If $g_bNotifyRemoteEnable = True Then NotifyRemoteControlProc(0)
EndFunc
Func NotifyReport()
If $g_bNotifyAlertVillageReport = True Then
NotifylPushBulletMessage($g_sNotifyOrigin & ":" & "\n" & " [" & GetTranslated(620,109, "G") & "]: " & _NumberFormat($iGoldCurrent) & " [" & GetTranslated(620,110, "E") & "]: " & _NumberFormat($iElixirCurrent) & " [" & GetTranslated(620,111, "DE") & "]: " & _NumberFormat($iDarkCurrent) & "  [" & GetTranslated(620,112, "T") & "]: " & _NumberFormat($iTrophyCurrent) & " [" & GetTranslated(620,105, "No. of Free Builders") & "]: " & _NumberFormat($iFreeBuilderCount))
EndIf
If $g_bNotifyAlertLastAttack = True Then
If Not($g_iStatsLastAttack[$CurrentAccount][$eLootGold] = "" And $g_iStatsLastAttack[$CurrentAccount][$eLootElixir] = "") Then NotifylPushBulletMessage($g_sNotifyOrigin & " | Last Gain :" & "\n" & " [" & GetTranslated(620,109, "G") & "]: " & _NumberFormat($g_iStatsLastAttack[$CurrentAccount][$eLootGold]) & " [" & GetTranslated(620,110, "E") & "]: " & _NumberFormat($g_iStatsLastAttack[$CurrentAccount][$eLootElixir]) & " [" & GetTranslated(620,111, "DE") & "]: " & _NumberFormat($g_iStatsLastAttack[$CurrentAccount][$eLootDarkElixir]) & "  [" & GetTranslated(620,112, "T") & "]: " & _NumberFormat($g_iStatsLastAttack[$CurrentAccount][$eLootTrophy]))
EndIf
If _Sleep($iDelayReportPushBullet1) Then Return
checkMainScreen(False)
EndFunc
Func _DeletePush()
NotifyDeletePushBullet()
SetLog("Delete all previous PushBullet messages...", $COLOR_BLUE)
EndFunc
Func PushMsg($Message, $Source = "")
NotifyPushMessageToBoth($Message, $Source)
EndFunc
Func _DeleteOldPushes()
NotifyDeleteOldPushesFromPushBullet()
EndFunc
Func _GetDateFromUnix($nPosix)
Local $nYear = 1970, $nMon = 1, $nDay = 1, $nHour = 00, $nMin = 00, $nSec = 00, $aNumDays = StringSplit("31,28,31,30,31,30,31,31,30,31,30,31", ",")
While 1
If(Mod($nYear + 1, 400) = 0) Or(Mod($nYear + 1, 4) = 0 And Mod($nYear + 1, 100) <> 0) Then
If $nPosix < 31536000 + 86400 Then ExitLoop
$nPosix -= 31536000 + 86400
$nYear += 1
Else
If $nPosix < 31536000 Then ExitLoop
$nPosix -= 31536000
$nYear += 1
EndIf
WEnd
While $nPosix > 86400
$nPosix -= 86400
$nDay += 1
WEnd
While $nPosix > 3600
$nPosix -= 3600
$nHour += 1
WEnd
While $nPosix > 60
$nPosix -= 60
$nMin += 1
WEnd
$nSec = $nPosix
For $i = 1 To 12
If $nDay < $aNumDays[$i] Then ExitLoop
$nDay -= $aNumDays[$i]
$nMon += 1
Next
Return $nYear & "-" & $nMon & "-" & $nDay & " " & $nHour & ":" & $nMin & ":" & StringFormat("%02i", $nSec)
EndFunc
Func NotifyPendingActions()
If($g_bNotifyPBEnable = False Or $g_sNotifyPBToken = "") And($g_bNotifyTGEnable = False Or $g_sNotifyTGToken = "") Then Return
NotifyRemoteControl()
If $g_bPBRequestScreenshot = True Or $g_bTGRequestScreenshot = True Then
$g_bNotifyForced = True
PushMsg("RequestScreenshot")
EndIf
If $g_bPBRequestBuilderInfo = True Or $g_bTGRequestBuilderInfo = True Then
$g_bNotifyForced = True
PushMsg("BuilderInfo")
EndIf
If $g_bPBRequestShieldInfo = True Or $g_bTGRequestShieldInfo = True Then
$g_bNotifyForced = True
PushMsg("ShieldInfo")
EndIf
PushMsg("BuilderIdle")
EndFunc
Func PushBulletRemoteControl()
If($g_bNotifyPBEnable = True) And $g_bNotifyRemoteEnable = True Then NotifyRemoteControlProc(1)
EndFunc
Func PushBulletDeleteOldPushes()
If $g_bNotifyPBEnable = True And $g_bNotifyDeletePushesOlderThan = True Then _DeleteOldPushes()
EndFunc
Func NotifylPushBulletMessage($pMessage = "")
If($g_bNotifyPBEnable = False Or $g_sNotifyPBToken = "") And($g_bNotifyTGEnable = False Or $g_sNotifyTGToken = "") Then Return
If $g_bNotifyForced = False Then
If $g_bNotifyScheduleWeekDaysEnable = True Then
If $g_abNotifyScheduleWeekDays[@WDAY - 1] = True Then
If $g_bNotifyScheduleHoursEnable = True Then
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If $g_abNotifyScheduleHours[$hour[0]] = False Then
SetLog("Notify not planned for this hour! Notification skipped", $COLOR_ORANGE)
SetLog($pMessage, $COLOR_ORANGE)
Return
EndIf
EndIf
Else
Return
EndIf
Else
If $g_bNotifyScheduleHoursEnable = True Then
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If $g_abNotifyScheduleHours[$hour[0]] = False Then
SetLog("Notify not planned for this hour! Notification skipped", $COLOR_ORANGE)
SetLog($pMessage, $COLOR_ORANGE)
Return
EndIf
EndIf
EndIf
EndIf
If $g_bNotifyPBEnable = True And $g_sNotifyPBToken <> "" Then
$g_bNotifyForced = False
Local $oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
$oHTTP.Open("Get", "https://api.pushbullet.com/v2/devices", False)
$oHTTP.SetCredentials($g_sNotifyPBToken, "", 0)
$oHTTP.Send()
Local $Result = $oHTTP.ResponseText
Local $device_iden = _StringBetween($Result, 'iden":"', '"')
Local $device_name = _StringBetween($Result, 'nickname":"', '"')
$oHTTP.Open("Post", "https://api.pushbullet.com/v2/pushes", False)
$oHTTP.SetCredentials($g_sNotifyPBToken, "", 0)
$oHTTP.SetRequestHeader("Content-Type", "application/json")
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN
Local $pPush = '{"type": "note", "body": "' & $pMessage & "\n" & $Date & "__" & $Time & '"}'
$oHTTP.Send($pPush)
EndIf
If $g_bNotifyTGEnable = True And $g_sNotifyTGToken <> "" Then
Local $oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
$oHTTP.Open("Get", "https://api.telegram.org/bot" & $g_sNotifyTGToken & "/getupdates" , False)
$oHTTP.Send()
Local $Result = $oHTTP.ResponseText
Local $chat_id = _StringBetween($Result, 'm":{"id":', ',"f')
$g_sTGChatID = _Arraypop($chat_id)
$oHTTP.Open("Post", "https://api.telegram.org/bot" & $g_sNotifyTGToken &"/sendmessage", False)
$oHTTP.SetRequestHeader("Content-Type", "application/json; charset=ISO-8859-1,utf-8")
Local $Date = @YEAR & '-' & @MON & '-' & @MDAY
Local $Time = @HOUR & '.' & @MIN
Local $TGPushMsg = '{"text":"' & $pmessage & '\n' & $Date & '__' & $Time & '", "chat_id":' & $g_sTGChatID & '}}'
$oHTTP.Send($TGPushMsg)
EndIf
EndFunc
Func NotifyPushToPushBullet($pMessage)
If($g_bNotifyPBEnable = False Or $g_sNotifyPBToken = "") And($g_bNotifyTGEnable = False Or $g_sNotifyTGToken = "") Then Return
If $g_bNotifyPBEnable = True And $g_sNotifyPBToken <> "" Then
Local $oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
$oHTTP.Open("Post", "https://api.pushbullet.com/v2/pushes", False)
Local $access_token = $g_sNotifyPBToken
$oHTTP.SetCredentials($access_token, "", 0)
$oHTTP.SetRequestHeader("Content-Type", "application/json")
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN
Local $pPush = '{"type": "note", "body": "' & $pMessage & "\n" & $Date & "__" & $Time & '"}'
$oHTTP.Send($pPush)
EndIf
EndFunc
Func NotifyDeletePushBullet()
If $g_bNotifyPBEnable = False Or $g_sNotifyPBToken = "" Then Return
Local $oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
$oHTTP.Open("DELETE", "https://api.pushbullet.com/v2/pushes", False)
Local $access_token = $g_sNotifyPBToken
$oHTTP.SetCredentials($access_token, "", 0)
$oHTTP.SetRequestHeader("Content-Type", "application/json")
$oHTTP.Send()
EndFunc
Func NotifyDeleteMessageFromPushBullet($iden)
If $g_bNotifyPBEnable = False Or $g_sNotifyPBToken = "" Then Return
Local $oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
$oHTTP.Open("Delete", "https://api.pushbullet.com/v2/pushes/" & $iden, False)
Local $access_token = $g_sNotifyPBToken
$oHTTP.SetCredentials($access_token, "", 0)
$oHTTP.SetRequestHeader("Content-Type", "application/json")
$oHTTP.Send()
$iden = ""
EndFunc
Func NotifyDeleteOldPushesFromPushBullet()
If $g_bNotifyPBEnable = False Or $g_sNotifyPBToken = "" Or $g_bNotifyDeletePushesOlderThan = False Then Return
Local $tLocal = _Date_Time_GetLocalTime()
Local $tSystem = _Date_Time_TzSpecificLocalTimeToSystemTime(DllStructGetPtr($tLocal))
Local $timeUTC = _Date_Time_SystemTimeToDateTimeStr($tSystem, 1)
Local $timestamplimit = 0
Local $oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
$oHTTP.Open("Get", "https://api.pushbullet.com/v2/pushes?active=true&modified_after=" & $timestamplimit, False)
Local $access_token = $g_sNotifyPBToken
$oHTTP.SetCredentials($access_token, "", 0)
$oHTTP.SetRequestHeader("Content-Type", "application/json")
$oHTTP.Send()
Local $Result = $oHTTP.ResponseText
Local $findstr = StringRegExp($Result, ',"created":')
Local $msgdeleted = 0
If $findstr = 1 Then
Local $body = _StringBetween($Result, '"body":"', '"', "", False)
Local $iden = _StringBetween($Result, '"iden":"', '"', "", False)
Local $created = _StringBetween($Result, '"created":', ',', "", False)
If IsArray($body) And IsArray($iden) And IsArray($created) Then
For $x = 0 To UBound($created) - 1
If $iden <> "" And $created <> "" Then
Local $hdif = _DateDiff('h', _GetDateFromUnix($created[$x]), $timeUTC)
If $hdif >= $g_iNotifyDeletePushesOlderThanHours Then
$msgdeleted += 1
NotifyDeleteMessageFromPushBullet($iden[$x])
EndIf
EndIf
$body[$x] = ""
$iden[$x] = ""
Next
EndIf
EndIf
If $msgdeleted > 0 Then
SetLog("Notify PushBullet: removed " & $msgdeleted & " messages older than " & $g_iNotifyDeletePushesOlderThanHours & " h ", $COLOR_GREEN)
EndIf
EndFunc
Func NotifyPushFileToPushBullet($File, $Folder, $FileType, $body)
If($g_bNotifyPBEnable = False Or $g_sNotifyPBToken = "") And($g_bNotifyTGEnable = False Or $g_sNotifyTGToken = "") Then Return
If $g_bNotifyPBEnable = True And $g_sNotifyPBToken <> "" Then
If FileExists($g_sProfilePath & "\" & $g_sProfileCurrentName & '\' & $Folder & '\' & $File) Then
Local $oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
$oHTTP.Open("Post", "https://api.pushbullet.com/v2/upload-request", False)
Local $access_token = $g_sNotifyPBToken
$oHTTP.SetCredentials($access_token, "", 0)
$oHTTP.SetRequestHeader("Content-Type", "application/json")
Local $pPush = '{"file_name": "' & $File & '", "file_type": "' & $FileType & '"}'
$oHTTP.Send($pPush)
Local $Result = $oHTTP.ResponseText
Local $upload_url = _StringBetween($Result, 'upload_url":"', '"')
Local $awsaccesskeyid = _StringBetween($Result, 'awsaccesskeyid":"', '"')
Local $acl = _StringBetween($Result, 'acl":"', '"')
Local $key = _StringBetween($Result, 'key":"', '"')
Local $signature = _StringBetween($Result, 'signature":"', '"')
Local $policy = _StringBetween($Result, 'policy":"', '"')
Local $file_url = _StringBetween($Result, 'file_url":"', '"')
If IsArray($upload_url) And IsArray($awsaccesskeyid) And IsArray($acl) And IsArray($key) And IsArray($signature) And IsArray($policy) Then
$Result = RunWait($g_sCurlPath & " -i -X POST " & $upload_url[0] & ' -F awsaccesskeyid="' & $awsaccesskeyid[0] & '" -F acl="' & $acl[0] & '" -F key="' & $key[0] & '" -F signature="' & $signature[0] & '" -F policy="' & $policy[0] & '" -F content-type="' & $FileType & '" -F file=@"' & $g_sProfilePath & "\" & $g_sProfileCurrentName & '\' & $Folder & '\' & $File & '"', "", @SW_HIDE)
$oHTTP.Open("Post", "https://api.pushbullet.com/v2/pushes", False)
$oHTTP.SetCredentials($access_token, "", 0)
$oHTTP.SetRequestHeader("Content-Type", "application/json")
Local $pPush = '{"type": "file", "file_name": "' & $File & '", "file_type": "' & $FileType & '", "file_url": "' & $file_url[0] & '", "body": "' & $body & '"}'
$oHTTP.Send($pPush)
Else
SetLog("Notify PushBullet: Unable to send file " & $File, $COLOR_RED)
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslated(620,170, "Unable to Upload File") & "\n" & GetTranslated(620,171, "Occured an error type") & " 1 " & GetTranslated(620,144, "uploading file to PushBullet server") & "...")
EndIf
Else
SetLog("Notify PushBullet: Unable to send file " & $File, $COLOR_RED)
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslated(620,170, "Unable to Upload File") & "\n" & GetTranslated(620,171, "Occured an error type") & " 2 " & GetTranslated(620,144, "uploading file to PushBullet server") & "...")
EndIf
EndIf
EndFunc
Func NotifyPushToTelegram($pMessage)
If($g_bNotifyPBEnable = False Or $g_sNotifyPBToken = "") And($g_bNotifyTGEnable = False Or $g_sNotifyTGToken = "") Then Return
If $g_bNotifyTGEnable = True And $g_sNotifyTGToken <> "" Then
Local $oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
Local $url = "https://api.telegram.org/bot"
$oHTTP.Open("Post", $url & $g_sNotifyTGToken & "/sendMessage", False)
$oHTTP.SetRequestHeader("Content-Type", "application/json; charset=ISO-8859-1,utf-8")
Local $Date = @YEAR & '-' & @MON & '-' & @MDAY
Local $Time = @HOUR & '.' & @MIN
Local $TGPushMsg = '{"text":"' & $pmessage & '\n' & $Date & '__' & $Time & '", "chat_id":' & $g_sTGChatID & '}}'
$oHTTP.Send($TGPushMsg)
EndIf
EndFunc
Func NotifyPushFileToTelegram($File, $Folder, $FileType, $body)
If($g_bNotifyPBEnable = False Or $g_sNotifyPBToken = "") And($g_bNotifyTGEnable = False Or $g_sNotifyTGToken = "") Then Return
If $g_bNotifyTGEnable = True And $g_sNotifyTGToken <> "" Then
If FileExists($g_sProfilePath & "\" & $g_sProfileCurrentName & '\' & $Folder & '\' & $File) Then
Local $oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
Local $telegram_url = "https://api.telegram.org/bot" & $g_sNotifyTGToken & "/sendPhoto"
Local $Result = RunWait($g_sCurlPath & " -i -X POST " & $telegram_url & ' -F chat_id="' & $g_sTGChatID &' " -F photo=@"' & $g_sProfilePath & "\" & $g_sProfileCurrentName & '\' & $Folder & '\' & $File & '"', "", @SW_HIDE)
$oHTTP.Open("Post", "https://api.telegram.org/bot" & $g_sNotifyTGToken & "/sendPhoto", False)
$oHTTP.SetRequestHeader("Content-Type", "application/json")
Local $pPush = '{"type": "file", "file_name": "' & $File & '", "file_type": "' & $FileType & '", "file_url": "' & $telegram_url & '", "body": "' & $body & '"}'
$oHTTP.Send($pPush)
Else
SetLog("Notify Telegram: Unable to send file " & $File, $COLOR_RED)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslated(620,170,"Unable to Upload File") & "\n" & GetTranslated(620,146,"Occured an error type 2 uploading file to Telegram server..."))
EndIf
EndIf
EndFunc
Func NotifyGetLastMessageFromTelegram()
If $g_bNotifyTGEnable = False Or $g_sNotifyTGToken = "" Then Return
Local $oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
$oHTTP.Open("Get", "https://api.telegram.org/bot" & $g_sNotifyTGToken & "/getupdates" , False)
$oHTTP.Send()
Local $Result = $oHTTP.ResponseText
Local $chat_id = _StringBetween($Result, 'm":{"id":', ',"f')
$g_sTGChatID = _Arraypop($chat_id)
Local $uid = _StringBetween($Result, 'update_id":', '"message"')
$g_sTGLast_UID = StringTrimRight(_Arraypop($uid), 2)
Local $findstr2 = StringRegExp(StringUpper($Result), '"TEXT":"')
If $findstr2 = 1 Then
Local $rmessage = _StringBetween($Result, 'text":"' ,'"}}' )
Local $g_sTGLastMessage = _Arraypop($rmessage)
EndIf
$oHTTP.Open("Get", "https://api.telegram.org/bot" & $g_sNotifyTGToken & "/getupdates?offset=" & $g_sTGLast_UID , False)
$oHTTP.Send()
Local $Result2 = $oHTTP.ResponseText
Local $findstr2 = StringRegExp(StringUpper($Result2), '"TEXT":"')
If $findstr2 = 1 Then
Local $rmessage = _StringBetween($Result2, 'text":"' ,'"}}' )
Local $g_sTGLastMessage = _Arraypop($rmessage)
If $g_sTGLastMessage = "" Then
Local $rmessage = _StringBetween($Result2, 'text":"' ,'","entities"' )
Local $g_sTGLastMessage = _Arraypop($rmessage)
EndIf
return $g_sTGLastMessage
EndIf
EndFunc
Func NotifyActivateKeyboardOnTelegram($TGMsg)
Local $oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
Local $url = "https://api.telegram.org/bot"
$oHTTP.Open("Post", $url & $g_sNotifyTGToken & "/sendMessage", False)
$oHTTP.SetRequestHeader("Content-Type", "application/json; charset=ISO-8859-1,utf-8")
Local $TGPushMsg = '{"text": "' & $TGMsg & '", "chat_id":' & $g_sTGChatID &', "reply_markup": {"keyboard": [["' & '\ud83d\udcf7 ' & GetTranslated(620,801,"Screenshot") & '","' & '\ud83d\udd28 ' & GetTranslated(620,802,"Builder") & '","' & '\ud83d\udd30 ' & GetTranslated(620,803,"Shield") & '"],["' & '\ud83d\udcc8 ' & GetTranslated(620,804,"Stats") & '","' & '\ud83d\udcaa ' & GetTranslated(620,805,"Troops") & '","' & '\u2753 ' & GetTranslated(620,806,"Help") & '"],["' & '\u25aa ' & GetTranslated(620,807,"Stop") & '","' & '\ud83d\udd00 ' & GetTranslated(620,808,"Pause") & '","' & '\u25b6 ' & GetTranslated(620,809,"Resume") & '","' & '\ud83d\udd01 ' & GetTranslated(620,810,"Restart") & '"],["' & '\ud83d\udccb ' & GetTranslated(620,811,"Log") & '","' & '\ud83c\udf04 ' & GetTranslated(620,812,"Lastraid") & '","' & '\ud83d\udcc4 ' & GetTranslated(620,813,"LastRaidTxt") & '"],["' & '\u2705 ' & GetTranslated(620,814,"Attack On") & '","' & '\u274C ' & GetTranslated(620,815,"Attack Off") & '"],["' & '\ud83d\udca4 ' & GetTranslated(620,816,"Hibernate") & '","' & '\u26a1 ' & GetTranslated(620,817,"Shut down") & '","' & '\ud83d\udd06 ' & GetTranslated(620,818,"Standby") & '"]],"one_time_keyboard": false,"resize_keyboard":true}}'
$oHTTP.Send($TGPushMsg)
$g_iTGLastRemote = $g_sTGLast_UID
EndFunc
Func NotifyRemoteControlProc($OnlyPB)
Static $pushLastModified = 0
If($g_bNotifyPBEnable = False And $g_bNotifyTGEnable = False) Or $g_bNotifyRemoteEnable = False Then Return
If $OnlyPB = 0 And $g_bNotifyPBEnable = True And $g_sNotifyPBToken <> "" Then
Local $oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
Local $pushbulletApiUrl
If $pushLastModified = 0 Then
$pushbulletApiUrl = "https://api.pushbullet.com/v2/pushes?active=true&limit=1"
Else
$pushbulletApiUrl = "https://api.pushbullet.com/v2/pushes?active=true&modified_after=" & $pushLastModified
EndIf
$oHTTP.Open("Get", $pushbulletApiUrl, False)
Local $access_token = $g_sNotifyPBToken
$oHTTP.SetCredentials($access_token, "", 0)
$oHTTP.SetRequestHeader("Content-Type", "application/json")
$oHTTP.Send()
Local $Result = $oHTTP.ResponseText
Local $modified = _StringBetween($Result, '"modified":', ',', "", False)
If UBound($modified) > 0 Then
$pushLastModified = Number($modified[0])
$pushLastModified -= 120
EndIf
Local $findstr = StringRegExp(StringUpper($Result), '"BODY":"BOT')
If $findstr = 1 Then
Local $body = _StringBetween($Result, '"body":"', '"', "", False)
Local $iden = _StringBetween($Result, '"iden":"', '"', "", False)
For $x = UBound($body) - 1 To 0 Step -1
If $body <> "" Or $iden <> "" Then
$body[$x] = StringUpper(StringStripWS($body[$x], $STR_STRIPLEADING + $STR_STRIPTRAILING + $STR_STRIPSPACES))
$iden[$x] = StringStripWS($iden[$x], $STR_STRIPLEADING + $STR_STRIPTRAILING + $STR_STRIPSPACES)
$g_bNotifyForced = True
Switch $body[$x]
Case GetTranslated(620,1, "BOT") & " " & GetTranslated(620,4, "HELP")
Local $txtHelp = "PushBullet " & GetTranslated(620,2,"Help") & " " & GetTranslated(620,3, " - You can remotely control your bot sending COMMANDS from the following list:")
$txtHelp &= '\n' & GetTranslated(620,1, -1) & " " & GetTranslated(620,4, -1) & GetTranslated(620,5, " - send this help message")
$txtHelp &= '\n' & GetTranslated(620,1, -1) & " " & GetTranslated(620,7,"DELETE") & GetTranslated(620,8, " - delete all your previous PushBullet messages")
$txtHelp &= '\n' & GetTranslated(620,1, -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslated(620,9,"RESTART") & GetTranslated(620,10, " - restart the Emulator and bot named") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,1, -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslated(620,11,"STOP") & GetTranslated(620,12, " - stop the bot named") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,1, -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslated(620,13,"PAUSE") & GetTranslated(620,14, " - pause the bot named") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,1, -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslated(620,15,"RESUME") & GetTranslated(620,16, " - resume the bot named") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,1, -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslated(620,17,"STATS") & GetTranslated(620,18, " - send Village Statistics of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,1, -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslated(620,19,"LOG") & GetTranslated(620,20, " - send the current log file of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,1, -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslated(620,21,"LASTRAID") & GetTranslated(620,22, " - send the last raid loot screenshot of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,1, -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslated(620,23,"LASTRAIDTXT") & GetTranslated(620,24, " - send the last raid loot values of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,1, -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslated(620,25,"SCREENSHOT") & GetTranslated(620,26, " - send a screenshot of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,1, -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslated(620,27,"SCREENSHOTHD") & GetTranslated(620,28, " - send a screenshot in high resolution of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,1, -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslated(620,29,"BUILDER") & GetTranslated(620,30, " - send a screenshot of builder status of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,1, -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslated(620,31,"SHIELD") & GetTranslated(620,32, " - send a screenshot of shield status of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= "\n" & GetTranslated(620,1, -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslated(620,33,"RESETSTATS") & GetTranslated(620,34, " - reset Village Statistics")
$txtHelp &= "\n" & GetTranslated(620,1, -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslated(620,35,"TROOPS") & GetTranslated(620,36, " - send Troops & Spells Stats")
$txtHelp &= "\n" & GetTranslated(620,1, -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslated(620,37,"HALTATTACKON") & GetTranslated(620,39, " - Turn On 'Halt Attack' in the 'Misc' Tab with the 'stay online' option")
$txtHelp &= "\n" & GetTranslated(620,1, -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslated(620,40,"HALTATTACKOFF") & GetTranslated(620,42, " - Turn Off 'Halt Attack' in the 'Misc' Tab")
$txtHelp &= "\n" & GetTranslated(620,1, -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslated(620,43,"HIBERNATE") & GetTranslated(620,44, " - Hibernate host PC")
$txtHelp &= "\n" & GetTranslated(620,1, -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslated(620,46,"SHUTDOWN") & GetTranslated(620,48, " - Shut down host PC")
$txtHelp &= "\n" & GetTranslated(620,1, -1) & " <" & $g_sNotifyOrigin & "> " & GetTranslated(620,50,"STANDBY") & GetTranslated(620,51, " - Standby host PC")
$txtHelp &= '\n'
$txtHelp &= '\n' & GetTranslated(620,98, "Examples:")
$txtHelp &= '\n' & GetTranslated(620,1, -1) & " " & $g_sNotifyOrigin & " " & GetTranslated(620,17,"STATS")
$txtHelp &= '\n' & GetTranslated(620,1, -1) & " " & GetTranslated(620,29,"BUILDER")
$txtHelp &= '\n' & GetTranslated(620,1, -1) & " " & $g_sNotifyOrigin & " " & GetTranslated(620,27,"SCREENSHOTHD")
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslated(620,100, "Request for Help") & "\n" & $txtHelp)
SetLog("Notify PushBullet: Your request has been received from " & $g_sNotifyOrigin & ". Help has been sent", $COLOR_GREEN)
NotifyDeleteMessageFromPushBullet($iden[$x])
Case GetTranslated(620,1, -1) & " " & GetTranslated(620,7,"DELETE")
NotifyDeletePushBullet()
SetLog("Notify PushBullet: Your request has been received.", $COLOR_GREEN)
Case GetTranslated(620,1, -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslated(620,9,"RESTART")
NotifyDeleteMessageFromPushBullet($iden[$x])
SetLog("Notify PushBullet: Your request has been received. Bot and Android Emulator restarting...", $COLOR_GREEN)
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslated(620,165, "Request to Restart") & "...\n" & GetTranslated(620,132, "Your bot and Emulator are now restarting") & "...")
SaveConfig()
RestartBot()
Case GetTranslated(620,1, -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslated(620,11,"STOP")
NotifyDeleteMessageFromPushBullet($iden[$x])
SetLog("Notify PushBullet: Your request has been received. Bot is now stopped", $COLOR_GREEN)
If $g_bRunState = True Then
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslated(620,124, "Request to Stop") & "..." & "\n" & GetTranslated(620,133, "Your bot is now stopping") & "...")
btnStop()
Else
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslated(620,124, "Request to Stop") & "..." & "\n" & GetTranslated(620,134, "Your bot is currently stopped, no action was taken"))
EndIf
Case GetTranslated(620,1, -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslated(620,13,"PAUSE")
If $g_bBotPaused = False And $g_bRunState = True Then
If( _ColorCheck(_GetPixelColor($NextBtn[0], $NextBtn[1], True), Hex($NextBtn[2], 6), $NextBtn[3])) = False And IsAttackPage() Then
SetLog("Notify PushBullet: Unable to pause during attack", $COLOR_RED)
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslated(620,166, "Request to Pause") & "\n" & GetTranslated(620,164, "Unable to pause during attack, try again later."))
ElseIf( _ColorCheck(_GetPixelColor($NextBtn[0], $NextBtn[1], True), Hex($NextBtn[2], 6), $NextBtn[3])) = True And IsAttackPage() Then
ReturnHome(False, False)
$Is_SearchLimit = True
$Is_ClientSyncError = False
UpdateStats()
$g_bRestart = True
TogglePauseImpl("Push")
Else
TogglePauseImpl("Push")
EndIf
Else
SetLog("Notify PushBullet: Your bot is currently paused, no action was taken", $COLOR_GREEN)
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslated(620,166, "Request to Pause") & "\n" & GetTranslated(620,150, "Your bot is currently paused, no action was taken"))
EndIf
NotifyDeleteMessageFromPushBullet($iden[$x])
Case GetTranslated(620,1, -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslated(620,15,"RESUME")
If $g_bBotPaused = True And $g_bRunState = True Then
TogglePauseImpl("Push")
Else
SetLog("Notify PushBullet: Your bot is currently resumed, no action was taken", $COLOR_GREEN)
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslated(620,167, "Request to Resume") & "\n" & GetTranslated(620,130, "Your bot is currently resumed, no action was taken"))
EndIf
NotifyDeleteMessageFromPushBullet($iden[$x])
Case GetTranslated(620,1, -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslated(620,17,"STATS")
SetLog("Notify PushBullet: Your request has been received. Statistics sent", $COLOR_GREEN)
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslated(620,108, "Stats Village Report") & "\n" & GetTranslated(620,148, "At Start") & "\n[" & GetTranslated(620,109, "G") & "]: " & _NumberFormat($g_iStatsStartedWith[$CurrentAccount][$eLootGold]) & " [" & GetTranslated(620,110, "E") & "]: " & _NumberFormat($g_iStatsStartedWith[$CurrentAccount][$eLootElixir]) & " [" & GetTranslated(620,111, "DE") & "]: " & _NumberFormat($g_iStatsStartedWith[$CurrentAccount][$eLootDarkElixir]) & " [" & GetTranslated(620,112, "T") & "]: " & $g_iStatsStartedWith[$CurrentAccount][$eLootTrophy] & "\n\n" & GetTranslated(620,114, "Now (Current Resources)") &"\n[" & GetTranslated(620,109, "G") & "]: " & _NumberFormat($iGoldCurrent) & " [" & GetTranslated(620,110, "E") & "]: " & _NumberFormat($iElixirCurrent) & " [" & GetTranslated(620,111, "DE") & "]: " & _NumberFormat($iDarkCurrent) & " [" & GetTranslated(620,112, "T") & "]: " & $iTrophyCurrent & " [" & GetTranslated(620,121, "GEM") & "]: " & $iGemAmount & "\n \n [" & GetTranslated(620,105, "No. of Free Builders") & "]: " & $iFreeBuilderCount & "\n [" & GetTranslated(620,117, "No. of Wall Up") & "]: " & GetTranslated(620,109, "G") & ": " & $g_iNbrOfWallsUppedGold[$CurrentAccount] & "/ " & GetTranslated(620,110, "E") & ": " & $g_iNbrOfWallsUppedElixir[$CurrentAccount] & "\n\n" & GetTranslated(620,116, "Attacked") & ": " & $iAttackedCount & "\n" & GetTranslated(620,115, "Skipped") & ": " & $g_iSkippedVillageCount[$CurrentAccount])
NotifyDeleteMessageFromPushBullet($iden[$x])
Case GetTranslated(620,1, -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslated(620,19,"LOG")
SetLog("Notify PushBullet: Your request has been received from " & $g_sNotifyOrigin & ". Log is now sent", $COLOR_GREEN)
NotifyPushFileToPushBullet($g_sLogFileName, GetTranslated(620,101, "logs"), "text/plain; charset=utf-8", $g_sNotifyOrigin & " | " & GetTranslated(620,102, "Current Log") & " \n")
NotifyDeleteMessageFromPushBullet($iden[$x])
Case GetTranslated(620,1, -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslated(620,21,"LASTRAID")
If $g_sAttackFile <> "" Then
SetLog("Notify PushBullet: Push Last Raid Snapshot...", $COLOR_GREEN)
NotifyPushFileToPushBullet($g_sAttackFile, GetTranslated(620,120, "Loots"), "image/jpeg", $g_sNotifyOrigin & " | " & GetTranslated(620,118, "Last Raid") & " \n" & $g_sAttackFile)
Else
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslated(620,131, "There is no last raid screenshot") & ".")
SetLog("There is no last raid screenshot.")
SetLog("Notify PushBullet: Your request has been received. Last Raid txt sent", $COLOR_GREEN)
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslated(620,119, "Last Raid txt") & "\n" & "[" & GetTranslated(620,109, "G") & "]: " & _NumberFormat($g_iStatsLastAttack[$CurrentAccount][$eLootGold]) & " [" & GetTranslated(620,110, "E") & "]: " & _NumberFormat($g_iStatsLastAttack[$CurrentAccount][$eLootElixir]) & " [" & GetTranslated(620,111, "DE") & "]: " & _NumberFormat($g_iStatsLastAttack[$CurrentAccount][$eLootDarkElixir]) & " [" & GetTranslated(620,112, "T") & "]: " & $g_iStatsLastAttack[$CurrentAccount][$eLootTrophy])
EndIf
NotifyDeleteMessageFromPushBullet($iden[$x])
Case GetTranslated(620,1, -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslated(620,23,"LASTRAIDTXT")
SetLog("Notify PushBullet: Your request has been received. Last Raid txt sent", $COLOR_GREEN)
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslated(620,119, "Last Raid txt") & "\n" & "[" & GetTranslated(620,109, "G") & "]: " & _NumberFormat($g_iStatsLastAttack[$CurrentAccount][$eLootGold]) & " [" & GetTranslated(620,110, "E") & "]: " & _NumberFormat($g_iStatsLastAttack[$CurrentAccount][$eLootElixir]) & " [" & GetTranslated(620,111, "DE") & "]: " & _NumberFormat($g_iStatsLastAttack[$CurrentAccount][$eLootDarkElixir]) & " [" & GetTranslated(620,112, "T") & "]: " & $g_iStatsLastAttack[$CurrentAccount][$eLootTrophy])
NotifyDeleteMessageFromPushBullet($iden[$x])
Case GetTranslated(620,1, -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslated(620,25,"SCREENSHOT")
SetLog("Notify PushBullet: ScreenShot request received", $COLOR_GREEN)
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslated(620,147,"Chief, your request for Screenshot will be processed ASAP"))
$g_bPBRequestScreenshot = True
$g_bNotifyForced = False
NotifyDeleteMessageFromPushBullet($iden[$x])
Case GetTranslated(620,1, -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslated(620,27,"SCREENSHOTHD")
SetLog("Notify PushBullet: ScreenShot HD request received", $COLOR_GREEN)
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslated(620,147,"Chief, your request for Screenshot will be processed ASAP"))
$g_bPBRequestScreenshot = True
$g_bPBRequestScreenshotHD = True
$g_bNotifyForced = False
NotifyDeleteMessageFromPushBullet($iden[$x])
Case GetTranslated(620,1, -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslated(620,29,"BUILDER")
SetLog("Notify PushBullet: Builder Status request received", $COLOR_GREEN)
$g_bPBRequestBuilderInfo = True
NotifyDeleteMessageFromPushBullet($iden[$x])
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslated(620,137,"Chief, your request for Builder Info will be processed ASAP"))
Case GetTranslated(620,1, -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslated(620,31,"SHIELD")
SetLog("Notify PushBullet: Shield Status request received", $COLOR_GREEN)
$g_bPBRequestShieldInfo = True
$g_bNotifyForced = False
NotifyDeleteMessageFromPushBullet($iden[$x])
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslated(620,139,"Chief, your request for Shield Info will be processed ASAP"))
Case GetTranslated(620,1, -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslated(620,33,"RESETSTATS")
btnResetStats()
SetLog("Notify PushBullet: Your request has been received. Statistics resetted", $COLOR_GREEN)
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslated(620,135,"Statistics resetted."))
Case GetTranslated(620,1, -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslated(620,35,"TROOPS")
SetLog("Notify PushBullet: Your request has been received. Sending Troop/Spell Stats...", $COLOR_GREEN)
Local $txtTroopStats = " | " & GetTranslated(620,136,"Troops/Spells set to Train") & ":\n" & "Barbs:" & $g_aiArmyCompTroops[$eTroopBarbarian] & " Arch:" & $g_aiArmyCompTroops[$eTroopArcher] & " Gobl:" & $g_aiArmyCompTroops[$eTroopGoblin] & "\n" & "Giant:" & $g_aiArmyCompTroops[$eTroopGiant] & " WallB:" & $g_aiArmyCompTroops[$eTroopWallBreaker] & " Wiza:" & $g_aiArmyCompTroops[$eTroopWizard] & "\n" & "Balloon:" & $g_aiArmyCompTroops[$eTroopBalloon] & " Heal:" & $g_aiArmyCompTroops[$eTroopHealer] & " Dragon:" & $g_aiArmyCompTroops[$eTroopDragon] & " Pekka:" & $g_aiArmyCompTroops[$eTroopPekka] & "\n" & "Mini:" & $g_aiArmyCompTroops[$eTroopMinion] & " Hogs:" & $g_aiArmyCompTroops[$eTroopHogRider] & " Valks:" & $g_aiArmyCompTroops[$eTroopValkyrie] & "\n" & "Golem:" & $g_aiArmyCompTroops[$eTroopGolem] & " Witch:" & $g_aiArmyCompTroops[$eTroopWitch] & " Lava:" & $g_aiArmyCompTroops[$eTroopLavaHound] & "\n" & "LSpell:" & $g_aiArmyCompSpells[$eSpellLightning] & " HeSpell:" & $g_aiArmyCompSpells[$eSpellHeal] & " RSpell:" & $g_aiArmyCompSpells[$eSpellRage] & " JSpell:" & $g_aiArmyCompSpells[$eSpellJump] & "\n" & "FSpell:" & $g_aiArmyCompSpells[$eSpellFreeze] & " PSpell:" & $g_aiArmyCompSpells[$eSpellPoison] & " ESpell:" & $g_aiArmyCompSpells[$eSpellEarthquake] & " HaSpell:" & $g_aiArmyCompSpells[$eSpellHaste] & "\n"
$txtTroopStats &= "\n" & GetTranslated(620,168,"Current Trained Troops & Spells") & ":"
$txtTroopStats &= "\n\n" & GetTranslated(620,169,"Current Army Camp") & ": " & $CurCamp & "/" & $TotalCamp
NotifyPushToPushBullet($g_sNotifyOrigin & $txtTroopStats)
Case GetTranslated(620,1, -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslated(620,37,"HALTATTACKON")
GUICtrlSetState($g_hChkBotStop, $GUI_CHECKED)
btnStop()
$g_bChkBotStop = True
$g_iCmbBotCond = 18
btnStart()
Case GetTranslated(620,1, -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslated(620,40,"HALTATTACKOFF")
GUICtrlSetState($g_hChkBotStop, $GUI_UNCHECKED)
btnStop()
btnStart()
Case GetTranslated(620,1, -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslated(620,43,"HIBERNATE")
SetLog("Notify PushBullet: Your request has been received from " & $g_sNotifyOrigin & ". Hibernate PC", $COLOR_GREEN)
NotifyPushToPushBullet(GetTranslated(620,45,"PC Hibernate sequence initiated"))
Shutdown(64)
Case GetTranslated(620,1, -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslated(620,46,"SHUTDOWN")
SetLog("Notify PushBullet: Your request has been received from " & $g_sNotifyOrigin & ". Shutdown PC", $COLOR_GREEN)
NotifyPushToPushBullet(GetTranslated(620,49,"PC Shutdown sequence initiated"))
Shutdown(5)
Case GetTranslated(620,1, -1) & " " & StringUpper($g_sNotifyOrigin) & " " & GetTranslated(620,50,"STANDBY")
SetLog("Notify PushBullet: Your request has been received from " & $g_sNotifyOrigin & ". Standby PC", $COLOR_GREEN)
NotifyPushToPushBullet(GetTranslated(620,52,"PC Standby sequence initiated"))
Shutdown(32)
Case Else
Local $lenstr = StringLen(GetTranslated(620,1, -1) & " " & StringUpper($g_sNotifyOrigin) & " " & "")
Local $teststr = StringLeft($body[$x], $lenstr)
If $teststr =(GetTranslated(620,1, -1) & " " & StringUpper($g_sNotifyOrigin) & " " & "") Then
SetLog("Notify PushBullet: received command syntax wrong, command ignored.", $COLOR_RED)
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslated(620,97, "Command not recognized") & "\n" & GetTranslated(620,99, "Please push BOT HELP to obtain a complete command list."))
NotifyDeleteMessageFromPushBullet($iden[$x])
EndIf
EndSwitch
$body[$x] = ""
$iden[$x] = ""
$g_bNotifyForced = False
EndIf
Next
EndIf
EndIf
If $g_bNotifyTGEnable = True And $g_sNotifyTGToken <> "" Then
$g_sTGLastMessage = NotifyGetLastMessageFromTelegram()
Local $TGActionMSG = StringUpper(StringStripWS($g_sTGLastMessage, $STR_STRIPLEADING + $STR_STRIPTRAILING + $STR_STRIPSPACES))
If($TGActionMSG = "/START" Or $TGActionMSG = "KEYB") And $g_iTGLastRemote <> $g_sTGLast_UID Then
$g_iTGLastRemote = $g_sTGLast_UID
NotifyActivateKeyboardOnTelegram($g_sBotTitle & " | Notify " & $g_sNotifyVersion)
Else
If $g_iTGLastRemote <> $g_sTGLast_UID Then
$g_iTGLastRemote = $g_sTGLast_UID
Switch $TGActionMSG
Case GetTranslated(620,4,"HELP"), '\U2753 ' & GetTranslated(620,4,"HELP")
Local $txtHelp = "Telegram " & GetTranslated(620,2,"Help") & " " & GetTranslated(620,3, " - You can remotely control your bot sending COMMANDS from the following list:")
$txtHelp &= '\n' & GetTranslated(620,4, -1) & GetTranslated(620,5, " - send this help message")
$txtHelp &= '\n' & GetTranslated(620,9,"RESTART") & GetTranslated(620,10, " - restart the Emulator and bot named") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,11,"STOP") & GetTranslated(620,12, " - stop the bot named") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,13,"PAUSE") & GetTranslated(620,14, " - pause the bot named") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,15,"RESUME") & GetTranslated(620,16, " - resume the bot named") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,17,"STATS") & GetTranslated(620,18, " - send Village Statistics of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,19,"LOG") & GetTranslated(620,20, " - send the current log file of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,21,"LASTRAID") & GetTranslated(620,22, " - send the last raid loot screenshot of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,23,"LASTRAIDTXT") & GetTranslated(620,24, " - send the last raid loot values of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,25,"SCREENSHOT") & GetTranslated(620,26, " - send a screenshot of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,27,"SCREENSHOTHD") & GetTranslated(620,28, " - send a screenshot in high resolution of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,29,"BUILDER") & GetTranslated(620,30, " - send a screenshot of builder status of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,31,"SHIELD") & GetTranslated(620,32, " - send a screenshot of shield status of") & " <" & $g_sNotifyOrigin & ">"
$txtHelp &= "\n" & GetTranslated(620,33,"RESETSTATS") & GetTranslated(620,34, " - reset Village Statistics")
$txtHelp &= "\n" & GetTranslated(620,35,"TROOPS") & GetTranslated(620,36, " - send Troops & Spells Stats")
$txtHelp &= "\n" & GetTranslated(620,37,"HALTATTACKON") & GetTranslated(620,39, " - Turn On 'Halt Attack' in the 'Misc' Tab with the 'stay online' option")
$txtHelp &= "\n" & GetTranslated(620,40,"HALTATTACKOFF") & GetTranslated(620,42, " - Turn Off 'Halt Attack' in the 'Misc' Tab")
$txtHelp &= "\n" & GetTranslated(620,43,"HIBERNATE") & GetTranslated(620,44, " - Hibernate host PC")
$txtHelp &= "\n" & GetTranslated(620,46,"SHUTDOWN") & GetTranslated(620,48, " - Shut down host PC")
$txtHelp &= "\n" & GetTranslated(620,50,"STANDBY") & GetTranslated(620,51, " - Standby host PC")
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslated(620,100,"Request for Help") & "\n" & $txtHelp)
SetLog("Notify Telegram: Your request has been received from " & $g_sNotifyOrigin & ". Help has been sent", $COLOR_GREEN)
Case GetTranslated(620,9,"RESTART"), '\UD83D\UDD01 ' & GetTranslated(620,9,"RESTART")
SetLog("Notify Telegram: Your request has been received.", $COLOR_GREEN)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslated(620,165,"Request to Restart") & "...\n" & GetTranslated(620,143,"Your bot and Emulator are now restarting..."))
SaveConfig()
RestartBot()
Case GetTranslated(620,11,"STOP"), '\U25AA ' & GetTranslated(620,11,"Stop")
SetLog("Notify Telegram: Your request has been received. Bot is now stopped", $COLOR_GREEN)
If $g_bRunState = True Then
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslated(620,125,"Request to Stop...") & "\n" & GetTranslated(620,126,"Your bot is now stopping..."))
btnStop()
Else
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslated(620,125,"Request to Stop...") & "\n" & GetTranslated(620,127,"Your bot is currently stopped, no action was taken"))
EndIf
Case GetTranslated(620,13,"PAUSE"), '\UD83D\UDD00 ' & GetTranslated(620,13,"PAUSE")
If $g_bBotPaused = False And $g_bRunState = True Then
If( _ColorCheck(_GetPixelColor($NextBtn[0], $NextBtn[1], True), Hex($NextBtn[2], 6), $NextBtn[3])) = False And IsAttackPage() Then
SetLog("Notify Telegram: Unable to pause during attack", $COLOR_RED)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslated(620,166,"Request to Pause") & "\n" & GetTranslated(620,138,"Unable to pause during attack, try again later."))
ElseIf( _ColorCheck(_GetPixelColor($NextBtn[0], $NextBtn[1], True), Hex($NextBtn[2], 6), $NextBtn[3])) = True And IsAttackPage() Then
ReturnHome(False, False)
$Is_SearchLimit = True
$Is_ClientSyncError = True
$g_bRestart = True
TogglePauseImpl("Push")
Return True
Else
TogglePauseImpl("Push")
EndIf
Else
SetLog("Notify Telegram: Your bot is currently paused, no action was taken", $COLOR_GREEN)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslated(620,166,"Request to Pause") & "\n" & GetTranslated(620,150,"Your bot is currently paused, no action was taken"))
EndIf
Case GetTranslated(620,15,"RESUME"), '\U25B6 ' & GetTranslated(620,15,"RESUME")
If $g_bBotPaused = True And $g_bRunState = True Then
TogglePauseImpl("Push")
Else
SetLog("Notify Telegram: Your bot is currently resumed, no action was taken", $COLOR_GREEN)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslated(620,167,"Request to Resume") & "\n" & GetTranslated(620,151,"Your bot is currently resumed, no action was taken"))
EndIf
Case GetTranslated(620,17,"STATS"), '\UD83D\UDCC8 ' & GetTranslated(620,17,"STATS")
SetLog("Notify Telegram: Your request has been received. Statistics sent", $COLOR_GREEN)
Local $GoldGainPerHour = "0 / h"
Local $ElixirGainPerHour = "0 / h"
Local $DarkGainPerHour = "0 / h"
Local $TrophyGainPerHour = "0 / h"
If $g_iFirstAttack = 2 Then
$GoldGainPerHour = _NumberFormat(Round($g_iStatsTotalGain[$CurrentAccount][$eLootGold] /(Int(TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600)) & "K / h"
$ElixirGainPerHour = _NumberFormat(Round($g_iStatsTotalGain[$CurrentAccount][$eLootElixir] /(Int(TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600)) & "K / h"
EndIf
If $g_iStatsStartedWith[$CurrentAccount][$eLootDarkElixir] <> "" Then
$DarkGainPerHour = _NumberFormat(Round($g_iStatsTotalGain[$CurrentAccount][$eLootDarkElixir] /(Int(TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600 * 1000)) & " / h"
EndIf
$TrophyGainPerHour = _NumberFormat(Round($g_iStatsTotalGain[$CurrentAccount][$eLootTrophy] /(Int(TimerDiff($g_hTimerSinceStarted) + $g_iTimePassed)) * 3600 * 1000)) & " / h"
Local $txtStats = " | " & GetTranslated(620,108,"Stats Village Report") & "\n" & GetTranslated(620,148,"At Start") & "\n[" & GetTranslated(620,109, "G") & "]: " & _NumberFormat($g_iStatsStartedWith[$CurrentAccount][$eLootGold]) & " [" & GetTranslated(620,110, "E") & "]: "
$txtStats &= _NumberFormat($g_iStatsStartedWith[$CurrentAccount][$eLootElixir]) & " [D]: " & _NumberFormat($g_iStatsStartedWith[$CurrentAccount][$eLootDarkElixir]) & " [" & GetTranslated(620,112, "T") & "]: " & $g_iStatsStartedWith[$CurrentAccount][$eLootTrophy]
$txtStats &= "\n\n" & GetTranslated(620,114,"Now (Current Resources)") & "\n[" & GetTranslated(620,109, "G") & "]: " & _NumberFormat($iGoldCurrent) & " [" & GetTranslated(620,110, "E") & "]: " & _NumberFormat($iElixirCurrent)
$txtStats &= " [D]: " & _NumberFormat($iDarkCurrent) & " [" & GetTranslated(620,112, "T") & "]: " & $iTrophyCurrent & " [GEM]: " & $iGemAmount
$txtStats &= "\n\n" & GetTranslated(620,140,"Gain per Hour") & ":\n[" & GetTranslated(620,109, "G") & "]: " & $GoldGainPerHour & " [" & GetTranslated(620,110, "E") & "]: " & $ElixirGainPerHour
$txtStats &= "\n[D]: " & $DarkGainPerHour & " [" & GetTranslated(620,112, "T") & "]: " & $TrophyGainPerHour
$txtStats &= "\n\n" & GetTranslated(620,105,"No. of Free Builders") & ": " & $iFreeBuilderCount & "\n[" & GetTranslated(620,117,"No. of Wall Up") & "]: [" & GetTranslated(620,109, "G") & "]: "
$txtStats &= $g_iNbrOfWallsUppedGold[$CurrentAccount] & "/ [" & GetTranslated(620,110, "E") & "]: " & $g_iNbrOfWallsUppedElixir[$CurrentAccount] & "\n\n" & GetTranslated(620,116,"Attacked") & ": "
$txtStats &= $iAttackedCount & "\n" & GetTranslated(620,115,"Skipped") & ": " & $g_iSkippedVillageCount[$CurrentAccount]
NotifyPushToTelegram($g_sNotifyOrigin & $txtStats)
Case GetTranslated(620,19,"LOG"), '\UD83D\UDCCB ' & GetTranslated(620,19,"LOG")
SetLog("Notify Telegram: Your request has been received from " & $g_sNotifyOrigin & ". Log is now sent", $COLOR_GREEN)
NotifyPushFileToTelegram($g_sLogFileName, "logs", "text\/plain; charset=utf-8", $g_sNotifyOrigin & " | Current Log " & "\n")
Case GetTranslated(620,21,"LASTRAID"), '\UD83C\UDF04 ' & GetTranslated(620,21,"LASTRAID")
If $LootFileName <> "" Then
NotifyPushFileToTelegram($LootFileName, GetTranslated(620,120, "Loots"), "image/jpeg", $g_sNotifyOrigin & " | " & GetTranslated(620,152,"Last Raid") & "\n" & $LootFileName)
SetLog("Notify Telegram: Push Last Raid Snapshot...", $COLOR_GREEN)
Else
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslated(620,141,"There is no last raid screenshot."))
SetLog("There is no last raid screenshot.")
SetLog("Notify Telegram: Your request has been received. Last Raid txt sent", $COLOR_GREEN)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslated(620,142,"Last Raid txt") & "\n" & "[" & GetTranslated(620,109, "G") & "]: " & _NumberFormat($g_iStatsLastAttack[$CurrentAccount][$eLootGold]) & " [" & GetTranslated(620,110, "E") & "]: " & _NumberFormat($g_iStatsLastAttack[$CurrentAccount][$eLootElixir]) & " [D]: " & _NumberFormat($g_iStatsLastAttack[$CurrentAccount][$eLootDarkElixir]) & " [" & GetTranslated(620,112, "T") & "]: " & $g_iStatsLastAttack[$CurrentAccount][$eLootTrophy])
EndIf
Case GetTranslated(620,23,"LASTRAIDTXT"), '\UD83D\UDCC4 ' & GetTranslated(620,23,"LASTRAIDTXT")
SetLog("Notify Telegram: Your request has been received. Last Raid txt sent", $COLOR_GREEN)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslated(620,142,"Last Raid txt") & "\n" & "[" & GetTranslated(620,109, "G") & "]: " & _NumberFormat($g_iStatsLastAttack[$CurrentAccount][$eLootGold]) & " [" & GetTranslated(620,110, "E") & "]: " & _NumberFormat($g_iStatsLastAttack[$CurrentAccount][$eLootElixir]) & " [D]: " & _NumberFormat($g_iStatsLastAttack[$CurrentAccount][$eLootDarkElixir]) & " [" & GetTranslated(620,112, "T") & "]: " & $g_iStatsLastAttack[$CurrentAccount][$eLootTrophy])
Case GetTranslated(620,25,"SCREENSHOT")
SetLog("Notify Telegram: ScreenShot request received", $COLOR_GREEN)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslated(620,147,"Chief, your request for Screenshot will be processed ASAP"))
$g_bTGRequestScreenshot = True
Case GetTranslated(620,27,"SCREENSHOTHD"), '\UD83D\UDCF7 ' & GetTranslated(620,25,"SCREENSHOT")
SetLog("Notify Telegram: ScreenShot HD request received", $COLOR_GREEN)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslated(620,147,"Chief, your request for Screenshot will be processed ASAP"))
$g_bTGRequestScreenshot = True
$g_bTGRequestScreenshotHD = True
$g_bNotifyForced = False
Case GetTranslated(620,29,"BUILDER"), '\UD83D\UDD28 ' & GetTranslated(620,29,"BUILDER")
SetLog("Notify Telegram: Builder Status request received", $COLOR_GREEN)
$g_bTGRequestBuilderInfo = True
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslated(620,137,"Chief, your request for Builder Info will be processed ASAP"))
Case GetTranslated(620,31,"SHIELD"), '\UD83D\UDD30 ' & GetTranslated(620,31,"SHIELD")
SetLog("Notify Telegram: Shield Status request received", $COLOR_GREEN)
$g_bTGRequestShieldInfo = True
$g_bNotifyForced = False
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslated(620,139,"Chief, your request for Shield Info will be processed ASAP"))
Case GetTranslated(620,33,"RESETSTATS")
btnResetStats()
SetLog("Notify Telegram: Your request has been received. Statistics resetted", $COLOR_GREEN)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslated(620,135,"Statistics resetted."))
Case GetTranslated(620,35,"TROOPS"), '\UD83D\UDCAA ' & GetTranslated(620,35,"TROOPS")
SetLog("Notify Telegram: Your request has been received. Sending Troop/Spell Stats...", $COLOR_GREEN)
Local $txtTroopStats = " | " & GetTranslated(620,136,"Troops/Spells set to Train") & ":\n" & "Barbs:" & $g_aiArmyCompTroops[$eTroopBarbarian] & " Arch:" & $g_aiArmyCompTroops[$eTroopArcher] & " Gobl:" & $g_aiArmyCompTroops[$eTroopGoblin] & "\n" & "Giant:" & $g_aiArmyCompTroops[$eTroopGiant] & " WallB:" & $g_aiArmyCompTroops[$eTroopWallBreaker] & " Wiza:" & $g_aiArmyCompTroops[$eTroopWizard] & "\n" & "Balloon:" & $g_aiArmyCompTroops[$eTroopBalloon] & " Heal:" & $g_aiArmyCompTroops[$eTroopHealer] & " Dragon:" & $g_aiArmyCompTroops[$eTroopDragon] & " Pekka:" & $g_aiArmyCompTroops[$eTroopPekka] & "\n" & "Mini:" & $g_aiArmyCompTroops[$eTroopMinion] & " Hogs:" & $g_aiArmyCompTroops[$eTroopHogRider] & " Valks:" & $g_aiArmyCompTroops[$eTroopValkyrie] & "\n" & "Golem:" & $g_aiArmyCompTroops[$eTroopGolem] & " Witch:" & $g_aiArmyCompTroops[$eTroopWitch] & " Lava:" & $g_aiArmyCompTroops[$eTroopLavaHound] & "\n" & "LSpell:" & $g_aiArmyCompSpells[$eSpellLightning] & " HeSpell:" & $g_aiArmyCompSpells[$eSpellHeal] & " RSpell:" & $g_aiArmyCompSpells[$eSpellRage] & " JSpell:" & $g_aiArmyCompSpells[$eSpellJump] & "\n" & "FSpell:" & $g_aiArmyCompSpells[$eSpellFreeze] & " PSpell:" & $g_aiArmyCompSpells[$eSpellPoison] & " ESpell:" & $g_aiArmyCompSpells[$eSpellEarthquake] & " HaSpell:" & $g_aiArmyCompSpells[$eSpellHaste] & "\n"
$txtTroopStats &= "\n" & GetTranslated(620,168,"Current Trained Troops & Spells") & ":"
$txtTroopStats &= "\n\n" & GetTranslated(620,169,"Current Army Camp") & ": " & $CurCamp & "/" & $TotalCamp
NotifyPushToTelegram($g_sNotifyOrigin & $txtTroopStats)
Case GetTranslated(620,37,"HALTATTACKON"), '\U274C ' & StringUpper(GetTranslated(620,38,"Attack Off"))
GUICtrlSetState($g_hChkBotStop, $GUI_CHECKED)
btnStop()
$g_bChkBotStop = True
$g_iCmbBotCond = 18
btnStart()
Case GetTranslated(620,40,"HALTATTACKOFF"), '\U2705 ' & StringUpper(GetTranslated(620,41,"Attack On"))
GUICtrlSetState($g_hChkBotStop, $GUI_UNCHECKED)
btnStop()
btnStart()
Case GetTranslated(620,43,"HIBERNATE"), '\UD83D\UDCA4 ' & GetTranslated(620,43,"HIBERNATE")
SetLog("Notify Telegram: Your request has been received from " & $g_sNotifyOrigin & ". Hibernate PC", $COLOR_GREEN)
NotifyPushToTelegram(GetTranslated(620,45,"PC Hibernate sequence initiated"))
Shutdown(64)
Case GetTranslated(620,46,"SHUTDOWN"), '\U26A1 ' & StringUpper(GetTranslated(620,47,"Shut down"))
SetLog("Notify Telegram: Your request has been received from " & $g_sNotifyOrigin & ". Shutdown PC", $COLOR_GREEN)
NotifyPushToTelegram(GetTranslated(620,49,"PC Shutdown sequence initiated"))
Shutdown(5)
Case GetTranslated(620,50,"STANDBY"), GetTranslated(620,50,"STANDBY")
SetLog("Notify Telegram: Your request has been received from " & $g_sNotifyOrigin & ". Standby PC", $COLOR_GREEN)
NotifyPushToTelegram(GetTranslated(620,52,"PC Standby sequence initiated"))
Shutdown(32)
EndSwitch
EndIf
EndIf
EndIf
EndFunc
Func NotifyPushToBoth($pMessage)
If($g_bNotifyPBEnable = False Or $g_sNotifyPBToken = "") And($g_bNotifyTGEnable = False Or $g_sNotifyTGToken = "") Then Return
If $g_bNotifyPBEnable = True And $g_sNotifyPBToken <> "" Then
Local $oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
$oHTTP.Open("Post", "https://api.pushbullet.com/v2/pushes", False)
Local $access_token = $g_sNotifyPBToken
$oHTTP.SetCredentials($access_token, "", 0)
$oHTTP.SetRequestHeader("Content-Type", "application/json")
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN
Local $pPush = '{"type": "note", "body": "' & $pMessage & "\n" & $Date & "__" & $Time & '"}'
$oHTTP.Send($pPush)
EndIf
If $g_bNotifyTGEnable = True And $g_sNotifyTGToken <> "" Then
Local $oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
Local $url = "https://api.telegram.org/bot"
$oHTTP.Open("Post", $url & $g_sNotifyTGToken & "/sendMessage", False)
$oHTTP.SetRequestHeader("Content-Type", "application/json; charset=ISO-8859-1,utf-8")
Local $Date = @YEAR & '-' & @MON & '-' & @MDAY
Local $Time = @HOUR & '.' & @MIN
Local $TGPushMsg = '{"text":"' & $pmessage & '\n' & $Date & '__' & $Time & '", "chat_id":' & $g_sTGChatID & '}}'
$oHTTP.Send($TGPushMsg)
EndIf
EndFunc
Func NotifyPushMessageToBoth($Message, $Source = "")
Static $iReportIdleBuilder = 0
If $g_bNotifyForced = False And $Message <> "DeleteAllPBMessages" Then
If $g_bNotifyScheduleWeekDaysEnable = True Then
If $g_abNotifyScheduleWeekDays[@WDAY - 1] = True Then
If $g_bNotifyScheduleHoursEnable = True Then
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If $g_abNotifyScheduleHours[$hour[0]] = False Then
SetLog("Notify not planned for this hour! Notification skipped", $COLOR_ORANGE)
SetLog($Message, $COLOR_ORANGE)
Return
EndIf
EndIf
Else
Return
EndIf
Else
If $g_bNotifyScheduleHoursEnable = True Then
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If $g_abNotifyScheduleHours[$hour[0]] = False Then
SetLog("Notify not planned for this hour! Notification skipped", $COLOR_ORANGE)
SetLog($Message, $COLOR_ORANGE)
Return
EndIf
EndIf
EndIf
EndIf
$g_bNotifyForced = False
Local $hBitmap_Scaled
Switch $Message
Case "Restarted"
If($g_bNotifyPBEnable = True Or $g_bNotifyTGEnable = True) And $g_bNotifyRemoteEnable = True Then NotifyPushToBoth($g_sNotifyOrigin & " | " & GetTranslated(620,145, "Bot restarted"))
Case "OutOfSync"
If($g_bNotifyPBEnable = True Or $g_bNotifyTGEnable = True) And $g_bNotifyAlertOutOfSync = True Then NotifyPushToBoth($g_sNotifyOrigin & " | " & GetTranslated(620,172, "Restarted after Out of Sync Error") & "\n" & GetTranslated(620,149, "Attacking now") & "...")
Case "LastRaid"
If($g_bNotifyPBEnable = True Or $g_bNotifyTGEnable = True) And $g_bNotifyAlerLastRaidTXT = True Then
NotifyPushToBoth($g_sNotifyOrigin & " | " & GetTranslated(620,119, "Last Raid txt") & "\n" & "[" & GetTranslated(620,109, "G") & "]: " & _NumberFormat($g_iStatsLastAttack[$CurrentAccount][$eLootGold]) & " [" & GetTranslated(620,110, "E") & "]: " & _NumberFormat($g_iStatsLastAttack[$CurrentAccount][$eLootElixir]) & " [" & GetTranslated(620,111, "DE") & "]: " & _NumberFormat($g_iStatsLastAttack[$CurrentAccount][$eLootDarkElixir]) & " [" & GetTranslated(620,112, "T") & "]: " & $g_iStatsLastAttack[$CurrentAccount][$eLootTrophy])
If _Sleep($iDelayPushMsg1) Then Return
If $g_bNotifyPBEnable = True Then SetLog("Notify PushBullet: Last Raid Text has been sent!", $COLOR_GREEN)
If $g_bNotifyTGEnable = True Then SetLog("Notify Telegram: Last Raid Text has been sent!", $COLOR_GREEN)
EndIf
If($g_bNotifyPBEnable = True Or $g_bNotifyTGEnable = True) And $g_bNotifyAlerLastRaidIMG = True Then
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN
If $ScreenshotLootInfo = 1 Then
$g_sAttackFile = $LootFileName
Else
_CaptureRegion()
$g_sAttackFile = "Notify_" & $Date & "__" & $Time & ".jpg"
$hBitmap_Scaled = _GDIPlus_ImageResize($hBitmap, _GDIPlus_ImageGetWidth($hBitmap) / 2, _GDIPlus_ImageGetHeight($hBitmap) / 2)
_GDIPlus_ImageSaveToFile($hBitmap_Scaled, $g_sProfileLootsPath & $g_sAttackFile)
_GDIPlus_ImageDispose($hBitmap_Scaled)
EndIf
If $g_bNotifyPBEnable = True Then SetLog("Notify PushBullet: Last Raid screenshot has been sent!", $COLOR_GREEN)
If $g_bNotifyTGEnable = True Then SetLog("Notify Telegram: Last Raid screenshot has been sent!", $COLOR_GREEN)
NotifyPushFileToBoth($g_sAttackFile, "Loots", "image/jpeg", $g_sNotifyOrigin & " | " & "Last Raid" & "\n" & $g_sAttackFile)
If _Sleep($iDelayPushMsg1) Then Return
Local $iDelete = FileDelete($g_sProfileLootsPath & $g_sAttackFile)
If Not $iDelete Then
If $g_bNotifyPBEnable = True Then SetLog("Notify PushBullet: An error occurred deleting temporary screenshot file.", $COLOR_RED)
If $g_bNotifyTGEnable = True Then SetLog("Notify Telegram: An error occurred deleting temporary screenshot file.", $COLOR_RED)
EndIf
EndIf
Case "FoundWalls"
If($g_bNotifyPBEnable = True Or $g_bNotifyTGEnable = True) And $g_bNotifyAlertUpgradeWalls = True Then NotifyPushToBoth($g_sNotifyOrigin & " | " & GetTranslated(620,173, "Found Wall level") & " " & $g_iCmbUpgradeWallsLevel + 4 & "\n" & " " & GetTranslated(620,177, "Wall segment has been located") & "...\n" & GetTranslated(620,153, "Upgrading") & "...")
Case "SkipWalls"
If($g_bNotifyPBEnable = True Or $g_bNotifyTGEnable = True) And $g_bNotifyAlertUpgradeWalls = True Then NotifyPushToBoth($g_sNotifyOrigin & " | " & GetTranslated(620,174, "Cannot find Wall level") & $g_iCmbUpgradeWallsLevel + 4 & "\n" & GetTranslated(620,154, "Skip upgrade") & "...")
Case "AnotherDevice3600"
If($g_bNotifyPBEnable = True Or $g_bNotifyTGEnable = True) And $g_bNotifyAlertAnotherDevice = True Then NotifyPushToBoth($g_sNotifyOrigin & " | 1. " & GetTranslated(620,175, "Another Device has connected") & "\n" & GetTranslated(620,176, "Another Device has connected, waiting") & " " & Floor(Floor($sTimeWakeUp / 60) / 60) & " " & GetTranslated(603,14, "Hours") & " " & Floor(Mod(Floor($sTimeWakeUp / 60), 60)) & " " & GetTranslated(603,9, "minutes") & " " & Floor(Mod($sTimeWakeUp, 60)) & " " & GetTranslated(603,8, "seconds"))
Case "AnotherDevice60"
If($g_bNotifyPBEnable = True Or $g_bNotifyTGEnable = True) And $g_bNotifyAlertAnotherDevice = True Then NotifyPushToBoth($g_sNotifyOrigin & " | 2. " & GetTranslated(620,175, "Another Device has connected") & "\n" & GetTranslated(620,176, "Another Device has connected, waiting") & " " & Floor(Mod(Floor($sTimeWakeUp / 60), 60)) & " " & GetTranslated(603,9, "minutes") & " " & Floor(Mod($sTimeWakeUp, 60)) & " " & GetTranslated(603,8, "seconds"))
Case "AnotherDevice"
If($g_bNotifyPBEnable = True Or $g_bNotifyTGEnable = True) And $g_bNotifyAlertAnotherDevice = True Then NotifyPushToBoth($g_sNotifyOrigin & " | 3. " & GetTranslated(620,175, "Another Device has connected") & "\n" & GetTranslated(620,176, "Another Device has connected, waiting") & " " & Floor(Mod($sTimeWakeUp, 60)) & " " & GetTranslated(603,8, "seconds"))
Case "TakeBreak"
If($g_bNotifyPBEnable = True Or $g_bNotifyTGEnable = True) And $g_bNotifyAlertTakeBreak = True Then NotifyPushToBoth($g_sNotifyOrigin & " | " & GetTranslated(620,106, "Chief, we need some rest!") & "\n" & GetTranslated(620,107, "Village must take a break.."))
Case "Update"
If($g_bNotifyPBEnable = True Or $g_bNotifyTGEnable = True) And $g_bNotifyAlertBOTUpdate = True Then NotifyPushToBoth($g_sNotifyOrigin & " | " & GetTranslated(620,129, "Chief, there is a new version of the bot available"))
Case "BuilderIdle"
If($g_bNotifyPBEnable = True Or $g_bNotifyTGEnable = True) And $g_bNotifyAlertBulderIdle = True Then
Local $iAvailBldr = $iFreeBuilderCount -($g_bUpgradeWallSaveBuilder ? 1 : 0)
If $iAvailBldr > 0 Then
If $iReportIdleBuilder <> $iAvailBldr Then
NotifyPushToBoth($g_sNotifyOrigin & " | " & GetTranslated(620,122,"You have") & " " & $iAvailBldr & " " & GetTranslated(620,123,"builder(s) idle."))
SetLog("You have " & $iAvailBldr & " builder(s) idle.", $COLOR_GREEN)
$iReportIdleBuilder = $iAvailBldr
EndIf
Else
$iReportIdleBuilder = 0
EndIf
EndIf
Case "CocError"
If($g_bNotifyPBEnable = True Or $g_bNotifyTGEnable = True) And $g_bNotifyAlertOutOfSync = True Then NotifyPushToBoth($g_sNotifyOrigin & " | " & GetTranslated(620,155, "CoC Has Stopped Error") & ".....")
Case "Pause"
If($g_bNotifyPBEnable = True Or $g_bNotifyTGEnable = True) And $g_bNotifyRemoteEnable = True And $Source = "Push" Then NotifyPushToBoth($g_sNotifyOrigin & " | " & GetTranslated(620,166, "Request to Pause") & "..." & "\n" & GetTranslated(620,156, "Your request has been received. Bot is now paused"))
Case "Resume"
If($g_bNotifyPBEnable = True Or $g_bNotifyTGEnable = True) And $g_bNotifyRemoteEnable = True And $Source = "Push" Then NotifyPushToBoth($g_sNotifyOrigin & " | " & GetTranslated(620,167, "Request to Resume") & "..." & "\n" & GetTranslated(620,157, "Your request has been received. Bot is now resumed"))
Case "OoSResources"
If($g_bNotifyPBEnable = True Or $g_bNotifyTGEnable = True) And $g_bNotifyAlertOutOfSync = True Then NotifyPushToBoth($g_sNotifyOrigin & " | " & GetTranslated(620,178, "Disconnected after") & " " & StringFormat("%3s", $SearchCount) & " " & GetTranslated(620,104, "skip(s)") & "\n" & GetTranslated(620,158, "Cannot locate Next button, Restarting Bot") & "...")
Case "MatchFound"
If($g_bNotifyPBEnable = True Or $g_bNotifyTGEnable = True) And $g_bNotifyAlertMatchFound = True Then NotifyPushToBoth($g_sNotifyOrigin & " | " & $g_asModeText[$g_iMatchMode] & " " & GetTranslated(620,103, "Match Found! after") & " " & StringFormat("%3s", $SearchCount) & " " & GetTranslated(620,104, "skip(s)") & "\n" & "[" & GetTranslated(620,109, "G") & "]: " & _NumberFormat($searchGold) & "; [" & GetTranslated(620,110, "E") & "]: " & _NumberFormat($searchElixir) & "; [" & GetTranslated(620,111, "DE") & "]: " & _NumberFormat($searchDark) & "; [" & GetTranslated(620,112, "T") & "]: " & $searchTrophy)
Case "UpgradeWithGold"
If($g_bNotifyPBEnable = True Or $g_bNotifyTGEnable = True) And $g_bNotifyAlertUpgradeWalls = True Then NotifyPushToBoth($g_sNotifyOrigin & " | " & GetTranslated(620,179, "Upgrade completed by using GOLD") & "\n" & GetTranslated(620,159, "Complete by using GOLD") & "...")
Case "UpgradeWithElixir"
If($g_bNotifyPBEnable = True Or $g_bNotifyTGEnable = True) And $g_bNotifyAlertUpgradeWalls = True Then NotifyPushToBoth($g_sNotifyOrigin & " | " & GetTranslated(620,180, "Upgrade completed by using ELIXIR") & "\n" & GetTranslated(620,159, "Complete by using ELIXIR") & "...")
Case "NoUpgradeWallButton"
If($g_bNotifyPBEnable = True Or $g_bNotifyTGEnable = True) And $g_bNotifyAlertUpgradeWalls = True Then NotifyPushToBoth($g_sNotifyOrigin & " | " & GetTranslated(620,160, "No Upgrade Gold Button") & "\n" & GetTranslated(620,160, "Cannot find gold upgrade button") & "...")
Case "NoUpgradeElixirButton"
If($g_bNotifyPBEnable = True Or $g_bNotifyTGEnable = True) And $g_bNotifyAlertUpgradeWalls = True Then NotifyPushToBoth($g_sNotifyOrigin & " | " & GetTranslated(620,181, "No Upgrade Elixir Button") & "\n" & GetTranslated(620,161, "Cannot find elixir upgrade button") & "...")
Case "RequestScreenshot"
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN
_CaptureRegion()
If $g_bPBRequestScreenshotHD = True Or $g_bTGRequestScreenshotHD = True Then
$hBitmap_Scaled = $hBitmap
Else
$hBitmap_Scaled = _GDIPlus_ImageResize($hBitmap, _GDIPlus_ImageGetWidth($hBitmap) / 2, _GDIPlus_ImageGetHeight($hBitmap) / 2)
EndIf
Local $Screnshotfilename = "Screenshot_" & $Date & "_" & $Time & ".jpg"
_GDIPlus_ImageSaveToFile($hBitmap_Scaled, $g_sProfileTempPath & $Screnshotfilename)
_GDIPlus_ImageDispose($hBitmap_Scaled)
If $g_bPBRequestScreenshot = True Or $g_bTGRequestScreenshot = True Then
If $g_bPBRequestScreenshot = True And $g_bNotifyPBEnable = True Then
NotifyPushFileToPushBullet($Screnshotfilename, "Temp", "image/jpeg", $g_sNotifyOrigin & " | " & GetTranslated(620,162, "Screenshot of your village") & " " & "\n" & $Screnshotfilename)
SetLog("Notify PushBullet: Screenshot sent!", $COLOR_GREEN)
EndIf
If $g_bTGRequestScreenshot = True And $g_bNotifyTGEnable = True Then
NotifyPushFileToTelegram($Screnshotfilename, "Temp", "image/jpeg", $g_sNotifyOrigin & " | " & GetTranslated(620,162, "Screenshot of your village") & " " & "\n" & $Screnshotfilename)
SetLog("Notify Telegram: Screenshot sent!", $COLOR_GREEN)
EndIf
EndIf
$g_bPBRequestScreenshot = False
$g_bPBRequestScreenshotHD = False
$g_bTGRequestScreenshot = False
$g_bTGRequestScreenshotHD = False
If _Sleep($iDelayPushMsg2) Then Return
Local $iDelete = FileDelete($g_sProfileTempPath & $Screnshotfilename)
If Not $iDelete Then
If $g_bNotifyPBEnable = True Then SetLog("Notify PushBullet: An error occurred deleting temporary screenshot file.", $COLOR_RED)
If $g_bNotifyTGEnable = True Then SetLog("Notify Telegram: An error occurred deleting temporary screenshot file.", $COLOR_RED)
EndIf
Case "BuilderInfo"
Click(0,0, 5)
Click(274,8)
_Sleep(500)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN
_CaptureRegion(224, 74, 446, 262)
Local $Screnshotfilename = "Screenshot_" & $Date & "_" & $Time & ".jpg"
_GDIPlus_ImageSaveToFile($hBitmap, $g_sProfileTempPath & $Screnshotfilename)
If $g_bPBRequestBuilderInfo = True Or $g_bTGRequestBuilderInfo = True Then
If $g_bPBRequestBuilderInfo = True And $g_bNotifyPBEnable = True Then
NotifyPushFileToPushBullet($Screnshotfilename, "Temp", "image/jpeg", $g_sNotifyOrigin & " | " & "Builder Information" & "\n" & $Screnshotfilename)
SetLog("Notify PushBullet: Builder Information sent!", $COLOR_GREEN)
EndIf
If $g_bTGRequestBuilderInfo = True And $g_bNotifyTGEnable = True Then
NotifyPushFileToTelegram($Screnshotfilename, "Temp", "image/jpeg", $g_sNotifyOrigin & " | " & "Builder Information" & "\n" & $Screnshotfilename)
SetLog("Notify Telegram: Builder Information sent!", $COLOR_GREEN)
EndIf
EndIf
$g_bPBRequestBuilderInfo = False
$g_bTGRequestBuilderInfo = False
If _Sleep($iDelayPushMsg2) Then Return
Local $iDelete = FileDelete($g_sProfileTempPath & $Screnshotfilename)
If Not $iDelete Then
If $g_bNotifyPBEnable = True Then SetLog("Notify PushBullet: An error occurred deleting temporary screenshot file.", $COLOR_RED)
If $g_bNotifyTGEnable = True Then SetLog("Notify Telegram: An error occurred deleting temporary screenshot file.", $COLOR_RED)
EndIf
Click(0,0, 5)
Case "ShieldInfo"
Click(0,0, 5)
Click(435,8)
_Sleep(500)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN
_CaptureRegion(200, 165, 660, 568)
Local $Screnshotfilename = "Screenshot_" & $Date & "_" & $Time & ".jpg"
_GDIPlus_ImageSaveToFile($hBitmap, $g_sProfileTempPath & $Screnshotfilename)
If $g_bPBRequestShieldInfo = True Or $g_bTGRequestShieldInfo = True Then
If $g_bPBRequestShieldInfo = True And $g_bNotifyPBEnable = True Then
NotifyPushFileToPushBullet($Screnshotfilename, "Temp", "image/jpeg", $g_sNotifyOrigin & " | " & "Shield Information" & "\n" & $Screnshotfilename)
SetLog("Notify PushBullet: Shield Information sent!", $COLOR_GREEN)
EndIf
If $g_bTGRequestShieldInfo = True And $g_bNotifyTGEnable = True Then
NotifyPushFileToTelegram($Screnshotfilename, "Temp", "image/jpeg", $g_sNotifyOrigin & " | " & "Shield Information" & "\n" & $Screnshotfilename)
SetLog("Notify Telegram: Shield Information sent!", $COLOR_GREEN)
EndIf
EndIf
$g_bPBRequestShieldInfo = False
$g_bTGRequestShieldInfo = False
If _Sleep($iDelayPushMsg2) Then Return
Local $iDelete = FileDelete($g_sProfileTempPath & $Screnshotfilename)
If Not $iDelete Then
If $g_bNotifyPBEnable = True Then SetLog("Notify PushBullet: An error occurred deleting temporary screenshot file.", $COLOR_RED)
If $g_bNotifyTGEnable = True Then SetLog("Notify Telegram: An error occurred deleting temporary screenshot file.", $COLOR_RED)
EndIf
Click(0,0, 5)
Case "DeleteAllPBMessages"
NotifyDeletePushBullet()
If $g_bNotifyPBEnable = True Then SetLog("Notify PushBullet: All messages deleted.", $COLOR_GREEN)
If $g_bNotifyTGEnable = True Then SetLog("Notify Telegram: All messages deleted.", $COLOR_GREEN)
$g_bNotifyDeleteAllPushesNow = False
Case "CampFull"
If($g_bNotifyPBEnable = True Or $g_bNotifyTGEnable = True) And $g_bNotifyAlertCampFull = True Then
NotifyPushToBoth($g_sNotifyOrigin & " | " & GetTranslated(620,128, "Your Army Camps are now Full"))
If $g_bNotifyPBEnable = True Then SetLog("Notify PushBullet: Your Army Camps are now Full", $COLOR_GREEN)
If $g_bNotifyTGEnable = True Then SetLog("Notify Telegram: Your Army Camps are now Full", $COLOR_GREEN)
EndIf
Case "Misc"
NotifyPushToBoth($Message)
EndSwitch
EndFunc
Func NotifyPushFileToBoth($File, $Folder, $FileType, $body)
If($g_bNotifyPBEnable = False Or $g_sNotifyPBToken = "") And($g_bNotifyTGEnable = False Or $g_sNotifyTGToken = "") Then Return
If $g_bNotifyPBEnable = True And $g_sNotifyPBToken <> "" Then
If FileExists($g_sProfilePath & "\" & $g_sProfileCurrentName & '\' & $Folder & '\' & $File) Then
Local $oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
$oHTTP.Open("Post", "https://api.pushbullet.com/v2/upload-request", False)
Local $access_token = $g_sNotifyPBToken
$oHTTP.SetCredentials($access_token, "", 0)
$oHTTP.SetRequestHeader("Content-Type", "application/json")
Local $pPush = '{"file_name": "' & $File & '", "file_type": "' & $FileType & '"}'
$oHTTP.Send($pPush)
Local $Result = $oHTTP.ResponseText
Local $upload_url = _StringBetween($Result, 'upload_url":"', '"')
Local $awsaccesskeyid = _StringBetween($Result, 'awsaccesskeyid":"', '"')
Local $acl = _StringBetween($Result, 'acl":"', '"')
Local $key = _StringBetween($Result, 'key":"', '"')
Local $signature = _StringBetween($Result, 'signature":"', '"')
Local $policy = _StringBetween($Result, 'policy":"', '"')
Local $file_url = _StringBetween($Result, 'file_url":"', '"')
If IsArray($upload_url) And IsArray($awsaccesskeyid) And IsArray($acl) And IsArray($key) And IsArray($signature) And IsArray($policy) Then
$Result = RunWait($g_sCurlPath & " -i -X POST " & $upload_url[0] & ' -F awsaccesskeyid="' & $awsaccesskeyid[0] & '" -F acl="' & $acl[0] & '" -F key="' & $key[0] & '" -F signature="' & $signature[0] & '" -F policy="' & $policy[0] & '" -F content-type="' & $FileType & '" -F file=@"' & $g_sProfilePath & "\" & $g_sProfileCurrentName & '\' & $Folder & '\' & $File & '"', "", @SW_HIDE)
$oHTTP.Open("Post", "https://api.pushbullet.com/v2/pushes", False)
$oHTTP.SetCredentials($access_token, "", 0)
$oHTTP.SetRequestHeader("Content-Type", "application/json")
Local $pPush = '{"type": "file", "file_name": "' & $File & '", "file_type": "' & $FileType & '", "file_url": "' & $file_url[0] & '", "body": "' & $body & '"}'
$oHTTP.Send($pPush)
Else
SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,726,"Unable to send file") & " " & $File, $COLOR_RED)
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslated(620,170, "Unable to Upload File") & "\n" & GetTranslated(620,171, "Occured an error type") & " 1 " & GetTranslated(620,144, "uploading file to PushBullet server") & "...")
EndIf
Else
SetLog("Notify PushBullet: Unable to send file " & $File, $COLOR_RED)
NotifyPushToPushBullet($g_sNotifyOrigin & " | " & GetTranslated(620,170, "Unable to Upload File") & "\n" & GetTranslated(620,171, "Occured an error type") & " 2 " & GetTranslated(620,144, "uploading file to PushBullet server") & "...")
EndIf
EndIf
If $g_bNotifyTGEnable = True And $g_sNotifyTGToken <> "" Then
If FileExists($g_sProfilePath & "\" & $g_sProfileCurrentName & '\' & $Folder & '\' & $File) Then
Local $oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
Local $telegram_url = "https://api.telegram.org/bot" & $g_sNotifyTGToken & "/sendPhoto"
Local $Result = RunWait($g_sCurlPath & " -i -X POST " & $telegram_url & ' -F chat_id="' & $g_sTGChatID &' " -F photo=@"' & $g_sProfilePath & "\" & $g_sProfileCurrentName & '\' & $Folder & '\' & $File & '"', "", @SW_HIDE)
$oHTTP.Open("Post", "https://api.telegram.org/bot" & $g_sNotifyTGToken & "/sendPhoto", False)
$oHTTP.SetRequestHeader("Content-Type", "application/json")
Local $pPush = '{"type": "file", "file_name": "' & $File & '", "file_type": "' & $FileType & '", "file_url": "' & $telegram_url & '", "body": "' & $body & '"}'
$oHTTP.Send($pPush)
Else
SetLog("Notify Telegram: Unable to send file " & $File, $COLOR_RED)
NotifyPushToTelegram($g_sNotifyOrigin & " | " & GetTranslated(620,170,"Unable to Upload File") & "\n" & GetTranslated(620,146,"Occured an error type 2 uploading file to Telegram server..."))
EndIf
EndIf
EndFunc
Global $TempGainCost[3] = [0, 0, 0]
Func StartGainCost()
$TempGainCost[0] = 0
$TempGainCost[1] = 0
$TempGainCost[2] = 0
VillageReport(True, True)
Local $tempCounter = 0
While($iGoldCurrent = "" Or $iElixirCurrent = "" Or($iDarkCurrent = "" And $g_iStatsStartedWith[$CurrentAccount][$eLootDarkElixir] <> "")) And $tempCounter < 5
$tempCounter += 1
If _Sleep(100) Then Return
VillageReport(True, True)
WEnd
$TempGainCost[0] = $iGoldCurrent
$TempGainCost[1] = $iElixirCurrent
$TempGainCost[2] = $iDarkCurrent
EndFunc
Func EndGainCost($Type)
VillageReport(True, True)
Local $tempCounter = 0
While($iGoldCurrent = "" Or $iElixirCurrent = "" Or($iDarkCurrent = "" And $g_iStatsStartedWith[$CurrentAccount][$eLootDarkElixir] <> "")) And $tempCounter < 5
$tempCounter += 1
VillageReport(True, True)
WEnd
Switch $Type
Case "Collect"
Local $tempGoldCollected = 0
Local $tempElixirCollected = 0
Local $tempDElixirCollected = 0
If $TempGainCost[0] <> "" And $iGoldCurrent <> "" And $TempGainCost[0] <> $iGoldCurrent Then
$tempGoldCollected = $iGoldCurrent - $TempGainCost[0]
$g_iGoldFromMines[$CurrentAccount] += $tempGoldCollected
$g_iStatsTotalGain[$CurrentAccount][$eLootGold] += $tempGoldCollected
EndIf
If $TempGainCost[1] <> "" And $iElixirCurrent <> "" And $TempGainCost[1] <> $iElixirCurrent Then
$tempElixirCollected = $iElixirCurrent - $TempGainCost[1]
$g_iElixirFromCollectors[$CurrentAccount] += $tempElixirCollected
$g_iStatsTotalGain[$CurrentAccount][$eLootElixir] += $tempElixirCollected
EndIf
If $TempGainCost[2] <> "" And $iDarkCurrent <> "" And $TempGainCost[2] <> $iDarkCurrent Then
$tempDElixirCollected = $iDarkCurrent - $TempGainCost[2]
$g_iDElixirFromDrills[$CurrentAccount] += $tempDElixirCollected
$g_iStatsTotalGain[$CurrentAccount][$eLootDarkElixir] += $tempDElixirCollected
EndIf
Case "Train"
Local $tempElixirSpent = 0
Local $tempDElixirSpent = 0
If $TempGainCost[1] <> "" And $iElixirCurrent <> "" And $TempGainCost[1] <> $iElixirCurrent Then
$tempElixirSpent =($TempGainCost[1] - $iElixirCurrent)
$g_iTrainCostElixir[$CurrentAccount] += $tempElixirSpent
$g_iStatsTotalGain[$CurrentAccount][$eLootElixir] -= $tempElixirSpent
EndIf
If $TempGainCost[2] <> "" And $iDarkCurrent <> "" And $TempGainCost[2] <> $iDarkCurrent Then
$tempDElixirSpent =($TempGainCost[2] - $iDarkCurrent)
$g_iTrainCostDElixir[$CurrentAccount] += $tempDElixirSpent
$g_iStatsTotalGain[$CurrentAccount][$eLootDarkElixir] -= $tempDElixirSpent
EndIf
EndSwitch
UpdateStats()
EndFunc
Func PrepareSearch()
SetLog("Going to Attack...", $COLOR_INFO)
ChkAttackCSVConfig()
If IsMainPage() Then
If $iUseRandomClick = 0 then
ClickP($aAttackButton, 1, 0, "#0149")
Else
ClickR($aAttackButtonRND, $aAttackButton[0], $aAttackButton[1], 1, 0)
EndIf
EndIf
If _Sleep($iDelayPrepareSearch1) Then Return
Local $j = 0
While Not(IsLaunchAttackPage())
If _Sleep($iDelayPrepareSearch1) Then Return
$j += 1
If $j > 15 Then ExitLoop
WEnd
If $j > 15 Then
SetLog("Launch attack Page Fail", $COLOR_ERROR)
AndroidPageError("PrepareSearch")
checkMainScreen()
$g_bRestart = True
$Is_ClientSyncError = False
Return
Else
If $iUseRandomClick = 0 then
ClickP($aFindMatchButton, 1, 0, "#0150")
Else
ClickR($aFindMatchButtonRND, $aFindMatchButton[0], $aFindMatchButton[1], 1, 0)
EndIf
If $iTownHallLevel <> "" And $iTownHallLevel > 0 Then
$g_iSearchCost[$CurrentAccount] += $aSearchCost[$iTownHallLevel - 1]
$g_iStatsTotalGain[$CurrentAccount][$eLootGold] -= $aSearchCost[$iTownHallLevel - 1]
EndIf
UpdateStats()
EndIf
If _Sleep($iDelayPrepareSearch2) Then Return
Local $Result = getAttackDisable(346, 182)
If isGemOpen(True) = True Then
Setlog(" Not enough gold to start searching.....", $COLOR_ERROR)
Click(585, 252, 1, 0, "#0151")
If _Sleep($iDelayPrepareSearch1) Then Return
Click(822, 32, 1, 0, "#0152")
If _Sleep($iDelayPrepareSearch1) Then Return
$OutOfGold = 1
EndIf
checkAttackDisable($iTaBChkAttack, $Result)
If $g_iDebugSetlog = 1 Then Setlog("PrepareSearch exit check $g_bRestart= " & $g_bRestart & ", $OutOfGold= " & $OutOfGold, $COLOR_DEBUG)
If $g_bRestart = True Or $OutOfGold = 1 Then
$Is_ClientSyncError = False
Return
EndIf
If IsAttackWhileShieldPage(False) Then
Local $offColors[3][3] = [[0x000000, 144, 1], [0xFFFFFF, 54, 17], [0xFFFFFF, 54, 28]]
Global $ButtonPixel = _MultiPixelSearch(359, 404 + $g_iMidOffsetY, 510, 445 + $g_iMidOffsetY, 1, 1, Hex(0x000000, 6), $offColors, 20)
If $g_iDebugSetlog = 1 Then Setlog("Shield btn clr chk-#1: " & _GetPixelColor(441, 344 + $g_iMidOffsetY, True) & ", #2: " &  _GetPixelColor(441 + 144, 344 + $g_iMidOffsetY, True) & ", #3: " & _GetPixelColor(441 + 54, 344 + 17 + $g_iMidOffsetY, True) & ", #4: " &  _GetPixelColor(441 + 54, 344 + 10 + $g_iMidOffsetY, True), $COLOR_DEBUG)
If IsArray($ButtonPixel) Then
If $g_iDebugSetlog = 1 Then
Setlog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("Shld Btn Pixel color found #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 144, $ButtonPixel[1], True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 54, $ButtonPixel[1] + 17, True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 54, $ButtonPixel[1] + 27, True), $COLOR_DEBUG)
EndIf
Click($ButtonPixel[0] + 75, $ButtonPixel[1] + 25, 1, 0, "#0153")
EndIf
EndIf
EndFunc
Global $iSkipped = 0
Func VillageSearch()
Local $Result
Local $weakBaseValues
Local $logwrited = False
$iSkipped = 0
If $g_iDebugDeadBaseImage = 1 Or $g_aiSearchEnableDebugDeadBaseImage > 0 Then
DirCreate($g_sProfileTempDebugPath & "\SkippedZombies\")
DirCreate($g_sProfileTempDebugPath & "\Zombies\")
setZombie()
EndIf
If $Is_ClientSyncError = False Then
For $i = 0 To $g_iModeCount - 1
$iAimGold[$i] = $g_aiFilterMinGold[$i]
$iAimElixir[$i] = $g_aiFilterMinElixir[$i]
$iAimGoldPlusElixir[$i] = $g_aiFilterMinGoldPlusElixir[$i]
$iAimDark[$i] =($g_abFilterMeetDEEnable[$i] ?($g_aiFilterMeetDEMin[$i]) :(0))
$iAimTrophy[$i] =($g_abFilterMeetTrophyEnable[$i] ?($g_aiFilterMeetTrophyMin[$i]) :(0))
Next
EndIf
If _Sleep($iDelayVillageSearch1) Then Return
$Result = getAttackDisable(346, 182)
checkAttackDisable($iTaBChkAttack, $Result)
If $g_bRestart = True Then Return
If Not($Is_SearchLimit) Then
SetLog(_StringRepeat("=", 50), $COLOR_INFO)
EndIf
For $x = 0 To $g_iModeCount - 1
If IsSearchModeActive($x) Then WriteLogVillageSearch($x)
Next
If Not($Is_SearchLimit) Then
SetLog(_StringRepeat("=", 50), $COLOR_INFO)
Else
SetLog(_PadStringCenter(" Restart To Search ", 54, "="), $COLOR_INFO)
EndIf
If $g_bSearchAttackNowEnable Then
GUICtrlSetState($g_hBtnAttackNowDB, $GUI_SHOW)
GUICtrlSetState($g_hBtnAttackNowLB, $GUI_SHOW)
GUICtrlSetState($g_hBtnAttackNowTS, $GUI_SHOW)
GUICtrlSetState($g_hPicTwoArrowShield, $GUI_HIDE)
GUICtrlSetState($g_hLblVersion, $GUI_HIDE)
EndIf
If $Is_ClientSyncError = False And $Is_SearchLimit = False Then
$SearchCount = 0
EndIf
If $Is_SearchLimit = True Then $Is_SearchLimit = False
While 1
ResetTHsearch()
If $g_iDebugVillageSearchImages = 1 Then DebugImageSave("villagesearch")
$logwrited = False
$g_bBtnAttackNowPressed = False
$SearchTHLResult = - 1
If $g_bRestart = True Then Return
WaitForClouds()
If $g_bRestart = True Then Return
GetResources(False)
If $g_bRestart = True Then Return
SuspendAndroid()
Local $noMatchTxt = ""
Local $dbBase = False
Local $match[$g_iModeCount]
For $i = 0 To $g_iModeCount - 1
$match[$i] = False
$isModeActive[$i] = False
Next
If _Sleep($iDelayRespond) Then Return
For $i = 0 To $g_iModeCount - 1
$isModeActive[$i] = IsSearchModeActive($i)
If $isModeActive[$i] Then
$match[$i] = CompareResources($i)
EndIf
Next
ForceCaptureRegion()
_CaptureRegion2()
For $i = 0 To $g_iModeCount - 1
If $match[$i] Then
If CheckZoomOut("VillageSearch", True, False) = False Then
$i = 0
Local $bMeasured
Do
$i += 1
If _Sleep($iDelayPrepareSearch3) Then Return
ForceCaptureRegion()
_CaptureRegion2()
$bMeasured = CheckZoomOut("VillageSearch", $i < 2, False)
Until $bMeasured = True Or $i >= 2
If $bMeasured = False Then Return
EndIf
ExitLoop
EndIf
Next
Local $THString = ""
If $match[$DB] Or $match[$LB] Or $match[$TS] Then
$THString = FindTownhall(False, False)
ElseIf($g_abFilterMeetOneConditionEnable[$DB] Or $g_abFilterMeetOneConditionEnable[$LB]) Then
$THString = FindTownhall(True, False)
ElseIf $g_abAttackTypeEnable[$TB] = 1 And($SearchCount >= $g_iAtkTBEnableCount) then
$THString = FindTownhall(True, False)
EndIf
For $i = 0 To $g_iModeCount - 2
If $isModeActive[$i] Then
If $g_abFilterMeetOneConditionEnable[$i] Then
If $g_abFilterMeetTH[$i] = False And $g_abFilterMeetTHOutsideEnable[$i] = False Then
Else
If CompareTH($i) Then $match[$i] = True
EndIf
Else
If Not CompareTH($i) Then $match[$i] = False
EndIf
EndIf
Next
if $SearchTHLResult = -1 then CompareTH(0)
$GetResourcesTXT = StringFormat("%3s", $SearchCount) & "> [G]:" & StringFormat("%7s", $searchGold) & " [E]:" & StringFormat("%7s", $searchElixir) & " [D]:" & StringFormat("%5s", $searchDark) & " [T]:" & StringFormat("%2s", $searchTrophy) & $THString
If Not $g_bRunState Then Return
Local $checkDeadBase =($match[$DB] And $g_aiAttackAlgorithm[$DB] <> 2) Or $match[$LB] Or($match[$DB] And $g_aiAttackAlgorithm[$DB] = 2 And $g_iMilkAttackType = 1)
If $checkDeadBase Then
$dbBase = checkDeadBase()
EndIf
If(IsWeakBaseActive($DB) And $dbBase And($match[$DB] Or $g_abFilterMeetOneConditionEnable[$DB])) Or(IsWeakBaseActive($LB) And($match[$LB] Or $g_abFilterMeetOneConditionEnable[$LB])) Then
If($searchTH <> "-" ) then
$weakBaseValues = IsWeakBase($IMGLOCTHLEVEL, $IMGLOCREDLINE, False)
Else
$weakBaseValues = IsWeakBase(11, "", False)
EndIf
For $i = 0 To $g_iModeCount - 2
If IsWeakBaseActive($i) And(($i = $DB And $dbBase) Or $i <> $DB) And($match[$i] Or $g_abFilterMeetOneConditionEnable[$i]) Then
If getIsWeak($weakBaseValues, $i) Then
$match[$i] = True
Else
$match[$i] = False
$noMatchTxt &= ", Not a Weak Base for " & $g_asModeText[$i]
EndIf
EndIf
Next
EndIf
CheckMilkingBase($match[$DB], $dbBase)
ResumeAndroid()
If $match[$DB] And $g_aiAttackAlgorithm[$DB] = 2 And $milkingAttackOutside = 1 Then
SetLog($GetResourcesTXT, $COLOR_SUCCESS, "Lucida Console", 7.5)
SetLog("      " & "Milking Attack th outside Found!", $COLOR_SUCCESS, "Lucida Console", 7.5)
$logwrited = True
$g_iMatchMode = $DB
ExitLoop
ElseIf $match[$DB] And $g_aiAttackAlgorithm[$DB] = 2 And $g_iMilkAttackType = 0 And StringLen($MilkFarmObjectivesSTR) > 0 Then
SetLog($GetResourcesTXT, $COLOR_SUCCESS, "Lucida Console", 7.5)
SetLog("      " & "Milking Attack HIGH CPU SETTINGS Found!", $COLOR_SUCCESS, "Lucida Console", 7.5)
$logwrited = True
$g_iMatchMode = $DB
ExitLoop
ElseIf $match[$DB] And $g_aiAttackAlgorithm[$DB] = 2 And $g_iMilkAttackType = 1 And StringLen($MilkFarmObjectivesSTR) > 0 And $dbBase Then
SetLog($GetResourcesTXT, $COLOR_SUCCESS, "Lucida Console", 7.5)
SetLog("      " & "Milking Attack LOW CPU SETTINGS Found!", $COLOR_SUCCESS, "Lucida Console", 7.5)
$logwrited = True
$g_iMatchMode = $DB
ExitLoop
ElseIf $match[$DB] And $dbBase Then
SetLog($GetResourcesTXT, $COLOR_SUCCESS, "Lucida Console", 7.5)
SetLog("      " & "Dead Base Found!", $COLOR_SUCCESS, "Lucida Console", 7.5)
$logwrited = True
$g_iMatchMode = $DB
ExitLoop
ElseIf $match[$LB] And Not $dbBase Then
SetLog($GetResourcesTXT, $COLOR_SUCCESS, "Lucida Console", 7.5)
SetLog("      " & "Live Base Found!", $COLOR_SUCCESS, "Lucida Console", 7.5)
$logwrited = True
$g_iMatchMode = $LB
ExitLoop
ElseIf $match[$LB] And $g_bCollectorFilterDisable Then
SetLog($GetResourcesTXT, $COLOR_SUCCESS, "Lucida Console", 7.5)
SetLog("      " & "Live Base Found!*", $COLOR_SUCCESS, "Lucida Console", 7.5)
$logwrited = True
$g_iMatchMode = $LB
ExitLoop
ElseIf $g_abAttackTypeEnable[$TB] = 1 And($SearchCount >= $g_iAtkTBEnableCount) Then
If $SearchTHLResult = 1 Then
SetLog($GetResourcesTXT, $COLOR_SUCCESS, "Lucida Console", 7.5)
SetLog("      " & "Not a match, but TH Bully Level Found! ", $COLOR_SUCCESS, "Lucida Console", 7.5)
$logwrited = True
$g_iMatchMode = $g_iAtkTBMode
ExitLoop
EndIf
EndIf
If SearchTownHallLoc() And $match[$TS] Then
If CompareResources($TS) Then
SetLog($GetResourcesTXT, $COLOR_SUCCESS, "Lucida Console", 7.5)
SetLog("      " & "TH Outside Found! ", $COLOR_SUCCESS, "Lucida Console", 7.5)
$logwrited = True
$g_iMatchMode = $TS
ExitLoop
Else
$noMatchTxt &= ", Not a " & $g_asModeText[$TS] & ", fails resource min"
EndIf
EndIf
If $match[$DB] And Not $dbBase Then
$noMatchTxt &= ", Not a " & $g_asModeText[$DB]
ElseIf $match[$LB] And $dbBase Then
$noMatchTxt &= ", Not a " & $g_asModeText[$LB]
EndIf
If $noMatchTxt <> "" Then
SetLog($GetResourcesTXT, $COLOR_BLACK, "Lucida Console", 7.5)
SetLog("      " & StringMid($noMatchTxt, 3), $COLOR_BLACK, "Lucida Console", 7.5)
$logwrited = True
EndIf
If Not($logwrited) Then
SetLog($GetResourcesTXT, $COLOR_BLACK, "Lucida Console", 7.5)
EndIf
If SearchLimit($iSkipped + 1) Then Return True
If checkAndroidReboot() = True Then
$g_bRestart = True
$Is_ClientSyncError = True
Return
EndIf
If $g_iSearchDelayMin > 0 And $g_iSearchDelayMax > 0 Then
If $g_iSearchDelayMin <> $g_iSearchDelayMax Then
If _Sleep(Round(1000 * Random($g_iSearchDelayMin, $g_iSearchDelayMax))) Then Return
Else
If _Sleep(1000 * $g_iSearchDelayMin) Then Return
EndIf
EndIf
If _Sleep($iDelayRespond) Then Return
If $g_bSearchAttackNowEnable And $g_iSearchAttackNowDelay > 0 Then
If _Sleep(1000 * $g_iSearchAttackNowDelay) Then Return
EndIf
If $g_bBtnAttackNowPressed = True Then ExitLoop
If $checkDeadBase And $g_iDebugDeadBaseImage = 0 And $SearchCount > $g_aiSearchEnableDebugDeadBaseImage Then
SetLog("Enabled collecting debug images of dead bases (zombies)", $COLOR_DEBUG)
SetLog("- Save skipped dead base when available Elixir with empty storage > " &(($g_aZombie[8] > -1) ?($g_aZombie[8] & "k") :("is disabled")), $COLOR_DEBUG)
SetLog("- Save skipped dead base when available Elixir > " &(($g_aZombie[9] > -1) ?($g_aZombie[9] & "k") :("is disabled")), $COLOR_DEBUG)
SetLog("- Save dead base when available Elixir < " &(($g_aZombie[10] > -1) ?($g_aZombie[10] & "k") :("is disabled")), $COLOR_DEBUG)
SetLog("- Save dead base when raided Elixir < " &(($g_aZombie[7] > -1) ?($g_aZombie[7] & "%") :("is disabled")), $COLOR_DEBUG)
$g_iDebugDeadBaseImage = 1
EndIf
If $g_iDebugDeadBaseImage = 1 Then setZombie()
Local $i = 0
While $i < 100
If _Sleep($iDelayVillageSearch2) Then Return
$i += 1
If( _ColorCheck(_GetPixelColor($NextBtn[0], $NextBtn[1], True), Hex($NextBtn[2], 6), $NextBtn[3])) And IsAttackPage() Then
If $iUseRandomClick = 0 Then
ClickP($NextBtn, 1, 0, "#0155")
Else
ClickR($NextBtnRND, $NextBtn[0], $NextBtn[1], 1, 0)
EndIf
ExitLoop
Else
If $g_iDebugSetlog = 1 Then SetLog("Wait to see Next Button... " & $i, $COLOR_DEBUG)
EndIf
If $i >= 99 Or isProblemAffect(True) Then
$Is_ClientSyncError = True
checkMainScreen()
If $g_bRestart Then
$iNbrOfOoS += 1
UpdateStats()
SetLog("Couldn't locate Next button", $COLOR_ERROR)
PushMsg("OoSResources")
Else
SetLog("Have strange problem Couldn't locate Next button, Restarting CoC and Bot...", $COLOR_ERROR)
$Is_ClientSyncError = False
CloseCoC(True)
EndIf
Return
EndIf
WEnd
If _Sleep($iDelayRespond) Then Return
$Result = getAttackDisable(346, 182)
checkAttackDisable($iTaBChkAttack, $Result)
If $g_bRestart = True Then Return
If isGemOpen(True) = True Then
Setlog(" Not enough gold to keep searching.....", $COLOR_ERROR)
Click(585, 252, 1, 0, "#0156")
If _Sleep($iDelayVillageSearch3) Then Return
$OutOfGold = 1
ReturnHome(False, False)
Return
EndIf
$iSkipped += 1
$g_iSkippedVillageCount[$CurrentAccount] += 1
If $iTownHallLevel <> "" And $iTownHallLevel > 0 Then
$g_iSearchCost[$CurrentAccount] += $aSearchCost[$iTownHallLevel - 1]
$g_iStatsTotalGain[$CurrentAccount][$eLootGold] -= $aSearchCost[$iTownHallLevel - 1]
EndIf
UpdateStats()
WEnd
If $g_bBtnAttackNowPressed = True Then
Setlog(_PadStringCenter(" Attack Now Pressed! ", 50, "~"), $COLOR_SUCCESS)
EndIf
If $g_bSearchAttackNowEnable Then
GUICtrlSetState($g_hBtnAttackNowDB, $GUI_HIDE)
GUICtrlSetState($g_hBtnAttackNowLB, $GUI_HIDE)
GUICtrlSetState($g_hBtnAttackNowTS, $GUI_HIDE)
GUICtrlSetState($g_hPicTwoArrowShield, $GUI_SHOW)
GUICtrlSetState($g_hLblVersion, $GUI_SHOW)
$g_bBtnAttackNowPressed = False
EndIf
If $g_bSearchAlertMe Then
TrayTip($g_asModeText[$g_iMatchMode] & " Match Found!", "Gold: " & $searchGold & "; Elixir: " & $searchElixir & "; Dark: " & $searchDark & "; Trophy: " & $searchTrophy, "", 0)
If FileExists(@WindowsDir & "\media\Festival\Windows Exclamation.wav") Then
SoundPlay(@WindowsDir & "\media\Festival\Windows Exclamation.wav", 1)
ElseIf FileExists(@WindowsDir & "\media\Windows Exclamation.wav") Then
SoundPlay(@WindowsDir & "\media\Windows Exclamation.wav", 1)
EndIf
EndIf
SetLog(_PadStringCenter(" Search Complete ", 50, "="), $COLOR_INFO)
PushMsg("MatchFound")
$Is_ClientSyncError = False
EndFunc
Func SearchLimit($iSkipped)
If $g_bSearchRestartEnable And $iSkipped >= Number($g_iSearchRestartLimit) Then
Local $Wcount = 0
While _CheckPixel($aSurrenderButton, $g_bCapturePixel) = False
If _Sleep($iDelaySWHTSearchLimit1) Then Return
$Wcount += 1
If $g_iDebugSetlog = 1 Then setlog("wait surrender button " & $Wcount, $COLOR_DEBUG)
If $Wcount >= 50 Or isProblemAffect(True) Then
checkMainScreen()
$Is_ClientSyncError = False
$g_bRestart = True
Return True
EndIf
WEnd
$Is_SearchLimit = True
ReturnHome(False, False)
getArmyCapacity(True, True)
$g_bRestart = True
$Is_ClientSyncError = True
Return True
Else
Return False
EndIf
EndFunc
Func WriteLogVillageSearch($x)
Local $MeetGxEtext = "", $MeetGorEtext = "", $MeetGplusEtext = "", $MeetDEtext = "", $MeetTrophytext = "", $MeetTHtext = "", $MeetTHOtext = "", $MeetWeakBasetext = "", $EnabledAftertext = ""
If $g_aiFilterMeetGE[$x] = 0 Then $MeetGxEtext = "- Meet: Gold and Elixir"
If $g_aiFilterMeetGE[$x] = 1 Then $MeetGorEtext = "- Meet: Gold or Elixir"
If $g_aiFilterMeetGE[$x] = 2 Then $MeetGplusEtext = "- Meet: Gold + Elixir"
If $g_abFilterMeetDEEnable[$x] Then $MeetDEtext = "- Dark"
If $g_abFilterMeetTrophyEnable[$x] Then $MeetTrophytext = "- Trophy"
If $g_abFilterMeetTH[$x] Then $MeetTHtext = "- Max TH " & $iMaxTH[$x]
If $g_abFilterMeetTHOutsideEnable[$x] Then $MeetTHOtext = "- TH Outside"
If IsWeakBaseActive($x) Then $MeetWeakBasetext = "- Weak Base"
If Not($Is_SearchLimit) And $g_iDebugSetlog = 1 Then
SetLog(_PadStringCenter(" Searching For " & $g_asModeText[$x] & " ", 54, "="), $COLOR_INFO)
Setlog("Enable " & $g_asModeText[$x] & " search IF ", $COLOR_INFO)
If $g_abSearchSearchesEnable[$x] Then Setlog("- Numbers of searches range " & $g_aiSearchSearchesMin[$x] & " - " & $g_aiSearchSearchesMax[$x], $COLOR_INFO)
If $g_abSearchTropiesEnable[$x] Then Setlog("- Search tropies range " & $g_aiSearchTrophiesMin[$x] & " - " & $g_aiSearchTrophiesMax[$x], $COLOR_INFO)
If $g_abSearchCampsEnable[$x] Then Setlog("- Army Camps % >  " & $g_aiSearchCampsPct[$x], $COLOR_INFO)
Setlog("Match " & $g_asModeText[$x] & "  village IF ", $COLOR_INFO)
If $MeetGxEtext <> "" Then Setlog($MeetGxEtext, $COLOR_INFO)
If $MeetGorEtext <> "" Then Setlog($MeetGorEtext, $COLOR_INFO)
If $MeetGplusEtext <> "" Then Setlog($MeetGplusEtext, $COLOR_INFO)
If $MeetDEtext <> "" Then Setlog($MeetDEtext, $COLOR_INFO)
If $MeetTrophytext <> "" Then Setlog($MeetTrophytext, $COLOR_INFO)
If $MeetTHtext <> "" Then Setlog($MeetTHtext, $COLOR_INFO)
If $MeetTHOtext <> "" Then Setlog($MeetTHOtext, $COLOR_INFO)
If $MeetWeakBasetext <> "" Then Setlog($MeetWeakBasetext, $COLOR_INFO)
If $g_abFilterMeetOneConditionEnable[$x] Then SetLog("Meet One and Attack!")
SetLog(_PadStringCenter(" RESOURCE CONDITIONS ", 50, "~"), $COLOR_INFO)
EndIf
If Not($Is_SearchLimit) Then
Local $txtTrophies = "", $txtTownhall = ""
If $g_abFilterMeetTrophyEnable[$x] Then $txtTrophies = " [T]:" & StringFormat("%2s", $iAimTrophy[$x])
If $g_abFilterMeetTH[$x] Then $txtTownhall = " [TH]:" & StringFormat("%2s", $iMaxTH[$x])
If $g_abFilterMeetTHOutsideEnable[$x] Then $txtTownhall &= ", Out"
If $g_aiFilterMeetGE[$x] = 2 Then
SetLog("Aim:           [G+E]:" & StringFormat("%7s", $iAimGoldPlusElixir[$x]) & " [D]:" & StringFormat("%5s", $iAimDark[$x]) & $txtTrophies & $txtTownhall & " for: " & $g_asModeText[$x], $COLOR_SUCCESS, "Lucida Console", 7.5)
Else
SetLog("Aim: [G]:" & StringFormat("%7s", $iAimGold[$x]) & " [E]:" & StringFormat("%7s", $iAimElixir[$x]) & " [D]:" & StringFormat("%5s", $iAimDark[$x]) & $txtTrophies & $txtTownhall & " for: " & $g_asModeText[$x], $COLOR_SUCCESS, "Lucida Console", 7.5)
EndIf
EndIf
EndFunc
Func DropTrophy()
If $iChkTrophyRange = 1 Then
If $g_iDebugSetlog = 1 Then SetLog("Drop Trophy START", $COLOR_DEBUG)
If $g_iDebugDeadBaseImage = 1 Then
DirCreate($g_sProfileTempDebugPath & "\SkippedZombies\")
DirCreate($g_sProfileTempDebugPath & "\Zombies\")
setZombie()
EndIf
$iTrophyCurrent = getTrophyMainScreen($aTrophies[0], $aTrophies[1])
If $g_iDebugSetlog = 1 Then SetLog("Current Trophy Count: " & $iTrophyCurrent, $COLOR_DEBUG)
If Number($iTrophyCurrent) <= Number($iTxtMaxTrophy) Then Return
Local $bHaveTroops = False
For $i = 0 To UBound($aDTtroopsToBeUsed, 1) - 1
If $aDTtroopsToBeUsed[$i][1] > 0 Then
$bDisableDropTrophy = False
$bHaveTroops = True
If $g_iDebugSetlog = 1 Then
SetLog("Drop Trophy Found " & StringFormat("%3s", $aDTtroopsToBeUsed[$i][1]) & " " & $aDTtroopsToBeUsed[$i][0], $COLOR_DEBUG)
ContinueLoop
Else
ExitLoop
EndIf
EndIf
Next
If $iChkTrophyHeroes = 1 And $iHeroAvailable > 0 Then
If $g_iDebugSetlog = 1 Then SetLog("Drop Trophy Found Hero BK|AQ|GW: " & BitOR($iHeroAvailable, $eHeroKing) & "|" & BitOR($iHeroAvailable, $eHeroQueen) & "|" & BitOR($iHeroAvailable, $eHeroWarden), $COLOR_DEBUG)
$bDisableDropTrophy = False
$bHaveTroops = True
EndIf
If $bDisableDropTrophy = True Or $bHaveTroops = False Then
Setlog("Drop Trophy temporarily disabled, missing proper troop type", $COLOR_ERROR)
If $g_iDebugSetlog = 1 Then SetLog("Drop Trophy END: No troops in $aDTtroopsToBeUsed array", $COLOR_DEBUG)
Return
EndIf
Local $bDropSuccessful
Local $iCount, $aRandomEdge, $iRandomXY
Local Const $DTArmyPercent = Round(Int($itxtDTArmyMin) / 100, 2)
Local $iTxtMaxTrophyNeedCheck = $iTxtMaxTrophy
Local Const $iWaitTime = 3
Local $iDateCalc, $sWaitToDate
$sWaitToDate = _DateAdd('n', $iWaitTime, _NowCalc())
If $g_iDebugSetlog = 1 Then SetLog("ChkBaseQuick delay time= " & $sWaitToDate & " Now= " & _NowCalc() & " Diff= " & _DateDiff('s', _NowCalc(), $sWaitToDate), $COLOR_DEBUG)
While Number($iTrophyCurrent) > Number($iTxtMaxTrophyNeedCheck)
$iTrophyCurrent = getTrophyMainScreen($aTrophies[0], $aTrophies[1])
SetLog("Trophy Count : " & $iTrophyCurrent, $COLOR_SUCCESS)
If Number($iTrophyCurrent) > Number($iTxtMaxTrophyNeedCheck) Then
Switch $iChkTrophyAtkDead
Case 1
If($CurCamp <=($TotalCamp * $DTArmyPercent)) Then
SetLog("Drop Trophy is waiting for " & $itxtDTArmyMin & "% full army to also attack Deadbases.", $COLOR_ACTION)
If $g_iDebugSetlog = 1 Then SetLog("Drop Trophy END: Drop Trophy + Dead Base skipped, army < " & $itxtDTArmyMin & "%.", $COLOR_DEBUG)
ExitLoop
EndIf
Case 0
If($CurCamp < 5) And($iChkTrophyHeroes = 1 And $iHeroAvailable = $eHeroNone) Then
SetLog("No troops available to use on Drop Trophy", $COLOR_ERROR)
If $g_iDebugSetlog = 1 Then SetLog("Drop Trophy END: Drop Trophy skipped, no army.", $COLOR_DEBUG)
ExitLoop
EndIf
EndSwitch
$iTxtMaxTrophyNeedCheck = $itxtdropTrophy
SetLog("Dropping Trophies to " & $itxtdropTrophy, $COLOR_INFO)
If _Sleep($iDelayDropTrophy4) Then ExitLoop
$bDropSuccessful = True
ZoomOut()
PrepareSearch()
If $OutOfGold = 1 Then Return
If $g_bRestart = True Then Return
If _Sleep($iDelayDropTrophy4) Then ExitLoop
If $iChkTrophyAtkDead = 1 Then
$iAimGold[$DB] = $g_aiFilterMinGold[$DB]
$iAimElixir[$DB] = $g_aiFilterMinElixir[$DB]
$iAimGoldPlusElixir[$DB] = $g_aiFilterMinGoldPlusElixir[$DB]
$SearchCount = 0
GetResources(False, $DT)
SetLog("Identification of your troops:", $COLOR_INFO)
PrepareAttack($DT)
If $g_bRestart = True Then Return
Local $G =(Number($searchGold) >= Number($iAimGold[$DB]))
Local $E =(Number($searchElixir) >= Number($iAimElixir[$DB]))
Local $GPE =((Number($searchElixir) + Number($searchGold)) >= Number($iAimGoldPlusElixir[$DB]))
If $G = True And $E = True And $GPE = True Then
SetLog("Found [G]:" & StringFormat("%7s", $searchGold) & " [E]:" & StringFormat("%7s", $searchElixir) & " [D]:" & StringFormat("%5s", $searchDark) & " [T]:" & StringFormat("%2s", $searchTrophy), $COLOR_BLACK, "Lucida Console", 7.5)
If $g_iDebugDeadBaseImage = 1 Then setZombie()
ForceCaptureRegion()
_CaptureRegion2()
If checkDeadBase() Then
SetLog("      " & "Dead Base Found on Drop Trophy!", $COLOR_SUCCESS, "Lucida Console", 7.5)
Attack()
$g_bFirstStart = True
ReturnHome($TakeLootSnapShot)
$Is_ClientSyncError = False
$Is_SearchLimit = False
$g_bRestart = True
If $g_iDebugSetlog = 1 Then SetLog("Drop Trophy END: Dead Base was attacked, reset army and return to Village.", $COLOR_DEBUG)
ExitLoop
Else
SetLog("      " & "Not a Dead Base, resuming Drop Trophy.", $COLOR_BLACK, "Lucida Console", 7.5)
EndIf
EndIf
Else
$SearchCount = 0
GetResources(False, $DT)
SetLog("Identification of your troops:", $COLOR_INFO)
PrepareAttack($DT)
If $g_bRestart = True Then Return
EndIf
If _Sleep($iDelayDropTrophy4) Then ExitLoop
If $iChkTrophyHeroes = 1 Then
$King = -1
$Queen = -1
$Warden = -1
For $i = 0 To UBound($atkTroops) - 1
If $atkTroops[$i][0] = $eKing Then
$King = $i
ElseIf $atkTroops[$i][0] = $eQueen Then
$Queen = $i
ElseIf $atkTroops[$i][0] = $eWarden Then
$Warden = $i
EndIf
Next
$aRandomEdge = $Edges[Round(Random(0, 3))]
$iRandomXY = Round(Random(0, 4))
If $g_iDebugSetlog = 1 Then Setlog("Hero Loc = " & $iRandomXY & ", X:Y= " & $aRandomEdge[$iRandomXY][0] & "|" & $aRandomEdge[$iRandomXY][1], $COLOR_DEBUG)
If($Queen <> -1 or $King <> -1 Or $Warden <> -1) Then
Local $DropHeroPriority
If $iCmbTrophyHeroesPriority = 0 Then $DropHeroPriority = "QKW"
If $iCmbTrophyHeroesPriority = 1 Then $DropHeroPriority = "QWK"
If $iCmbTrophyHeroesPriority = 2 Then $DropHeroPriority = "KQW"
If $iCmbTrophyHeroesPriority = 3 Then $DropHeroPriority = "KWQ"
If $iCmbTrophyHeroesPriority = 4 Then $DropHeroPriority = "WKQ"
If $iCmbTrophyHeroesPriority = 5 Then $DropHeroPriority = "WQK"
Local $t
For $i = 1 to 3
$t = StringMid($DropHeroPriority, $i, 1)
Switch $t
Case "Q"
If $Queen <> -1 Then
SetTrophyLoss()
SetLog("Deploying Queen", $COLOR_INFO)
Click(GetXPosOfArmySlot($Queen, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0179")
If _Sleep($iDelayDropTrophy1) Then ExitLoop
Click($aRandomEdge[$iRandomXY][0], $aRandomEdge[$iRandomXY][1], 1, 0, "#0180")
If _Sleep($iDelayDropTrophy4) Then ExitLoop
If IsAttackPage() Then SelectDropTroop($Queen)
ReturnHome(False, False)
If _Sleep($iDelayDropTrophy1) Then ExitLoop
ExitLoop
EndIf
Case "K"
If $King <> -1 Then
SetTrophyLoss()
SetLog("Deploying King", $COLOR_INFO)
Click(GetXPosOfArmySlot($King, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0177")
If _Sleep($iDelayDropTrophy1) Then ExitLoop
Click($aRandomEdge[$iRandomXY][0], $aRandomEdge[$iRandomXY][1], 1, 0, "#0178")
If _Sleep($iDelayDropTrophy4) Then ExitLoop
If IsAttackPage() Then SelectDropTroop($King)
ReturnHome(False, False)
If _Sleep($iDelayDropTrophy1) Then ExitLoop
ExitLoop
EndIf
Case "W"
If $Warden <> -1 Then
SetTrophyLoss()
SetLog("Deploying Warden", $COLOR_INFO)
Click(GetXPosOfArmySlot($Warden, 68), 595 + $g_iBottomOffsetY, 1, 0, "#0000")
If _Sleep($iDelayDropTrophy1) Then ExitLoop
Click($aRandomEdge[$iRandomXY][0], $aRandomEdge[$iRandomXY][1], 1, 0, "#0000")
If _Sleep($iDelayDropTrophy4) Then ExitLoop
If IsAttackPage() Then SelectDropTroop($Warden)
ReturnHome(False, False)
If _Sleep($iDelayDropTrophy1) Then ExitLoop
ExitLoop
EndIf
EndSwitch
Next
EndIf
EndIf
If($Queen = -1 And $King = -1 And $Warden = -1) Or $iChkTrophyHeroes = 0 Then
$aRandomEdge = $Edges[Round(Random(0, 3))]
$iRandomXY = Round(Random(0, 4))
If $g_iDebugSetlog = 1 Then Setlog("Troop Loc = " & $iRandomXY & ", X:Y= " & $aRandomEdge[$iRandomXY][0] & "|" & $aRandomEdge[$iRandomXY][1], $COLOR_DEBUG)
Select
Case $atkTroops[0][0] = $eBarb
Click($aRandomEdge[$iRandomXY][0], $aRandomEdge[$iRandomXY][1], 1, 0, "#0181")
$g_aiCurrentTroops[$eTroopBarbarian] += 1
$ArmyComp -= 1
SetLog("Deploying 1 Barbarian", $COLOR_INFO)
Case $atkTroops[0][0] = $eArch
Click($aRandomEdge[$iRandomXY][0], $aRandomEdge[$iRandomXY][1], 1, 0, "#0182")
$g_aiCurrentTroops[$eTroopArcher] += 1
$ArmyComp -= 1
SetLog("Deploying 1 Archer", $COLOR_INFO)
Case $atkTroops[0][0] = $eGiant
Click($aRandomEdge[$iRandomXY][0], $aRandomEdge[$iRandomXY][1], 1, 0, "#0183")
$g_aiCurrentTroops[$eTroopGiant] += 1
$ArmyComp -= 5
SetLog("Deploying 1 Giant", $COLOR_INFO)
Case $atkTroops[0][0] = $eWall
Click($aRandomEdge[$iRandomXY][0], $aRandomEdge[$iRandomXY][1], 1, 0, "#0184")
$g_aiCurrentTroops[$eTroopWallBreaker] += 1
$ArmyComp -= 2
SetLog("Deploying 1 WallBreaker", $COLOR_INFO)
Case $atkTroops[0][0] = $eGobl
Click($aRandomEdge[$iRandomXY][0], $aRandomEdge[$iRandomXY][1], 1, 0, "#0185")
$g_aiCurrentTroops[$eTroopGoblin] += 1
$ArmyComp -= 2
SetLog("Deploying 1 Goblin", $COLOR_INFO)
Case $atkTroops[0][0] = $eMini
Click($aRandomEdge[$iRandomXY][0], $aRandomEdge[$iRandomXY][1], 1, 0, "#0186")
$g_aiCurrentTroops[$eTroopMinion] += 1
$ArmyComp -= 2
SetLog("Deploying 1 Minion", $COLOR_INFO)
Case Else
SetLog("You don?t have Tier 1/2 Troops, Stop dropping trophies.", $COLOR_INFO)
$bDisableDropTrophy = True
$bDropSuccessful = False
ExitLoop
EndSelect
If $bDropSuccessful Then SetTrophyLoss()
If _Sleep($iDelayDropTrophy1) Then ExitLoop
ReturnHome(False, False)
If _Sleep($iDelayDropTrophy1) Then ExitLoop
EndIf
$iDateCalc = _DateDiff('s', _NowCalc(), $sWaitToDate)
If $g_iDebugSetlog = 1 Then SetLog("ChkBaseQuick delay= " & $sWaitToDate & " Now= " & _NowCalc() & " Diff= " & $iDateCalc, $COLOR_DEBUG)
If $iDateCalc <= 0 Then
Setlog(" Checking base during long drop cycle", $COLOR_INFO)
CheckBaseQuick()
$sWaitToDate = _DateAdd('n', $iWaitTime, _NowCalc())
If $g_iDebugSetlog = 1 Then SetLog("ChkBaseQuick new delay time= " & $sWaitToDate, $COLOR_DEBUG)
EndIf
Else
SetLog("Trophy Drop Complete", $COLOR_INFO)
EndIf
WEnd
If $g_iDebugSetlog = 1 Then SetLog("Drop Trophy END", $COLOR_DEBUG)
Else
If $g_iDebugSetlog = 1 Then SetLog("Drop Trophy SKIP", $COLOR_DEBUG)
EndIf
EndFunc
Func SetTrophyLoss()
Local $sTrophyLoss
If _ColorCheck(_GetPixelColor(33, 148, True), Hex(0x000000, 6), 10) or _ColorCheck(_GetPixelColor(31, 144, True), Hex(0x282020, 6), 5) Then
$sTrophyLoss = getTrophyLossAttackScreen(48, 214)
Else
$sTrophyLoss = getTrophyLossAttackScreen(48, 184)
EndIf
Setlog(" Trophy loss = " & $sTrophyLoss, $COLOR_DEBUG)
$g_iDroppedTrophyCount[$CurrentAccount] -= Number($sTrophyLoss)
UpdateStats()
EndFunc
Func UpgradeWall()
If $g_bAutoUpgradeWallsEnable = True Then
SetLog("Checking Upgrade Walls", $COLOR_INFO)
If SkipWallUpgrade() Then Return
If $iFreeBuilderCount > 0 Then
ClickP($aAway, 1, 0, "#0313")
Local $MinWallGold = Number($iGoldCurrent - $g_iWallCost) > Number($g_iUpgradeWallMinGold)
Local $MinWallElixir = Number($iElixirCurrent - $g_iWallCost) > Number($g_iUpgradeWallMinElixir)
Switch $g_iUpgradeWallLootType
Case 0
If $MinWallGold Then
SetLog("Upgrading Wall using Gold", $COLOR_SUCCESS)
If imglocCheckWall() Then UpgradeWallGold()
Else
SetLog("Gold is below minimum, Skipping Upgrade", $COLOR_ERROR)
EndIf
Case 1
If $MinWallElixir Then
Setlog("Upgrading Wall using Elixir", $COLOR_SUCCESS)
If imglocCheckWall() Then UpgradeWallElixir()
Else
Setlog("Elixir is below minimum, Skipping Upgrade", $COLOR_ERROR)
EndIf
Case 2
If $MinWallElixir Then
SetLog("Upgrading Wall using Elixir", $COLOR_SUCCESS)
If imglocCheckWall() And Not UpgradeWallElixir() Then
SetLog("Upgrade with Elixir failed, attempt to upgrade using Gold", $COLOR_ERROR)
UpgradeWallGold()
EndIf
Else
SetLog("Elixir is below minimum, attempt to upgrade using Gold", $COLOR_ERROR)
If $MinWallGold Then
If imglocCheckWall() Then UpgradeWallGold()
Else
Setlog("Gold is below minimum, Skipping Upgrade", $COLOR_ERROR)
EndIf
EndIf
EndSwitch
If _CheckPixel($g_aShopWindowOpen, $g_bCapturePixel, Default, "ChkShopOpen", $COLOR_DEBUG) = True Then
Click(820, 40, 1, 0, "#0315")
EndIf
ClickP($aAway, 1, 0, "#0314")
If _Sleep(100) Then Return
Else
SetLog("No free builder, Upgrade Walls skipped..", $COLOR_ERROR)
EndIf
EndIf
If _Sleep($iDelayUpgradeWall1) Then Return
checkMainScreen(False)
EndFunc
Func UpgradeWallGold()
If _Sleep($iDelayRespond) Then Return
Local $offColors[3][3] = [[0xD6714B, 47, 37], [0xF0E850, 70, 0], [0xF4F8F2, 79, 0]]
Global $ButtonPixel = _MultiPixelSearch(240, 563 + $g_iBottomOffsetY, 670, 650 + $g_iBottomOffsetY, 1, 1, Hex(0xF3F3F1, 6), $offColors, 30)
If IsArray($ButtonPixel) Then
If $g_iDebugSetlog = 1 Then
Setlog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("Color #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 47, $ButtonPixel[1] + 37, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 70, $ButtonPixel[1], True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 79, $ButtonPixel[1], True), $COLOR_DEBUG)
EndIf
Click($ButtonPixel[0] + 20, $ButtonPixel[1] + 20, 1, 0, "#0316")
If _Sleep($iDelayUpgradeWallGold2) Then Return
If _ColorCheck(_GetPixelColor(677, 150 + $g_iMidOffsetY, True), Hex(0xE1090E, 6), 20) Then
If isNoUpgradeLoot(False) = True Then
SetLog("Upgrade stopped due no loot", $COLOR_ERROR)
Return False
EndIf
Click(440, 480 + $g_imidOffsetY, 1, 0, "#0317")
If _Sleep(1000) Then Return
If isGemOpen(True) Then
ClickP($aAway, 1, 0, "#0314")
SetLog("Upgrade stopped due no loot", $COLOR_ERROR)
Return False
Else
If _Sleep($iDelayUpgradeWallGold3) Then Return
SetLog("Upgrade complete", $COLOR_SUCCESS)
PushMsg("UpgradeWithGold")
$g_iNbrOfWallsUppedGold[$CurrentAccount] += 1
$iNbrOfWallsUpped += 1
$g_iCostGoldWall[$CurrentAccount] += $g_iWallCost
UpdateStats()
Return True
EndIf
EndIf
Else
Setlog("No Upgrade Gold Button", $COLOR_ERROR)
Pushmsg("NowUpgradeGoldButton")
Return False
EndIf
EndFunc
Func UpgradeWallElixir()
If _Sleep($iDelayRespond) Then Return
Local $offColors[3][3] = [[0xBC5B31, 38, 32], [0xF84CF9, 72, 0], [0xF5F9F2, 79, 0]]
Global $ButtonPixel = _MultiPixelSearch(240, 563 + $g_iBottomOffsetY, 670, 650 + $g_iBottomOffsetY, 1, 1, Hex(0xF4F7F2, 6), $offColors, 30)
If IsArray($ButtonPixel) Then
Click($ButtonPixel[0] + 20, $ButtonPixel[1] + 20, 1, 0, "#0322")
If _Sleep($iDelayUpgradeWallElixir2) Then Return
If _ColorCheck(_GetPixelColor(677, 150 + $g_iMidOffsetY, True), Hex(0xE1090E, 6), 20) Then
If isNoUpgradeLoot(False) = True Then
SetLog("Upgrade stopped due to insufficient loot", $COLOR_ERROR)
Return False
EndIf
Click(440, 480 + $g_imidOffsetY, 1, 0, "#0317")
If _Sleep(1000) Then Return
If isGemOpen(True) Then
ClickP($aAway, 1, 0, "#0314")
SetLog("Upgrade stopped due to insufficient loot", $COLOR_ERROR)
Return False
Else
If _Sleep($iDelayUpgradeWallElixir3) Then Return
SetLog("Upgrade complete", $COLOR_SUCCESS)
PushMsg("UpgradeWithElixir")
$g_iNbrOfWallsUppedElixir[$CurrentAccount] += 1
$iNbrOfWallsUpped += 1
$g_iCostElixirWall[$CurrentAccount] += $g_iWallCost
UpdateStats()
Return True
EndIf
EndIf
Else
Setlog("No Upgrade Elixir Button", $COLOR_ERROR)
Pushmsg("NowUpgradeElixirButton")
Return False
EndIf
EndFunc
Func SkipWallUpgrade()
InireadS($g_iUpgradeWallLootType, $g_sProfileConfigPath, "upgrade", "use-storage", "0")
Local $iUpgradeAction = 0
Local $iBuildingsNeedGold = 0
Local $iBuildingsNeedElixir = 0
Local $iAvailBuilderCount = 0
If getBuilderCount() = False Then Return True
If _Sleep($iDelayRespond) Then Return True
$iAvailBuilderCount = $iFreeBuilderCount
For $iz = 0 To UBound($g_avBuildingUpgrades, 1) - 1
If $g_abBuildingUpgradeEnable[$iz] = True Then $iUpgradeAction += 1
Next
If $iFreeBuilderCount >($g_bUpgradeWallSaveBuilder ? 1 : 0) And $iUpgradeAction > 0 Then
For $iz = 0 To UBound($g_avBuildingUpgrades, 1) - 1
If $iAvailBuilderCount >($g_bUpgradeWallSaveBuilder ? 1 : 0) And $g_abBuildingUpgradeEnable[$iz] = True And($g_avBuildingUpgrades[$iz][7] = "" And $g_abUpgradeRepeatEnable[$iz]) Then
Switch $g_avBuildingUpgrades[$iz][3]
Case "Gold"
$iBuildingsNeedGold += Number($g_avBuildingUpgrades[$iz][2])
$iAvailBuilderCount -= 1
Case "Elixir"
$iBuildingsNeedElixir += Number($g_avBuildingUpgrades[$iz][2])
$iAvailBuilderCount -= 1
EndSwitch
EndIf
Next
SetLog("SkipWall-Upgrade Summary: G:" & $iBuildingsNeedGold & ", E:" & $iBuildingsNeedElixir & ", Wall: " & $g_iWallCost & ", MinG: " & $g_iUpgradeWallMinGold & ", MinE: " & $g_iUpgradeWallMinElixir)
If $iBuildingsNeedGold > 0 Or $iBuildingsNeedElixir > 0 Then
Switch $g_iUpgradeWallLootType
Case 0
If $iGoldCurrent -($iBuildingsNeedGold + $g_iWallCost + Number($g_iUpgradeWallMinGold)) < 0 Then
SetLog("Skip Wall upgrade -insufficient gold for selected upgrades", $COLOR_WARNING)
Return True
EndIf
Case 1
If $iElixirCurrent -($iBuildingsNeedElixir + $g_iWallCost + Number($g_iUpgradeWallMinElixir)) < 0 Then
SetLog("Skip Wall upgrade - insufficient elixir for selected upgrades", $COLOR_WARNING)
Return True
EndIf
Case 2
If $iGoldCurrent -($iBuildingsNeedGold + $g_iWallCost + Number($g_iUpgradeWallMinGold)) < 0 Then
SetLog("Wall upgrade: insufficient gold for selected upgrades", $COLOR_WARNING)
If $iElixirCurrent -($iBuildingsNeedElixir + $g_iWallCost + Number($g_iUpgradeWallMinElixir)) >= 0 Then
Setlog("Using Elixir only for wall Upgrade", $COLOR_SUCCESS1)
$g_iUpgradeWallLootType = 1
Else
SetLog("Skip Wall upgrade -insufficient resources for selected upgrades", $COLOR_WARNING)
Return True
EndIf
EndIf
If $iElixirCurrent -($iBuildingsNeedElixir + $g_iWallCost + Number($g_iUpgradeWallMinElixir)) < 0 Then
SetLog("Wall upgrade: insufficient elixir for selected upgrades", $COLOR_WARNING)
If $iGoldCurrent -($iBuildingsNeedGold + $g_iWallCost + Number($g_iUpgradeWallMinGold)) >= 0 Then
Setlog("Using Gold only for wall Upgrade", $COLOR_SUCCESS1)
$g_iUpgradeWallLootType = 0
Else
SetLog("Skip Wall upgrade -insufficient resources for selected upgrades", $COLOR_WARNING)
Return True
EndIf
EndIf
EndSwitch
EndIf
If _Sleep($iDelayRespond) Then Return True
EndIf
Local $bMinWallElixir = Number($iElixirCurrent) >($g_iWallCost + Number($iLaboratoryElixirCost) + Number($g_iUpgradeWallMinElixir))
If $g_bAutoLabUpgradeEnable = True And $g_iCmbLaboratory >= 1 And $g_iCmbLaboratory <= 18 And $bMinWallElixir = False Then
For $i = 1 To 18
If $g_iCmbLaboratory = $i Then
Local $sName = $aLabTroops[$i][3]
ExitLoop
EndIf
Next
Local $LabElixirNeeded = $iLaboratoryElixirCost
If $LabElixirNeeded = 0 Then $LabElixirNeeded = "unknown"
Switch $g_iUpgradeWallLootType
Case 0
Case 1
Setlog("Laboratory needs " & $LabElixirNeeded & " Elixir to Upgrade:  " & $sName, $COLOR_SUCCESS1)
Setlog("Skipping Wall Upgrade", $COLOR_SUCCESS1)
Return True
Case 2
Setlog("Laboratory needs " & $LabElixirNeeded & " Elixir to Upgrade:  " & $sName, $COLOR_SUCCESS1)
Setlog("Using Gold only for wall Upgrade  ", $COLOR_SUCCESS1)
$g_iUpgradeWallLootType = 0
EndSwitch
EndIf
EndFunc
Global $itxtUpgradeLevel[$g_iUpgradeSlots] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Func UpgradeBuilding()
Local $iz = 0
Local $iUpgradeAction = -1
Local $iAvailBldr, $iAvailGold, $iAvailElixir, $iAvailDark
Local $iUpGrdEndTimeDiff = 0
Local $aCheckFrequency[9] = [5, 15, 20, 30, 60, 60, 120, 240, 240]
Local $iDTDiff
Local $bChkAllRptUpgrade = False
Local $sTime
Static Local $sNextCheckTime = _DateAdd("n", -1, _NowCalc())
If @error Then _logErrorDateAdd(@error)
$g_iUpgradeMinGold = Number($g_iUpgradeMinGold)
$g_iUpgradeMinElixir = Number($g_iUpgradeMinElixir)
$g_iUpgradeMinDark = Number($g_iUpgradeMinDark)
For $iz = 0 To UBound($g_avBuildingUpgrades, 1) - 1
If $g_abBuildingUpgradeEnable[$iz] = True Then
$iUpgradeAction += 2 ^($iz + 1)
EndIf
Next
If $iUpgradeAction < 0 Then Return False
$iUpgradeAction = 0
Setlog("Checking Upgrades", $COLOR_INFO)
VillageReport(True, True)
$iAvailGold = Number($iGoldCurrent)
$iAvailElixir = Number($iElixirCurrent)
$iAvailDark = Number($iDarkCurrent)
$iAvailBldr = $iFreeBuilderCount -($g_bUpgradeWallSaveBuilder = True ? 1 : 0)
If $iAvailBldr <= 0 Then
Setlog("No builder available for upgrade process", $COLOR_ERROR)
Return False
EndIf
For $iz = 0 To UBound($g_avBuildingUpgrades, 1) - 1
If $g_iDebugSetlog = 1 Then SetlogUpgradeValues($iz)
If $g_abBuildingUpgradeEnable[$iz] = False Then ContinueLoop
If $g_avBuildingUpgrades[$iz][0] <= 0 Or $g_avBuildingUpgrades[$iz][1] <= 0 Or $g_avBuildingUpgrades[$iz][3] = "" Then ContinueLoop
If $iAvailBldr <= 0 And $bChkAllRptUpgrade = False Then
Setlog("No builder available for #" & $iz + 1 & ", " & $g_avBuildingUpgrades[$iz][4], $COLOR_ERROR)
Return False
EndIf
If $g_abUpgradeRepeatEnable[$iz] = True Then
If $bChkAllRptUpgrade = False Then
$iDTDiff = Int(_DateDiff("n", _NowCalc(), $sNextCheckTime))
If @error Then _logErrorDateDiff(@error)
If $g_iDebugSetlog = 1 Then
Setlog("Delay time between repeat upgrade checks = " & $aCheckFrequency[($iTownHallLevel < 3 ? 0 : $iTownHallLevel - 3)] & " Min", $COLOR_DEBUG)
SetLog("Delay time remaining = " & $iDTDiff & " Min", $COLOR_DEBUG)
EndIf
If $iDTDiff < 0 Then
$sNextCheckTime = _DateAdd("n", $aCheckFrequency[($iTownHallLevel < 3 ? 0 : $iTownHallLevel - 3)], _NowCalc())
If @error Then _logErrorDateAdd(@error)
$bChkAllRptUpgrade = True
If $g_iDebugSetlog = 1 Then SetLog("New delayed check time=  " & $sNextCheckTime, $COLOR_DEBUG)
EndIf
EndIf
If _DateIsValid($g_avBuildingUpgrades[$iz][7]) Then
$iUpGrdEndTimeDiff = Int(_DateDiff("n", _NowCalc(), $g_avBuildingUpgrades[$iz][7]))
If @error Then
_logErrorDateDiff(@error)
$iUpGrdEndTimeDiff = 0
EndIf
If $g_iDebugSetlog = 1 Then SetLog("Difference between upgrade end and NOW= " & $iUpGrdEndTimeDiff & " Min", $COLOR_DEBUG)
EndIf
If $bChkAllRptUpgrade = True Or $iUpGrdEndTimeDiff < 0 Then
If UpgradeValue($iz, True) = False Then
If $g_iDebugSetlog = 1 Then SetlogUpgradeValues($iz)
Setlog("Repeat upgrade #" & $iz + 1 & " " & $g_avBuildingUpgrades[$iz][4] & " not ready yet", $COLOR_ERROR)
ContinueLoop
ElseIf($iAvailBldr <= 0) Then
Setlog("No builder available for " & $g_avBuildingUpgrades[$iz][4], $COLOR_ERROR)
ContinueLoop
EndIf
EndIf
EndIf
SetLog("Upgrade #" & $iz + 1 & " " & $g_avBuildingUpgrades[$iz][4] & " Selected", $COLOR_SUCCESS)
If $g_iDebugSetlog = 1 Then SetLog("-Upgrade location =  " & "(" & $g_avBuildingUpgrades[$iz][0] & "," & $g_avBuildingUpgrades[$iz][1] & ")", $COLOR_DEBUG)
If _Sleep($iDelayUpgradeBuilding1) Then Return
Switch $g_avBuildingUpgrades[$iz][3]
Case "Gold"
If $iAvailGold < $g_avBuildingUpgrades[$iz][2] + $g_iUpgradeMinGold Then
SetLog("Insufficent Gold for #" & $iz + 1 & ", requires: " & $g_avBuildingUpgrades[$iz][2] & " + " & $g_iUpgradeMinGold, $COLOR_INFO)
ContinueLoop
EndIf
If UpgradeNormal($iz) = False Then ContinueLoop
$iUpgradeAction += 2 ^($iz + 1)
Setlog("Gold used = " & $g_avBuildingUpgrades[$iz][2], $COLOR_INFO)
$g_iNbrOfBuildingsUppedGold[$CurrentAccount] += 1
$g_iCostGoldBuilding[$CurrentAccount] += $g_avBuildingUpgrades[$iz][2]
UpdateStats()
$iAvailGold -= $g_avBuildingUpgrades[$iz][2]
$iAvailBldr -= 1
Case "Elixir"
If $iAvailElixir < $g_avBuildingUpgrades[$iz][2] + $g_iUpgradeMinElixir Then
SetLog("Insufficent Elixir for #" & $iz + 1 & ", requires: " & $g_avBuildingUpgrades[$iz][2] & " + " & $g_iUpgradeMinElixir, $COLOR_INFO)
ContinueLoop
EndIf
If UpgradeNormal($iz) = False Then ContinueLoop
$iUpgradeAction += 2 ^($iz + 1)
Setlog("Elixir used = " & $g_avBuildingUpgrades[$iz][2], $COLOR_INFO)
$g_iNbrOfBuildingsUppedElixir[$CurrentAccount] += 1
$g_iCostElixirBuilding[$CurrentAccount] += $g_avBuildingUpgrades[$iz][2]
UpdateStats()
$iAvailElixir -= $g_avBuildingUpgrades[$iz][2]
$iAvailBldr -= 1
Case "Dark"
If $iAvailDark < $g_avBuildingUpgrades[$iz][2] + $g_iUpgradeMinDark Then
SetLog("Insufficent Dark for #" & $iz + 1 & ", requires: " & $g_avBuildingUpgrades[$iz][2] & " + " & $g_iUpgradeMinDark, $COLOR_INFO)
ContinueLoop
EndIf
If UpgradeHero($iz) = False Then ContinueLoop
$iUpgradeAction += 2 ^($iz + 1)
Setlog("Dark Elixir used = " & $g_avBuildingUpgrades[$iz][2], $COLOR_INFO)
$g_iNbrOfHeroesUpped[$CurrentAccount] += 1
$g_iCostDElixirHero[$CurrentAccount] += $g_avBuildingUpgrades[$iz][2]
UpdateStats()
$iAvailDark -= $g_avBuildingUpgrades[$iz][2]
$iAvailBldr -= 1
Case Else
Setlog("Something went wrong with loot type on Upgradebuilding module on #" & $iz + 1, $COLOR_ERROR)
ExitLoop
EndSwitch
$g_avBuildingUpgrades[$iz][7] = _NowCalc()
If $g_iDebugSetlog = 1 Then SetLog("Upgrade #" & $iz + 1 & " " & $g_avBuildingUpgrades[$iz][4] & " Started @ " & $g_avBuildingUpgrades[$iz][7], $COLOR_SUCCESS)
Local $aArray = StringSplit($g_avBuildingUpgrades[$iz][6], ' ', BitOR($STR_CHRSPLIT, $STR_NOCOUNT))
If IsArray($aArray) Then
Local $iRemainingTimeMin = 0
For $i = 0 To UBound($aArray) - 1
$sTime = ""
Select
Case StringInStr($aArray[$i], "d", $STR_NOCASESENSEBASIC) > 0
$sTime = StringTrimRight($aArray[$i], 1)
$iRemainingTimeMin +=(Int($sTime) * 24 * 60) - 7
Case StringInStr($aArray[$i], "h", $STR_NOCASESENSEBASIC) > 0
$sTime = StringTrimRight($aArray[$i], 1)
$iRemainingTimeMin +=(Int($sTime) * 60) - 3
Case StringInStr($aArray[$i], "m", $STR_NOCASESENSEBASIC) > 0
$sTime = StringTrimRight($aArray[$i], 1)
$iRemainingTimeMin += Int($sTime)
Case Else
Setlog("Upgrade #" & $iz + 1 & " OCR time invalid" & $aArray[$i], $COLOR_WARNING)
EndSelect
If $g_iDebugSetlog = 1 Then Setlog("Upgrade Time: " & $aArray[$i] & ", Minutes= " & $iRemainingTimeMin, $COLOR_DEBUG)
Next
$g_avBuildingUpgrades[$iz][7] = _DateAdd('n', Floor($iRemainingTimeMin), _NowCalc())
If @error Then _logErrorDateAdd(@error)
SetLog("Upgrade #" & $iz + 1 & " " & $g_avBuildingUpgrades[$iz][4] & " Finishes @ " & $g_avBuildingUpgrades[$iz][7], $COLOR_SUCCESS)
GUICtrlSetData($g_hTxtUpgradeEndTime[$iz], $g_avBuildingUpgrades[$iz][7])
Else
Setlog("Non critical error processing upgrade time for " & "#" & $iz + 1 & ": " & $g_avBuildingUpgrades[$iz][4], $COLOR_WARNING)
EndIf
Next
If $iUpgradeAction <= 0 Then
Setlog("No Upgrades Available", $COLOR_SUCCESS)
Else
saveConfig()
EndIf
If _Sleep($iDelayUpgradeBuilding2) Then Return
checkMainScreen(False)
Return $iUpgradeAction
EndFunc
Func UpgradeNormal($inum)
Local $aResult
ClickP($aAway, 1, 0, "#0211")
If _Sleep($iDelayUpgradeNormal1) Then Return
BuildingClick($g_avBuildingUpgrades[$inum][0], $g_avBuildingUpgrades[$inum][1], "#0296")
If _Sleep($iDelayUpgradeNormal1) Then Return
$aResult = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If StringStripWS($aResult[1], BitOR($STR_STRIPLEADING, $STR_STRIPTRAILING)) <> StringStripWS($g_avBuildingUpgrades[$inum][4], BitOR($STR_STRIPLEADING, $STR_STRIPTRAILING)) Then
SetLog("#" & $inum + 1 & ":" & $g_avBuildingUpgrades[$inum][4] & ": Not same as :" & $aResult[1] & ":? Retry now...", $COLOR_INFO)
ClickP($aAway, 1, 0, "#0211")
If _Sleep($iDelayUpgradeNormal1) Then Return
BuildingClick($g_avBuildingUpgrades[$inum][0], $g_avBuildingUpgrades[$inum][1], "#0296")
If _Sleep($iDelayUpgradeNormal1) Then Return
$aResult = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If $aResult[0] > 1 Then
If StringStripWS($aResult[1], BitOR($STR_STRIPLEADING, $STR_STRIPTRAILING)) <> StringStripWS($g_avBuildingUpgrades[$inum][4], BitOR($STR_STRIPLEADING, $STR_STRIPTRAILING)) Then
SetLog("Found #" & $inum + 1 & ":" & $g_avBuildingUpgrades[$inum][4] & ": Not same as : " & $aResult[1] & ":, May need new location?", $COLOR_ERROR)
Return False
EndIf
EndIf
EndIf
If $g_avBuildingUpgrades[$inum][3] = "Gold" Then
Local $offColors[3][3] = [[0xD6714B, 47, 37], [0xF0E850, 70, 0], [0xF4F8F2, 79, 0]]
Global $ButtonPixel = _MultiPixelSearch(240, 563 + $g_iBottomOffsetY, 670, 650 + $g_iBottomOffsetY, 1, 1, Hex(0xF3F3F1, 6), $offColors, 30)
If $g_iDebugSetlog = 1 And IsArray($ButtonPixel) Then
Setlog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("Color #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 47, $ButtonPixel[1] + 37, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 70, $ButtonPixel[1], True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 79, $ButtonPixel[1], True), $COLOR_DEBUG)
EndIf
Else
Local $offColors[3][3] = [[0xBC5B31, 38, 32], [0xF84CF9, 72, 0], [0xF5F9F2, 79, 0]]
Global $ButtonPixel = _MultiPixelSearch(240, 563 + $g_iBottomOffsetY, 670, 650 + $g_iBottomOffsetY, 1, 1, Hex(0xF4F7F2, 6), $offColors, 30)
If $g_iDebugSetlog = 1 And IsArray($ButtonPixel) Then
Setlog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("Color #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 38, $ButtonPixel[1] + 32, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 72, $ButtonPixel[1], True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 79, $ButtonPixel[1], True), $COLOR_DEBUG)
EndIf
EndIf
If IsArray($ButtonPixel) Then
If _Sleep($iDelayUpgradeNormal2) Then Return
Click($ButtonPixel[0] + 20, $ButtonPixel[1] + 20, 1, 0, "#0297")
If _Sleep($iDelayUpgradeNormal3) Then Return
If $g_iDebugImageSave = 1 Then DebugImageSave("UpgradeRegBtn1")
If _ColorCheck(_GetPixelColor(677, 150 + $g_iMidOffsetY, True), Hex(0xE00408, 6), 20) Then
If _ColorCheck(_GetPixelColor(459, 490 + $g_iMidOffsetY, True), Hex(0xE70A12, 6), 20) And _ColorCheck(_GetPixelColor(459, 494 + $g_iMidOffsetY), Hex(0xE70A12, 6), 20) And  _ColorCheck(_GetPixelColor(459, 498 + $g_iMidOffsetY, True), Hex(0xE70A12, 6), 20) Then
SetLog("Upgrade Fail #" & $inum + 1 & " " & $g_avBuildingUpgrades[$inum][4] & ", No Loot!", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0298")
Return False
Else
Click(440, 480 + $g_iMidOffsetY, 1, 0, "#0299")
If _Sleep($iDelayUpgradeNormal3) Then Return
If $g_iDebugImageSave = 1 Then DebugImageSave("UpgradeRegBtn2")
If _ColorCheck(_GetPixelColor(573, 256 + $g_iMidOffsetY, True), Hex(0xE1090E, 6), 20) Then
SetLog("Upgrade Fail #" & $inum + 1 & " " & $g_avBuildingUpgrades[$inum][4] & " No Loot!", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0300")
Return False
EndIf
SetLog("Upgrade #" & $inum + 1 & " " & $g_avBuildingUpgrades[$inum][4] & " started", $COLOR_SUCCESS)
GUICtrlSetImage($g_hPicUpgradeStatus[$inum], $g_sLibIconPath, $eIcnGreenLight)
$g_aiPicUpgradeStatus[$inum] = $eIcnGreenLight
GUICtrlSetData($g_hTxtUpgradeValue[$inum], -($g_avBuildingUpgrades[$inum][2]))
GUICtrlSetData($g_hTxtUpgradeLevel[$inum], $g_avBuildingUpgrades[$inum][5] & "+")
$itxtUpgradeLevel[$inum] = $g_avBuildingUpgrades[$inum][5] & "+"
If $g_abUpgradeRepeatEnable[$inum] = False Then
GUICtrlSetState($g_hChkUpgrade[$inum], $GUI_UNCHECKED)
$g_abBuildingUpgradeEnable[$inum] = False
$g_avBuildingUpgrades[$inum][0] = -1
$g_avBuildingUpgrades[$inum][1] = -1
$g_avBuildingUpgrades[$inum][3] = ""
GUICtrlSetData($g_hTxtUpgradeLevel[$inum], $g_avBuildingUpgrades[$inum][5] & "+")
$g_avBuildingUpgrades[$inum][5] = $g_avBuildingUpgrades[$inum][5] & "+"
ElseIf $g_abUpgradeRepeatEnable[$inum] = True Then
GUICtrlSetState($g_hChkUpgrade[$inum], $GUI_CHECKED)
$g_abBuildingUpgradeEnable[$inum] = True
EndIf
ClickP($aAway, 2, 0, "#0301")
If _Sleep($iDelayUpgradeNormal3) Then Return
Return True
EndIf
ElseIf _ColorCheck(_GetPixelColor(721, 118 + $g_iMidOffsetY, True), Hex(0xDF0408, 6), 20) Then
If _ColorCheck(_GetPixelColor(459, 490 + $g_iMidOffsetY, True), Hex(0xE70A12, 6), 20) And _ColorCheck(_GetPixelColor(459, 494 + $g_iMidOffsetY), Hex(0xE70A12, 6), 20) And  _ColorCheck(_GetPixelColor(459, 498 + $g_iMidOffsetY, True), Hex(0xE70A12, 6), 20) Then
SetLog("Upgrade Fail #" & $inum + 1 & " " & $g_avBuildingUpgrades[$inum][4] & ", No Loot!", $COLOR_RED)
ClickP($aAway, 2, 0, "#0298")
Return False
Else
Click(670, 510 + $g_iMidOffsetY, 1, 0, "#0299")
If _Sleep($iDelayUpgradeNormal3) Then Return
If $g_iDebugImageSave = 1 Then DebugImageSave("UpgradeRegBtn2")
If _ColorCheck(_GetPixelColor(573, 256 + $g_iMidOffsetY, True), Hex(0xE1090E, 6), 20) Then
SetLog("Upgrade Fail #" & $inum + 1 & " " & $g_avBuildingUpgrades[$inum][4] & " No Loot!", $COLOR_RED)
ClickP($aAway, 2, 0, "#0300")
Return False
EndIf
SetLog("Upgrade #" & $inum + 1 & " " & $g_avBuildingUpgrades[$inum][4] & " started", $COLOR_GREEN)
GUICtrlSetImage($g_hPicUpgradeStatus[$inum], $g_sLibIconPath, $eIcnGreenLight)
$g_aiPicUpgradeStatus[$inum] = $eIcnGreenLight
GUICtrlSetData($g_hTxtUpgradeValue[$inum], -($g_avBuildingUpgrades[$inum][2]))
GUICtrlSetData($g_hTxtUpgradeLevel[$inum], $g_avBuildingUpgrades[$inum][5] & "+")
$itxtUpgradeLevel[$inum] = $g_avBuildingUpgrades[$inum][5] & "+"
If $g_abUpgradeRepeatEnable[$inum] = False Then
GUICtrlSetState($g_hChkUpgrade[$inum], $GUI_UNCHECKED)
$g_abBuildingUpgradeEnable[$inum] = False
$g_avBuildingUpgrades[$inum][0] = -1
$g_avBuildingUpgrades[$inum][1] = -1
$g_avBuildingUpgrades[$inum][3] = ""
GUICtrlSetData($g_hTxtUpgradeLevel[$inum], $g_avBuildingUpgrades[$inum][5] & "+")
$g_avBuildingUpgrades[$inum][5] = $g_avBuildingUpgrades[$inum][5] & "+"
ElseIf $g_abUpgradeRepeatEnable[$inum] = True Then
GUICtrlSetState($g_hChkUpgrade[$inum], $GUI_CHECKED)
$g_abBuildingUpgradeEnable[$inum] = True
EndIf
ClickP($aAway, 2, 0, "#0301")
If _Sleep($iDelayUpgradeNormal3) Then Return
Return True
EndIf
Else
Setlog("Upgrade #" & $inum + 1 & " window open fail", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0302")
EndIf
Else
Setlog("Upgrade #" & $inum + 1 & " Error finding button", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0303")
Return False
EndIf
EndFunc
Func UpgradeHero($inum)
BuildingClick($g_avBuildingUpgrades[$inum][0], $g_avBuildingUpgrades[$inum][1], "#0304")
If _Sleep($iDelayUpgradeHero1) Then Return
Local $offColors[3][3] = [[0xE07B50, 41, 23], [0x282020, 72, 0], [0xF4F5F2, 79, 0]]
Global $ButtonPixel = _MultiPixelSearch(240, 563 + $g_iBottomOffsetY, 670, 620 + $g_iBottomOffsetY, 1, 1, Hex(0xF5F6F2, 6), $offColors, 30)
If IsArray($ButtonPixel) Then
If $g_iDebugSetlog = 1 And IsArray($ButtonPixel) Then
Setlog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("Color #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 41, $ButtonPixel[1] + 23, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 72, $ButtonPixel[1], True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 79, $ButtonPixel[1], True), $COLOR_DEBUG)
EndIf
If _Sleep($iDelayUpgradeHero2) Then Return
Click($ButtonPixel[0] + 20, $ButtonPixel[1] + 20, 1, 0, "#0305")
If _Sleep($iDelayUpgradeHero3) Then Return
If $g_iDebugImageSave = 1 Then DebugImageSave("UpgradeDarkBtn1")
If _ColorCheck(_GetPixelColor(715, 120 + $g_iMidOffsetY, True), Hex(0xE1090E, 6), 20) Then
If _ColorCheck(_GetPixelColor(691, 523 + $g_iMidOffsetY, True), Hex(0xE70A12, 6), 20) And _ColorCheck(_GetPixelColor(691, 527 + $g_iMidOffsetY), Hex(0xE70A12, 6), 20) And  _ColorCheck(_GetPixelColor(691, 531 + $g_iMidOffsetY, True), Hex(0xE70A12, 6), 20) Then
SetLog("Hero Upgrade Fail #" & $inum + 1 & " " & $g_avBuildingUpgrades[$inum][4] & " No DE!", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0306")
Return False
Else
Click(660, 515 + $g_iMidOffsetY, 1, 0, "#0307")
ClickP($aAway, 1, 0, "#0308")
If _Sleep($iDelayUpgradeHero1) Then Return
If $g_iDebugImageSave = 1 Then DebugImageSave("UpgradeDarkBtn2")
If _ColorCheck(_GetPixelColor(573, 256 + $g_iMidOffsetY, True), Hex(0xE1090E, 6), 20) Then
SetLog("Upgrade Fail #" & $inum + 1 & " " & $g_avBuildingUpgrades[$inum][4] & " No DE!", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0309")
Return False
EndIf
SetLog("Hero Upgrade #" & $inum + 1 & " " & $g_avBuildingUpgrades[$inum][4] & " started", $COLOR_SUCCESS)
GUICtrlSetImage($g_hPicUpgradeStatus[$inum], $g_sLibIconPath, $eIcnGreenLight)
$g_aiPicUpgradeStatus[$inum] = $eIcnGreenLight
GUICtrlSetData($g_hTxtUpgradeValue[$inum], -($g_avBuildingUpgrades[$inum][2]))
GUICtrlSetData($g_hTxtUpgradeLevel[$inum], $g_avBuildingUpgrades[$inum][5] & "+")
$itxtUpgradeLevel[$inum] = $g_avBuildingUpgrades[$inum][5] & "+"
If $g_abUpgradeRepeatEnable[$inum] = False Then
GUICtrlSetState($g_hChkUpgrade[$inum], $GUI_UNCHECKED)
$g_abBuildingUpgradeEnable[$inum] = False
$g_avBuildingUpgrades[$inum][0] = -1
$g_avBuildingUpgrades[$inum][1] = -1
$g_avBuildingUpgrades[$inum][3] = ""
GUICtrlSetData($g_hTxtUpgradeLevel[$inum], $g_avBuildingUpgrades[$inum][5] & "+")
$g_avBuildingUpgrades[$inum][5] = $g_avBuildingUpgrades[$inum][5] & "+"
ElseIf $g_abUpgradeRepeatEnable[$inum] = True Then
GUICtrlSetState($g_hChkUpgrade[$inum], $GUI_CHECKED)
$g_abBuildingUpgradeEnable[$inum] = True
EndIf
ClickP($aAway, 2, 0, "#0310")
If _Sleep($iDelayUpgradeHero2) Then Return
Return True
EndIf
Else
Setlog("Upgrade #" & $inum + 1 & " window open fail", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0311")
EndIf
Else
Setlog("Upgrade #" & $inum + 1 & " Error finding button", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0312")
Return False
EndIf
EndFunc
Func SetlogUpgradeValues($i)
Local $j
For $j = 0 To UBound($g_avBuildingUpgrades, 2) - 1
Setlog("$g_avBuildingUpgrades[" & $i & "][" & $j & "]= " & $g_avBuildingUpgrades[$i][$j], $COLOR_DEBUG)
Next
Setlog("$g_hChkUpgrade= " & $g_abBuildingUpgradeEnable[$i], $COLOR_DEBUG)
Setlog("$g_hTxtUpgradeName= " & $g_avBuildingUpgrades[$i][4], $COLOR_DEBUG)
Setlog("$g_hTxtUpgradeLevel= " & $itxtUpgradeLevel[$i], $COLOR_DEBUG)
Setlog("$g_hPicUpgradeType= " & $g_aiPicUpgradeStatus[$i], $COLOR_DEBUG)
Setlog("$g_hTxtUpgradeValue= " & $g_avBuildingUpgrades[$i][2], $COLOR_DEBUG)
Setlog("$g_hTxtUpgradeTime= " & $g_avBuildingUpgrades[$i][6], $COLOR_DEBUG)
Setlog("$g_hTxtUpgradeEndTime= " & $g_avBuildingUpgrades[$i][7], $COLOR_DEBUG)
Setlog("$g_hChkUpgradeRepeat= " & $g_abUpgradeRepeatEnable, $COLOR_DEBUG)
EndFunc
Func UpgradeHeroes()
If $g_bUpgradeKingEnable = False And $g_bUpgradeQueenEnable = False And $g_bUpgradeWardenEnable = False Then Return
If _Sleep(500) Then Return
checkMainScreen(False)
If $g_bRestart = True Then Return
If $g_bUpgradeKingEnable = True Then
If isInsideDiamond($KingAltarPos) = False Then LocateKingAltar()
If $KingAltarPos[0] = -1 Or $KingAltarPos[1] = -1 Then LocateKingAltar()
SaveConfig()
EndIf
If $g_bUpgradeQueenEnable = True Then
If isInsideDiamond($QueenAltarPos) = False Then LocateQueenAltar()
If $QueenAltarPos[0] = -1 Or $QueenAltarPos[1] = -1 Then LocateQueenAltar()
SaveConfig()
EndIf
If $g_bUpgradeWardenEnable = True Then
If isInsideDiamond($WardenAltarPos) = False Then LocateWardenAltar()
If $WardenAltarPos[0] = -1 Or $WardenAltarPos[1] = -1 Then LocateWardenAltar()
EndIf
If $g_bAutoLabUpgradeEnable = True And $g_iCmbLaboratory >= 19 Then
Setlog("Laboratory needs DE to Upgrade :  " & $aLabTroops[$g_iCmbLaboratory][3])
SetLog("Skipping the Heroes Upgrade!")
Return
EndIf
SetLog("Upgrading Heroes", $COLOR_INFO)
If getBuilderCount() = False Then Return
If _Sleep($iDelayRespond) Then Return
If $iFreeBuilderCount < 1 +($g_bUpgradeWallSaveBuilder ? 1 : 0) Then
SetLog("Not Enough Builders for Queen", $COLOR_ERROR)
Return
EndIf
QueenUpgrade()
If _Sleep($iDelayUpgradeHero1) Then Return
If getBuilderCount() = False Then Return
If _Sleep($iDelayRespond) Then Return
If $iFreeBuilderCount < 1 +($g_bUpgradeWallSaveBuilder ? 1 : 0) Then
SetLog("Not Enough Builders for King", $COLOR_ERROR)
Return
EndIf
KingUpgrade()
If _Sleep($iDelayUpgradeHero1) Then Return
If getBuilderCount() = False Then Return
If _Sleep($iDelayRespond) Then Return
If $iFreeBuilderCount < 1 +($g_bUpgradeWallSaveBuilder ? 1 : 0) Then
SetLog("Not Enough Builder for Warden", $COLOR_ERROR)
Return
EndIf
WardenUpgrade()
EndFunc
Func QueenUpgrade()
If $g_bUpgradeQueenEnable = False Then Return
Local $aHeroLevel = 0
SetLog("Upgrade Queen")
ClickP($aTopLeftClient, 1, 0, "#0166")
If _Sleep(500) Then Return
BuildingClickP($QueenAltarPos)
Local $sInfo = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
Local $CountGetInfo = 0
While IsArray($sInfo) = False
$sInfo = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
Sleep(100)
$CountGetInfo += 1
If $CountGetInfo >= 50 Then Return
WEnd
If $g_iDebugSetlog = 1 Then SetLog(_ArrayToString($sInfo, " "), $COLOR_DEBUG)
If @error Then Return SetError(0, 0, 0)
If $sInfo[0] > 1 Or $sInfo[0] = "" Then
If StringInStr($sInfo[1], "Quee") = 0 Then
SetLog("Bad AQ location", $COLOR_ACTION)
Return
Else
If $sInfo[2] <> "" Then
$aHeroLevel = Number($sInfo[2])
SetLog("Your Queen Level read as: " & $aHeroLevel, $COLOR_SUCCESS)
If $aHeroLevel = $iMaxQueenLevel Then
SetLog("Your AQ is max, cannot upgrade!", $COLOR_INFO)
$g_bUpgradeQueenEnable = False
Return
EndIf
Else
SetLog("Your Queen Level was not found!", $COLOR_INFO)
Return
EndIf
EndIf
EndIf
If _Sleep($iDelayUpgradeHero1) Then Return
If _ColorCheck(_GetPixelColor(837, 134, True), Hex(0x302030, 6), 10) Then
$iDarkCurrent = Number(getResourcesMainScreen(728, 123))
If $g_iDebugSetlog = 1 Then SetLog("Updating village values [D]: " & $iDarkCurrent, $COLOR_DEBUG)
Else
If $g_iDebugSetlog = 1 Then Setlog("getResourcesMainScreen didn't get the DE value", $COLOR_DEBUG)
EndIf
If $iDarkCurrent <($aQueenUpgCost[$aHeroLevel] * 1000) + $g_iUpgradeMinDark Then
SetLog("Insufficient DE for Upg Queen, requires: " &($aQueenUpgCost[$aHeroLevel] * 1000) & " + " & $g_iUpgradeMinDark, $COLOR_INFO)
Return
EndIf
Local $offColors[3][3] = [[0xE07B50, 41, 23], [0x282020, 72, 0], [0xF5F9F2, 79, 0]]
Global $ButtonPixel = _MultiPixelSearch(240, 563 + $g_iBottomOffsetY, 670, 620 + $g_iBottomOffsetY, 1, 1, Hex(0xF5F6F2, 6), $offColors, 30)
If IsArray($ButtonPixel) Then
If $g_iDebugSetlog = 1 And IsArray($ButtonPixel) Then
Setlog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("Color #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 41, $ButtonPixel[1] + 23, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 72, $ButtonPixel[1], True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 79, $ButtonPixel[1], True), $COLOR_DEBUG)
EndIf
If _Sleep($iDelayUpgradeHero2) Then Return
Click($ButtonPixel[0] + 20, $ButtonPixel[1] + 20, 1, 0, "#0305")
If _Sleep($iDelayUpgradeHero3) Then Return
If $g_iDebugImageSave = 1 Then DebugImageSave("UpgradeDarkBtn1")
If _ColorCheck(_GetPixelColor(721, 118 + $g_iMidOffsetY, True), Hex(0xE00408, 6), 20) Then
If _ColorCheck(_GetPixelColor(691, 523 + $g_iMidOffsetY, True), Hex(0xE70A12, 6), 20) And _ColorCheck(_GetPixelColor(691, 527 + $g_iMidOffsetY), Hex(0xE70A12, 6), 20) And  _ColorCheck(_GetPixelColor(691, 531 + $g_iMidOffsetY, True), Hex(0xE70A12, 6), 20) Then
SetLog("Queen Upgrade Fail! No DE!", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0306")
Return
Else
Click(665, 515 + $g_iMidOffsetY, 1, 0, "#0307")
ClickP($aAway, 1, 0, "#0308")
If _Sleep($iDelayUpgradeHero1) Then Return
If $g_iDebugImageSave = 1 Then DebugImageSave("UpgradeDarkBtn2")
If _ColorCheck(_GetPixelColor(573, 256 + $g_iMidOffsetY, True), Hex(0xDB0408, 6), 20) Then
SetLog("Queen Upgrade Fail! No DE!", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0309")
Return
EndIf
SetLog("Queen Upgrade complete", $COLOR_SUCCESS)
If _Sleep($iDelayUpgradeHero2) Then Return
$g_iNbrOfHeroesUpped[$CurrentAccount] += 1
$g_iCostDElixirHero[$CurrentAccount] += $aQueenUpgCost[$aHeroLevel - 1] * 1000
UpdateStats()
EndIf
Else
Setlog("Upgrade Queen window open fail", $COLOR_ERROR)
EndIf
Else
Setlog("Upgrade Queen error finding button", $COLOR_ERROR)
EndIf
ClickP($aAway, 2, 0, "#0312")
EndFunc
Func KingUpgrade()
If $g_bUpgradeKingEnable = False Then Return
Local $aHeroLevel = 0
SetLog("Upgrade King")
BuildingClickP($KingAltarPos)
If _Sleep(500) Then Return
Local $sInfo = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
Local $CountGetInfo = 0
While IsArray($sInfo) = False
$sInfo = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
If _Sleep(100) Then Return
$CountGetInfo += 1
If $CountGetInfo >= 50 Then Return
WEnd
If $g_iDebugSetlog = 1 Then SetLog(_ArrayToString($sInfo, " "), $COLOR_DEBUG)
If @error Then Return SetError(0, 0, 0)
If $sInfo[0] > 1 Or $sInfo[0] = "" Then
If StringInStr($sInfo[1], "Barbarian") = 0 Then
SetLog("Bad King location", $COLOR_ACTION)
Return
Else
If $sInfo[2] <> "" Then
$aHeroLevel = Number($sInfo[2])
SetLog("Your King Level read as: " & $aHeroLevel, $COLOR_SUCCESS)
If $aHeroLevel = $iMaxKingLevel Then
SetLog("Your BK is max, cannot upgrade!", $COLOR_INFO)
$g_bUpgradeKingEnable = False
Return
EndIf
Else
SetLog("Your King Level was not found!", $COLOR_INFO)
Return
EndIf
EndIf
EndIf
If _Sleep($iDelayUpgradeHero1) Then Return
If _ColorCheck(_GetPixelColor(837, 134, True), Hex(0x302030, 6), 10) Then
$iDarkCurrent = Number(getResourcesMainScreen(728, 123))
If $g_iDebugSetlog = 1 Then SetLog("Updating village values [D]: " & $iDarkCurrent, $COLOR_DEBUG)
Else
If $g_iDebugSetlog = 1 Then Setlog("getResourcesMainScreen didn't get the DE value", $COLOR_DEBUG)
EndIf
If _Sleep(100) Then Return
If $iDarkCurrent <($aKingUpgCost[$aHeroLevel] * 1000) + $g_iUpgradeMinDark Then
SetLog("Insufficient DE for Upg King, requires: " &($aKingUpgCost[$aHeroLevel] * 1000) & " + " & $g_iUpgradeMinDark, $COLOR_INFO)
Return
EndIf
Local $offColors[3][3] = [[0xE07B50, 41, 23], [0x282020, 72, 0], [0xF4F5F2, 79, 0]]
Global $ButtonPixel = _MultiPixelSearch(240, 563 + $g_iBottomOffsetY, 670, 620 + $g_iBottomOffsetY, 1, 1, Hex(0xF5F6F2, 6), $offColors, 30)
If IsArray($ButtonPixel) Then
If $g_iDebugSetlog = 1 And IsArray($ButtonPixel) Then
Setlog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("Color #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 41, $ButtonPixel[1] + 23, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 72, $ButtonPixel[1], True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 79, $ButtonPixel[1], True), $COLOR_DEBUG)
EndIf
If _Sleep($iDelayUpgradeHero2) Then Return
Click($ButtonPixel[0] + 20, $ButtonPixel[1] + 20, 1, 0, "#0305")
If _Sleep($iDelayUpgradeHero3) Then Return
If $g_iDebugImageSave = 1 Then DebugImageSave("UpgradeDarkBtn1")
If _ColorCheck(_GetPixelColor(715, 120 + $g_iMidOffsetY, True), Hex(0xE01C20, 6), 20) Then
If _ColorCheck(_GetPixelColor(691, 523 + $g_iMidOffsetY, True), Hex(0xE70A12, 6), 20) And _ColorCheck(_GetPixelColor(691, 527 + $g_iMidOffsetY), Hex(0xE70A12, 6), 20) And  _ColorCheck(_GetPixelColor(691, 531 + $g_iMidOffsetY, True), Hex(0xE70A12, 6), 20) Then
SetLog("King Upgrade Fail! No DE!", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0306")
Return
Else
Click(660, 515 + $g_iMidOffsetY, 1, 0, "#0307")
ClickP($aAway, 1, 0, "#0308")
If _Sleep($iDelayUpgradeHero1) Then Return
If $g_iDebugImageSave = 1 Then DebugImageSave("UpgradeDarkBtn2")
If _ColorCheck(_GetPixelColor(573, 256 + $g_iMidOffsetY, True), Hex(0xDB0408, 6), 20) Then
SetLog("King Upgrade Fail! No DE!", $COLOR_ERROR)
ClickP($aAway, 2, 0, "#0309")
Return
EndIf
SetLog("King Upgrade complete", $COLOR_SUCCESS)
If _Sleep($iDelayUpgradeHero2) Then Return
$g_iNbrOfHeroesUpped[$CurrentAccount] += 1
$g_iCostDElixirHero[$CurrentAccount] += $aKingUpgCost[$aHeroLevel - 1] * 1000
UpdateStats()
EndIf
Else
Setlog("Upgrade King window open fail", $COLOR_ERROR)
EndIf
Else
Setlog("Upgrade King error finding button", $COLOR_ERROR)
EndIf
ClickP($aAway, 2, 0, "#0312")
EndFunc
Func WardenUpgrade()
If $g_bUpgradeWardenEnable = False Then Return
If Number($iTownHallLevel) <= 10 Then
Setlog("Must have TH 11 for Grand Warden upgrade", $COLOR_ERROR)
Return
EndIf
Local $aHeroLevel = 0
SetLog("Upgrade Grand Warden")
ClickP($WardenAltarPos, 1, 0, "#8888")
If _Sleep($iDelayUpgradeHero2) Then Return
Local $sInfo = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
Local $CountGetInfo = 0
While IsArray($sInfo) = False
$sInfo = BuildingInfo(242, 520 + $g_iBottomOffsetY)
If @error Then SetError(0, 0, 0)
If _Sleep(100) Then Return
$CountGetInfo += 1
If $CountGetInfo = 50 Then Return
WEnd
If $g_iDebugSetlog = 1 Then SetLog(_ArrayToString($sInfo, " "))
If @error Then Return SetError(0, 0, 0)
If $sInfo[0] > 1 Or $sInfo[0] = "" Then
If StringInStr($sInfo[1], "Grand") = 0 Then
SetLog("Bad Warden location", $COLOR_ACTION)
Return
Else
If $sInfo[2] <> "" Then
$aHeroLevel = Number($sInfo[2])
SetLog("Your Warden Level read as: " & $aHeroLevel, $COLOR_SUCCESS)
If $aHeroLevel = $iMaxWardenLevel Then
SetLog("Your Warden is max, cannot upgrade!", $COLOR_INFO)
$g_bUpgradeWardenEnable = False
Return
EndIf
Else
SetLog("Your Warden Level was not found!", $COLOR_INFO)
Return
EndIf
EndIf
EndIf
If _Sleep($iDelayUpgradeHero1) Then Return
If _ColorCheck(_GetPixelColor(837, 134, True), Hex(0x302030, 6), 10) Then
$iElixirCurrent = getResourcesMainScreen(705, 74)
If $g_iDebugSetlog = 1 Then SetLog("Updating village values [E]: " & $iElixirCurrent, $COLOR_DEBUG)
Else
$iElixirCurrent = getResourcesMainScreen(710, 74)
EndIf
If _Sleep(100) Then Return
If $iElixirCurrent <($aWardenUpgCost[$aHeroLevel] * 1000000) + $g_iUpgradeMinElixir Then
SetLog("Insufficient Elixir for Warden Upgrade, requires: " &($aWardenUpgCost[$aHeroLevel] * 1000000) & " + " & $g_iUpgradeMinElixir, $COLOR_INFO)
Return
EndIf
If _Sleep($iDelayUpgradeHero2) Then Return
Local $offColors[3][3] = [[0xBC5B31, 38, 32], [0xF84CF9, 72, 0], [0xF5F9F2, 79, 0]]
Global $ButtonPixel = _MultiPixelSearch(240, 563 + $g_iBottomOffsetY, 670, 620 + $g_iBottomOffsetY, 1, 1, Hex(0xF4F7F2, 6), $offColors, 30)
If IsArray($ButtonPixel) Then
If $g_iDebugSetlog = 1 And IsArray($ButtonPixel) Then
Setlog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("Color #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 41, $ButtonPixel[1] + 23, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 72, $ButtonPixel[1], True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 79, $ButtonPixel[1], True), $COLOR_DEBUG)
EndIf
If _Sleep($iDelayUpgradeHero2) Then Return
Click($ButtonPixel[0] + 20, $ButtonPixel[1] + 20, 1, 0, "#0305")
If _Sleep($iDelayUpgradeHero3) Then Return
If $g_iDebugSetlog = 1 Then DebugImageSave("UpgradeElixirBtn1")
If $g_iDebugSetlog = 1 Then Setlog("pixel: " & _GetPixelColor(718, 120 + $g_iMidOffsetY, True) & " expected " & Hex(0xDD0408, 6) & " result: " & _ColorCheck(_GetPixelColor(718, 120 + $g_iMidOffsetY, True), Hex(0xDD0408, 6), 20), $COLOR_DEBUG)
If _ColorCheck(_GetPixelColor(718, 120 + $g_iMidOffsetY, True), Hex(0xDD0408, 6), 20) Then
If $g_iDebugSetlog = 1 Then Setlog("pixel1: " & _GetPixelColor(692, 525 + $g_iMidOffsetY, True) & " expected " & Hex(0xFFFFFF, 6) & " result: " &(_ColorCheck(_GetPixelColor(692, 525 + $g_iMidOffsetY, True), Hex(0xFFFFFF, 6), 20)), $COLOR_DEBUG)
If Not(_ColorCheck(_GetPixelColor(692, 525 + $g_iMidOffsetY, True), Hex(0xFFFFFF, 6), 20)) Then
SetLog("Warden Upgrade Fail! No Elixir!", $COLOR_ERROR)
ClickP($aAway, 1, 0, "#0306")
Return
Else
Click(660, 515 + $g_iMidOffsetY, 1, 0, "#0307")
ClickP($aAway, 1, 0, "#0308")
If _Sleep($iDelayUpgradeHero1) Then Return
If $g_iDebugSetlog = 1 Then DebugImageSave("UpgradeElixirBtn2")
If _ColorCheck(_GetPixelColor(573, 256 + $g_iMidOffsetY, True), Hex(0xDB0408, 6), 20) Then
SetLog("Warden Upgrade Fail! No Elixir!", $COLOR_ERROR)
ClickP($aAway, 1, 0, "#0309")
Return
EndIf
SetLog("Warden Upgrade Started", $COLOR_SUCCESS)
If _Sleep($iDelayUpgradeHero2) Then Return
$g_iNbrOfHeroesUpped[$CurrentAccount] += 1
$g_iCostElixirBuilding[$CurrentAccount] += $aWardenUpgCost[$aHeroLevel - 1] * 1000
UpdateStats()
EndIf
Else
Setlog("Upgrade Warden window open fail", $COLOR_ERROR)
EndIf
Else
Setlog("Upgrade Warden error finding button", $COLOR_ERROR)
EndIf
ClickP($aAway, 2, 0, "#0312")
EndFunc
Func ArmyHeroStatus($Hero)
Local $directory = "trainwindow-HeroStatus-bundle"
Local Const $aHeroesRect[3][4] = [[610, 340, 683, 390], [683, 340, 758, 390], [757, 340, 833, 390]]
Local $Result, $Status
Select
Case $Hero = "King" Or $Hero = 0 Or $Hero = $eKing
$Result = SearchArmy($directory, $aHeroesRect[0][0], $aHeroesRect[0][1], $aHeroesRect[0][2], $aHeroesRect[0][3], "", True)
$Status = $Result[0][0]
Switch $Status
Case "heal"
GUICtrlSetState($g_lblKingStatus[$CurrentAccount], $GUI_SHOW)
GUICtrlSetBkColor($g_lblKingStatus[$CurrentAccount], $COLOR_YELLOW)
If WinGetState(Eval($hGuiPopOut & $CurrentAccount)) <> -1 Then
GUICtrlSetState($g_lblKingStatusPO[$CurrentAccount], $GUI_SHOW)
GUICtrlSetBkColor($g_lblKingStatusPO[$CurrentAccount], $COLOR_YELLOW)
EndIf
Case "upgrade"
GUICtrlSetState($g_lblKingStatus[$CurrentAccount], $GUI_SHOW)
GUICtrlSetBkColor($g_lblKingStatus[$CurrentAccount], $COLOR_RED)
If WinGetState(Eval($hGuiPopOut & $CurrentAccount)) <> -1 Then
GUICtrlSetState($g_lblKingStatusPO[$CurrentAccount], $GUI_SHOW)
GUICtrlSetBkColor($g_lblKingStatusPO[$CurrentAccount], $COLOR_RED)
EndIf
Case "none"
GUICtrlSetState($g_lblKingStatus[$CurrentAccount], $GUI_HIDE)
If WinGetState(Eval($hGuiPopOut & $CurrentAccount)) <> -1 Then
GUICtrlSetState($g_lblKingStatusPO[$CurrentAccount], $GUI_HIDE)
EndIf
Case Else
GUICtrlSetState($g_lblKingStatus[$CurrentAccount], $GUI_SHOW)
GUICtrlSetBkColor($g_lblKingStatus[$CurrentAccount], $COLOR_GREEN)
If WinGetState(Eval($hGuiPopOut & $CurrentAccount)) <> -1 Then
GUICtrlSetState($g_lblKingStatusPO[$CurrentAccount], $GUI_SHOW)
GUICtrlSetBkColor($g_lblKingStatusPO[$CurrentAccount], $COLOR_GREEN)
EndIF
EndSwitch
If $Status = "" Then $Status = "king"
Return $Status
Case $Hero = "Queen" Or $Hero = 1 Or $Hero = $eQueen
$Result = SearchArmy($directory, $aHeroesRect[1][0], $aHeroesRect[1][1], $aHeroesRect[1][2], $aHeroesRect[1][3], "", True)
$Status = $Result[0][0]
Switch $Status
Case "heal"
GUICtrlSetState($g_lblQueenStatus[$CurrentAccount], $GUI_SHOW)
GUICtrlSetBkColor($g_lblQueenStatus[$CurrentAccount], $COLOR_YELLOW)
If WinGetState(Eval($hGuiPopOut & $CurrentAccount)) <> -1 Then
GUICtrlSetState($g_lblQueenStatusPO[$CurrentAccount], $GUI_SHOW)
GUICtrlSetBkColor($g_lblQueenStatusPO[$CurrentAccount], $COLOR_YELLOW)
EndIf
Case "upgrade"
GUICtrlSetState($g_lblQueenStatus[$CurrentAccount], $GUI_SHOW)
GUICtrlSetBkColor($g_lblQueenStatus[$CurrentAccount], $COLOR_RED)
If WinGetState(Eval($hGuiPopOut & $CurrentAccount)) <> -1 Then
GUICtrlSetState($g_lblQueenStatusPO[$CurrentAccount], $GUI_SHOW)
GUICtrlSetBkColor($g_lblQueenStatusPO[$CurrentAccount], $COLOR_RED)
EndIf
Case "none"
GUICtrlSetState($g_lblQueenStatus[$CurrentAccount], $GUI_HIDE)
If WinGetState(Eval($hGuiPopOut & $CurrentAccount)) <> -1 Then
GUICtrlSetState($g_lblQueenStatusPO[$CurrentAccount], $GUI_HIDE)
EndIf
Case Else
GUICtrlSetState($g_lblQueenStatus[$CurrentAccount], $GUI_SHOW)
GUICtrlSetBkColor($g_lblQueenStatus[$CurrentAccount], $COLOR_GREEN)
If WinGetState(Eval($hGuiPopOut & $CurrentAccount)) <> -1 Then
GUICtrlSetState($g_lblQueenStatusPO[$CurrentAccount], $GUI_SHOW)
GUICtrlSetBkColor($g_lblQueenStatusPO[$CurrentAccount], $COLOR_GREEN)
EndIF
EndSwitch
If $Status = "" Then $Status = "queen"
Return $Status
Case $Hero = "Warden" Or $Hero = 2 Or $Hero = $eWarden
$Result = SearchArmy($directory, $aHeroesRect[2][0], $aHeroesRect[2][1], $aHeroesRect[2][2], $aHeroesRect[2][3], "", True)
$Status = $Result[0][0]
Switch $Status
Case "heal"
GUICtrlSetState($g_lblWardenStatus[$CurrentAccount], $GUI_SHOW)
GUICtrlSetBkColor($g_lblWardenStatus[$CurrentAccount], $COLOR_YELLOW)
If WinGetState(Eval($hGuiPopOut & $CurrentAccount)) <> -1 Then
GUICtrlSetState($g_lblWardenStatusPO[$CurrentAccount], $GUI_SHOW)
GUICtrlSetBkColor($g_lblWardenStatusPO[$CurrentAccount], $COLOR_YELLOW)
EndIf
Case "upgrade"
GUICtrlSetState($g_lblWardenStatus[$CurrentAccount], $GUI_SHOW)
GUICtrlSetBkColor($g_lblWardenStatus[$CurrentAccount], $COLOR_RED)
If WinGetState(Eval($hGuiPopOut & $CurrentAccount)) <> -1 Then
GUICtrlSetState($g_lblWardenStatusPO[$CurrentAccount], $GUI_SHOW)
GUICtrlSetBkColor($g_lblWardenStatusPO[$CurrentAccount], $COLOR_RED)
EndIf
Case "none"
GUICtrlSetState($g_lblWardenStatus[$CurrentAccount], $GUI_HIDE)
If WinGetState(Eval($hGuiPopOut & $CurrentAccount)) <> -1 Then
GUICtrlSetState($g_lblWardenStatusPO[$CurrentAccount], $GUI_HIDE)
EndIf
Case Else
GUICtrlSetState($g_lblWardenStatus[$CurrentAccount], $GUI_SHOW)
GUICtrlSetBkColor($g_lblWardenStatus[$CurrentAccount], $COLOR_GREEN)
If WinGetState(Eval($hGuiPopOut & $CurrentAccount)) <> -1 Then
GUICtrlSetState($g_lblWardenStatusPO[$CurrentAccount], $GUI_SHOW)
GUICtrlSetBkColor($g_lblWardenStatusPO[$CurrentAccount], $COLOR_GREEN)
EndIF
EndSwitch
If $Status = "" Then $Status = "warden"
Return $Status
EndSelect
EndFunc
Func CountHeroes()
Local $directory = "trainwindow-HeroStatus-bundle"
Local Const $aHeroesRect[3][4] = [[643, 340, 683, 390], [718, 340, 758, 390], [749, 340, 833, 390]]
Local $Result, $Status
Local $Available = 0, $Healing = 0, $Upgrading = 0, $None = 0, $AvaiAndHealing = 0
Local $ToReturn[5] = [$Available, $Healing, $Upgrading, $None, $AvaiAndHealing]
For $i = 0 To(UBound($aHeroesRect) - 1)
$Result = SearchArmy($directory, $aHeroesRect[$i][0], $aHeroesRect[$i][1], $aHeroesRect[$i][2], $aHeroesRect[$i][3], "", True)
$Status = $Result[0][0]
Switch $Status
Case "heal"
$Healing += 1
Case "upgrade"
$Upgrading += 1
Case "none"
$None += 1
Case Else
$Available += 1
EndSwitch
Next
$AvaiAndHealing = Number($Available + $Healing)
$ToReturn[0] = $Available
$ToReturn[1] = $Healing
$ToReturn[2] = $Upgrading
$ToReturn[3] = $None
$ToReturn[4] = $AvaiAndHealing
Return $ToReturn
EndFunc
Func GetTranslated($iSection = -1, $iKey = -1, $sText = "", $var1 = Default, $var2 = Default, $var3 = Default)
$sText = StringReplace($sText, @CRLF, "\r\n")
Local $sDefaultText, $sLanguageText
If $g_iDebugMultilanguage = 1 Then Return($iSection & "-" & $iKey)
If $iSection = -1 Or $iKey = -1 Or $sText = "" Then Return "-2"
Local $bOutBound = False
If $iSection >= UBound($aLanguage, $UBOUND_ROWS) Or $iKey >= UBound($aLanguage, $UBOUND_COLUMNS) Then $bOutBound = True
If $bOutBound = True Then ReDim $aLanguage[$iSection + 1][$iKey + 1]
If $aLanguage[$iSection][$iKey] <> "" Then Return $aLanguage[$iSection][$iKey]
If $sLanguage = $sDefaultLanguage Then
$sDefaultText = IniRead($dirLanguages & $sDefaultLanguage & ".ini", $iSection, $iKey, "-3")
If $sText = "-1" Then
If $sDefaultText <> "-3" Then
$sDefaultText = GetTranslatedParsedText($sDefaultText, $var1, $var2, $var3)
$aLanguage[$iSection][$iKey] = $sDefaultText
Return $sDefaultText
Else
Return "-3"
EndIf
EndIf
If $sDefaultText <> $sText Then
IniWrite($dirLanguages & $sDefaultLanguage & ".ini", $iSection, $iKey, $sText)
$sText = GetTranslatedParsedText($sText, $var1, $var2, $var3)
$aLanguage[$iSection][$iKey] = $sText
Return $sText
Else
$sDefaultText = GetTranslatedParsedText($sDefaultText, $var1, $var2, $var3)
$aLanguage[$iSection][$iKey] = $sDefaultText
Return $sDefaultText
EndIf
Else
$sLanguageText = IniRead($dirLanguages & $sLanguage & ".ini", $iSection, $iKey, "-3")
If $sText = "-1" Then
If $sLanguageText = "-3" Then
$sDefaultText = IniRead($dirLanguages & $sDefaultLanguage & ".ini", $iSection, $iKey, $sText)
$sDefaultText = GetTranslatedParsedText($sDefaultText, $var1, $var2, $var3)
$aLanguage[$iSection][$iKey] = $sDefaultText
Return $sDefaultText
Else
$sLanguageText = GetTranslatedParsedText($sLanguageText, $var1, $var2, $var3)
$aLanguage[$iSection][$iKey] = $sLanguageText
Return $sLanguageText
EndIf
EndIf
If $sLanguageText = "-3" Then
IniWrite($dirLanguages & $sLanguage & ".ini", $iSection, $iKey, $sText)
$sText = GetTranslatedParsedText($sText, $var1, $var2, $var3)
$aLanguage[$iSection][$iKey] = $sText
Return $sText
EndIf
$sLanguageText = GetTranslatedParsedText($sLanguageText, $var1, $var2, $var3)
$aLanguage[$iSection][$iKey] = $sLanguageText
Return $sLanguageText
EndIf
EndFunc
Func GetTranslatedParsedText($sText, $var1 = Default, $var2 = Default, $var3 = Default)
Local $s = StringReplace($sText, "\r\n", @CRLF)
If $var1 = Default Then Return $s
If $var2 = Default Then Return StringFormat($sText, $var1)
If $var3 = Default Then Return StringFormat($sText, $var1, $var2)
Return StringFormat($sText, $var1, $var2, $var3)
EndFunc
Func DetectLanguage()
Local $decimalCode = "", $countryCode = "", $langName = ""
$sLanguage = IniRead($g_sProfileConfigPath, "other", "language", "")
If Not FileExists(@ScriptDir & "\Languages\" & $sLanguage & ".ini") Then $sLanguage = ""
If $sLanguage = "" Then
Local $OSLang = @OSLang
If $g_iDebugSetlog Then SetLog("Detected language code: " & $OSLang)
Switch $OSLang
Case Hex(0x0004, 4)
$decimalCode = '4'
$countryCode = 'zh-CHS'
$langName = 'Chinese_S'
Case Hex(0x0401, 4)
$decimalCode = '1025'
$countryCode = 'ar-SA'
$langName = 'Arabic'
Case Hex(0x0402, 4)
$decimalCode = '1026'
$countryCode = 'bg-BG'
$langName = 'Bulgarian'
Case Hex(0x0403, 4)
$decimalCode = '1027'
$countryCode = 'ca-ES'
$langName = 'Catalan'
Case Hex(0x0404, 4)
$decimalCode = '1028'
$countryCode = 'zh-TW'
$langName = 'Chinese_T'
Case Hex(0x0405, 4)
$decimalCode = '1029'
$countryCode = 'cs-CZ'
$langName = 'Czech'
Case Hex(0x0406, 4)
$decimalCode = '1030'
$countryCode = 'da-DK'
$langName = 'Danish'
Case Hex(0x0407, 4)
$decimalCode = '1031'
$countryCode = 'de-DE'
$langName = 'German'
Case Hex(0x0408, 4)
$decimalCode = '1032'
$countryCode = 'el-GR'
$langName = 'Greek'
Case Hex(0x0409, 4)
$decimalCode = '1033'
$countryCode = 'en-US'
$langName = 'English'
Case Hex(0x040A, 4)
$decimalCode = '1034'
$countryCode = 'es-ES_tradnl'
$langName = 'Spanish'
Case Hex(0x040B, 4)
$decimalCode = '1035'
$countryCode = 'fi-FI'
$langName = 'Finnish'
Case Hex(0x040C, 4)
$decimalCode = '1036'
$countryCode = 'fr-FR'
$langName = 'French'
Case Hex(0x040D, 4)
$decimalCode = '1037'
$countryCode = 'he-IL'
$langName = 'Hebrew'
Case Hex(0x040E, 4)
$decimalCode = '1038'
$countryCode = 'hu-HU'
$langName = 'Hungarian'
Case Hex(0x040F, 4)
$decimalCode = '1039'
$countryCode = 'is-IS'
$langName = 'Icelandic'
Case Hex(0x0410, 4)
$decimalCode = '1040'
$countryCode = 'it-IT'
$langName = 'Italian'
Case Hex(0x0411, 4)
$decimalCode = '1041'
$countryCode = 'ja-JP'
$langName = 'Japanese'
Case Hex(0x0412, 4)
$decimalCode = '1042'
$countryCode = 'ko-KR'
$langName = 'Korean'
Case Hex(0x0413, 4)
$decimalCode = '1043'
$countryCode = 'nl-NL'
$langName = 'Dutch'
Case Hex(0x0414, 4)
$decimalCode = '1044'
$countryCode = 'nb-NO'
$langName = 'Norwegian'
Case Hex(0x0415, 4)
$decimalCode = '1045'
$countryCode = 'pl-PL'
$langName = 'Polish'
Case Hex(0x0416, 4)
$decimalCode = '1046'
$countryCode = 'pt-BR'
$langName = 'Portuguese'
Case Hex(0x0417, 4)
$decimalCode = '1047'
$countryCode = 'rm-CH'
$langName = 'Romansh'
Case Hex(0x0418, 4)
$decimalCode = '1048'
$countryCode = 'ro-RO'
$langName = 'Romanian'
Case Hex(0x0419, 4)
$decimalCode = '1049'
$countryCode = 'ru-RU'
$langName = 'Russian'
Case Hex(0x041A, 4)
$decimalCode = '1050'
$countryCode = 'hr-HR'
$langName = 'Croatian'
Case Hex(0x041B, 4)
$decimalCode = '1051'
$countryCode = 'sk-SK'
$langName = 'Slovak'
Case Hex(0x041C, 4)
$decimalCode = '1052'
$countryCode = 'sq-AL'
$langName = 'Albanian'
Case Hex(0x041D, 4)
$decimalCode = '1053'
$countryCode = 'sv-SE'
$langName = 'Swedish'
Case Hex(0x041E, 4)
$decimalCode = '1054'
$countryCode = 'th-TH'
$langName = 'Thai'
Case Hex(0x041F, 4)
$decimalCode = '1055'
$countryCode = 'tr-TR'
$langName = 'Turkish'
Case Hex(0x0420, 4)
$decimalCode = '1056'
$countryCode = 'ur-PK'
$langName = 'Urdu'
Case Hex(0x0421, 4)
$decimalCode = '1057'
$countryCode = 'id-ID'
$langName = 'Indonesian'
Case Hex(0x0422, 4)
$decimalCode = '1058'
$countryCode = 'uk-UA'
$langName = 'Ukrainian'
Case Hex(0x0423, 4)
$decimalCode = '1059'
$countryCode = 'be-BY'
$langName = 'Belarusian'
Case Hex(0x0424, 4)
$decimalCode = '1060'
$countryCode = 'sl-SI'
$langName = 'Slovenian'
Case Hex(0x0425, 4)
$decimalCode = '1061'
$countryCode = 'et-EE'
$langName = 'Estonian'
Case Hex(0x0426, 4)
$decimalCode = '1062'
$countryCode = 'lv-LV'
$langName = 'Latvian'
Case Hex(0x0427, 4)
$decimalCode = '1063'
$countryCode = 'lt-LT'
$langName = 'Lithuanian'
Case Hex(0x0428, 4)
$decimalCode = '1064'
$countryCode = 'tg-Cyrl-TJ'
$langName = 'Tajik'
Case Hex(0x0429, 4)
$decimalCode = '1065'
$countryCode = 'fa-IR'
$langName = 'Persian'
Case Hex(0x042A, 4)
$decimalCode = '1066'
$countryCode = 'vi-VN'
$langName = 'Vietnamese'
Case Hex(0x042B, 4)
$decimalCode = '1067'
$countryCode = 'hy-AM'
$langName = 'Armenian'
Case Hex(0x042C, 4)
$decimalCode = '1068'
$countryCode = 'az-Latn-AZ'
$langName = 'Azeri'
Case Hex(0x042D, 4)
$decimalCode = '1069'
$countryCode = 'eu-ES'
$langName = 'Basque'
Case Hex(0x042E, 4)
$decimalCode = '1070'
$countryCode = 'hsb-DE'
$langName = 'Upper'
Case Hex(0x042F, 4)
$decimalCode = '1071'
$countryCode = 'mk-MK'
$langName = 'Macedonian'
Case Hex(0x0432, 4)
$decimalCode = '1074'
$countryCode = 'tn-ZA'
$langName = 'Setswana'
Case Hex(0x0434, 4)
$decimalCode = '1076'
$countryCode = 'xh-ZA'
$langName = 'isiXhosa'
Case Hex(0x0435, 4)
$decimalCode = '1077'
$countryCode = 'zu-ZA'
$langName = 'isiZulu'
Case Hex(0x0436, 4)
$decimalCode = '1078'
$countryCode = 'af-ZA'
$langName = 'Afrikaans'
Case Hex(0x0437, 4)
$decimalCode = '1079'
$countryCode = 'ka-GE'
$langName = 'Georgian'
Case Hex(0x0438, 4)
$decimalCode = '1080'
$countryCode = 'fo-FO'
$langName = 'Faroese'
Case Hex(0x0439, 4)
$decimalCode = '1081'
$countryCode = 'hi-IN'
$langName = 'Hindi'
Case Hex(0x043A, 4)
$decimalCode = '1082'
$countryCode = 'mt-MT'
$langName = 'Maltese'
Case Hex(0x043B, 4)
$decimalCode = '1083'
$countryCode = 'se-NO'
$langName = 'Sami'
Case Hex(0x043e, 4)
$decimalCode = '1086'
$countryCode = 'ms-MY'
$langName = 'Malay'
Case Hex(0x043F, 4)
$decimalCode = '1087'
$countryCode = 'kk-KZ'
$langName = 'Kazakh'
Case Hex(0x0440, 4)
$decimalCode = '1088'
$countryCode = 'ky-KG'
$langName = 'Kyrgyz'
Case Hex(0x0441, 4)
$decimalCode = '1089'
$countryCode = 'sw-KE'
$langName = 'Swahili'
Case Hex(0x0442, 4)
$decimalCode = '1090'
$countryCode = 'tk-TM'
$langName = 'Turkmen'
Case Hex(0x0443, 4)
$decimalCode = '1091'
$countryCode = 'uz-Latn-UZ'
$langName = 'Uzbek'
Case Hex(0x0444, 4)
$decimalCode = '1092'
$countryCode = 'tt-RU'
$langName = 'Tatar'
Case Hex(0x0445, 4)
$decimalCode = '1093'
$countryCode = 'bn-IN'
$langName = 'Bangla'
Case Hex(0x0446, 4)
$decimalCode = '1094'
$countryCode = 'pa-IN'
$langName = 'Punjabi'
Case Hex(0x0447, 4)
$decimalCode = '1095'
$countryCode = 'gu-IN'
$langName = 'Gujarati'
Case Hex(0x0448, 4)
$decimalCode = '1096'
$countryCode = 'or-IN'
$langName = 'Oriya'
Case Hex(0x0449, 4)
$decimalCode = '1097'
$countryCode = 'ta-IN'
$langName = 'Tamil'
Case Hex(0x044A, 4)
$decimalCode = '1098'
$countryCode = 'te-IN'
$langName = 'Telugu'
Case Hex(0x044B, 4)
$decimalCode = '1099'
$countryCode = 'kn-IN'
$langName = 'Kannada'
Case Hex(0x044C, 4)
$decimalCode = '1100'
$countryCode = 'ml-IN'
$langName = 'Malayalam'
Case Hex(0x044D, 4)
$decimalCode = '1101'
$countryCode = 'as-IN'
$langName = 'Assamese'
Case Hex(0x044E, 4)
$decimalCode = '1102'
$countryCode = 'mr-IN'
$langName = 'Marathi'
Case Hex(0x044F, 4)
$decimalCode = '1103'
$countryCode = 'sa-IN'
$langName = 'Sanskrit'
Case Hex(0x0450, 4)
$decimalCode = '1104'
$countryCode = 'mn-MN'
$langName = 'Mongolian'
Case Hex(0x0451, 4)
$decimalCode = '1105'
$countryCode = 'bo-CN'
$langName = 'Tibetan'
Case Hex(0x0452, 4)
$decimalCode = '1106'
$countryCode = 'cy-GB'
$langName = 'Welsh'
Case Hex(0x0453, 4)
$decimalCode = '1107'
$countryCode = 'km-KH'
$langName = 'Khmer'
Case Hex(0x0454, 4)
$decimalCode = '1108'
$countryCode = 'lo-LA'
$langName = 'Lao'
Case Hex(0x0456, 4)
$decimalCode = '1110'
$countryCode = 'gl-ES'
$langName = 'Galician'
Case Hex(0x0457, 4)
$decimalCode = '1111'
$countryCode = 'kok-IN'
$langName = 'Konkani'
Case Hex(0x0459, 4)
$decimalCode = '1113'
$countryCode = 'sd-Deva-IN'
$langName = '(reserved)'
Case Hex(0x045A, 4)
$decimalCode = '1114'
$countryCode = 'syr-SY'
$langName = 'Syriac'
Case Hex(0x045B, 4)
$decimalCode = '1115'
$countryCode = 'si-LK'
$langName = 'Sinhala'
Case Hex(0x045C, 4)
$decimalCode = '1116'
$countryCode = 'chr-Cher-US'
$langName = 'Cherokee'
Case Hex(0x045D, 4)
$decimalCode = '1117'
$countryCode = 'iu-Cans-CA'
$langName = 'Inuktitut'
Case Hex(0x045E, 4)
$decimalCode = '1118'
$countryCode = 'am-ET'
$langName = 'Amharic'
Case Hex(0x0461, 4)
$decimalCode = '1121'
$countryCode = 'ne-NP'
$langName = 'Nepali'
Case Hex(0x0462, 4)
$decimalCode = '1122'
$countryCode = 'fy-NL'
$langName = 'Frisian'
Case Hex(0x0463, 4)
$decimalCode = '1123'
$countryCode = 'ps-AF'
$langName = 'Pashto'
Case Hex(0x0464, 4)
$decimalCode = '1124'
$countryCode = 'fil-PH'
$langName = 'Filipino'
Case Hex(0x0465, 4)
$decimalCode = '1125'
$countryCode = 'dv-MV'
$langName = 'Divehi'
Case Hex(0x0468, 4)
$decimalCode = '1128'
$countryCode = 'ha-Latn-NG'
$langName = 'Hausa'
Case Hex(0x046A, 4)
$decimalCode = '1130'
$countryCode = 'yo-NG'
$langName = 'Yoruba'
Case Hex(0x046B, 4)
$decimalCode = '1131'
$countryCode = 'quz-BO'
$langName = 'Quechua'
Case Hex(0x046C, 4)
$decimalCode = '1132'
$countryCode = 'nso-ZA'
$langName = 'Sesotho'
Case Hex(0x046D, 4)
$decimalCode = '1133'
$countryCode = 'ba-RU'
$langName = 'Bashkir'
Case Hex(0x046E, 4)
$decimalCode = '1134'
$countryCode = 'lb-LU'
$langName = 'Luxembourgish'
Case Hex(0x046F, 4)
$decimalCode = '1135'
$countryCode = 'kl-GL'
$langName = 'Greenlandic'
Case Hex(0x0470, 4)
$decimalCode = '1136'
$countryCode = 'ig-NG'
$langName = 'Igbo'
Case Hex(0x0473, 4)
$decimalCode = '1139'
$countryCode = 'ti-ET'
$langName = 'Tigrinya'
Case Hex(0x0475, 4)
$decimalCode = '1141'
$countryCode = 'haw-US'
$langName = 'Hawiian'
Case Hex(0x0478, 4)
$decimalCode = '1144'
$countryCode = 'ii-CN'
$langName = 'Yi'
Case Hex(0x047A, 4)
$decimalCode = '1146'
$countryCode = 'arn-CL'
$langName = 'Mapudungun'
Case Hex(0x047C, 4)
$decimalCode = '1148'
$countryCode = 'moh-CA'
$langName = 'Mohawk'
Case Hex(0x047E, 4)
$decimalCode = '1150'
$countryCode = 'br-FR'
$langName = 'Breton'
Case Hex(0x0480, 4)
$decimalCode = '1152'
$countryCode = 'ug-CN'
$langName = 'Uyghur'
Case Hex(0x0481, 4)
$decimalCode = '1153'
$countryCode = 'mi-NZ'
$langName = 'Maori'
Case Hex(0x0482, 4)
$decimalCode = '1154'
$countryCode = 'oc-FR'
$langName = 'Occitan'
Case Hex(0x0483, 4)
$decimalCode = '1155'
$countryCode = 'co-FR'
$langName = 'Corsican'
Case Hex(0x0484, 4)
$decimalCode = '1156'
$countryCode = 'gsw-FR'
$langName = 'Alsatian'
Case Hex(0x0485, 4)
$decimalCode = '1157'
$countryCode = 'sah-RU'
$langName = 'Sakha'
Case Hex(0x0486, 4)
$decimalCode = '1158'
$countryCode = 'quc-Latn-GT'
$langName = "K'iche"
Case Hex(0x0487, 4)
$decimalCode = '1159'
$countryCode = 'rw-RW'
$langName = 'Kinyarwanda'
Case Hex(0x0488, 4)
$decimalCode = '1160'
$countryCode = 'wo-SN'
$langName = 'Wolof'
Case Hex(0x048C, 4)
$decimalCode = '1164'
$countryCode = 'prs-AF'
$langName = 'Dari'
Case Hex(0x0491, 4)
$decimalCode = '1169'
$countryCode = 'gd-GB'
$langName = 'Scottish'
Case Hex(0x0492, 4)
$decimalCode = '1170'
$countryCode = 'ku-Arab-IQ'
$langName = 'Central'
Case Hex(0x0801, 4)
$decimalCode = '2049'
$countryCode = 'ar-IQ'
$langName = 'Arabic'
Case Hex(0x0803, 4)
$decimalCode = '2051'
$countryCode = 'ca-ES-valencia'
$langName = 'Valencian'
Case Hex(0x0804, 4)
$decimalCode = '2052'
$countryCode = 'zh-CN'
$langName = 'Chinese_S'
Case Hex(0x0807, 4)
$decimalCode = '2055'
$countryCode = 'de-CH'
$langName = 'German'
Case Hex(0x0809, 4)
$decimalCode = '2057'
$countryCode = 'en-GB'
$langName = 'English'
Case Hex(0x080A, 4)
$decimalCode = '2058'
$countryCode = 'es-MX'
$langName = 'Spanish'
Case Hex(0x080C, 4)
$decimalCode = '2060'
$countryCode = 'fr-BE'
$langName = 'French'
Case Hex(0x0810, 4)
$decimalCode = '2064'
$countryCode = 'it-CH'
$langName = 'Italian'
Case Hex(0x0813, 4)
$decimalCode = '2067'
$countryCode = 'nl-BE'
$langName = 'Dutch'
Case Hex(0x0814, 4)
$decimalCode = '2068'
$countryCode = 'nn-NO'
$langName = 'Norwegian'
Case Hex(0x0816, 4)
$decimalCode = '2070'
$countryCode = 'pt-PT'
$langName = 'Portuguese'
Case Hex(0x081A, 4)
$decimalCode = '2074'
$countryCode = 'sr-Latn-CS'
$langName = 'Serbian'
Case Hex(0x081D, 4)
$decimalCode = '2077'
$countryCode = 'sv-FI'
$langName = 'Swedish'
Case Hex(0x0820, 4)
$decimalCode = '2080'
$countryCode = 'ur-IN'
$langName = 'Urdu'
Case Hex(0x082C, 4)
$decimalCode = '2092'
$countryCode = 'az-Cyrl-AZ'
$langName = 'Azeri'
Case Hex(0x082E, 4)
$decimalCode = '2094'
$countryCode = 'dsb-DE'
$langName = 'Lower'
Case Hex(0x0832, 4)
$decimalCode = '2098'
$countryCode = 'tn-BW'
$langName = 'Setswana'
Case Hex(0x083B, 4)
$decimalCode = '2107'
$countryCode = 'se-SE'
$langName = 'Sami'
Case Hex(0x083C, 4)
$decimalCode = '2108'
$countryCode = 'ga-IE'
$langName = 'Irish'
Case Hex(0x083E, 4)
$decimalCode = '2110'
$countryCode = 'ms-BN'
$langName = 'Malay'
Case Hex(0x0843, 4)
$decimalCode = '2115'
$countryCode = 'uz-Cyrl-UZ'
$langName = 'Uzbek'
Case Hex(0x0845, 4)
$decimalCode = '2117'
$countryCode = 'bn-BD'
$langName = 'Bangla'
Case Hex(0x0846, 4)
$decimalCode = '2118'
$countryCode = 'pa-Arab-PK'
$langName = 'Punjabi'
Case Hex(0x0849, 4)
$decimalCode = '2121'
$countryCode = 'ta-LK'
$langName = 'Tamil'
Case Hex(0x0850, 4)
$decimalCode = '2128'
$countryCode = 'mn-Mong-CN'
$langName = 'Mongolian'
Case Hex(0x0859, 4)
$decimalCode = '2137'
$countryCode = 'sd-Arab-PK'
$langName = 'Sindhi'
Case Hex(0x085D, 4)
$decimalCode = '2141'
$countryCode = 'iu-Latn-CA'
$langName = 'Inuktitut'
Case Hex(0x085F, 4)
$decimalCode = '2143'
$countryCode = 'tzm-Latn-DZ'
$langName = 'Tamazight'
Case Hex(0x0867, 4)
$decimalCode = '2151'
$countryCode = 'ff-Latn-SN'
$langName = 'Pular'
Case Hex(0x086B, 4)
$decimalCode = '2155'
$countryCode = 'quz-EC'
$langName = 'Quechua'
Case Hex(0x0873, 4)
$decimalCode = '2163'
$countryCode = 'ti-ER'
$langName = '(reserved)'
Case Hex(0x0873, 4)
$decimalCode = '2163'
$countryCode = 'ti-ER'
$langName = 'Tigrinya'
Case Hex(0x0C01, 4)
$decimalCode = '3073'
$countryCode = 'ar-EG'
$langName = 'Arabic'
Case Hex(0x0C04, 4)
$decimalCode = '3076'
$countryCode = 'zh-HK'
$langName = 'Chinese_T'
Case Hex(0x0C07, 4)
$decimalCode = '3079'
$countryCode = 'de-AT'
$langName = 'German'
Case Hex(0x0C09, 4)
$decimalCode = '3081'
$countryCode = 'en-AU'
$langName = 'English'
Case Hex(0x0C0A, 4)
$decimalCode = '3082'
$countryCode = 'es-ES'
$langName = 'Spanish'
Case Hex(0x0C0C, 4)
$decimalCode = '3084'
$countryCode = 'fr-CA'
$langName = 'French'
Case Hex(0x0C1A, 4)
$decimalCode = '3098'
$countryCode = 'sr-Cyrl-CS'
$langName = 'Serbian'
Case Hex(0x0C3B, 4)
$decimalCode = '3131'
$countryCode = 'se-FI'
$langName = 'Sami'
Case Hex(0x0C6B, 4)
$decimalCode = '3179'
$countryCode = 'quz-PE'
$langName = 'Quechua'
Case Hex(0x1001, 4)
$decimalCode = '4097'
$countryCode = 'ar-LY'
$langName = 'Arabic'
Case Hex(0x1004, 4)
$decimalCode = '4100'
$countryCode = 'zh-SG'
$langName = 'Chinese_S'
Case Hex(0x1007, 4)
$decimalCode = '4103'
$countryCode = 'de-LU'
$langName = 'German'
Case Hex(0x1009, 4)
$decimalCode = '4105'
$countryCode = 'en-CA'
$langName = 'English'
Case Hex(0x100A, 4)
$decimalCode = '4106'
$countryCode = 'es-GT'
$langName = 'Spanish'
Case Hex(0x100C, 4)
$decimalCode = '4108'
$countryCode = 'fr-CH'
$langName = 'French'
Case Hex(0x101A, 4)
$decimalCode = '4122'
$countryCode = 'hr-BA'
$langName = 'Croatian'
Case Hex(0x103B, 4)
$decimalCode = '4155'
$countryCode = 'smj-NO'
$langName = 'Sami'
Case Hex(0x105F, 4)
$decimalCode = '4191'
$countryCode = 'tzm-Tfng-MA'
$langName = 'Central'
Case Hex(0x1401, 4)
$decimalCode = '5121'
$countryCode = 'ar-DZ'
$langName = 'Arabic'
Case Hex(0x1404, 4)
$decimalCode = '5124'
$countryCode = 'zh-MO'
$langName = 'Chinese_T'
Case Hex(0x1407, 4)
$decimalCode = '5127'
$countryCode = 'de-LI'
$langName = 'German'
Case Hex(0x1409, 4)
$decimalCode = '5129'
$countryCode = 'en-NZ'
$langName = 'English'
Case Hex(0x140A, 4)
$decimalCode = '5130'
$countryCode = 'es-CR'
$langName = 'Spanish'
Case Hex(0x140C, 4)
$decimalCode = '5132'
$countryCode = 'fr-LU'
$langName = 'French'
Case Hex(0x141A, 4)
$decimalCode = '5146'
$countryCode = 'bs-Latn-BA'
$langName = 'Bosnian'
Case Hex(0x143B, 4)
$decimalCode = '5179'
$countryCode = 'smj-SE'
$langName = 'Sami'
Case Hex(0x1801, 4)
$decimalCode = '6145'
$countryCode = 'ar-MA'
$langName = 'Arabic'
Case Hex(0x1809, 4)
$decimalCode = '6153'
$countryCode = 'en-IE'
$langName = 'English'
Case Hex(0x180A, 4)
$decimalCode = '6154'
$countryCode = 'es-PA'
$langName = 'Spanish'
Case Hex(0x180C, 4)
$decimalCode = '6156'
$countryCode = 'fr-MC'
$langName = 'French'
Case Hex(0x181A, 4)
$decimalCode = '6170'
$countryCode = 'sr-Latn-BA'
$langName = 'Serbian'
Case Hex(0x183B, 4)
$decimalCode = '6203'
$countryCode = 'sma-NO'
$langName = 'Sami'
Case Hex(0x1C01, 4)
$decimalCode = '7169'
$countryCode = 'ar-TN'
$langName = 'Arabic'
Case Hex(0x1c09, 4)
$decimalCode = '7177'
$countryCode = 'en-ZA'
$langName = 'English'
Case Hex(0x1C0A, 4)
$decimalCode = '7178'
$countryCode = 'es-DO'
$langName = 'Spanish'
Case Hex(0x1C1A, 4)
$decimalCode = '7194'
$countryCode = 'sr-Cyrl-BA'
$langName = 'Serbian'
Case Hex(0x1C3B, 4)
$decimalCode = '7227'
$countryCode = 'sma-SE'
$langName = 'Sami'
Case Hex(0x2001, 4)
$decimalCode = '8193'
$countryCode = 'ar-OM'
$langName = 'Arabic'
Case Hex(0x2009, 4)
$decimalCode = '8201'
$countryCode = 'en-JM'
$langName = 'English'
Case Hex(0x200A, 4)
$decimalCode = '8202'
$countryCode = 'es-VE'
$langName = 'Spanish'
Case Hex(0x201A, 4)
$decimalCode = '8218'
$countryCode = 'bs-Cyrl-BA'
$langName = 'Bosnian'
Case Hex(0x203B, 4)
$decimalCode = '8251'
$countryCode = 'sms-FI'
$langName = 'Sami'
Case Hex(0x2401, 4)
$decimalCode = '9217'
$countryCode = 'ar-YE'
$langName = 'Arabic'
Case Hex(0x2409, 4)
$decimalCode = '9225'
$countryCode = 'en-029'
$langName = 'English'
Case Hex(0x240A, 4)
$decimalCode = '9226'
$countryCode = 'es-CO'
$langName = 'Spanish'
Case Hex(0x241A, 4)
$decimalCode = '9242'
$countryCode = 'sr-Latn-RS'
$langName = 'Serbian'
Case Hex(0x243B, 4)
$decimalCode = '9275'
$countryCode = 'smn-FI'
$langName = 'Sami'
Case Hex(0x2801, 4)
$decimalCode = '10241'
$countryCode = 'ar-SY'
$langName = 'Arabic'
Case Hex(0x2809, 4)
$decimalCode = '10249'
$countryCode = 'en-BZ'
$langName = 'English'
Case Hex(0x280A, 4)
$decimalCode = '10250'
$countryCode = 'es-PE'
$langName = 'Spanish'
Case Hex(0x281A, 4)
$decimalCode = '10266'
$countryCode = 'sr-Cyrl-RS'
$langName = 'Serbian'
Case Hex(0x2C01, 4)
$decimalCode = '11265'
$countryCode = 'ar-JO'
$langName = 'Arabic'
Case Hex(0x2C09, 4)
$decimalCode = '11273'
$countryCode = 'en-TT'
$langName = 'English'
Case Hex(0x2C0A, 4)
$decimalCode = '11274'
$countryCode = 'es-AR'
$langName = 'Spanish'
Case Hex(0x2C1A, 4)
$decimalCode = '11290'
$countryCode = 'sr-Latn-ME'
$langName = 'Serbian'
Case Hex(0x3001, 4)
$decimalCode = '12289'
$countryCode = 'ar-LB'
$langName = 'Arabic'
Case Hex(0x3009, 4)
$decimalCode = '12297'
$countryCode = 'en-ZW'
$langName = 'English'
Case Hex(0x300A, 4)
$decimalCode = '12298'
$countryCode = 'es-EC'
$langName = 'Spanish'
Case Hex(0x301A, 4)
$decimalCode = '12314'
$countryCode = 'sr-Cyrl-ME'
$langName = 'Serbian'
Case Hex(0x3401, 4)
$decimalCode = '13313'
$countryCode = 'ar-KW'
$langName = 'Arabic'
Case Hex(0x3409, 4)
$decimalCode = '13321'
$countryCode = 'en-PH'
$langName = 'English'
Case Hex(0x340A, 4)
$decimalCode = '13322'
$countryCode = 'es-CL'
$langName = 'Spanish'
Case Hex(0x3801, 4)
$decimalCode = '14337'
$countryCode = 'ar-AE'
$langName = 'Arabic'
Case Hex(0x380A, 4)
$decimalCode = '14346'
$countryCode = 'es-UY'
$langName = 'Spanish'
Case Hex(0x3C01, 4)
$decimalCode = '15361'
$countryCode = 'ar-BH'
$langName = 'Arabic'
Case Hex(0x3C0A, 4)
$decimalCode = '15370'
$countryCode = 'es-PY'
$langName = 'Spanish'
Case Hex(0x4001, 4)
$decimalCode = '16385'
$countryCode = 'ar-QA'
$langName = 'Arabic'
Case Hex(0x4009, 4)
$decimalCode = '16393'
$countryCode = 'en-IN'
$langName = 'English'
Case Hex(0x400A, 4)
$decimalCode = '16394'
$countryCode = 'es-BO'
$langName = 'Spanish'
Case Hex(0x4409, 4)
$decimalCode = '17417'
$countryCode = 'en-MY'
$langName = 'English'
Case Hex(0x440A, 4)
$decimalCode = '17418'
$countryCode = 'es-SV'
$langName = 'Spanish'
Case Hex(0x4809, 4)
$decimalCode = '18441'
$countryCode = 'en-SG'
$langName = 'English'
Case Hex(0x480A, 4)
$decimalCode = '18442'
$countryCode = 'es-HN'
$langName = 'Spanish'
Case Hex(0x4C0A, 4)
$decimalCode = '19466'
$countryCode = 'es-NI'
$langName = 'Spanish'
Case Hex(0x500A, 4)
$decimalCode = '20490'
$countryCode = 'es-PR'
$langName = 'Spanish'
Case Hex(0x540A, 4)
$decimalCode = '21514'
$countryCode = 'es-US'
$langName = 'Spanish'
Case Hex(0x7C04, 4)
$decimalCode = '31748'
$countryCode = 'zh-CHT'
$langName = 'Chinese_T'
Case Else
SetLog("Your computer's language was not recognized.")
$langName = "NONE"
EndSwitch
SetLog("Detected System Locale: " & $langName, $COLOR_INFO)
If FileExists($dirLanguages & "/" & $langName & ".ini") Then
SetLog("Language file " & $langName & ".ini found in " & $dirLanguages)
$sLanguage = $langName
IniWrite($g_sProfileConfigPath, "other", "language", $sLanguage)
Else
SetLog("Language file for " & $langName & " not found! Defaulting to English", $COLOR_ERROR)
$sLanguage = $sDefaultLanguage
EndIf
Else
$sLanguage = IniRead($g_sProfileConfigPath, "other", "language", $sDefaultLanguage)
EndIf
EndFunc
ReferenceFunctions()
ReferenceGlobals()
Func ReferenceFunctions()
If True Then Return
Local $a1, $a2
setMaxDegreeOfParallelism()
FindPreferredAdbPath()
CloseVboxAndroidSvc()
SetScreenAndroid()
WaitForRunningVMS()
WaitForAndroidBootCompleted()
RebootAndroidSetScreenDefault()
AndroidSetFontSizeNormal()
AndroidCloseSystemBar()
AndroidOpenSystemBar()
AndroidPicturePathAutoConfig()
_ShortcutAppId(0)
_GUICtrlGetControlID()
IsStopped()
GetFont()
btnAnalyzeVillage()
btnTestDonate()
btnTestButtons()
arrows()
XPStyleToggle()
btnConfigureCollectors()
btnConfigureReduction()
btnConfigureTHBully()
btnConfigureDBWeakBase()
btnConfigureABWeakBase()
EnableSearchPanels(0)
btnMilkingOptions()
btnDBAttackConfigure()
btnABAttackConfigure()
btnTestTHcsv()
btnConfigureReplayShare()
btnLoots()
btnLogs()
AttackCSVAssignDefaultScriptName()
GUIControl_WM_SYSCOMMAND(0, 0, 0, 0)
RedrawBotWindowNow()
_GUICtrlListView_SetItemHeightByFont(0, 0)
_GUICtrlListView_GetHeightToFitRows(0, 0)
LockSemaphore(0)
UnlockSemaphore(0)
OverallDamage()
Barch()
MilkingDebug()
CheckMilkingBaseTest()
SortRedline(0, 0, 0)
_SortRedline(0)
FindClosestToAxis(0)
GetSlotIndexFromXPos(0)
CheckFullBarrack()
CountHeroes()
GetCurTotalDarkSpell()
IsFullArmy()
IsFullSpells()
IsElixirTroop(0)
TestTroopsCoords()
TestSpellsCoords()
TestTrainRevamp2()
checkDeadBaseNew()
imglocIsDeadBase($a1)
GetDeployableNextTo(0)
decodeTroopEnum(0)
decodeTroopName(0)
IsScreenOpen(0, 0, 0, 0)
imglocTrainIfAvailable(0, 0, 0)
imglocFindAvailableToTrain(0)
GUISetFont_DPI(0)
SetDPI()
_SysTrayIconTitles()
_SysTrayIconPids()
_SysTrayIconProcesses()
_SysTrayIconIndex(0)
_SysTrayIconTooltip(0)
_SysTrayIconPos(0)
_SysTrayIconVisible(0)
_SysTrayIconHide(0, 0)
_SysTrayIconMove(0, 0)
ZoomOutBlueStacks()
ZoomOutBlueStacks2()
ZoomOutMEmu()
ZoomOutDroid4X()
ZoomOutNox()
DefaultZoomOut()
ZoomOutCtrlWheelScroll()
ZoomOutCtrlClick()
OpenBS()
OpenBlueStacks()
OpenBlueStacks2()
InitBlueStacksX()
InitBlueStacks()
InitBlueStacks2()
RestartBlueStacksXCoC()
RestartBlueStacksCoC()
RestartBlueStacks2CoC()
CheckScreenBlueStacksX()
CheckScreenBlueStacks()
CheckScreenBlueStacks2()
SetScreenBlueStacks()
SetScreenBlueStacks2()
RebootBlueStacksSetScreen()
ConfigBlueStacks2WindowManager()
RebootBlueStacks2SetScreen()
GetBlueStacksRunningInstance()
GetBlueStacks2RunningInstance()
GetBlueStacksProgramParameter()
GetBlueStacks2ProgramParameter()
BlueStacksBotStartEvent()
BlueStacksBotStopEvent()
BlueStacks2BotStartEvent()
BlueStacks2BotStopEvent()
BlueStacksAdjustClickCoordinates($a1, $a2)
BlueStacks2AdjustClickCoordinates($a1, $a2)
DisableBS(0, 0)
EnableBS(0, 0)
GetBlueStacksSvcPid()
CloseBlueStacks()
CloseBlueStacks2()
KillBSProcess()
ServiceStop(0)
CloseUnsupportedBlueStacks2()
OpenDroid4X()
GetDroid4XProgramParameter()
GetDroid4XPath()
GetDroid4XAdbPath()
InitDroid4X()
SetScreenDroid4X()
RebootDroid4XSetScreen()
CheckScreenDroid4X()
UpdateDroid4XConfig()
UpdateDroid4XWindowState()
CloseDroid4X()
OpenMEmu()
GetMEmuProgramParameter()
GetMEmuPath()
GetMEmuAdbPath()
InitMEmu()
WaitForAmMEmu(0)
SetScreenMEmu()
RebootMEmuSetScreen()
CloseMEmu()
CheckScreenMEmu()
UpdateMEmuConfig()
UpdateMEmuWindowState()
OpenLeapDroid()
IsLeapDroidCommandLine(0)
GetLeapDroidProgramParameter()
GetLeapDroidPath()
GetLeapDroidAdbPath()
InitLeapDroid()
UpdateLeapdroidSettings($a1, 0, 0)
SetScreenLeapDroid()
RebootLeapDroidSetScreen()
CloseLeapDroid()
CheckScreenLeapDroid()
EmbedLeapDroid()
LeapDroidBotStartEvent()
LeapDroidBotStopEvent()
OpenNox()
IsNoxCommandLine(0)
GetNoxProgramParameter()
GetNoxRtPath()
GetNoxPath()
GetNoxAdbPath()
InitNox()
SetScreenNox()
RebootNoxSetScreen()
CloseNox()
CheckScreenNox()
GetNoxRunningInstance()
RedrawNoxWindow()
HideNoxWindow()
EmbedNox()
OpenKOPLAYER()
GetKOPLAYERProgramParameter()
IsKOPLAYERCommandLine(0)
GetKOPLAYERPath()
GetKOPLAYERAdbPath()
InitKOPLAYER()
SetScreenKOPLAYER()
RebootKOPLAYERSetScreen()
CloseKOPLAYER()
CheckScreenKOPLAYER()
EmbedKOPLAYER()
OpeniTools()
IsiToolsCommandLine(0)
GetiToolsProgramParameter()
GetiToolsPath()
GetiToolsAdbPath()
InitiTools()
SetScreeniTools()
RebootiToolsSetScreen()
CloseiTools()
CheckScreeniTools()
HideiToolsWindow()
EmbediTools()
AndroidEmbedded()
_ReduceMemory(0)
_ProcessSuspendResume2(0)
__EnumDefaultProc(0, 0)
__EnumPageFilesProc(0, 0, 0)
GemClickP(0, 0)
DebugSaveDesktopImage(0)
SetGuiLog(0)
Tab(0, 0)
_BlockInputEx(0)
__BlockInputEx_KeyBoardHook_Proc(0, 0, 0)
__BlockInputEx_MouseHook_Proc(0, 0, 0)
__BlockInputEx_UnhookWinHooks_Proc()
__BlockInputEx_Parse_vkCodesList_CLASSes(0)
__BlockInputEx_Parse_vmCodesList_CLASSes(0)
__BlockInputEx_KeyStr_To_vkCode(0)
__BlockInputEx_WinGetHovered()
__BlockInputEx_OnAutoItExit()
WinGetPos2(0)
ControlGetPos2(0, 0, 0)
WindowSystemMenu(0, 0)
IsMainChatOpenPage()
IsClanInfoPage()
IsPixelColorGray(0)
_MultiPixelSearch2(0, 0, 0, 0, 0, 0, 0, 0, 0)
boolPixelSearch(0, 0, 0)
getArmyTroopQuantity(0, 0)
getArmyTroopKind(0, 0)
getBarracksTroopQuantity(0, 0)
getOcrSpellDetection(0, 0)
getOcrSpellQuantity(0, 0)
getOcrClanLevel(0, 0)
getOcrDonationTroopsDetection(0, 0)
getOcrOverAllDamage(0, 0)
getHeroStatus(0, 0)
returnAllMatches(0)
returnLowestLevelSingleMatch(0)
updateGlobalVillageOffset(0, 0)
GemClickR(0, 0, 0)
EndFunc
Func ReferenceGlobals()
If True Then Return
Local $a1
$a1 = $troopsToBeUsed
$a1 = $MilkFarmOffsetMine
$a1 = $MilkFarmOffsetElixir
$a1 = $MilkFarmOffsetDark
$a1 = $aArmyCCRemainTime
$a1 = $aIsReloadError
$a1 = $g_iAndroidControlClickWindow
$a1 = $weakDefenseMaxLevels
$a1 = $ATTACKVECTOR_A
$a1 = $ATTACKVECTOR_B
$a1 = $ATTACKVECTOR_C
$a1 = $ATTACKVECTOR_D
$a1 = $ATTACKVECTOR_E
$a1 = $ATTACKVECTOR_F
$a1 = $ATTACKVECTOR_G
$a1 = $ATTACKVECTOR_H
$a1 = $ATTACKVECTOR_I
$a1 = $ATTACKVECTOR_J
$a1 = $ATTACKVECTOR_K
$a1 = $ATTACKVECTOR_L
$a1 = $ATTACKVECTOR_M
$a1 = $ATTACKVECTOR_N
$a1 = $ATTACKVECTOR_O
$a1 = $ATTACKVECTOR_P
$a1 = $ATTACKVECTOR_Q
$a1 = $ATTACKVECTOR_R
$a1 = $ATTACKVECTOR_S
$a1 = $ATTACKVECTOR_T
$a1 = $ATTACKVECTOR_U
$a1 = $ATTACKVECTOR_V
$a1 = $ATTACKVECTOR_W
$a1 = $ATTACKVECTOR_X
$a1 = $ATTACKVECTOR_Y
$a1 = $ATTACKVECTOR_Z
$a1 = $eIcnArcher
$a1 = $eIcnDonArcher
$a1 = $eIcnBalloon
$a1 = $eIcnDonBalloon
$a1 = $eIcnBarbarian
$a1 = $eIcnDonBarbarian
$a1 = $eEmpty1
$a1 = $eIcnBuilder
$a1 = $eIcnCC
$a1 = $eIcnGUI
$a1 = $eIcnDark
$a1 = $eIcnDragon
$a1 = $eIcnDonDragon
$a1 = $eIcnDrill
$a1 = $eIcnElixir
$a1 = $eIcnCollector
$a1 = $eIcnFreezeSpell
$a1 = $eIcnGem
$a1 = $eIcnGiant
$a1 = $eIcnDonGiant
$a1 = $eIcnTrap
$a1 = $eIcnGoblin
$a1 = $eIcnDonGoblin
$a1 = $eIcnGold
$a1 = $eIcnGolem
$a1 = $eIcnDonGolem
$a1 = $eIcnHealer
$a1 = $eIcnDonHealer
$a1 = $eIcnHogRider
$a1 = $eIcnDonHogRider
$a1 = $eIcnHealSpell
$a1 = $eIcnInferno
$a1 = $eIcnJumpSpell
$a1 = $eIcnLavaHound
$a1 = $eIcnDonLavaHound
$a1 = $eIcnLightSpell
$a1 = $eIcnMinion
$a1 = $eIcnDonMinion
$a1 = $eIcnPekka
$a1 = $eIcnDonPekka
$a1 = $eEmpty2
$a1 = $eIcnRageSpell
$a1 = $eIcnTroops
$a1 = $eIcnHourGlass
$a1 = $eIcnTH1
$a1 = $eIcnTH10
$a1 = $eIcnTrophy
$a1 = $eIcnValkyrie
$a1 = $eIcnDonValkyrie
$a1 = $eIcnWall
$a1 = $eIcnWallBreaker
$a1 = $eIcnDonWallBreaker
$a1 = $eIcnWitch
$a1 = $eIcnDonWitch
$a1 = $eIcnWizard
$a1 = $eIcnDonWizard
$a1 = $eIcnXbow
$a1 = $eIcnBarrackBoost
$a1 = $eIcnMine
$a1 = $eIcnCamp
$a1 = $eIcnBarrack
$a1 = $eIcnSpellFactory
$a1 = $eIcnDonBlacklist
$a1 = $eIcnSpellFactoryBoost
$a1 = $eIcnMortar
$a1 = $eIcnWizTower
$a1 = $eIcnPayPal
$a1 = $eIcnNotify
$a1 = $eIcnGreenLight
$a1 = $eIcnLaboratory
$a1 = $eIcnRedLight
$a1 = $eIcnBlank
$a1 = $eIcnYellowLight
$a1 = $eIcnDonCustom
$a1 = $eIcnTombstone
$a1 = $eIcnSilverStar
$a1 = $eIcnGoldStar
$a1 = $eIcnDarkBarrack
$a1 = $eIcnCollectorLocate
$a1 = $eIcnDrillLocate
$a1 = $eIcnMineLocate
$a1 = $eIcnBarrackLocate
$a1 = $eIcnDarkBarrackLocate
$a1 = $eIcnDarkSpellFactoryLocate
$a1 = $eIcnDarkSpellFactory
$a1 = $eIcnEarthQuakeSpell
$a1 = $eIcnHasteSpell
$a1 = $eIcnPoisonSpell
$a1 = $eIcnBldgTarget
$a1 = $eIcnBldgX
$a1 = $eIcnRecycle
$a1 = $eIcnHeroes
$a1 = $eIcnBldgElixir
$a1 = $eIcnBldgGold
$a1 = $eIcnMagnifier
$a1 = $eIcnWallElixir
$a1 = $eIcnWallGold
$a1 = $eIcnKing
$a1 = $eIcnQueen
$a1 = $eIcnDarkSpellBoost
$a1 = $eIcnQueenBoostLocate
$a1 = $eIcnKingBoostLocate
$a1 = $eIcnKingUpgr
$a1 = $eIcnQueenUpgr
$a1 = $eIcnWardenUpgr
$a1 = $eIcnWarden
$a1 = $eIcnWardenBoostLocate
$a1 = $eIcnKingBoost
$a1 = $eIcnQueenBoost
$a1 = $eIcnWardenBoost
$a1 = $eEmpty3
$a1 = $eIcnReload
$a1 = $eIcnCopy
$a1 = $eIcnAddcvs
$a1 = $eIcnEdit
$a1 = $eIcnTreeSnow
$a1 = $eIcnSleepingQueen
$a1 = $eIcnSleepingKing
$a1 = $eIcnGoldElixir
$a1 = $eIcnBowler
$a1 = $eIcnDonBowler
$a1 = $eIcnCCDonate
$a1 = $eIcnEagleArt
$a1 = $eIcnGembox
$a1 = $eIcnInferno4
$a1 = $eIcnInfo
$a1 = $eIcnMain
$a1 = $eIcnTree
$a1 = $eIcnProfile
$a1 = $eIcnCCRequest
$a1 = $eIcnTelegram
$a1 = $eIcnTiles
$a1 = $eIcnXbow3
$a1 = $eIcnBark
$a1 = $eIcnDailyProgram
$a1 = $eIcnLootCart
$a1 = $eIcnSleepMode
$a1 = $eIcnTH11
$a1 = $eIcnTrainMode
$a1 = $eIcnSleepingWarden
$a1 = $eIcnCloneSpell
$a1 = $eIcnSkeletonSpell
$a1 = $eIcnBabyDragon
$a1 = $eIcnDonBabyDragon
$a1 = $eIcnMiner
$a1 = $eIcnDonMiner
$a1 = $eIcnNoShield
$a1 = $eIcnDonCustomB
$a1 = $eIcnAirdefense
$a1 = $eIcnDarkBarrackBoost
$a1 = $eIcnDarkElixirStorage
$a1 = $eIcnSpellsCost
$a1 = $eIcnTroopsCost
$a1 = $eIcnResetButton
$a1 = $eIcnNewSmartZap
$a1 = $eIcnTrain
$a1 = $eIcnAttack
$a1 = $eIcnDelay
$a1 = $eIcnReOrder
$a1 = $eIcn2Arrow
$a1 = $eIcnArrowLeft
$a1 = $eIcnArrowRight
$a1 = $eIcnAndroid
$a1 = $eHdV04
$a1 = $eHdV05
$a1 = $eHdV06
$a1 = $eHdV07
$a1 = $eHdV08
$a1 = $eHdV09
$a1 = $eHdV10
$a1 = $eHdV11
$a1 = $eUnranked
$a1 = $eBronze
$a1 = $eSilver
$a1 = $eGold
$a1 = $eCrystal
$a1 = $eMaster
$a1 = $eChampion
$a1 = $eTitan
$a1 = $eLegend
$a1 = $eWall04
$a1 = $eWall05
$a1 = $eWall06
$a1 = $eWall07
$a1 = $eWall08
$a1 = $eWall09
$a1 = $eWall10
$a1 = $eWall11
$a1 = $eIcnPBNotify
$a1 = $eIcnCCTroops
$a1 = $eIcnCCSpells
$a1 = $eIcnSpellsGroup
$a1 = $eBahasaIND
$a1 = $eChinese_S
$a1 = $eChinese_T
$a1 = $eEnglish
$a1 = $eFrench
$a1 = $eGerman
$a1 = $eItalian
$a1 = $ePersian
$a1 = $eRussian
$a1 = $eSpanish
$a1 = $eTurkish
$a1 = $eMissingLangIcon
$a1 = $eWall12
$a1 = $ePortuguese
$a1 = $eIcnDonPoisonSpell
$a1 = $eIcnDonEarthQuakeSpell
$a1 = $eIcnDonHasteSpell
$a1 = $eIcnDonSkeletonSpell
$a1 = $eVietnamese
$a1 = $eKorean
$a1 = $eTroopBarbarian
$a1 = $eTroopArcher
$a1 = $eTroopGiant
$a1 = $eTroopGoblin
$a1 = $eTroopWallBreaker
$a1 = $eTroopBalloon
$a1 = $eTroopWizard
$a1 = $eTroopHealer
$a1 = $eTroopDragon
$a1 = $eTroopPekka
$a1 = $eTroopBabyDragon
$a1 = $eTroopMiner
$a1 = $eTroopMinion
$a1 = $eTroopHogRider
$a1 = $eTroopValkyrie
$a1 = $eTroopGolem
$a1 = $eTroopWitch
$a1 = $eTroopLavaHound
$a1 = $eTroopBowler
$a1 = $eTroopCount
$a1 = $eSpellLightning
$a1 = $eSpellHeal
$a1 = $eSpellRage
$a1 = $eSpellJump
$a1 = $eSpellFreeze
$a1 = $eSpellClone
$a1 = $eSpellPoison
$a1 = $eSpellEarthquake
$a1 = $eSpellHaste
$a1 = $eSpellSkeleton
$a1 = $eSpellCount
$a1 = $eBarb
$a1 = $eArch
$a1 = $eGiant
$a1 = $eGobl
$a1 = $eWall
$a1 = $eBall
$a1 = $eWiza
$a1 = $eHeal
$a1 = $eDrag
$a1 = $ePekk
$a1 = $eBabyD
$a1 = $eMine
$a1 = $eMini
$a1 = $eHogs
$a1 = $eValk
$a1 = $eGole
$a1 = $eWitc
$a1 = $eLava
$a1 = $eBowl
$a1 = $eKing
$a1 = $eQueen
$a1 = $eWarden
$a1 = $eCastle
$a1 = $eLSpell
$a1 = $eHSpell
$a1 = $eRSpell
$a1 = $eJSpell
$a1 = $eFSpell
$a1 = $eCSpell
$a1 = $ePSpell
$a1 = $eESpell
$a1 = $eHaSpell
$a1 = $eSkSpell
EndFunc
Opt("GUIResizeMode", $GUI_DOCKALL)
Opt("GUIEventOptions", 1)
Opt("GUICloseOnESC", 0)
Opt("WinTitleMatchMode", 3)
Opt("GUIOnEventMode", 1)
Opt("MouseClickDelay", 10)
Opt("MouseClickDownDelay", 10)
Opt("TrayMenuMode", 3)
Opt("TrayOnEventMode", 1)
InitializeBot()
MainLoop()
Func UpdateBotTitle()
Local $sTitle = "My Bot " & $g_sBotVersion & "  DocOc " & $g_sModversion & " "
If $g_sBotTitle = "" Then
$g_sBotTitle = $sTitle
Return
EndIf
$g_sBotTitle = $sTitle & "(" &($g_sAndroidInstance <> "" ? $g_sAndroidInstance : $g_sAndroidEmulator) & ")"
If $g_hFrmBot <> 0 Then
WinSetTitle($g_hFrmBot, "", $g_sBotTitle)
EndIf
SetDebugLog("Bot title updated to: " & $g_sBotTitle)
EndFunc
Func InitializeBot()
ProcessCommandLine()
SetupProfileFolder()
If CheckPrerequisites(True) Then
MBRFunc(True)
EndIf
UpdateBotTitle()
InitAndroidConfig()
If FileExists(@ScriptDir & "\EnableMBRDebug.txt") Then $g_bDevMode = True
SetDebugLog("@AutoItExe: " & @AutoItExe)
SetDebugLog("@ScriptFullPath: " & @ScriptFullPath)
SetDebugLog("@WorkingDir: " & @WorkingDir)
SetDebugLog("@AutoItPID: " & @AutoItPID)
SetDebugLog("@OSArch: " & @OSArch)
SetDebugLog("@OSVersion: " & @OSVersion)
SetDebugLog("@OSBuild: " & @OSBuild)
SetDebugLog("@OSServicePack: " & @OSServicePack)
SetDebugLog("Primary Display: " & @DesktopWidth & " x " & @DesktopHeight & " - " & @DesktopDepth & "bit")
If FileExists($g_sProfileConfigPath) Or FileExists($g_sProfileBuildingPath) Then
readConfig()
EndIf
__GDIPlus_Startup()
CreateSplashScreen()
Local $hBotLaunchTime = TimerInit()
Local $sAndroidInfo = ""
Local $iBotProcessPriority = _ProcessGetPriority(@AutoItPID)
ProcessSetPriority(@AutoItPID, $PROCESS_ABOVENORMAL)
InitializeMBR($sAndroidInfo)
CreateMainGUI()
InitializeMainGUI()
SetupFilesAndFolders()
ShowMainGUI()
DestroySplashScreen()
FinalInitialization($hBotLaunchTime, $sAndroidInfo)
ProcessSetPriority(@AutoItPID, $iBotProcessPriority)
LaunchWatchdog()
AutoStart()
EndFunc
Func ProcessCommandLine()
If $CmdLine[0] > 0 Then
For $i = 1 To $CmdLine[0]
Switch $CmdLine[$i]
Case "/restart", "/r", "-restart", "-r"
$g_bBotLaunchOption_Restart = True
Case "/autostart", "/a", "-autostart", "-a"
$g_bBotLaunchOption_Autostart = True
Case Else
$g_asCmdLine[0] += 1
ReDim $g_asCmdLine[$g_asCmdLine[0] + 1]
$g_asCmdLine[$g_asCmdLine[0]] = $CmdLine[$i]
EndSwitch
Next
EndIf
If $g_asCmdLine[0] > 0 Then
$g_sProfileCurrentName = StringRegExpReplace($g_asCmdLine[1], '[/:*?"<>|]', '_')
ElseIf FileExists($g_sProfilePath & "\profile.ini") Then
$g_sProfileCurrentName = StringRegExpReplace(IniRead($g_sProfilePath & "\profile.ini", "general", "defaultprofile", ""), '[/:*?"<>|]', '_')
If $g_sProfileCurrentName = "" Or Not FileExists($g_sProfilePath & "\" & $g_sProfileCurrentName) Then $g_sProfileCurrentName = "<No Profiles>"
Else
$g_sProfileCurrentName = "<No Profiles>"
EndIf
EndFunc
Func InitializeAndroid()
Local $s = GetTranslated(500, 21, "Initializing Android...")
SplashStep($s)
If $g_bBotLaunchOption_Restart = False Then
InitAndroidConfig(True)
If $g_asCmdLine[0] > 1 Then
Local $i
For $i = 0 To UBound($g_avAndroidAppConfig) - 1
If StringCompare($g_avAndroidAppConfig[$i][0], $g_asCmdLine[2]) = 0 Then
$g_iAndroidConfig = $i
SplashStep($s & "(" & $g_avAndroidAppConfig[$i][0] & ")...", False)
If $g_avAndroidAppConfig[$i][1] <> "" And $g_asCmdLine[0] > 2 Then
UpdateAndroidConfig($g_asCmdLine[3])
Else
UpdateAndroidConfig()
EndIf
SplashStep($s & "(" & $g_avAndroidAppConfig[$i][0] & ")", False)
EndIf
Next
EndIf
SplashStep(GetTranslated(500, 22, "Detecting Android..."))
If $g_asCmdLine[0] < 2 Then
DetectRunningAndroid()
If Not $g_bFoundRunningAndroid Then DetectInstalledAndroid()
EndIf
EndIf
CleanSecureFiles()
EndFunc
Func SetupProfileFolder()
$g_sProfileConfigPath = $g_sProfilePath & "\" & $g_sProfileCurrentName & "\config.ini"
$g_sProfileWeakBasePath = $g_sProfilePath & "\" & $g_sProfileCurrentName & "\stats_chkweakbase.INI"
$g_sProfileBuildingPath = $g_sProfilePath & "\" & $g_sProfileCurrentName & "\building.ini"
$g_sProfileLogsPath = $g_sProfilePath & "\" & $g_sProfileCurrentName & "\Logs\"
$g_sProfileLootsPath = $g_sProfilePath & "\" & $g_sProfileCurrentName & "\Loots\"
$g_sProfileTempPath = $g_sProfilePath & "\" & $g_sProfileCurrentName & "\Temp\"
$g_sProfileTempDebugPath = $g_sProfilePath & "\" & $g_sProfileCurrentName & "\Temp\Debug\"
$g_sProfileDonateCapturePath = $g_sProfilePath & "\" & $g_sProfileCurrentName & '\Donate\'
$g_sProfileDonateCaptureWhitelistPath = $g_sProfilePath & "\" & $g_sProfileCurrentName & '\Donate\White List\'
$g_sProfileDonateCaptureBlacklistPath = $g_sProfilePath & "\" & $g_sProfileCurrentName & '\Donate\Black List\'
EndFunc
Func InitializeMBR(ByRef $sAI)
If Not FileExists(@ScriptDir & "\License.txt") Then
Local $hDownload = InetGet("http://www.gnu.org/licenses/gpl-3.0.txt", @ScriptDir & "\License.txt")
Local $i = 0
Do
Sleep($iDelayDownloadLicense)
$i += 1
Until InetGetInfo($hDownload, $INET_DOWNLOADCOMPLETE) Or $i > 25
InetClose($hDownload)
EndIf
If Not FileExists(@ScriptDir & "\Languages") Then DirCreate(@ScriptDir & "\Languages")
DetectLanguage()
TranslateTroopNames()
InitializeCOCDistributors()
Local $sMsg = GetTranslated(500, 1, "Don't Run/Compile the Script as (x64)! Try to Run/Compile the Script as (x86) to get the bot to work.\r\n" & "If this message still appears, try to re-install AutoIt.")
If @AutoItX64 = 1 Then
DestroySplashScreen()
MsgBox(0, "", $sMsg)
__GDIPlus_Shutdown()
Exit
EndIf
InitializeAndroid()
UpdateBotTitle()
UpdateSplashTitle($g_sBotTitle & GetTranslated(500, 20, ", Profile: %s", $g_sProfileCurrentName))
If $g_bBotLaunchOption_Restart = True Then
If WinGetHandle($g_sBotTitle) Then SplashStep(GetTranslated(500, 36, "Closing previous bot..."), False)
If CloseRunningBot($g_sBotTitle) = True Then
Sleep(3000)
WinGetAndroidHandle()
EndIf
EndIf
Local $cmdLineHelp = GetTranslated(500, 2, "By using the commandline (or a shortcut) you can start multiple Bots:\r\n" & "     MyBot.run.exe [ProfileName] [EmulatorName] [InstanceName]\r\n\r\n" & "With the first command line parameter, specify the Profilename (you can create profiles on the Bot/Profiles tab, if a " & "profilename contains a {space}, then enclose the profilename in double quotes). " & "With the second, specify the name of the Emulator and with the third, an Android Instance (not for BlueStacks). \r\n" & "Supported Emulators are MEmu, Droid4X, Nox, BlueStacks2, BlueStacks, KOPlayer and LeapDroid.\r\n\r\n" & "Examples:\r\n" & "     MyBot.run.exe MyVillage BlueStacks2\r\n" & "     MyBot.run.exe ""My Second Village"" MEmu MEmu_1")
$g_hMutex_BotTitle = _Singleton($g_sBotTitle, 1)
$sAI = GetTranslated(500, 3, "%s", $g_sAndroidEmulator)
Local $sAndroidInfo2 = GetTranslated(500, 4, "%s (instance %s)", $g_sAndroidEmulator, $g_sAndroidInstance)
If $g_sAndroidInstance <> "" Then
$sAI = $sAndroidInfo2
EndIf
$sMsg = GetTranslated(500, 5, "My Bot for %s is already running.\r\n\r\n", $sAI)
If $g_hMutex_BotTitle = 0 Then
DestroySplashScreen()
MsgBox(BitOR($MB_OK, $MB_ICONINFORMATION, $MB_TOPMOST), $g_sBotTitle, $sMsg & $cmdLineHelp)
__GDIPlus_Shutdown()
Exit
EndIf
$g_hMutex_Profile = _Singleton(StringReplace($g_sProfilePath & "\" & $g_sProfileCurrentName, "\", "-"), 1)
$sMsg = GetTranslated(500, 6, "My Bot with Profile %s is already running in %s.\r\n\r\n", $g_sProfileCurrentName, $g_sProfilePath & "\" & $g_sProfileCurrentName)
If $g_hMutex_Profile = 0 Then
_WinAPI_CloseHandle($g_hMutex_BotTitle)
DestroySplashScreen()
MsgBox(BitOR($MB_OK, $MB_ICONINFORMATION, $MB_TOPMOST), $g_sBotTitle, $sMsg & $cmdLineHelp)
__GDIPlus_Shutdown()
Exit
EndIf
$g_hMutex_MyBot = _Singleton("MyBot.run", 1)
$g_bOnlyInstance = $g_hMutex_MyBot <> 0
SetDebugLog("My Bot is " &($g_bOnlyInstance ? "" : "not ") & "the only running instance")
EndFunc
Func SetupFilesAndFolders()
CheckPrerequisites(False)
DirCreate($g_sProfilePresetPath)
DirCreate($g_sProfilePath & "\" & $g_sProfileCurrentName)
DirCreate($g_sProfileLogsPath)
DirCreate($g_sProfileLootsPath)
DirCreate($g_sProfileTempPath)
DirCreate($g_sProfileTempDebugPath)
$g_sProfileDonateCapturePath = $g_sProfilePath & "\" & $g_sProfileCurrentName & '\Donate\'
$g_sProfileDonateCaptureWhitelistPath = $g_sProfilePath & "\" & $g_sProfileCurrentName & '\Donate\White List\'
$g_sProfileDonateCaptureBlacklistPath = $g_sProfilePath & "\" & $g_sProfileCurrentName & '\Donate\Black List\'
DirCreate($g_sProfileDonateCapturePath)
DirCreate($g_sProfileDonateCaptureWhitelistPath)
DirCreate($g_sProfileDonateCaptureBlacklistPath)
FileMove(@ScriptDir & "\*.ini", $g_sProfilePath & "\" & $g_sProfileCurrentName, $FC_OVERWRITE + $FC_CREATEPATH)
DirCopy(@ScriptDir & "\Logs", $g_sProfilePath & "\" & $g_sProfileCurrentName & "\Logs", $FC_OVERWRITE + $FC_CREATEPATH)
DirCopy(@ScriptDir & "\Loots", $g_sProfilePath & "\" & $g_sProfileCurrentName & "\Loots", $FC_OVERWRITE + $FC_CREATEPATH)
DirCopy(@ScriptDir & "\Temp", $g_sProfilePath & "\" & $g_sProfileCurrentName & "\Temp", $FC_OVERWRITE + $FC_CREATEPATH)
DirRemove(@ScriptDir & "\Logs", 1)
DirRemove(@ScriptDir & "\Loots", 1)
DirRemove(@ScriptDir & "\Temp", 1)
If FileExists($g_sProfileConfigPath) = 0 Then
createProfile(True)
applyConfig()
EndIf
If $ichkDeleteLogs = 1 Then DeleteFiles($g_sProfileLogsPath, "*.*", $iDeleteLogsDays, 0)
If $ichkDeleteLoots = 1 Then DeleteFiles($g_sProfileLootsPath, "*.*", $iDeleteLootsDays, 0)
If $ichkDeleteTemp = 1 Then DeleteFiles($g_sProfileTempPath, "*.*", $iDeleteTempDays, 0)
If $ichkDeleteTemp = 1 Then DeleteFiles($g_sProfileTempDebugPath, "*.*", $iDeleteTempDays, 0)
SetDebugLog("$g_sProfilePath = " & $g_sProfilePath)
SetDebugLog("$g_sProfileCurrentName = " & $g_sProfileCurrentName)
SetDebugLog("$g_sProfileLogsPath = " & $g_sProfileLogsPath)
EndFunc
Func FinalInitialization(Const $hBLT, Const $sAI)
If $g_bFoundRunningAndroid Then
SetLog(GetTranslated(500, 7, "Found running %s %s", $g_sAndroidEmulator, $g_sAndroidVersion), $COLOR_SUCCESS)
EndIf
If $g_bFoundInstalledAndroid Then
SetLog("Found installed " & $g_sAndroidEmulator & " " & $g_sAndroidVersion, $COLOR_SUCCESS)
EndIf
SetLog(GetTranslated(500, 8, "Android Emulator Configuration: %s", $sAI), $COLOR_SUCCESS)
CheckDisplay()
LoadAmountOfResourcesImages()
CheckVersion()
$g_iBotLaunchTime = TimerDiff($hBLT)
SetDebugLog("MyBot.run launch time " & Round($g_iBotLaunchTime) & " ms.")
If $g_bAndroidShieldEnabled = False Then
SetLog(GetTranslated(500, 9, "Android Shield not available for %s", @OSVersion), $COLOR_ACTION)
EndIf
DisableProcessWindowsGhosting()
EndFunc
Func MainLoop()
While 1
_Sleep($iDelaySleep, True, False)
Switch $g_iBotAction
Case $eBotStart
BotStart()
If $g_iBotAction = $eBotStart Then $g_iBotAction = $eBotNoAction
Case $eBotStop
BotStop()
If $g_iBotAction = $eBotStop Then $g_iBotAction = $eBotNoAction
Case $eBotSearchMode
BotSearchMode()
If $g_iBotAction = $eBotSearchMode Then $g_iBotAction = $eBotNoAction
Case $eBotClose
BotClose()
EndSwitch
WEnd
EndFunc
Func runBot()
If $FirstInit Then SwitchAccount(True)
Local $iWaitTime
While 1
PrepareDonateCC()
$g_bRestart = False
$fullArmy = False
$g_iCommandStop = -1
If _Sleep($iDelayRunBot1) Then Return
checkMainScreen()
If $g_bRestart = True Then ContinueLoop
If $ichkSwitchAccount = 1 Then
Setlog("Checking the Lab's Status", $COLOR_INFO)
If Labstatus() Then
GUICtrlSetBkColor($g_lblLabStatus[$CurrentAccount], $COLOR_GREEN)
GUICtrlSetBkColor($g_lblLabStatusPO[$CurrentAccount], $COLOR_GREEN)
EndIf
If _Sleep($iDelayRunBot5) Then Return
checkMainScreen(False)
If $g_bRestart = True Then ContinueLoop
Setlog("Checking the Hero's Status", $COLOR_INFO)
HeroStatsStaus()
If _Sleep($iDelayRunBot5) Then Return
checkMainScreen(False)
If $g_bRestart = True Then ContinueLoop
EndIf
chkShieldStatus()
If $g_bRestart = True Then ContinueLoop
If $g_bQuicklyFirstStart = True Then
$g_bQuicklyFirstStart = False
Else
$g_bQuickAttack = QuickAttack()
EndIf
If checkAndroidReboot() = True Then ContinueLoop
If $Is_ClientSyncError = False And $Is_SearchLimit = False And($g_bQuickAttack = False) Then
If BotCommand() Then btnStop()
If _Sleep($iDelayRunBot2) Then Return
checkMainScreen(False)
If $g_bRestart = True Then ContinueLoop
If _Sleep($iDelayRunBot3) Then Return
VillageReport()
If $OutOfGold = 1 And(Number($iGoldCurrent) >= Number($g_iTxtRestartGold)) Then
$OutOfGold = 0
Setlog("Switching back to normal after no gold to search ...", $COLOR_SUCCESS)
$g_bChkBotStop = False
$g_iCmbBotCond = _GUICtrlComboBox_GetCurSel($g_hCmbBotCond)
$bTrainEnabled = True
$bDonationEnabled = True
ContinueLoop
EndIf
If $OutOfElixir = 1 And(Number($iElixirCurrent) >= Number($g_iTxtRestartElixir)) And(Number($iDarkCurrent) >= Number($g_iTxtRestartDark)) Then
$OutOfElixir = 0
Setlog("Switching back to normal setting after no elixir to train ...", $COLOR_SUCCESS)
$g_bChkBotStop = False
$g_iCmbBotCond = _GUICtrlComboBox_GetCurSel($g_hCmbBotCond)
$bTrainEnabled = True
$bDonationEnabled = True
ContinueLoop
EndIf
If _Sleep($iDelayRunBot5) Then Return
checkMainScreen(False)
If $g_bRestart = True Then ContinueLoop
Local $aRndFuncList = ['Collect', 'CheckTombs', 'ReArm', 'CleanYard', 'CollectTreasury']
While 1
If $g_bRunState = False Then Return
If $g_bRestart = True Then ContinueLoop 2
If UBound($aRndFuncList) > 1 Then
Local $Index = Random(0, UBound($aRndFuncList), 1)
If $Index > UBound($aRndFuncList) - 1 Then $Index = UBound($aRndFuncList) - 1
_RunFunction($aRndFuncList[$Index])
_ArrayDelete($aRndFuncList, $Index)
Else
_RunFunction($aRndFuncList[0])
ExitLoop
EndIf
If $g_bRestart = True Then ContinueLoop 2
WEnd
AddIdleTime()
If $g_bRunState = False Then Return
If $g_bRestart = True Then ContinueLoop
If IsSearchAttackEnabled() Then
Local $aRndFuncList = ['ReplayShare', 'NotifyReport', 'DonateCC,Train', 'BoostBarracks', 'BoostSpellFactory', 'BoostKing', 'BoostQueen', 'BoostWarden', 'RequestCC']
While 1
If $g_bRunState = False Then Return
If $g_bRestart = True Then ContinueLoop 2
If UBound($aRndFuncList) > 1 Then
Local $Index = Random(0, UBound($aRndFuncList), 1)
If $Index > UBound($aRndFuncList) - 1 Then $Index = UBound($aRndFuncList) - 1
_RunFunction($aRndFuncList[$Index])
_ArrayDelete($aRndFuncList, $Index)
Else
_RunFunction($aRndFuncList[0])
ExitLoop
EndIf
If checkAndroidReboot() = True Then ContinueLoop 2
WEnd
If $g_bRunState = False Then Return
If $g_bRestart = True Then ContinueLoop
If $g_iUnbrkMode >= 1 Then
If Unbreakable() = True Then ContinueLoop
EndIf
EndIf
MainSuperXPHandler()
Local $aRndFuncList = ['Laboratory', 'UpgradeHeroes', 'UpgradeBuilding']
While 1
If $g_bRunState = False Then Return
If $g_bRestart = True Then ContinueLoop 2
If UBound($aRndFuncList) > 1 Then
$Index = Random(0, UBound($aRndFuncList), 1)
If $Index > UBound($aRndFuncList) - 1 Then $Index = UBound($aRndFuncList) - 1
_RunFunction($aRndFuncList[$Index])
_ArrayDelete($aRndFuncList, $Index)
Else
_RunFunction($aRndFuncList[0])
ExitLoop
EndIf
If checkAndroidReboot() = True Then ContinueLoop 2
WEnd
If $g_bRunState = False Then Return
If $g_bRestart = True Then ContinueLoop
If IsSearchAttackEnabled() Then
$iNbrOfWallsUpped = 0
UpgradeWall()
If _Sleep($iDelayRunBot3) Then Return
If $g_bRestart = True Then ContinueLoop
Idle()
If _Sleep($iDelayRunBot3) Then Return
If $g_bRestart = True Then ContinueLoop
If $g_iCommandStop <> 0 And $g_iCommandStop <> 3 Then
AttackMain()
$g_bSkipFirstZoomout = False
If $OutOfGold = 1 Then
Setlog("Switching to Halt Attack, Stay Online/Collect mode ...", $COLOR_ERROR)
$g_bChkBotStop = True
$g_iCmbBotCond = 18
$g_bFirstStart = True
ContinueLoop
EndIf
If _Sleep($iDelayRunBot1) Then Return
If $g_bRestart = True Then ContinueLoop
EndIf
Else
$iWaitTime = Random($iDelayWaitAttack1, $iDelayWaitAttack2)
SetLog("Attacking Not Planned and Skipped, Waiting random " & StringFormat("%0.1f", $iWaitTime / 1000) & " Seconds", $COLOR_WARNING)
If _SleepStatus($iWaitTime) Then Return False
EndIf
Else
If $g_bQuickAttack Then
Setlog("Quick Restart... ", $COLOR_INFO)
Else
If $Is_SearchLimit = True Then
SetLog("Restarted due search limit", $COLOR_INFO)
Else
SetLog("Restarted after Out of Sync Error: Attack Now", $COLOR_INFO)
EndIf
EndIf
If _Sleep($iDelayRunBot3) Then Return
$iTrophyCurrent = Number(getTrophyMainScreen($aTrophies[0], $aTrophies[1]))
If $g_iDebugSetlog = 1 Then SetLog("Runbot Trophy Count: " & $iTrophyCurrent, $COLOR_DEBUG)
AttackMain()
$g_bSkipFirstZoomout = False
If $OutOfGold = 1 Then
Setlog("Switching to Halt Attack, Stay Online/Collect mode ...", $COLOR_ERROR)
$g_bChkBotStop = True
$g_iCmbBotCond = 18
$g_bFirstStart = True
$Is_ClientSyncError = False
ContinueLoop
EndIf
If _Sleep($iDelayRunBot5) Then Return
If $g_bRestart = True Then ContinueLoop
EndIf
WEnd
EndFunc
Func Idle()
Static $iCollectCounter = 0
Local $TimeIdle = 0
If $g_iDebugSetlog = 1 Then SetLog("Func Idle ", $COLOR_DEBUG)
While $IsFullArmywithHeroesAndSpells = False
checkAndroidReboot()
NotifyPendingActions()
If _Sleep($iDelayIdle1) Then Return
If $g_iCommandStop = -1 Then SetLog("====== Waiting for full army ======", $COLOR_SUCCESS)
Local $hTimer = TimerInit()
Local $iReHere = 0
BotHumanization()
If $bActiveDonate And $g_bChkDonate Then
Local $aHeroResult = CheckArmyCamp(True, True, True)
While $iReHere < 7
$iReHere += 1
If $iReHere = 1 And SkipDonateNearFullTroops(True, $aHeroResult) = False And BalanceDonRec(True) Then
DonateCC(True)
ElseIf SkipDonateNearFullTroops(False, $aHeroResult) = False And BalanceDonRec(False) Then
DonateCC(True)
EndIf
If _Sleep($iDelayIdle2) Then ExitLoop
If $g_bRestart = True Then ExitLoop
If checkAndroidReboot() Then ContinueLoop 2
WEnd
EndIF
If _Sleep($iDelayIdle1) Then ExitLoop
checkObstacles()
checkMainScreen(False)
If($g_iCommandStop = 3 Or $g_iCommandStop = 0) And $bTrainEnabled = True Then
CheckArmyCamp(True, True)
If _Sleep($iDelayIdle1) Then Return
If($fullArmy = False Or $bFullArmySpells = False) And $bTrainEnabled = True Then
SetLog("Army Camp and Barracks are not full, Training Continues...", $COLOR_ACTION)
$g_iCommandStop = 0
EndIf
EndIf
ReplayShare($iShareAttackNow)
If _Sleep($iDelayIdle1) Then Return
If $g_bRestart = True Then ExitLoop
If $iCollectCounter > $g_iCollectAtCount Then
Local $aRndFuncList = ['Collect', 'CheckTombs', 'DonateCC', 'CleanYard']
While 1
If $g_bRunState = False Then Return
If $g_bRestart = True Then ExitLoop
If checkAndroidReboot() Then ContinueLoop 2
If UBound($aRndFuncList) > 1 Then
Local $Index = Random(0, UBound($aRndFuncList), 1)
If $Index > UBound($aRndFuncList) - 1 Then $Index = UBound($aRndFuncList) - 1
_RunFunction($aRndFuncList[$Index])
_ArrayDelete($aRndFuncList, $Index)
Else
_RunFunction($aRndFuncList[0])
ExitLoop
EndIf
WEnd
If $g_bRunState = False Then Return
If $g_bRestart = True Then ExitLoop
If _Sleep($iDelayIdle1) Or $g_bRunState = False Then ExitLoop
$iCollectCounter = 0
EndIf
$iCollectCounter = $iCollectCounter + 1
AddIdleTime()
checkMainScreen(False)
If $g_iCommandStop = -1 Then
If $actual_train_skip < $max_train_skip Then
If CheckNeedOpenTrain($g_iTimeBeforeTrain) Then TrainRevamp()
MainSuperXPHandler()
If $g_bRestart = True Then ExitLoop
If _Sleep($iDelayIdle1) Then ExitLoop
checkMainScreen(False)
Else
Setlog("Humanize bot, prevent to delete and recreate troops " & $actual_train_skip + 1 & "/" & $max_train_skip, $color_blue)
$actual_train_skip = $actual_train_skip + 1
If $actual_train_skip >= $max_train_skip Then
$actual_train_skip = 0
EndIf
CheckArmyCamp(True, True)
EndIf
EndIf
If _Sleep($iDelayIdle1) Then Return
If $g_iCommandStop = 0 And $bTrainEnabled = True Then
If Not($fullArmy) Then
If $actual_train_skip < $max_train_skip Then
If CheckNeedOpenTrain($g_iTimeBeforeTrain) Then TrainRevamp()
If $g_bRestart = True Then ExitLoop
If _Sleep($iDelayIdle1) Then ExitLoop
checkMainScreen(False)
Else
$actual_train_skip = $actual_train_skip + 1
If $actual_train_skip >= $max_train_skip Then
$actual_train_skip = 0
EndIf
CheckArmyCamp(True, True)
EndIf
MainSuperXPHandler()
EndIf
If $fullArmy Then
SetLog("Army Camp and Barracks are full, stop Training...", $COLOR_ACTION)
$g_iCommandStop = 3
EndIf
EndIf
If _Sleep($iDelayIdle1) Then Return
If $g_iCommandStop = -1 Then
DropTrophy()
If $g_bRestart = True Then ExitLoop
If _Sleep($iDelayIdle1) Then ExitLoop
checkMainScreen(False)
EndIf
If _Sleep($iDelayIdle1) Then Return
If $g_bRestart = True Then ExitLoop
$TimeIdle += Round(TimerDiff($hTimer) / 1000, 2)
$g_iTimeBeforeTrain += Round(TimerDiff($hTimer) / 1000, 2)
If $canRequestCC = True Then RequestCC()
SetLog("Time Idle: " & StringFormat("%02i", Floor(Floor($TimeIdle / 60) / 60)) & ":" & StringFormat("%02i", Floor(Mod(Floor($TimeIdle / 60), 60))) & ":" & StringFormat("%02i", Floor(Mod($TimeIdle, 60))))
SwitchAccount()
If $OutOfGold = 1 Or $OutOfElixir = 1 Then Return
If($g_iCommandStop = 3 Or $g_iCommandStop = 0) And $bTrainEnabled = False Then ExitLoop
If $iChkSnipeWhileTrain = 1 Then SnipeWhileTrain()
If $g_iCommandStop = -1 Then
SmartWait4Train()
If $g_bRestart = True Then ExitLoop
EndIf
WEnd
EndFunc
Func AttackMain()
If $ichkEnableSuperXP = 1 And $irbSXTraining = 2 Then
MainSuperXPHandler()
Return
EndIf
getArmyCapacity(True, True)
If IsSearchAttackEnabled() Then
If(IsSearchModeActive($DB) And checkCollectors(True, False)) Or IsSearchModeActive($LB) Or IsSearchModeActive($TS) Then
If $iChkUseCCBalanced = 1 Then
ProfileReport()
If _Sleep($iDelayAttackMain1) Then Return
checkMainScreen(False)
If $g_bRestart = True Then Return
EndIf
If $iChkTrophyRange = 1 And Number($iTrophyCurrent) > Number($iTxtMaxTrophy) Then
DropTrophy()
$Is_ClientSyncError = False
If _Sleep($iDelayAttackMain1) Then Return
Return
EndIf
If $g_iDebugSetlog = 1 Then
SetLog(_PadStringCenter(" Hero status check" & BitAND($g_aiAttackUseHeroes[$DB], $g_aiSearchHeroWaitEnable[$DB], $iHeroAvailable) & "|" & $g_aiSearchHeroWaitEnable[$DB] & "|" & $iHeroAvailable, 54, "="), $COLOR_DEBUG)
SetLog(_PadStringCenter(" Hero status check" & BitAND($g_aiAttackUseHeroes[$LB], $g_aiSearchHeroWaitEnable[$LB], $iHeroAvailable) & "|" & $g_aiSearchHeroWaitEnable[$LB] & "|" & $iHeroAvailable, 54, "="), $COLOR_DEBUG)
EndIf
PrepareSearch()
If $OutOfGold = 1 Then Return
If $g_bRestart = True Then Return
VillageSearch()
If $OutOfGold = 1 Then Return
If $g_bRestart = True Then Return
PrepareAttack($g_iMatchMode)
If $g_bRestart = True Then Return
Attack()
If $g_bRestart = True Then Return
ReturnHome($TakeLootSnapShot)
If _Sleep($iDelayAttackMain2) Then Return
Return True
Else
Setlog("No one of search condition match:", $COLOR_WARNING)
Setlog("Waiting on troops, heroes and/or spells according to search settings", $COLOR_WARNING)
$Is_SearchLimit = False
$Is_ClientSyncError = False
$g_bQuickAttack = False
EndIf
Else
SetLog("Attacking Not Planned, Skipped..", $COLOR_WARNING)
EndIf
EndFunc
Func Attack()
SetLog(" ====== Start Attack ====== ", $COLOR_SUCCESS)
If($g_iMatchMode = $DB And $g_aiAttackAlgorithm[$DB] = 1) Or($g_iMatchMode = $LB And $g_aiAttackAlgorithm[$LB] = 1) Then
If $g_iDebugSetlog = 1 Then Setlog("start scripted attack", $COLOR_ERROR)
Algorithm_AttackCSV()
ElseIf $g_iMatchMode = $DB And $g_aiAttackAlgorithm[$DB] = 2 Then
If $g_iDebugSetlog = 1 Then Setlog("start milking attack", $COLOR_ERROR)
Alogrithm_MilkingAttack()
Else
If $g_iDebugSetlog = 1 Then Setlog("start standard attack", $COLOR_ERROR)
algorithm_AllTroops()
EndIf
EndFunc
Func QuickAttack()
getArmyCapacity(True, True)
If($g_aiAttackAlgorithm[$DB] = 2 And IsSearchModeActive($DB)) Or(IsSearchModeActive($TS)) Then
VillageReport()
EndIf
$iTrophyCurrent = getTrophyMainScreen($aTrophies[0], $aTrophies[1])
If($iChkTrophyRange = 1 And Number($iTrophyCurrent) > Number($iTxtMaxTrophy)) Then
If $g_iDebugSetlog = 1 Then Setlog("No quickly re-attack, need to drop tropies", $COLOR_DEBUG)
Return False
EndIf
If $g_aiAttackAlgorithm[$DB] = 2 And IsSearchModeActive($DB) Then
If Int($CurCamp) >= $TotalCamp * $g_aiSearchCampsPct[$DB] / 100 And $g_abSearchCampsEnable[$DB] Then
If $g_iDebugSetlog = 1 Then Setlog("Milking: Quickly re-attack " & Int($CurCamp) & " >= " & $TotalCamp & " * " & $g_aiSearchCampsPct[$DB] & "/100 " & "= " & $TotalCamp * $g_aiSearchCampsPct[$DB] / 100, $COLOR_DEBUG)
Return True
Else
If $g_iDebugSetlog = 1 Then Setlog("Milking: No Quickly re-attack:  cur. " & Int($CurCamp) & "  need " & $TotalCamp * $g_aiSearchCampsPct[$DB] / 100 & " firststart = " &($g_bQuicklyFirstStart), $COLOR_DEBUG)
Return False
EndIf
EndIf
If IsSearchModeActive($TS) Then
If Int($CurCamp) >= $TotalCamp * $g_aiSearchCampsPct[$TS] / 100 And $g_abSearchCampsEnable[$TS] Then
If $g_iDebugSetlog = 1 Then Setlog("THSnipe: Quickly re-attack " & Int($CurCamp) & " >= " & $TotalCamp & " * " & $g_aiSearchCampsPct[$TS] & "/100 " & "= " & $TotalCamp * $g_aiSearchCampsPct[$TS] / 100, $COLOR_DEBUG)
Return True
Else
If $g_iDebugSetlog = 1 Then Setlog("THSnipe: No Quickly re-attack:  cur. " & Int($CurCamp) & "  need " & $TotalCamp * $g_aiSearchCampsPct[$TS] / 100 & " firststart = " &($g_bQuicklyFirstStart), $COLOR_DEBUG)
Return False
EndIf
EndIf
EndFunc
Func _RunFunction($action)
SetDebugLog("_RunFunction: " & $action & " BEGIN", $COLOR_DEBUG2)
Switch $action
Case "Collect"
Collect()
_Sleep($iDelayRunBot1)
Case "CollectTreasury"
CollectTreasury()
Case "CheckTombs"
CheckTombs()
_Sleep($iDelayRunBot3)
Case "CleanYard"
CleanYard()
Case "ReArm"
ReArm()
_Sleep($iDelayRunBot3)
Case "ReplayShare"
ReplayShare($iShareAttackNow)
_Sleep($iDelayRunBot3)
Case "NotifyReport"
NotifyReport()
_Sleep($iDelayRunBot3)
Case "DonateCC"
If $bActiveDonate And $g_bChkDonate Then
If SkipDonateNearFullTroops(True) = False And BalanceDonRec(True) Then DonateCC()
If _Sleep($iDelayRunBot1) = False Then checkMainScreen(False)
EndIF
Case "DonateCC,Train"
If $bActiveDonate And $g_bChkDonate Then
If $g_bFirstStart Then
getArmyCapacity(True, False)
getArmySpellCapacity(False, True)
EndIf
If SkipDonateNearFullTroops(True) = False And BalanceDonRec(True) Then DonateCC()
EndIF
If _Sleep($iDelayRunBot1) = False Then checkMainScreen(False)
If $bTrainEnabled = True Then
If $actual_train_skip < $max_train_skip Then
TrainRevamp()
_Sleep($iDelayRunBot1)
Else
Setlog("Humanize bot, prevent to delete and recreate troops " & $actual_train_skip + 1 & "/" & $max_train_skip, $color_blue)
$actual_train_skip = $actual_train_skip + 1
If $actual_train_skip >= $max_train_skip Then
$actual_train_skip = 0
EndIf
CheckOverviewFullArmy(True, False)
If ISArmyWindow(False, $ArmyTAB) then CheckExistentArmy("Spells")
getArmyHeroCount(False, TRue)
EndIf
Else
If $g_iDebugSetlogTrain = 1 Then Setlog("Halt mode - training disabled", $COLOR_DEBUG)
EndIf
Case "BoostBarracks"
BoostBarracks()
Case "BoostSpellFactory"
BoostSpellFactory()
Case "BoostKing"
BoostKing()
Case "BoostQueen"
BoostQueen()
Case "BoostWarden"
BoostWarden()
Case "RequestCC"
RequestCC()
If _Sleep($iDelayRunBot1) = False Then checkMainScreen(False)
Case "Laboratory"
Laboratory()
If _Sleep($iDelayRunBot3) = False Then checkMainScreen(False)
Case "UpgradeHeroes"
UpgradeHeroes()
_Sleep($iDelayRunBot3)
Case "UpgradeBuilding"
UpgradeBuilding()
_Sleep($iDelayRunBot3)
Case "SuperXP"
MainSuperXPHandler()
_Sleep($iDelayRunBot3)
Case ""
SetDebugLog("Function call doesn't support empty string, please review array size", $COLOR_ERROR)
Case Else
SetLog("Unknown function call: " & $action, $COLOR_ERROR)
EndSwitch
SetDebugLog("_RunFunction: " & $action & " END", $COLOR_DEBUG2)
EndFunc
